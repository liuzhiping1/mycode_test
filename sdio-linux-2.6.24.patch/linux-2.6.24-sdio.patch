Support for Linux 2.6.24 and add support for Atheros Wifi chips AR6001.

        SDIO-linux project

The overall project goal of SDIO-linux is to provide SDIO support through
a new SDIO stack that supports multiple kinds of SDIO devices, SD card,
SDIO GPS, SDIO Bluetooth, and SDIO wireless network cards.

The original code for this new SDIO stack comes from Atheros and works
on mulitiple operating systems.  The previous sourcegorge patches have been
ported to Linux 2.6.10 and 2.6.18, and this patch has been ported to 2.6.24,
and supports the Atheros wifi chips.


Index: linux-2.6/drivers/sdio/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/Kconfig
@@ -0,0 +1,22 @@
+#
+# SDIO driver and host controller support
+#
+
+menu "SDIO support"
+
+config SDIO
+	tristate "SDIO support"
+	default m
+	---help---
+	  good luck.
+
+if SDIO
+
+source "drivers/sdio/hcd/Kconfig"
+
+source "drivers/sdio/functions/Kconfig"
+
+endif
+
+endmenu
+
Index: linux-2.6/drivers/sdio/Makefile
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/Makefile
@@ -0,0 +1,3 @@
+#Makefile for SDIO stack
+obj-$(CONFIG_SDIO)      += busdriver/  hcd/  lib/ functions/
+
Index: linux-2.6/drivers/sdio/busdriver/Makefile
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/busdriver/Makefile
@@ -0,0 +1,5 @@
+#
+# SDIO stack bus drivers
+#
+obj-$(CONFIG_SDIO) += sdio_busdriver.o
+sdio_busdriver-objs := sdio_bus.o sdio_function.o sdio_bus_misc.o sdio_bus_events.o sdio_bus_os.o
Index: linux-2.6/drivers/sdio/busdriver/_busdriver.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/busdriver/_busdriver.h
@@ -0,0 +1,466 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: _busdriver.h
+
+@abstract: internal include file for busdriver
+
+@notice: Copyright (c), 2004-2006 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#ifndef ___BUSDRIVER_H___
+#define ___BUSDRIVER_H___
+#include <linux/sdio/sdio_lib.h>
+
+#define SDIODBG_FUNC_IRQ  (SDDBG_TRACE + 1)
+#define SDIODBG_REQUESTS  (SDDBG_TRACE + 2)
+#define SDIODBG_CD_TIMER  (SDDBG_TRACE + 3)
+#define SDIODBG_HCD_EVENTS  (SDDBG_TRACE + 4)
+
+#define SDIOBUS_CD_TIMER_ID 0
+
+#define SDBUS_MAX_RETRY   3
+
+/* Notes on list linkages:
+ *  list heads are held in BDCONTEXT
+ *  HcdList - SDHCD
+ *          one per registered host controller
+ *          Next - links of all HCDs
+ *  DeviceList SDDEVICE
+ *          one per inserted device
+ *          Next - links of all devices
+ *          DeviceListNext - links of all devices on a function
+ *          pFunction - ptr to Function supportting this device
+ *          pHcd - ptr to HCD with supporting this device
+ *  FunctionList SDFUNCTION
+ *          one per register function driver
+ *          Next - links of all functions
+ *          DeviceList - list of devices being support by this function
+ *                       uses DeviceListNext in SDDEVICE to link
+ *
+ *
+*/
+
+#define SDMMC_DEFAULT_CMD_RETRIES           1
+#define SDMMC_DEFAULT_CARD_READY_RETRIES    200
+#define OCR_READY_CHECK_DELAY_MS            10
+#define SDMMC_POWER_SETTLE_DELAY            400  /* in milliseconds */
+#define SDBUS_DEFAULT_REQ_LIST_SIZE         16
+#define SDBUS_DEFAULT_REQ_SIG_SIZE          8
+#define CARD_DETECT_PAUSE                   100
+#define SDBUS_DEFAULT_CD_POLLING_INTERVAL   1000  /* in milliseconds */
+#define MAX_CARD_DETECT_MSGS                16
+#define SDMMC_DEFAULT_BYTES_PER_BLOCK       2048
+#define SDMMC_DEFAULT_BLOCKS_PER_TRANS      512
+#define SDMMC_CMD13_POLLING_MULTIPLIER      1000 /* per block multiplier */
+#define MAX_HCD_REQ_RECURSION               5
+#define MAX_HCD_RECURSION_RUNAWAY           100
+
+    /* internal signalling item */
+typedef struct _SIGNAL_ITEM{
+    SDLIST       SDList;        /* list link*/
+    OS_SIGNAL    Signal;        /* signal */
+}SIGNAL_ITEM, *PSIGNAL_ITEM;
+
+typedef struct _HCD_EVENT_MESSAGE {
+    HCD_EVENT Event;    /* the event */
+    PSDHCD    pHcd;     /* hcd that generated the event */
+}HCD_EVENT_MESSAGE, *PHCD_EVENT_MESSAGE;
+
+/* internal data for bus driver */
+typedef struct _BDCONTEXT {
+
+    /* list of SD requests and signalling semaphores and a semaphore to protect it */
+    SDLIST  RequestList;
+    SDLIST  SignalList;
+    OS_CRITICALSECTION RequestListCritSection;
+    /* list of host controller bus drivers, sempahore to protect it */
+    SDLIST HcdList;
+    OS_SEMAPHORE HcdListSem;
+    /* list of inserted devices, semaphore to protect it */
+    SDLIST DeviceList;
+    OS_SEMAPHORE DeviceListSem;
+    /* list of function drivers, semaphore to protect it */
+    SDLIST FunctionList;
+    OS_SEMAPHORE FunctionListSem;
+    INT              RequestListSize;        /* default request list */
+    INT              SignalSemListSize;      /* default signalling semaphore size */
+    INT              CurrentRequestAllocations; /*current count of allocated requests */
+    INT              CurrentSignalAllocations;   /* current count of signal allocations */
+    INT              MaxRequestAllocations;  /* max number of allocated requests to keep around*/
+    INT              MaxSignalAllocations;   /* max number of signal allocations to keep around*/
+    INT              RequestRetries;         /* cmd retries */
+    INT              CardReadyPollingRetry;  /* card ready polling retry count */
+    INT              PowerSettleDelay;       /* power settle delay */
+    INT              CMD13PollingMultiplier; /* CMD13 (GET STATUS) multiplier */
+    SD_BUSCLOCK_RATE DefaultOperClock;       /* default operation clock */
+    SD_BUSMODE_FLAGS DefaultBusMode;         /* default bus mode */
+    UINT16           DefaultOperBlockLen;    /* default operational block length per block */
+    UINT16           DefaultOperBlockCount;  /* default operational block count per transaction */
+    UINT32           CDPollingInterval;      /* card insert/removal polling interval */
+    UINT8            InitMask;               /* bus driver init mask */
+#define BD_TIMER_INIT    0x01
+#define HELPER_INIT      0x02
+#define RESOURCE_INIT    0x04
+    BOOL             CDTimerQueued;          /* card detect timer queued */
+    OSKERNEL_HELPER  CardDetectHelper;       /* card detect helper */
+    PSDMESSAGE_QUEUE pCardDetectMsgQueue;    /* card detect message queue */
+    ULONG            HcdInUseField;          /* bit field of in use HCD numbers*/
+    UINT32           ConfigFlags;            /* bus driver configuration flags */
+#define BD_CONFIG_SDREQ_FORCE_ALL_ASYNC 0x00000001
+    INT              MaxHcdRecursion;        /* max HCD recurion level */
+}BDCONTEXT, *PBDCONTEXT;
+
+#define BD_DEFAULT_CONFIG_FLAGS 0x00000000
+#define IsQueueBusy(pRequestQueue)      (pRequestQueue)->Busy
+#define MarkQueueBusy(pRequestQueue)    (pRequestQueue)->Busy = TRUE
+#define MarkQueueNotBusy(pRequestQueue) (pRequestQueue)->Busy = FALSE
+
+#define CLEAR_INTERNAL_REQ_FLAGS(pReq) (pReq)->Flags &= ~(UINT)((SDREQ_FLAGS_RESP_SPI_CONVERTED | \
+                                                          SDREQ_FLAGS_FORCE_DEFERRED_COMPLETE))
+
+/* macros to insert request into the queue */
+#define QueueRequest(pReqQ,pReq) SDListInsertTail(&(pReqQ)->Queue,&(pReq)->SDList)
+#define QueueRequestToFront(pReqQ,pReq) SDListInsertHead(&(pReqQ)->Queue,&(pReq)->SDList)
+
+/* macros to remove an item from the head of the queue */
+static INLINE PSDREQUEST DequeueRequest(PSDREQUESTQUEUE pRequestQueue) {
+    PSDLIST pItem;
+    pItem = SDListRemoveItemFromHead(&pRequestQueue->Queue);
+    if (pItem != NULL) {
+        return CONTAINING_STRUCT(pItem, SDREQUEST, SDList);
+    }
+    return NULL;
+};
+
+static INLINE SDIO_STATUS InitializeRequestQueue(PSDREQUESTQUEUE pRequestQueue) {
+    SDLIST_INIT(&pRequestQueue->Queue);
+    MarkQueueNotBusy(pRequestQueue);
+    return SDIO_STATUS_SUCCESS;
+}
+
+static INLINE void CleanupRequestQueue(PSDREQUESTQUEUE pRequestQueue) {
+
+}
+
+/* for bus driver internal use only */
+SDIO_STATUS _SDIO_BusDriverInitialize(void);
+SDIO_STATUS _SDIO_BusGetDefaultSettings(PBDCONTEXT pBdc);
+void _SDIO_BusDriverCleanup(void);
+SDIO_STATUS RemoveAllFunctions(void);
+SDIO_STATUS RemoveHcdFunctions(PSDHCD pHcd);
+PSDDEVICE AllocateDevice(PSDHCD pHcd);
+BOOL AddDeviceToList(PSDDEVICE pDevice);
+SDIO_STATUS DeleteDevices(PSDHCD pHcd);
+SDIO_STATUS NotifyDeviceRemove(PSDDEVICE pDevice);
+extern PBDCONTEXT pBusContext;
+extern const CT_VERSION_CODE g_Version;
+SDIO_STATUS _SDIO_RegisterHostController(PSDHCD pHcd);
+SDIO_STATUS _SDIO_UnregisterHostController(PSDHCD pHcd);
+SDIO_STATUS _SDIO_HandleHcdEvent(PSDHCD pHcd, HCD_EVENT Event);
+SDIO_STATUS _SDIO_RegisterFunction(PSDFUNCTION pFunction);
+SDIO_STATUS _SDIO_UnregisterFunction(PSDFUNCTION pFunction);
+SDIO_STATUS _SDIO_CheckResponse(PSDHCD pHcd, PSDREQUEST pReq, SDHCD_RESPONSE_CHECK_MODE CheckMode);
+SDIO_STATUS ProbeForFunction(PSDDEVICE pDevice, PSDHCD pHcd);
+SDIO_STATUS SDInitializeCard(PSDHCD pHcd);
+SDIO_STATUS SDQuerySDMMCInfo(PSDDEVICE pDevice);
+SDIO_STATUS SDQuerySDIOInfo(PSDDEVICE pDevice);
+SDIO_STATUS SDEnableFunction(PSDDEVICE pDevice, PSDCONFIG_FUNC_ENABLE_DISABLE_DATA pEnData);
+SDIO_STATUS SDAllocFreeSlotCurrent(PSDDEVICE pDevice, BOOL Allocate, PSDCONFIG_FUNC_SLOT_CURRENT_DATA pData);
+SDIO_STATUS SDMaskUnmaskFunctionIRQ(PSDDEVICE pDevice, BOOL Mask);
+SDIO_STATUS SDFunctionAckInterrupt(PSDDEVICE pDevice);
+SDIO_STATUS SDSPIModeEnableDisableCRC(PSDDEVICE pDevice,BOOL Enable);
+SDIO_STATUS IssueBusConfig(PSDDEVICE pDev, PSDCONFIG pConfig);
+SDIO_STATUS IssueBusRequest(PSDDEVICE pDev, PSDREQUEST pReq);
+PSDREQUEST IssueAllocRequest(PSDDEVICE pDev);
+void IssueFreeRequest(PSDDEVICE pDev, PSDREQUEST pReq);
+PSDREQUEST AllocateRequest(void);
+void FreeRequest(PSDREQUEST pReq);
+PSIGNAL_ITEM AllocateSignal(void);
+void FreeSignal(PSIGNAL_ITEM pSignal);
+SDIO_STATUS InitializeTimers(void);
+SDIO_STATUS CleanupTimers(void);
+SDIO_STATUS QueueTimer(INT TimerID, UINT32 TimeOut);
+SDIO_STATUS DeviceAttach(PSDHCD pHcd);
+SDIO_STATUS DeviceDetach(PSDHCD pHcd);
+SDIO_STATUS DeviceInterrupt(PSDHCD pHcd);
+SDIO_STATUS CardInitSetup(PSDHCD pHcd);
+void RunCardDetect(void);
+void SDIO_NotifyTimerTriggered(INT TimerID);
+SDIO_STATUS TestPresence(PSDHCD          pHcd,
+                         CARD_INFO_FLAGS TestType,
+                         PSDREQUEST      pReq);
+#define _IssueSimpleBusRequest(pHcd,Cmd,Arg,Flags,pReqToUse) \
+          _IssueBusRequestBd((pHcd),(Cmd),(Arg),(Flags),(pReqToUse),NULL,0)
+
+SDIO_STATUS Do_OS_IncHcdReference(PSDHCD pHcd);
+SDIO_STATUS Do_OS_DecHcdReference(PSDHCD pHcd);
+SDIO_STATUS TryNoIrqPendingCheck(PSDDEVICE pDev);
+
+    /* check API version compatibility of an HCD or function driver to a stack major/minor version
+     if the driver version is greater than the major number, we are compatible
+     if the driver version is equal, then we check if the minor is greater than or equal
+     we don't have to check for the less than major, because the bus driver never loads
+     drivers with different major numbers ...
+     if the busdriver compiled version major is greater than the major version being checked this
+     macro will resolved to ALWAYS true thus optimizing the code to not check the HCD since
+     as a rule we never load an HCD with a lower major number */
+#define CHECK_API_VERSION_COMPAT(p,major,minor)       \
+     ((CT_SDIO_STACK_VERSION_MAJOR(CT_SDIO_STACK_VERSION_CODE) > (major)) || \
+      (GET_SDIO_STACK_VERSION_MINOR((p)) >= (minor)))
+
+static INLINE SDIO_STATUS OS_IncHcdReference(PSDHCD pHcd) {
+        /* this API was added in version 2.3 which requires access to a field in the HCD structure */
+    if (CHECK_API_VERSION_COMPAT(pHcd,2,3)) {
+            /* we can safely call the OS-dependent function */
+        return Do_OS_IncHcdReference(pHcd);
+    }
+    return SDIO_STATUS_SUCCESS;
+}
+
+static INLINE SDIO_STATUS OS_DecHcdReference(PSDHCD pHcd) {
+            /* this API was added in version 2.3 which requires access to a field in the HCD structure */
+    if (CHECK_API_VERSION_COMPAT(pHcd,2,3)) {
+            /* we can safely call the OS-dependent function */
+        return Do_OS_DecHcdReference(pHcd);
+    }
+    return SDIO_STATUS_SUCCESS;
+}
+
+SDIO_STATUS _IssueBusRequestBd(PSDHCD           pHcd,
+                               UINT8            Cmd,
+                               UINT32           Argument,
+                               SDREQUEST_FLAGS  Flags,
+                               PSDREQUEST       pReqToUse,
+                               PVOID            pData,
+                               INT              Length);
+
+SDIO_STATUS IssueRequestToHCD(PSDHCD pHcd,PSDREQUEST pReq);
+
+#define CALL_HCD_CONFIG(pHcd,pCfg) (pHcd)->pConfigure((pHcd),(pCfg))
+    /* macro to force all requests to be asynchronous in the HCD */
+static INLINE BOOL ForceAllRequestsAsync(void) {
+    return (pBusContext->ConfigFlags & BD_CONFIG_SDREQ_FORCE_ALL_ASYNC);
+}
+
+static INLINE SDIO_STATUS CallHcdRequest(PSDHCD pHcd) {
+
+    if (pHcd->pCurrentRequest->Flags & SDREQ_FLAGS_PSEUDO) {
+        DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: PSEUDO Request 0x%X \n",
+                    (INT)pHcd->pCurrentRequest));
+            /* return successful completion so that processing can finish */
+        return SDIO_STATUS_SUCCESS;
+    }
+
+    if (ForceAllRequestsAsync()) {
+            /* all requests must be completed(indicated) in a separate context */
+        pHcd->pCurrentRequest->Flags |= SDREQ_FLAGS_FORCE_DEFERRED_COMPLETE;
+    } else {
+            /* otherwise perform a test on flags in the HCD */
+        if (!CHECK_API_VERSION_COMPAT(pHcd,2,6) &&
+            AtomicTest_Set(&pHcd->HcdFlags, HCD_REQUEST_CALL_BIT)) {
+
+            /* bit was already set, this is a recursive call,
+             * we need to tell the HCD to complete the
+             * request in a separate context */
+            DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: Recursive CallHcdRequest \n"));
+            pHcd->pCurrentRequest->Flags |= SDREQ_FLAGS_FORCE_DEFERRED_COMPLETE;
+        }
+    }
+#ifdef DEBUG
+    {
+        SDIO_STATUS status;
+        BOOL forceDeferred;
+        forceDeferred = pHcd->pCurrentRequest->Flags & SDREQ_FLAGS_FORCE_DEFERRED_COMPLETE;
+        status = pHcd->pRequest(pHcd);
+        if (forceDeferred) {
+                /* status better be pending... */
+            DBG_ASSERT(status == SDIO_STATUS_PENDING);
+        }
+        return status;
+    }
+#else
+    return pHcd->pRequest(pHcd);
+#endif
+
+}
+
+/* note the caller of this macro must take the HCD lock to protect the count */
+#define CHECK_HCD_RECURSE(pHcd,pReq)   \
+{                                      \
+    (pHcd)->Recursion++;               \
+    DBG_ASSERT((pHcd)->Recursion < MAX_HCD_RECURSION_RUNAWAY); \
+    if ((pHcd)->Recursion > pBusContext->MaxHcdRecursion) {    \
+        DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: Recursive Request Count Exceeded (%d) \n",(pHcd)->Recursion)); \
+        (pReq)->Flags |= SDREQ_FLAGS_FORCE_DEFERRED_COMPLETE; \
+    }                                                         \
+}
+
+/* InternalFlags bit number settings */
+#define SDBD_INIT        1
+#define SDBD_PENDING    15
+#define SDBD_ALLOC_IRQ_SAFE     2
+
+#define SDBD_ALLOC_IRQ_SAFE_MASK (1 << SDBD_ALLOC_IRQ_SAFE)
+
+static void INLINE DoRequestCompletion(PSDREQUEST pReq, PSDHCD pHcd) {
+    CLEAR_INTERNAL_REQ_FLAGS(pReq);
+    if (pReq->pCompletion != NULL) {
+        DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: Calling completion on request:0x%X, CMD:%d \n",
+           (INT)pReq, pReq->Command));
+            /* call completion routine, mark request reusable */
+        AtomicTest_Clear(&pReq->InternalFlags, SDBD_PENDING);
+        pReq->pCompletion(pReq);
+    } else {
+            /* mark request reusable */
+        AtomicTest_Clear(&pReq->InternalFlags, SDBD_PENDING);
+    }
+}
+
+THREAD_RETURN CardDetectHelperFunction(POSKERNEL_HELPER pHelper);
+THREAD_RETURN SDIOIrqHelperFunction(POSKERNEL_HELPER pHelper);
+
+void ConvertSPI_Response(PSDREQUEST pReq, UINT8 *pRespBuffer);
+
+static INLINE SDIO_STATUS PostCardDetectEvent(PBDCONTEXT pSDB, HCD_EVENT Event, PSDHCD pHcd) {
+    HCD_EVENT_MESSAGE message;
+    SDIO_STATUS       status;
+    message.Event = Event;
+    message.pHcd = pHcd;
+
+    if (pHcd != NULL) {
+            /* increment HCD reference count to process this HCD message */
+        status = OS_IncHcdReference(pHcd);
+        if (!SDIO_SUCCESS(status)) {
+            return status;
+        }
+    }
+        /* post card detect message */
+    status = SDLIB_PostMessage(pSDB->pCardDetectMsgQueue, &message, sizeof(message));
+    if (!SDIO_SUCCESS(status)) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: PostCardDetectEvent error status %d\n",status));
+        if (pHcd != NULL) {
+                /* decrement count */
+            OS_DecHcdReference(pHcd);
+        }
+        return status;
+    }
+        /* wake card detect helper */
+    DBG_PRINT(SDIODBG_HCD_EVENTS, ("SDIO Bus Driver: PostCardDetectEvent waking\n"));
+    return SD_WAKE_OS_HELPER(&pSDB->CardDetectHelper);
+};
+
+/* initialize device fields */
+static INLINE void InitDeviceData(PSDHCD pHcd, PSDDEVICE pDevice) {
+    ZERO_POBJECT(pDevice);
+    SDLIST_INIT(&pDevice->SDList);
+    SDLIST_INIT(&pDevice->FuncListLink);
+    pDevice->pRequest = IssueBusRequest;
+    pDevice->pConfigure = IssueBusConfig;
+    pDevice->AllocRequest = IssueAllocRequest;
+    pDevice->FreeRequest = IssueFreeRequest;
+        /* set card flags in the ID */
+    pDevice->pId[0].CardFlags = pHcd->CardProperties.Flags;
+    pDevice->pFunction = NULL;
+    pDevice->pHcd = pHcd;
+    SET_SDIO_STACK_VERSION(pDevice);
+}
+
+/* de-initialize device fields */
+static INLINE void DeinitDeviceData(PSDDEVICE pDevice) {
+}
+
+/* reset hcd state */
+static INLINE void ResetHcdState(PSDHCD pHcd) {
+    ZERO_POBJECT(&pHcd->CardProperties);
+    pHcd->PendingHelperIrqs = 0;
+    pHcd->PendingIrqAcks = 0;
+    pHcd->IrqsEnabled = 0;
+    pHcd->pCurrentRequest = NULL;
+    pHcd->IrqProcState = SDHCD_IDLE;
+        /* mark this device as special */
+    pHcd->pPseudoDev->pId[0].CardFlags = CARD_PSEUDO;
+    pHcd->SlotCurrentAllocated = 0;
+}
+
+static INLINE SDIO_STATUS _IssueConfig(PSDHCD           pHcd,
+                                       SDCONFIG_COMMAND Command,
+                                       PVOID            pData,
+                                       INT              Length){
+    SDCONFIG  configHdr;
+    SET_SDCONFIG_CMD_INFO(&configHdr,Command,pData,Length);
+    return CALL_HCD_CONFIG(pHcd,&configHdr);
+}
+
+/* prototypes */
+#define _AcquireHcdLock(pHcd)CriticalSectionAcquireSyncIrq(&(pHcd)->HcdCritSection)
+#define _ReleaseHcdLock(pHcd)CriticalSectionReleaseSyncIrq(&(pHcd)->HcdCritSection)
+
+#define AcquireHcdLock(pDev) CriticalSectionAcquireSyncIrq(&(pDev)->pHcd->HcdCritSection)
+#define ReleaseHcdLock(pDev) CriticalSectionReleaseSyncIrq(&(pDev)->pHcd->HcdCritSection)
+
+SDIO_STATUS OS_AddDevice(PSDDEVICE pDevice, PSDFUNCTION pFunction);
+void OS_RemoveDevice(PSDDEVICE pDevice);
+SDIO_STATUS OS_InitializeDevice(PSDDEVICE pDevice, PSDFUNCTION pFunction);
+SDIO_STATUS SetOperationalBusMode(PSDDEVICE               pDevice,
+                                  PSDCONFIG_BUS_MODE_DATA pBusMode);
+void FreeDevice(PSDDEVICE pDevice);
+BOOL IsPotentialIdMatch(PSD_PNP_INFO pIdsDev, PSD_PNP_INFO pIdsFuncList);
+
+
+#define CHECK_FUNCTION_DRIVER_VERSION(pF) \
+    (GET_SDIO_STACK_VERSION_MAJOR((pF)) == CT_SDIO_STACK_VERSION_MAJOR(g_Version))
+#define CHECK_HCD_DRIVER_VERSION(pH) \
+    (GET_SDIO_STACK_VERSION_MAJOR((pH)) == CT_SDIO_STACK_VERSION_MAJOR(g_Version))
+
+/* CLARIFICATION on SDREQ_FLAGS_PSEUDO and SDREQ_FLAGS_BARRIER flags :
+ *
+ * A request marked as PSEUDO is synchronized with bus requests and is not a true request
+ * that is issued to an HCD.
+ *
+ * A request marked with a BARRIER flag requires that the completion routine be called
+ * before the next bus request starts.  This is required for HCD requests that can change
+ * bus or clock modes.  Changing the clock or bus mode while a bus request is pending
+ * can cause problems.
+ *
+ *
+ *
+ * */
+#define SD_PSEUDO_REQ_FLAGS \
+      (SDREQ_FLAGS_PSEUDO | SDREQ_FLAGS_BARRIER | SDREQ_FLAGS_TRANS_ASYNC)
+
+#endif /*___BUSDRIVER_H___*/
Index: linux-2.6/drivers/sdio/busdriver/sdio_bus.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/busdriver/sdio_bus.c
@@ -0,0 +1,2120 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdio_bus.c
+
+@abstract: OS independent bus driver support
+@category abstract: HD_Reference Host Controller Driver Interfaces.
+@category abstract: PD_Reference
+    Peripheral Driver Interfaces.
+
+#notes: this file supports the HCD's and generic functions
+
+@notice: Copyright (c), 2004-2006 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define MODULE_NAME  SDBUSDRIVER
+#include <linux/sdio/ctsystem.h>
+#include <linux/sdio/sdio_busdriver.h>
+#include <linux/sdio/_sdio_defs.h>
+#include <linux/sdio/sdio_lib.h>
+#include <linux/sdio/mmc_defs.h>
+#include "_busdriver.h"
+
+/* list of host controller bus drivers */
+PBDCONTEXT pBusContext = NULL;
+static void CleanUpBusResources(void);
+static SDIO_STATUS AllocateBusResources(void);
+static PSIGNAL_ITEM BuildSignal(void);
+static void DestroySignal(PSIGNAL_ITEM pSignal);
+
+const CT_VERSION_CODE g_Version = CT_SDIO_STACK_VERSION_CODE;
+/*
+ * _SDIO_BusDriverInitialize - call once on driver loading
+ *
+*/
+SDIO_STATUS _SDIO_BusDriverInitialize(void)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+
+    DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Version: %d.%d\n",
+       CT_SDIO_STACK_VERSION_MAJOR(g_Version),CT_SDIO_STACK_VERSION_MINOR(g_Version)));
+
+    DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: enter _SDIO_BusDriverInitialize\n"));
+
+    do {
+        /* allocate our internal data initialize it */
+        pBusContext = KernelAlloc(sizeof(BDCONTEXT));
+        if (pBusContext == NULL) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: _SDIO_BusDriverInitialize can't allocate memory.\n"));
+            status = SDIO_STATUS_NO_RESOURCES;
+            break;
+        }
+        memset(pBusContext,0,sizeof(BDCONTEXT));
+        SDLIST_INIT(&pBusContext->RequestList);
+        SDLIST_INIT(&pBusContext->HcdList);
+        SDLIST_INIT(&pBusContext->DeviceList);
+        SDLIST_INIT(&pBusContext->FunctionList);
+        SDLIST_INIT(&pBusContext->SignalList);
+
+            /* setup defaults */
+        pBusContext->RequestRetries = SDMMC_DEFAULT_CMD_RETRIES;
+        pBusContext->CardReadyPollingRetry = SDMMC_DEFAULT_CARD_READY_RETRIES;
+        pBusContext->PowerSettleDelay = SDMMC_POWER_SETTLE_DELAY;
+        pBusContext->DefaultOperClock = MMC_HS_MAX_BUS_CLOCK;
+        pBusContext->DefaultBusMode = SDCONFIG_BUS_WIDTH_4_BIT;
+        pBusContext->RequestListSize = SDBUS_DEFAULT_REQ_LIST_SIZE;
+        pBusContext->SignalSemListSize = SDBUS_DEFAULT_REQ_SIG_SIZE;
+        pBusContext->CDPollingInterval = SDBUS_DEFAULT_CD_POLLING_INTERVAL;
+        pBusContext->DefaultOperBlockLen = SDMMC_DEFAULT_BYTES_PER_BLOCK;
+        pBusContext->DefaultOperBlockCount = SDMMC_DEFAULT_BLOCKS_PER_TRANS;
+        pBusContext->ConfigFlags = BD_DEFAULT_CONFIG_FLAGS;
+        pBusContext->CMD13PollingMultiplier = SDMMC_CMD13_POLLING_MULTIPLIER;
+        pBusContext->MaxHcdRecursion = MAX_HCD_REQ_RECURSION;
+
+            /* get overrides for the defaults */
+        status = _SDIO_BusGetDefaultSettings(pBusContext);
+        if (!SDIO_SUCCESS(status)) {
+            break;
+        }
+
+        pBusContext->MaxRequestAllocations = pBusContext->RequestListSize << 1;
+        pBusContext->MaxSignalAllocations = pBusContext->SignalSemListSize << 1;
+
+        status = CriticalSectionInit(&pBusContext->RequestListCritSection);
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: _SDIO_BusDriverInitialize can't CriticalSectionInit.\n"));
+            break;
+        }
+        status = SemaphoreInitialize(&pBusContext->HcdListSem, 1);
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: _SDIO_BusDriverInitialize can't SemaphoreInitialize HcdListSem.\n"));
+            break;
+        }
+        status = SemaphoreInitialize(&pBusContext->DeviceListSem, 1);
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: _SDIO_BusDriverInitialize can't SemaphoreInitialize DeviceListSem.\n"));
+            break;
+        }
+        status = SemaphoreInitialize(&pBusContext->FunctionListSem, 1);
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: _SDIO_BusDriverInitialize can't SemaphoreInitialize FunctionListSem.\n"));
+            break;
+        }
+        status = AllocateBusResources();
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: _SDIO_BusDriverInitialize can't AllocateBusResources.\n"));
+            break;
+        }
+
+        pBusContext->InitMask |= RESOURCE_INIT;
+
+        pBusContext->pCardDetectMsgQueue = SDLIB_CreateMessageQueue(MAX_CARD_DETECT_MSGS,
+                                                                   sizeof(HCD_EVENT_MESSAGE));
+
+        if (NULL == pBusContext->pCardDetectMsgQueue) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: _SDIO_BusDriverInitialize can't CreateMessageQueue.\n"));
+            status = SDIO_STATUS_NO_RESOURCES;
+            break;
+        }
+
+        status = SDLIB_OSCreateHelper(&pBusContext->CardDetectHelper,
+                                      CardDetectHelperFunction,
+                                      NULL);
+
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: _SDIO_BusDriverInitialize can't OSCreateHelper.\n"));
+            break;
+        }
+
+        pBusContext->InitMask |= HELPER_INIT;
+
+        status = InitializeTimers();
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: _SDIO_BusDriverInitialize can't InitializeTimers.\n"));
+            break;
+        }
+        pBusContext->InitMask |= BD_TIMER_INIT;
+    } while(FALSE);
+
+    if (!SDIO_SUCCESS(status)) {
+        _SDIO_BusDriverCleanup();
+    }
+
+    return status;
+}
+
+
+/*
+ * _SDIO_BusDriverBusDriverCleanup - call once on driver unloading
+ *
+*/
+void _SDIO_BusDriverCleanup(void) {
+    DBG_PRINT(SDDBG_TRACE, ("+SDIO Bus Driver: _SDIO_BusDriverCleanup\n"));
+
+    if (pBusContext->InitMask & BD_TIMER_INIT) {
+        CleanupTimers();
+    }
+
+    if (pBusContext->InitMask & HELPER_INIT) {
+        SDLIB_OSDeleteHelper(&pBusContext->CardDetectHelper);
+    }
+
+    if (pBusContext->pCardDetectMsgQueue != NULL) {
+        SDLIB_DeleteMessageQueue(pBusContext->pCardDetectMsgQueue);
+        pBusContext->pCardDetectMsgQueue = NULL;
+    }
+        /* remove functions */
+    RemoveAllFunctions();
+        /* cleanup all devices */
+    DeleteDevices(NULL);
+    CleanUpBusResources();
+    CriticalSectionDelete(&pBusContext->RequestListCritSection);
+    SemaphoreDelete(&pBusContext->HcdListSem);
+    SemaphoreDelete(&pBusContext->DeviceListSem);
+    SemaphoreDelete(&pBusContext->FunctionListSem);
+    KernelFree(pBusContext);
+    pBusContext = NULL;
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO Bus Driver: _SDIO_BusDriverCleanup\n"));
+}
+
+
+/* cleanup hcd */
+static void CleanupHcd(PSDHCD pHcd)
+{
+    SDLIB_OSDeleteHelper(&pHcd->SDIOIrqHelper);
+    CleanupRequestQueue(&pHcd->CompletedRequestQueue);
+    CleanupRequestQueue(&pHcd->RequestQueue);
+    CriticalSectionDelete(&pHcd->HcdCritSection);
+    SemaphoreDelete(&pHcd->ConfigureOpsSem);
+    pHcd->pCurrentRequest = NULL;
+    if (pHcd->pPseudoDev != NULL) {
+        FreeDevice(pHcd->pPseudoDev);
+        pHcd->pPseudoDev = NULL;
+    }
+}
+
+/* set up the hcd */
+static SDIO_STATUS SetupHcd(PSDHCD pHcd)
+{
+    SDIO_STATUS status;
+
+    ZERO_POBJECT(&pHcd->SDIOIrqHelper);
+    ZERO_POBJECT(&pHcd->ConfigureOpsSem);
+    ZERO_POBJECT(&pHcd->HcdCritSection);
+    ZERO_POBJECT(&pHcd->RequestQueue);
+    ZERO_POBJECT(&pHcd->CompletedRequestQueue);
+    pHcd->pPseudoDev = NULL;
+    pHcd->Recursion = 0;
+
+    do {
+
+        pHcd->pPseudoDev = AllocateDevice(pHcd);
+
+        if (NULL == pHcd->pPseudoDev) {
+            status = SDIO_STATUS_NO_RESOURCES;
+            break;
+        }
+
+        ResetHcdState(pHcd);
+
+        status = SemaphoreInitialize(&pHcd->ConfigureOpsSem,1);
+        if (!SDIO_SUCCESS(status)) {
+            break;
+        }
+        status = CriticalSectionInit(&pHcd->HcdCritSection);
+        if (!SDIO_SUCCESS(status)) {
+            break;
+        }
+        status = InitializeRequestQueue(&pHcd->RequestQueue);
+        if (!SDIO_SUCCESS(status)) {
+            break;
+        }
+        status = InitializeRequestQueue(&pHcd->CompletedRequestQueue);
+        if (!SDIO_SUCCESS(status)) {
+            break;
+        }
+            /* create SDIO Irq helper */
+        status = SDLIB_OSCreateHelper(&pHcd->SDIOIrqHelper,
+                                      SDIOIrqHelperFunction,
+                                     (PVOID)pHcd);
+    } while(FALSE);
+
+    if (!SDIO_SUCCESS(status)) {
+            /* undo what we did */
+        CleanupHcd(pHcd);
+    }
+    return status;
+}
+
+
+/*
+ * _SDIO_RegisterHostController - register a host controller bus driver
+ *
+*/
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Register a host controller driver with the bus driver.
+
+  @function name: SDIO_RegisterHostController
+  @prototype: SDIO_STATUS SDIO_RegisterHostController (PSDHCD pHcd)
+  @category: HD_Reference
+
+  @input:  pHcd - the host controller definition structure.
+
+  @output: none
+
+  @return: SDIO_STATUS - SDIO_STATUS_SUCCESS when successful.
+
+  @notes: Each host controller driver must register with the bus driver when loaded.
+          The driver registers an SDHCD structure initialized with hardware properties
+          and callback functions for bus requests and configuration.  On multi-slot
+          hardware ,each slot should be registered with a separate SDHCD structure.
+          The bus driver views each slot as a seperate host controller object.
+          The driver should be prepared to receive configuration requests before
+          this call returns. The host controller driver must unregister itself when
+          shutting down.
+
+  @example: Registering a host controller driver:
+    static SDHCD Hcd = {
+       .pName = "sdio_custom_hcd",
+       .Version = CT_SDIO_STACK_VERSION_CODE,  // set stack version code
+       .SlotNumber = 0,                        // bus driver internal use
+       .Attributes = SDHCD_ATTRIB_BUS_1BIT | SDHCD_ATTRIB_BUS_4BIT | SDHCD_ATTRIB_MULTI_BLK_IRQ
+                     SDHCD_ATTRIB_AUTO_CMD12 ,
+       .MaxBytesPerBlock = 2048     // each data block can be up to 2048 bytes
+       .MaxBlocksPerTrans = 1024,   // each data transaction can consist of 1024 blocks
+       .MaxSlotCurrent = 500,       // max FET switch current rating
+       .SlotVoltageCaps = SLOT_POWER_3_3V,      // only 3.3V operation
+       .SlotVoltagePreferred = SLOT_POWER_3_3V,
+       .MaxClockRate = 24000000,   // 24 Mhz max operation
+       .pContext = &HcdContext,    // set our driver context
+       .pRequest = HcdRequest,     // set SDIO bus request callback
+       .pConfigure = HcdConfig,    // set SDIO bus configuration callback
+    };
+    if (!SDIO_SUCCESS((status = SDIO_RegisterHostController(&Hcd)))) {
+         DBG_PRINT(SDDBG_ERROR, ("SDIO HCD - failed to register with host, status =%d\n",
+                                    status));
+    }
+
+  @see also: SDIO_UnregisterHostController
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS _SDIO_RegisterHostController(PSDHCD pHcd) {
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+
+    DBG_PRINT(SDDBG_TRACE, ("+SDIO Bus Driver: _SDIO_RegisterHostController - %s\n",pHcd->pName));
+    DBG_PRINT(SDDBG_TRACE, ("+SDIO Bus Driver: Host Controller Stack Version: %d.%d \n",
+        GET_SDIO_STACK_VERSION_MAJOR(pHcd),GET_SDIO_STACK_VERSION_MINOR(pHcd)));
+
+    if (!CHECK_HCD_DRIVER_VERSION(pHcd)) {
+        DBG_PRINT(SDDBG_ERROR,
+           ("SDIO Bus Driver: HCD Major Version Mismatch (hcd = %d, bus driver = %d)\n",
+           GET_SDIO_STACK_VERSION_MAJOR(pHcd), CT_SDIO_STACK_VERSION_MAJOR(g_Version)));
+        return SDIO_STATUS_INVALID_PARAMETER;
+    }
+        /* setup hcd */
+    status = SetupHcd(pHcd);
+    if (!SDIO_SUCCESS(status)) {
+        return status;
+    }
+
+    do {
+        INT slotNumber;
+
+            /* protect the HCD list */
+        if (!SDIO_SUCCESS((status = SemaphorePendInterruptable(&pBusContext->HcdListSem)))) {
+            break;  /* wait interrupted */
+        }
+            /* find a unique number for this HCD, must be done under semaphore protection */
+        slotNumber = FirstClearBit(&pBusContext->HcdInUseField);
+        if (slotNumber < 0) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: _SDIO_RegisterHostController, error, slotNumber exceeded\n"));
+            /* fake something */
+            slotNumber = 31;
+        }
+        SetBit(&pBusContext->HcdInUseField, slotNumber);
+        pHcd->SlotNumber = slotNumber;
+            /* add HCD to the end of the internal list */
+        SDListAdd(&pBusContext->HcdList , &pHcd->SDList);
+        if (!SDIO_SUCCESS((status = SemaphorePost(&pBusContext->HcdListSem)))) {
+            break;   /* wait interrupted */
+        }
+        if (pHcd->Attributes & SDHCD_ATTRIB_SLOT_POLLING) {
+                /* post message to card detect helper to do polling */
+            PostCardDetectEvent(pBusContext, EVENT_HCD_CD_POLLING, NULL);
+        }
+    } while (FALSE);
+
+    if (!SDIO_SUCCESS(status)) {
+       CleanupHcd(pHcd);
+       DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: _SDIO_RegisterHostController, error 0x%X.\n", status));
+    }
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO Bus Driver: _SDIO_RegisterHostController\n"));
+    return status;
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Unregister a host controller driver with the bus driver.
+
+  @function name: SDIO_UnregisterHostController
+  @prototype: SDIO_STATUS SDIO_UnregisterHostController (PSDHCD pHcd)
+  @category: HD_Reference
+
+  @input:  pHcd - the host controller definition structure that was registered.
+
+  @output: none
+
+  @return: SDIO_STATUS - SDIO_STATUS_SUCCESS when successful.
+
+  @notes: Each host controller driver must unregister with the bus driver when
+          unloading. The driver is responsible for halting any outstanding I/O
+          operations.  The bus driver will automatically unload function drivers
+          that may be attached assigned to cards inserted into slots.
+
+  @example: Unregistering a host controller driver:
+    if (!SDIO_SUCCESS((status = SDIO_UnregisterHostController(&Hcd)))) {
+         DBG_PRINT(SDDBG_ERROR, ("SDIO HCD - failed to unregister with host, status =%d\n",
+                                    status));
+    }
+
+  @see also: SDIO_RegisterHostController
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS _SDIO_UnregisterHostController(PSDHCD pHcd) {
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+
+    DBG_PRINT(SDDBG_TRACE, ("+SDIO Bus Driver: _SDIO_UnregisterHostController\n"));
+
+        /* remove functions associated with the HCD */
+    RemoveHcdFunctions(pHcd);
+        /* remove any devices associated with the HCD */
+    DeleteDevices(pHcd);
+    /* wait for the message queue to be empty, so we don't have any delayed requests going
+       to this device */
+    while(!SDLIB_IsQueueEmpty(pBusContext->pCardDetectMsgQueue)) {
+        /* wait for the messages to be handled */
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: _SDIO_UnregisterHostController, waiting on messages\n"));
+        OSSleep(250);
+    }
+
+    /* protect the HCD list */
+    if (!SDIO_SUCCESS((status = SemaphorePendInterruptable(&pBusContext->HcdListSem)))) {
+        goto cleanup;   /* wait interrupted */
+    }
+    ClearBit(&pBusContext->HcdInUseField, pHcd->SlotNumber);
+    /* delete HCD from list  */
+    SDListRemove(&pHcd->SDList);
+    if (!SDIO_SUCCESS((status = SemaphorePost(&pBusContext->HcdListSem)))) {
+        goto cleanup;   /* wait interrupted */
+    }
+        /* cleanup anything we allocated */
+    CleanupHcd(pHcd);
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO Bus Driver: _SDIO_UnregisterHostController\n"));
+    return status;
+cleanup:
+    DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: _SDIO_UnregisterHostController, error 0x%X.\n", status));
+    return status;
+}
+
+/* documentation headers only for Request and Configure */
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: The bus driver calls the request callback to start an SDIO bus transaction.
+  @function name: Request
+  @prototype: SDIO_STATUS (*pRequest) (struct _SDHCD *pHcd)
+  @category: HD_Reference
+
+  @input:  pHcd - the host controller structure that was registered
+
+  @output: none
+
+  @return: SDIO_STATUS
+
+  @notes:
+          The bus driver maintains an internal queue of SDREQUEST structures submited by function
+          drivers. The driver should use request macros to obtain a pointer to the current SDREQUEST
+          at the head of the queue.  The driver can access the fields of the current request in order
+          to program hardware appropriately.   Once the request completes, the driver should update
+          the current request information (final status, response bytes and/or data) and call
+          SDIO_HandleHcdEvent() with the event type of EVENT_HCD_TRANSFER_DONE.
+          The bus driver will remove the current request from the head of the queue and start the next
+          request.
+
+  @example: Example of a typical Request callback:
+  SDIO_STATUS HcdRequest(PSDHCD pHcd)
+  {
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    PSDHCD_DRIVER_CONTEXT pHct = (PSDHCD_DRIVER_CONTEXT)pHcd->pContext;
+    UINT32                temp = 0;
+    PSDREQUEST            pReq;
+       // get the current request
+    pReq = GET_CURRENT_REQUEST(pHcd);
+    DBG_ASSERT(pReq != NULL);
+       // get controller settings based on response type
+    switch (GET_SDREQ_RESP_TYPE(pReq->Flags)) {
+        case SDREQ_FLAGS_NO_RESP:
+            break;
+        case SDREQ_FLAGS_RESP_R1:
+        case SDREQ_FLAGS_RESP_MMC_R4:
+        case SDREQ_FLAGS_RESP_MMC_R5:
+        case SDREQ_FLAGS_RESP_R6:
+        case SDREQ_FLAGS_RESP_SDIO_R5:
+            temp |= CMDDAT_RES_R1_R4_R5;
+            break;
+        case SDREQ_FLAGS_RESP_R1B:
+            temp |= (CMDDAT_RES_R1_R4_R5 | CMDAT_RES_BUSY);
+            break;
+        case SDREQ_FLAGS_RESP_R2:
+            temp |= CMDDAT_RES_R2;
+            break;
+        case SDREQ_FLAGS_RESP_R3:
+        case SDREQ_FLAGS_RESP_SDIO_R4:
+            temp |= CMDDAT_RES_R3;
+            break;
+    }
+        // check for data
+    if (pReq->Flags & SDREQ_FLAGS_DATA_TRANS){
+        temp |= CMDDAT_DATA_EN;
+        // set data remaining count
+        pReq->DataRemaining = pReq->BlockLen * pReq->BlockCount;
+        DBG_PRINT(TRACE_DATA, ("SDIO %s Data Transfer, Blocks:%d, BlockLen:%d, Total:%d \n",
+                    IS_SDREQ_WRITE_DATA(pReq->Flags) ? "TX":"RX",
+                    pReq->BlockCount, pReq->BlockLen, pReq->DataRemaining));
+        if (IS_SDREQ_WRITE_DATA(pReq->Flags)) {
+                // write operation
+        }
+    }
+    // .... program hardware, interrupt handler will complete request
+    return SDIO_STATUS_PENDING;
+  }
+
+  @see also: SDIO_HandleHcdEvent
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: The bus driver calls the configure callback to set various options
+             and modes in the host controller hardware.
+
+  @function name: Configure
+  @prototype: SDIO_STATUS (*pConfigure) (struct _SDHCD *pHcd, PSDCONFIG pConfig)
+  @category: HD_Reference
+
+  @input:  pHcd - the host controller structure that was registered
+  @input:  pConfig - configuration request structure
+
+  @output: none
+
+  @return: SDIO_STATUS
+
+  @notes:
+          The host controller driver recieves configuration requests for options
+          such as slot voltage, bus width, clock rates and interrupt detection.
+          The bus driver guarantees that only one configuration option request
+          can be issued at a time.
+
+  @example: Example of a typical configure callback:
+  SDIO_STATUS HcdConfig(PSDHCD pHcd, PSDCONFIG pConfig)
+  {
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    PSDHCD_DRIVER_CONTEXT pHct = (PSDHCD_DRIVER_CONTEXT)pHcd->pContext;
+    UINT16      command;
+        // get command
+    command = GET_SDCONFIG_CMD(pConfig);
+        // decode command
+    switch (command){
+        case SDCONFIG_GET_WP:
+            if (GetGpioPinLevel(pHct,SDIO_CARD_WP_GPIO) == WP_POLARITY) {
+                *((SDCONFIG_WP_VALUE *)pConfig->pData) = 1;
+            } else {
+                *((SDCONFIG_WP_VALUE *)pConfig->pData) = 0;
+            }
+            break;
+        case SDCONFIG_SEND_INIT_CLOCKS:
+            ClockStartStop(pHct,CLOCK_ON);
+                // sleep a little, should be at least 80 clocks at our lowest clock setting
+            status = OSSleep(100);
+            ClockStartStop(pHct,CLOCK_OFF);
+            break;
+        case SDCONFIG_SDIO_INT_CTRL:
+            if (GET_SDCONFIG_CMD_DATA(PSDCONFIG_SDIO_INT_CTRL_DATA,pConfig)->SlotIRQEnable) {
+                // request to enable IRQ detection
+            } else {
+                // request to disable IRQ detectioon
+            }
+            break;
+        case SDCONFIG_SDIO_REARM_INT:
+                // request to re-arm the card IRQ detection logic
+            break;
+        case SDCONFIG_BUS_MODE_CTRL:
+                // request to set bus mode
+            {
+                // get bus mode data structure
+               PSDCONFIG_BUS_MODE_DATA pBusMode =
+                      GET_SDCONFIG_CMD_DATA(PSDCONFIG_SDIO_INT_CTRL_DATA,pConfig);
+                // set bus mode based on settings in bus mode structure
+                // bus mode   :  pBusMode->BusModeFlags
+                // clock rate :  pBusMode->ClockRate
+            }
+            break;
+        case SDCONFIG_POWER_CTRL:
+                // request to set power/voltage
+            {
+                PSDCONFIG_POWER_CTRL_DATA pPowerSetting =
+                       GET_SDCONFIG_CMD_DATA(PSDCONFIG_POWER_CTRL_DATA,pConfig);
+                if (pPowerSetting->SlotPowerEnable) {
+                    // turn on slot power
+                    //
+                } else {
+                    // turn off slot power
+                }
+                DBG_PRINT(PXA_TRACE_CONFIG, ("SDIO PXA255 PwrControl: En:%d, VCC:0x%X \n",
+                      pPowerSetting->SlotPowerEnable,
+                      pPowerSetting->SlotPowerVoltageMask));
+            }
+            break;
+        default:
+            // unsupported
+            status = SDIO_STATUS_INVALID_PARAMETER;
+    }
+    return status;
+ }
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+
+/*
+ * Allocate a Device instance
+ */
+PSDDEVICE AllocateDevice(PSDHCD pHcd)
+{
+    PSDDEVICE pDevice;
+
+    pDevice = KernelAlloc(sizeof(SDDEVICE));
+    if (pDevice != NULL) {
+        InitDeviceData(pHcd,pDevice);
+    }
+    return pDevice;
+}
+
+
+/*
+ * Free a Device instance
+ */
+void FreeDevice(PSDDEVICE pDevice)
+{
+    DeinitDeviceData(pDevice);
+    KernelFree(pDevice);
+}
+/*
+ * add this device to the list
+ */
+BOOL AddDeviceToList(PSDDEVICE pDevice)
+{
+    BOOL success = FALSE;
+
+    do {
+            /* protect the driver list */
+        if (!SDIO_SUCCESS(SemaphorePendInterruptable(&pBusContext->DeviceListSem))) {
+            break;   /* wait interrupted */
+        }
+
+            /* add new device to the internal list */
+        SDListAdd(&pBusContext->DeviceList , &pDevice->SDList);
+
+        if (!SDIO_SUCCESS(SemaphorePost(&pBusContext->DeviceListSem))) {
+            break;
+        }
+
+        success = TRUE;
+    } while (FALSE);
+
+    return success;
+}
+
+/*
+ *  Delete device associated with the HCD
+ *  if pHCD is NULL this function cleans up all devices, the caller
+ *  better have cleaned up functions first!
+ */
+SDIO_STATUS DeleteDevices(PSDHCD pHcd)
+{
+    SDIO_STATUS status;
+    PSDDEVICE   pDevice;
+    DBG_PRINT(SDDBG_TRACE, ("+SDIO Bus Driver: DeleteDevices hcd:0x%X \n", (INT)pHcd));
+      /* protect the device list */
+    if (!SDIO_SUCCESS((status = SemaphorePendInterruptable(&pBusContext->DeviceListSem)))) {
+        goto cleanup;   /* wait interrupted */
+    }
+    SDITERATE_OVER_LIST_ALLOW_REMOVE(&pBusContext->DeviceList,pDevice,SDDEVICE,SDList) {
+            /* only remove devices for the hcd or if we are cleaning up all */
+        if ((NULL == pHcd) || (pDevice->pHcd == pHcd)) {
+            SDListRemove(&pDevice->SDList);
+            DeinitDeviceData(pDevice);
+            FreeDevice(pDevice);
+        }
+    }SDITERATE_END;
+    if (!SDIO_SUCCESS((status = SemaphorePost(&pBusContext->DeviceListSem)))) {
+        goto cleanup;   /* wait interrupted */
+    }
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO Bus Driver: DeleteDevices \n"));
+    return status;
+cleanup:
+    DBG_PRINT(SDDBG_ERROR, ("-SDIO Bus Driver: DeleteDevice, error exit 0x%X\n", status));
+    return status;
+}
+
+
+static SDIO_STATUS AllocateBusResources(void)
+{
+    INT                 ii;
+    PSDREQUEST          pReq;
+    PSIGNAL_ITEM        pSignal;
+
+    DBG_PRINT(SDDBG_TRACE,
+    ("+SDIO Bus Driver: AllocateBusResources (R:%d,S:%d) (CR:%d,MR:%d)(CS:%d,MS:%d) \n",
+       pBusContext->RequestListSize,
+       pBusContext->SignalSemListSize,
+       pBusContext->CurrentRequestAllocations,pBusContext->MaxRequestAllocations,
+       pBusContext->CurrentSignalAllocations,pBusContext->MaxSignalAllocations));
+
+        /* allocate some initial requests */
+    for (ii = 0; ii < pBusContext->RequestListSize; ii++) {
+        pReq = AllocateRequest();
+        if (pReq == NULL) {
+            break;
+        }
+            /* free requests adds the request to the list */
+        FreeRequest(pReq);
+    }
+
+    for (ii = 0; ii < pBusContext->SignalSemListSize; ii++) {
+        pSignal = AllocateSignal();
+        if (pSignal == NULL) {
+            break;
+        }
+            /* freeing it adds it to the list */
+        FreeSignal(pSignal);
+    }
+
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO Bus Driver: AllocateBusResources\n"));
+    return SDIO_STATUS_SUCCESS;
+}
+
+
+/* cleanup bus resources */
+static void CleanUpBusResources(void)
+{
+    PSDLIST      pItem;
+    PSDREQUEST   pReq;
+    PSIGNAL_ITEM pSignal;
+
+    DBG_PRINT(SDDBG_TRACE, ("+SDIO Bus Driver: CleanUpBusResources (CR:%d,MR:%d)(CS:%d,MS:%d) \n",
+       pBusContext->CurrentRequestAllocations,pBusContext->MaxRequestAllocations,
+       pBusContext->CurrentSignalAllocations,pBusContext->MaxSignalAllocations));
+
+    while(1) {
+        pItem = SDListRemoveItemFromHead(&pBusContext->RequestList);
+        if (NULL == pItem) {
+            break;
+        }
+            /* free the request */
+        pReq = CONTAINING_STRUCT(pItem, SDREQUEST, SDList);
+        if (pReq->InternalFlags & SDBD_ALLOC_IRQ_SAFE_MASK) {
+            KernelFreeIrqSafe(pReq);
+        } else {
+            KernelFree(pReq);
+        }
+        pBusContext->CurrentRequestAllocations--;
+    }
+
+    if (pBusContext->CurrentRequestAllocations != 0) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Request allocations are not ZERO! (CR:%d)\n",
+             pBusContext->CurrentRequestAllocations));
+    }
+
+    while(1) {
+        pItem = SDListRemoveItemFromHead(&pBusContext->SignalList);
+        if (NULL == pItem) {
+            break;
+        }
+        pSignal = CONTAINING_STRUCT(pItem, SIGNAL_ITEM, SDList);
+        DestroySignal(pSignal);
+        pBusContext->CurrentSignalAllocations--;
+    }
+
+    if (pBusContext->CurrentSignalAllocations != 0) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Signal allocations are not ZERO! (CR:%d)\n",
+             pBusContext->CurrentRequestAllocations));
+    }
+
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO Bus Driver: CleanUpBusResources\n"));
+}
+
+
+/* free a request to the lookaside list */
+void FreeRequest(PSDREQUEST pReq)
+{
+    SDIO_STATUS status;
+    CT_DECLARE_IRQ_SYNC_CONTEXT();
+
+    status = CriticalSectionAcquireSyncIrq(&pBusContext->RequestListCritSection);
+        /* protect request list */
+    if (!SDIO_SUCCESS(status)) {
+        return;
+    }
+
+    if ((pBusContext->CurrentRequestAllocations <= pBusContext->MaxRequestAllocations) ||
+         !(pReq->InternalFlags & SDBD_ALLOC_IRQ_SAFE_MASK)) {
+            /* add it to the list */
+        SDListAdd(&pBusContext->RequestList, &pReq->SDList);
+            /* we will hold onto this one */
+        pReq = NULL;
+    } else {
+            /* decrement count */
+        pBusContext->CurrentRequestAllocations--;
+    }
+
+    status = CriticalSectionReleaseSyncIrq(&pBusContext->RequestListCritSection);
+
+    if (pReq != NULL) {
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Free Request allocation (CR:%d,MR:%d)\n",
+        pBusContext->CurrentRequestAllocations,pBusContext->MaxRequestAllocations));
+        if (pReq->InternalFlags & SDBD_ALLOC_IRQ_SAFE_MASK) {
+            KernelFreeIrqSafe(pReq);
+        } else {
+                /* we should never free the ones that were normally allocated */
+            DBG_ASSERT(FALSE);
+        }
+    }
+}
+
+/* allocate a request from the lookaside list */
+PSDREQUEST AllocateRequest(void)
+{
+    PSDLIST  pItem;
+    SDIO_STATUS status;
+    PSDREQUEST pReq = NULL;
+    ATOMIC_FLAGS internalflags;
+    CT_DECLARE_IRQ_SYNC_CONTEXT();
+
+
+    status = CriticalSectionAcquireSyncIrq(&pBusContext->RequestListCritSection);
+
+    if (!SDIO_SUCCESS(status)) {
+        return NULL;
+    }
+
+    if (pBusContext->InitMask & RESOURCE_INIT) {
+            /* check the list, we are now running... */
+        pItem = SDListRemoveItemFromHead(&pBusContext->RequestList);
+    } else {
+            /* we are loading the list with requests at initialization */
+        pItem = NULL;
+    }
+    status = CriticalSectionReleaseSyncIrq(&pBusContext->RequestListCritSection);
+
+    if (pItem != NULL) {
+        pReq = CONTAINING_STRUCT(pItem, SDREQUEST, SDList);
+    } else {
+        if (pBusContext->InitMask & RESOURCE_INIT) {
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Request List empty..allocating new one (irq-safe) (CR:%d,MR:%d)\n",
+            pBusContext->CurrentRequestAllocations,pBusContext->MaxRequestAllocations));
+                /* the resource list was already allocated, we must be running now.
+                 * at run-time, we allocate using the safe IRQ */
+            pReq = (PSDREQUEST)KernelAllocIrqSafe(sizeof(SDREQUEST));
+                /* mark that this one was created using IRQ safe allocation */
+            internalflags = SDBD_ALLOC_IRQ_SAFE_MASK;
+        } else {
+                /* use the normal allocation since we are called at initialization */
+            pReq = (PSDREQUEST)KernelAlloc(sizeof(SDREQUEST));
+            internalflags = 0;
+        }
+
+        if (pReq != NULL) {
+            pReq->InternalFlags = internalflags;
+                /* keep track of allocations */
+            status = CriticalSectionAcquireSyncIrq(&pBusContext->RequestListCritSection);
+            pBusContext->CurrentRequestAllocations++;
+            status = CriticalSectionReleaseSyncIrq(&pBusContext->RequestListCritSection);
+        }
+    }
+
+
+    if (pReq != NULL) {
+            /* preserve internal flags */
+        internalflags = pReq->InternalFlags;
+        ZERO_POBJECT(pReq);
+        pReq->InternalFlags = internalflags;
+    }
+
+    return pReq;
+}
+
+void DestroySignal(PSIGNAL_ITEM pSignal)
+{
+   SignalDelete(&pSignal->Signal);
+   KernelFree(pSignal);
+}
+
+PSIGNAL_ITEM BuildSignal(void)
+{
+    PSIGNAL_ITEM pSignal;
+
+    pSignal = (PSIGNAL_ITEM)KernelAlloc(sizeof(SIGNAL_ITEM));
+    if (pSignal != NULL) {
+            /* initialize signal */
+        if (!SDIO_SUCCESS(SignalInitialize(&pSignal->Signal))) {
+            KernelFree(pSignal);
+            pSignal = NULL;
+        }
+    }
+    return pSignal;
+}
+/* free a signal*/
+void FreeSignal(PSIGNAL_ITEM pSignal)
+{
+    SDIO_STATUS status;
+    CT_DECLARE_IRQ_SYNC_CONTEXT();
+
+    status = CriticalSectionAcquireSyncIrq(&pBusContext->RequestListCritSection);
+
+    if (!SDIO_SUCCESS(status)) {
+        return;
+    }
+
+    if (pBusContext->CurrentSignalAllocations <= pBusContext->MaxSignalAllocations) {
+            /* add it to the list */
+        SDListAdd(&pBusContext->SignalList, &pSignal->SDList);
+            /* flag that we are holding onto it */
+        pSignal = NULL;
+    } else {
+            /* decrement count */
+        pBusContext->CurrentSignalAllocations--;
+    }
+
+    status = CriticalSectionReleaseSyncIrq(&pBusContext->RequestListCritSection);
+
+    if (pSignal != NULL) {
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Free signal allocation (CS:%d,MS:%d)\n",
+        pBusContext->CurrentSignalAllocations,pBusContext->MaxSignalAllocations));
+        DestroySignal(pSignal);
+    }
+}
+
+/* allocate a signal from the list */
+PSIGNAL_ITEM AllocateSignal(void)
+{
+    PSDLIST         pItem;
+    PSIGNAL_ITEM    pSignal;
+    SDIO_STATUS status;
+    CT_DECLARE_IRQ_SYNC_CONTEXT();
+
+    status = CriticalSectionAcquireSyncIrq(&pBusContext->RequestListCritSection);
+
+    if (!SDIO_SUCCESS(status)) {
+        return NULL;
+    }
+
+    if (pBusContext->InitMask & RESOURCE_INIT) {
+            /* check the list */
+        pItem = SDListRemoveItemFromHead(&pBusContext->SignalList);
+    } else {
+            /* we are loading the list */
+        pItem = NULL;
+    }
+
+    status = CriticalSectionReleaseSyncIrq(&pBusContext->RequestListCritSection);
+    if (pItem != NULL) {
+            /* return the one from the list */
+        pSignal = CONTAINING_STRUCT(pItem, SIGNAL_ITEM, SDList);
+    } else {
+        if (pBusContext->InitMask & RESOURCE_INIT) {
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Signal List empty..allocating new one (CS:%d,MS:%d)\n",
+            pBusContext->CurrentSignalAllocations,pBusContext->MaxSignalAllocations));
+        }
+            /* just allocate one */
+        pSignal = BuildSignal();
+        status = CriticalSectionAcquireSyncIrq(&pBusContext->RequestListCritSection);
+        if (pSignal != NULL) {
+            pBusContext->CurrentSignalAllocations++;
+        }
+        status = CriticalSectionReleaseSyncIrq(&pBusContext->RequestListCritSection);
+    }
+
+
+    return pSignal;
+}
+
+/*
+ * Issus Bus Request (exposed to function drivers)
+*/
+PSDREQUEST IssueAllocRequest(PSDDEVICE pDev)
+{
+    return AllocateRequest();
+}
+
+/*
+ * Free Request (exposed to function drivers)
+*/
+void IssueFreeRequest(PSDDEVICE pDev, PSDREQUEST pReq)
+{
+    FreeRequest(pReq);
+}
+
+/*
+ * Issus Bus Request (exposed to function drivers)
+*/
+SDIO_STATUS IssueBusRequest(PSDDEVICE pDev, PSDREQUEST pReq)
+{
+    pReq->pFunction = pDev->pFunction;
+    return IssueRequestToHCD(pDev->pHcd,pReq);
+}
+
+
+    /* completion routine for HCD configs, this is synchronized with normal bus requests */
+static void HcdConfigComplete(PSDREQUEST pReq)
+{
+
+    pReq->Status = CALL_HCD_CONFIG((PSDHCD)pReq->pDataBuffer, (PSDCONFIG)pReq->pCompleteContext);
+
+    SignalSet(&((PSIGNAL_ITEM)pReq->pHcdContext)->Signal);
+}
+
+SDIO_STATUS SendSyncedHcdBusConfig(PSDDEVICE pDevice, PSDCONFIG pConfig)
+{
+    SDIO_STATUS     status = SDIO_STATUS_SUCCESS;
+    PSDREQUEST      pReq = NULL;
+    PSIGNAL_ITEM    pSignal = NULL;
+
+    do {
+
+        pSignal = AllocateSignal();
+        if (NULL == pSignal) {
+            status = SDIO_STATUS_NO_RESOURCES;
+            break;
+        }
+
+        pReq = AllocateRequest();
+        if (NULL == pReq) {
+            status = SDIO_STATUS_NO_RESOURCES;
+            break;
+        }
+
+            /* issue pseudo request to sync this with bus requests */
+        pReq->pCompletion = HcdConfigComplete;
+        pReq->pCompleteContext = pConfig;
+            /* re-use hcd context to store the signal since this request
+             * never actually goes to an HCD */
+        pReq->pHcdContext = pSignal;
+        pReq->pDataBuffer = pDevice->pHcd;
+            /* flag this as barrier in case it may change the bus mode of the HCD */
+        pReq->Flags = SDREQ_FLAGS_PSEUDO | SDREQ_FLAGS_BARRIER | SDREQ_FLAGS_TRANS_ASYNC;
+        pReq->Status = SDIO_STATUS_SUCCESS;
+
+            /* issue request */
+        status = IssueRequestToHCD(pDevice->pHcd,pReq);
+
+    } while (FALSE);
+
+    if (SDIO_SUCCESS(status)) {
+        DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: Config Request Sync-Op waiting....\n"));
+        status = SignalWait(&pSignal->Signal);
+
+        if (SDIO_SUCCESS(status)) {
+                /* return the result of the configuration request */
+            status = pReq->Status;
+        }
+    }
+
+        /* cleanup */
+    if (pReq != NULL) {
+        FreeRequest(pReq);
+    }
+
+    if (pSignal != NULL) {
+        FreeSignal(pSignal);
+    }
+
+    return status;
+}
+
+/*
+ * Issus bus Configuration  (exposed to function drivers)
+*/
+SDIO_STATUS IssueBusConfig(PSDDEVICE pDev, PSDCONFIG pConfig)
+{
+    SDIO_STATUS status;
+    INT         cmdLength;
+    UINT8       debugLevel = SDDBG_ERROR;
+
+    cmdLength = GET_SDCONFIG_CMD_LEN(pConfig);
+    status = SDIO_STATUS_INVALID_PARAMETER;
+
+    do {
+            /* check buffers and length */
+        if (IS_SDCONFIG_CMD_GET(pConfig) || IS_SDCONFIG_CMD_PUT(pConfig)) {
+            if ((GET_SDCONFIG_CMD_DATA(PVOID,pConfig) == NULL) || (0 == cmdLength)) {
+                break;
+            }
+        }
+
+        switch (GET_SDCONFIG_CMD(pConfig)) {
+            case SDCONFIG_FUNC_ACK_IRQ:
+                status = SDFunctionAckInterrupt(pDev);
+                break;
+            case SDCONFIG_FUNC_ENABLE_DISABLE:
+                if (cmdLength < sizeof(SDCONFIG_FUNC_ENABLE_DISABLE_DATA)) {
+                    break;
+                }
+                status = SDEnableFunction(pDev,
+                           GET_SDCONFIG_CMD_DATA(PSDCONFIG_FUNC_ENABLE_DISABLE_DATA,pConfig));
+                break;
+            case SDCONFIG_FUNC_UNMASK_IRQ:
+                status = SDMaskUnmaskFunctionIRQ(pDev,FALSE);
+                break;
+            case SDCONFIG_FUNC_MASK_IRQ:
+                status = SDMaskUnmaskFunctionIRQ(pDev,TRUE);
+                break;
+            case SDCONFIG_FUNC_SPI_MODE_DISABLE_CRC:
+                status = SDSPIModeEnableDisableCRC(pDev,FALSE);
+                break;
+            case SDCONFIG_FUNC_SPI_MODE_ENABLE_CRC:
+                status = SDSPIModeEnableDisableCRC(pDev,TRUE);
+                break;
+            case SDCONFIG_FUNC_ALLOC_SLOT_CURRENT:
+                status = SDAllocFreeSlotCurrent(pDev,
+                                                TRUE,
+                                   GET_SDCONFIG_CMD_DATA(PSDCONFIG_FUNC_SLOT_CURRENT_DATA,pConfig));
+                break;
+            case SDCONFIG_FUNC_FREE_SLOT_CURRENT:
+                status = SDAllocFreeSlotCurrent(pDev, FALSE, NULL);
+                break;
+            case SDCONFIG_FUNC_CHANGE_BUS_MODE:
+
+                status = SetOperationalBusMode(pDev,
+                                               GET_SDCONFIG_CMD_DATA(PSDCONFIG_BUS_MODE_DATA,
+                                               pConfig));
+                break;
+            case SDCONFIG_FUNC_NO_IRQ_PEND_CHECK:
+                status = TryNoIrqPendingCheck(pDev);
+                break;
+            default:
+
+                if (GET_SDCONFIG_CMD(pConfig) & SDCONFIG_FLAGS_HC_CONFIG) {
+                        /* synchronize config requests with busrequests */
+                    status = SendSyncedHcdBusConfig(pDev,pConfig);
+                } else {
+                    DBG_PRINT(SDDBG_ERROR,
+                        ("SDIO Bus Driver: IssueBusConfig - unknown command:0x%X \n",
+                        GET_SDCONFIG_CMD(pConfig)));
+                    status = SDIO_STATUS_INVALID_PARAMETER;
+                }
+                break;
+        }
+    } while(FALSE);
+
+    if (!SDIO_SUCCESS(status)) {
+
+           if(status == SDIO_STATUS_FUNC_ENABLE_TIMEOUT ){ /* reduce debug level to avoid timeout error messages */
+                debugLevel = SDDBG_TRACE;
+         }
+
+
+         DBG_PRINT(debugLevel,
+                ("SDIO Bus Driver: IssueBusConfig - Error in command:0x%X, Buffer:0x%X, Length:%d Err:%d\n",
+                GET_SDCONFIG_CMD(pConfig),
+                GET_SDCONFIG_CMD_DATA(INT,pConfig),
+                cmdLength, status));
+    }
+    return status;
+}
+
+/* start a request */
+static INLINE SDIO_STATUS StartHcdRequest(PSDHCD pHcd, PSDREQUEST pReq)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    CT_DECLARE_IRQ_SYNC_CONTEXT();
+
+    if ((pReq->pFunction != NULL) && (pReq->pFunction->Flags & SDFUNCTION_FLAG_REMOVING)) {
+        /* this device or function is going away, fail any new requests */
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: StartHcdRequest, fail request 0x%X, device is removing\n", (UINT)pReq));
+        pReq->Status = SDIO_STATUS_CANCELED;
+        return SDIO_STATUS_SDREQ_QUEUE_FAILED;
+    }
+
+    status = _AcquireHcdLock(pHcd);
+
+    if (!SDIO_SUCCESS(status)) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to acquire HCD request lock: Err:%d\n", status));
+        pReq->Status = SDIO_STATUS_SDREQ_QUEUE_FAILED;
+        return SDIO_STATUS_SDREQ_QUEUE_FAILED;
+    }
+
+    if (pReq->Flags & SDREQ_FLAGS_QUEUE_HEAD) {
+            /* caller wants this request queued to the head */
+
+            /* a completion routine for a barrier request is called
+             * while the queue is busy.  A barrier request can
+             * insert a new request at the head of the queue */
+        DBG_ASSERT(IsQueueBusy(&pHcd->RequestQueue));
+        QueueRequestToFront(&pHcd->RequestQueue,pReq);
+    } else {
+            /* insert in queue at tail */
+        QueueRequest(&pHcd->RequestQueue,pReq);
+
+            /* is queue busy ? */
+        if (IsQueueBusy(&pHcd->RequestQueue)) {
+                /* release lock */
+            status = _ReleaseHcdLock(pHcd);
+                /* controller is busy already, no need to call the hcd */
+            return SDIO_STATUS_PENDING;
+        }
+            /* mark it as busy */
+        MarkQueueBusy(&pHcd->RequestQueue);
+    }
+
+        /* remove item from head and set current request */
+    SET_CURRENT_REQUEST(pHcd, DequeueRequest(&pHcd->RequestQueue));
+    if (CHECK_API_VERSION_COMPAT(pHcd,2,6)) {
+        CHECK_HCD_RECURSE(pHcd, pHcd->pCurrentRequest);
+    }
+        /* release lock */
+    status = _ReleaseHcdLock(pHcd);
+        /* controller was not busy, call into HCD to process current request */
+    status = CallHcdRequest(pHcd);
+    return status;
+}
+
+
+/* used by CMD12,CMD13 to save the original completion routine */
+#define GET_BD_RSV_REQUEST_COMPLETION(pR)   (PSDEQUEST_COMPLETION)(pR)->pBdRsv1
+#define SET_BD_RSV_REQUEST_COMPLETION(pR,c) (pR)->pBdRsv1 = (PVOID)(c)
+
+/* used by CMD12 processing to save/restore the original data transfer status */
+#define GET_BD_RSV_ORIG_STATUS(pR)          (SDIO_STATUS)(pR)->pBdRsv2
+#define SET_BD_RSV_ORIG_STATUS(pR,s)        (pR)->pBdRsv2 = (PVOID)(s)
+
+/* used by CMD13 processing to get/set polling count */
+#define GET_BD_RSV_STATUS_POLL_COUNT(pR)     (INT)(pR)->pBdRsv2
+#define SET_BD_RSV_STATUS_POLL_COUNT(pR,s)   (pR)->pBdRsv2 = (PVOID)(s)
+
+/* used by CMD55 processing to save the second part of the request */
+#define GET_BD_RSV_ORIG_REQ(pR)             (PSDREQUEST)(pR)->pBdRsv1
+#define SET_BD_RSV_ORIG_REQ(pR,r)           (pR)->pBdRsv1 = (PVOID)(r)
+
+/* used by all to save HCD */
+#define GET_BD_RSV_HCD(pR)                  (PSDHCD)(pR)->pBdRsv3
+#define SET_BD_RSV_HCD(pR,h)                (pR)->pBdRsv3 = (PVOID)(h)
+
+static void CMD13CompletionBarrier(PSDREQUEST pReq);
+
+static INLINE void SetupCMD13(PSDHCD pHcd, PSDREQUEST pReq)
+{
+    pReq->Command = CMD13;
+        /* sequence must be atomic, queue it to the head and flag as a barrier */
+    pReq->Flags = SDREQ_FLAGS_QUEUE_HEAD | SDREQ_FLAGS_BARRIER | SDREQ_FLAGS_TRANS_ASYNC;
+    if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+        pReq->Argument = 0;
+        pReq->Flags |= SDREQ_FLAGS_RESP_R2;
+    } else {
+        pReq->Flags |= SDREQ_FLAGS_RESP_R1;
+        pReq->Argument |= pHcd->CardProperties.RCA << 16;
+    }
+        /* insert completion */
+    pReq->pCompletion = CMD13CompletionBarrier;
+}
+
+/* CMD13 (GET STATUS) completion */
+static void CMD13CompletionBarrier(PSDREQUEST pReq)
+{
+    PSDEQUEST_COMPLETION pOrigCompletion = GET_BD_RSV_REQUEST_COMPLETION(pReq);
+    PSDHCD               pHcd = GET_BD_RSV_HCD(pReq);
+    INT                  pollingCount = GET_BD_RSV_STATUS_POLL_COUNT(pReq);
+    BOOL                 doCompletion = TRUE;
+    UINT32               cardStatus;
+
+    DBG_ASSERT(pOrigCompletion != NULL);
+    DBG_ASSERT(pHcd != NULL);
+    DBG_PRINT(SDIODBG_REQUESTS, ("+SDIO Bus Driver: CMD13CompletionBarrier (cnt:%d) \n",pollingCount));
+
+    do {
+        if (!SDIO_SUCCESS(pReq->Status)) {
+            break;
+        }
+
+        cardStatus = SD_R1_GET_CARD_STATUS(pReq->Response);
+
+        if (cardStatus & SD_CS_TRANSFER_ERRORS) {
+            DBG_PRINT(SDIODBG_REQUESTS,("SDIO Bus Driver: Card transfer errors : 0x%X \n",cardStatus));
+            pReq->Status = SDIO_STATUS_PROGRAM_STATUS_ERROR;
+            break;
+        }
+
+        if (SD_CS_GET_STATE(cardStatus) != SD_CS_STATE_PRG) {
+            DBG_PRINT(SDIODBG_REQUESTS,("SDIO Bus Driver: Card programming done \n"));
+            break;
+        }
+
+        DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: Card still programming.. \n"));
+        pollingCount--;
+
+        if (pollingCount < 0) {
+            pReq->Status = SDIO_STATUS_PROGRAM_TIMEOUT;
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: card programming timeout!\n"));
+            break;
+        }
+
+        doCompletion = FALSE;
+            /* keep trying */
+        SET_BD_RSV_STATUS_POLL_COUNT(pReq, pollingCount);
+        SetupCMD13(pHcd,pReq);
+        DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: re-issuing CMD13 \n"));
+            /* re-issue */
+        IssueRequestToHCD(pHcd, pReq);
+
+    } while (FALSE);
+
+
+    if (doCompletion) {
+            /* restore original completion routine */
+        pReq->pCompletion = pOrigCompletion;
+            /* call original completion routine */
+        pOrigCompletion(pReq);
+    }
+
+    DBG_PRINT(SDIODBG_REQUESTS, ("-SDIO Bus Driver: CMD13CompletionBarrier \n"));
+}
+
+/* command 13 (GET STATUS) preparation */
+static void PrepCMD13Barrier(PSDREQUEST pReq)
+{
+    SDIO_STATUS status = pReq->Status;
+    PSDHCD      pHcd = GET_BD_RSV_HCD(pReq);
+    INT         pollingCount;
+    PSDEQUEST_COMPLETION pOrigCompletion = GET_BD_RSV_REQUEST_COMPLETION(pReq);
+
+    DBG_ASSERT(pHcd != NULL);
+    DBG_ASSERT(pOrigCompletion != NULL);
+
+    DBG_PRINT(SDIODBG_REQUESTS, ("+SDIO Bus Driver: PrepCMD13Barrier \n"));
+
+    if (SDIO_SUCCESS(status)) {
+            /* re-use the request for CMD13 */
+        SetupCMD13(pHcd,pReq);
+            /* set polling count to a multiple of the Block count, if the BlockCount was
+             * zeroed by the HCD, then set it to 1X multiplier */
+        pollingCount = max(pBusContext->CMD13PollingMultiplier,
+                           pBusContext->CMD13PollingMultiplier * (INT)pReq->BlockCount);
+            /* initialize count */
+        SET_BD_RSV_STATUS_POLL_COUNT(pReq, pollingCount);
+            /* re-issue it, we can call IssueRequest here since we are re-using the request */
+        IssueRequestToHCD(pHcd, pReq);
+    } else {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Request Failure (%d) , CMD13 bypassed.\n",status));
+            /* call the original completion routine */
+        pOrigCompletion(pReq);
+    }
+
+    DBG_PRINT(SDIODBG_REQUESTS, ("-SDIO Bus Driver: PrepCMD13Barrier (%d) \n",status));
+}
+
+/* CMD12 completion */
+static void CMD12Completion(PSDREQUEST pReq)
+{
+    PSDEQUEST_COMPLETION pOrigCompletion = GET_BD_RSV_REQUEST_COMPLETION(pReq);
+
+    DBG_ASSERT(pOrigCompletion != NULL);
+
+    DBG_PRINT(SDIODBG_REQUESTS, ("+SDIO Bus Driver: CMD12Completion \n"));
+
+        /* restore original completion routine */
+    pReq->pCompletion = pOrigCompletion;
+
+    if (SDIO_SUCCESS(pReq->Status)) {
+            /* if CMD12 succeeds, we want to return the result of the original
+             * request */
+        pReq->Status = GET_BD_RSV_ORIG_STATUS(pReq);
+        DBG_PRINT(SDIODBG_REQUESTS,
+                ("SDIO Bus Driver: PrepCMD12Completion original status %d \n",pReq->Status));
+    }
+        /* call original completion routine */
+    pOrigCompletion(pReq);
+
+    DBG_PRINT(SDIODBG_REQUESTS, ("-SDIO Bus Driver: CMD12Completion \n"));
+}
+
+/* CMD12 preparation */
+static void PrepCMD12Barrier(PSDREQUEST pReq)
+{
+
+    SDIO_STATUS status = pReq->Status;
+    PSDHCD               pHcd = GET_BD_RSV_HCD(pReq);
+    PSDEQUEST_COMPLETION pOrigCompletion = GET_BD_RSV_REQUEST_COMPLETION(pReq);
+
+    DBG_ASSERT(pHcd != NULL);
+    DBG_ASSERT(pOrigCompletion != NULL);
+
+    DBG_PRINT(SDIODBG_REQUESTS, ("+SDIO Bus Driver: PrepCMD12Barrier \n"));
+
+    if (SDIO_SUCCESS(status) ||    /* only issue CMD12 on success or specific bus errors */
+        (SDIO_STATUS_BUS_READ_TIMEOUT == status) ||
+        (SDIO_STATUS_BUS_READ_CRC_ERR == status) ||
+        (SDIO_STATUS_BUS_WRITE_ERROR == status)) {
+        if (!CHECK_API_VERSION_COMPAT(pHcd,2,6)) {
+            if (!ForceAllRequestsAsync()) {
+                /* clear the call bit as an optimization, note clearing it wholesale here will
+                 * allow request processing to recurse one more level */
+                AtomicTest_Clear(&pHcd->HcdFlags, HCD_REQUEST_CALL_BIT);
+            }
+        }
+            /* re-use the request for CMD12 */
+        pReq->Command = CMD12;
+        pReq->Argument = 0;
+
+            /* if the data transfer was successful, check for transfer check */
+        if (SDIO_SUCCESS(status) &&
+            (pReq->Flags & SDREQ_FLAGS_AUTO_TRANSFER_STATUS)) {
+                /* original data request requires a transfer status check, which is another
+                 * barrier request */
+            pReq->Flags = SDREQ_FLAGS_RESP_R1B | SDREQ_FLAGS_QUEUE_HEAD | SDREQ_FLAGS_BARRIER |
+                          SDREQ_FLAGS_TRANS_ASYNC;
+            DBG_PRINT(SDIODBG_REQUESTS, ("-SDIO Bus Driver: PrepCMD12Barrier , chaining CMD13 \n"));
+                /* switch out completion to send the CMD13 next */
+            pReq->pCompletion = PrepCMD13Barrier;
+        } else {
+            pReq->Flags = SDREQ_FLAGS_RESP_R1B | SDREQ_FLAGS_QUEUE_HEAD | SDREQ_FLAGS_TRANS_ASYNC;
+            pReq->pCompletion = CMD12Completion;
+        }
+
+            /* save the original data transfer request status */
+        SET_BD_RSV_ORIG_STATUS(pReq,status);
+            /* re-issue it, we can call IssueRequest here since we are re-using the request */
+        IssueRequestToHCD(pHcd, pReq);
+    } else {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Request Failure (%d) , CMD12 bypassed.\n",status));
+            /* call the original completion routine */
+        pOrigCompletion(pReq);
+    }
+
+    DBG_PRINT(SDIODBG_REQUESTS, ("-SDIO Bus Driver: PrepCMD12Barrier (%d) \n",status));
+}
+
+
+/* CMD55 barrier - this is a special barrier completion routine, we have to submit the second
+ * part of the command command sequence atomically */
+static void CMD55CompletionBarrier(PSDREQUEST pReq)
+{
+    SDIO_STATUS status = pReq->Status;
+    PSDREQUEST  pOrigReq = GET_BD_RSV_ORIG_REQ(pReq);
+    PSDHCD      pHcd = GET_BD_RSV_HCD(pReq);
+    BOOL        doCompletion = FALSE;
+
+    DBG_ASSERT(pOrigReq != NULL);
+    DBG_ASSERT(pHcd != NULL);
+
+    DBG_PRINT(SDIODBG_REQUESTS, ("+SDIO Bus Driver: CMD55Completion \n"));
+
+    do {
+
+        if (!SDIO_SUCCESS(status)) {
+                /* command 55 failed */
+            pOrigReq->Status = status;
+            doCompletion = TRUE;
+            break;
+        }
+
+        if (!(SD_R1_GET_CARD_STATUS(pReq->Response) & SD_CS_APP_CMD)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Card is not accepting CMD55, status:0x%X \n",
+                    SD_R1_GET_CARD_STATUS(pReq->Response)));
+            pOrigReq->Status = SDIO_STATUS_INVALID_COMMAND;
+            doCompletion = TRUE;
+            break;
+        }
+
+        if (!CHECK_API_VERSION_COMPAT(pHcd,2,6)) {
+            if (!ForceAllRequestsAsync()) {
+                AtomicTest_Clear(&pHcd->HcdFlags, HCD_REQUEST_CALL_BIT);
+            }
+        }
+
+            /* flag the original request to queue to the head */
+        pOrigReq->Flags |= SDREQ_FLAGS_QUEUE_HEAD;
+            /* submit original request, we cannot call IssueRequestHCD() here because the
+             * original request has already gone through IssueRequestHCD() already */
+        status = StartHcdRequest(pHcd, pOrigReq);
+
+        if (SDIO_STATUS_PENDING == status) {
+            break;
+        }
+
+        pOrigReq->Status = status;
+
+        if (SDIO_STATUS_SDREQ_QUEUE_FAILED == status) {
+                /* never made it to the queue */
+            doCompletion = TRUE;
+            break;
+        }
+
+            /* request completed in-line */
+        _SDIO_HandleHcdEvent(pHcd, EVENT_HCD_TRANSFER_DONE);
+
+    } while (FALSE);
+
+    if (doCompletion) {
+        DoRequestCompletion(pOrigReq, pHcd);
+    }
+
+        /* free the CMD55 request */
+    FreeRequest(pReq);
+
+    DBG_PRINT(SDIODBG_REQUESTS, ("-SDIO Bus Driver: CMD55Completion \n"));
+}
+
+
+/* synch completion routine */
+static void SynchCompletion(PSDREQUEST pRequest)
+{
+    PSIGNAL_ITEM pSignal;
+
+    pSignal = (PSIGNAL_ITEM)pRequest->pCompleteContext;
+    DBG_ASSERT(pSignal != NULL);
+    if (!SDIO_SUCCESS(SignalSet(&pSignal->Signal))) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: SynchCompletion - signal failed \n"));
+    }
+
+}
+
+/*
+ * Issue a request to the host controller
+ *
+ *
+ * The following flags are handled internally by the bus driver to guarantee atomicity.
+ *
+ *    SDREQ_FLAGS_APP_CMD - SD Extended commands requiring CMD55 to precede the actual command
+ *    SDREQ_FLAGS_AUTO_CMD12 - Memory Card Data transfer needs CMD12 to stop transfer
+ *                             (multi-block reads/writes)
+ *    SDREQ_FLAGS_AUTO_TRANSFER_STATUS - Memory card data transfer needs transfer status polling
+ *                                       using CMD13
+ *
+ *    These request flags require additional commands prepended or appended to the original command
+ *
+ *    The order of command execution :
+ *
+ *    Order  Condition                 Command Issued
+ *    -------------------------------------------------------------
+ *      1.   If APP_CMD                CMD55 issued.
+ *      2.   Always                    Caller command issued.
+ *      3.   If AUTO_CMD12             CMD12 issued.
+ *      4.   If AUTO_TRANSFER_STATUS   CMD13 issued until card programming is complete
+*/
+SDIO_STATUS IssueRequestToHCD(PSDHCD pHcd, PSDREQUEST pReq)
+{
+    SDIO_STATUS     status = SDIO_STATUS_SUCCESS;
+    PSIGNAL_ITEM    pSignal = NULL;
+    BOOL            handleFailedReqSubmit = FALSE;
+
+    CLEAR_INTERNAL_REQ_FLAGS(pReq);
+
+    do {
+            /* mark request in-use */
+        ATOMIC_FLAGS internal = AtomicTest_Set(&pReq->InternalFlags, SDBD_PENDING);
+        if (internal & (1<<SDBD_PENDING)) {
+            DBG_ASSERT_WITH_MSG(FALSE,
+                            "SDIO Bus Driver: IssueRequestToHCD - request already in use \n");
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Request already in use: 0x%X",(INT)pReq));
+        }
+
+        if (!(pReq->Flags & SDREQ_FLAGS_TRANS_ASYNC)) {
+                /* caller wants synchronous operation, insert our completion routine */
+            pReq->pCompletion = SynchCompletion;
+            pSignal = AllocateSignal();
+            if (NULL == pSignal) {
+                status = SDIO_STATUS_NO_RESOURCES;
+                pReq->Status = SDIO_STATUS_NO_RESOURCES;
+                handleFailedReqSubmit = TRUE;
+                    /* no need to continue */
+                break;
+            }
+            pReq->pCompleteContext = (PVOID)pSignal;
+        }
+
+        if ((pReq->Flags & SDREQ_FLAGS_AUTO_CMD12) &&
+            !(pHcd->Attributes & SDHCD_ATTRIB_AUTO_CMD12) &&
+            !(IS_HCD_BUS_MODE_SPI(pHcd) && IS_SDREQ_WRITE_DATA(pReq->Flags))) {
+            DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: Auto CMD12 on Request:0x%08X \n",(INT)pReq));
+                /* caller wants CMD12 auto-issued and the HCD does not support it */
+                /* setup caller's request as a barrier and replace their completion routine */
+            pReq->Flags |= SDREQ_FLAGS_BARRIER;
+                /* take off the flag, since the BD will be issuing it */
+            pReq->Flags &= ~SDREQ_FLAGS_AUTO_CMD12;
+                /* save original completion */
+            SET_BD_RSV_REQUEST_COMPLETION(pReq,pReq->pCompletion);
+                /* save the HCD we are on */
+            SET_BD_RSV_HCD(pReq,pHcd);
+                /* use completion for preping CMD12 */
+            pReq->pCompletion = PrepCMD12Barrier;
+        }
+
+        if (pReq->Flags & SDREQ_FLAGS_AUTO_TRANSFER_STATUS) {
+            /* caller wants transfer status checked. If a CMD12
+             * barrier request has been setup we let the CMD12 completion take care
+             * of setting up the transfer check */
+            if (pReq->pCompletion != PrepCMD12Barrier) {
+                    /* make CMD13 prep a barrier */
+                pReq->Flags |= SDREQ_FLAGS_BARRIER;
+                    /* save original completion */
+                SET_BD_RSV_REQUEST_COMPLETION(pReq,pReq->pCompletion);
+                    /* save the HCD we are on */
+                SET_BD_RSV_HCD(pReq,pHcd);
+                    /* use completion for preping CMD13 */
+                pReq->pCompletion = PrepCMD13Barrier;
+            }
+        }
+
+            /* check app command, the two command sequence must be handled atomically */
+        if (pReq->Flags & SDREQ_FLAGS_APP_CMD) {
+            PSDREQUEST      pCmd55;
+                /* allocate request to handle initial CMD55 command */
+            pCmd55 = AllocateRequest();
+            if (NULL == pCmd55) {
+                status = SDIO_STATUS_NO_RESOURCES;
+                pReq->Status = SDIO_STATUS_NO_RESOURCES;
+                    /* complete the caller's request with error */
+                handleFailedReqSubmit = TRUE;
+                    /* no need to continue */
+                break;
+            }
+                /* first submit CMD55 */
+                /* set RCA */
+            pCmd55->Argument = pHcd->CardProperties.RCA << 16;
+                /* mark as a barrier request */
+            pCmd55->Flags = SDREQ_FLAGS_RESP_R1 | SDREQ_FLAGS_BARRIER | SDREQ_FLAGS_TRANS_ASYNC;
+            pCmd55->Command = CMD55;
+                /* call our barrier completion routine when done */
+            pCmd55->pCompletion = CMD55CompletionBarrier;
+                /* save request and target HCD */
+            SET_BD_RSV_ORIG_REQ(pCmd55,pReq);
+            SET_BD_RSV_HCD(pCmd55,pHcd);
+                /* recursively start the CMD55 request, since the CMD55 is a barrier
+                 * request, it's completion routine will submit the actual request
+                 * atomically */
+            status = IssueRequestToHCD(pHcd, pCmd55);
+
+        } else {
+                /* start the normal request */
+            status = StartHcdRequest(pHcd,pReq);
+        }
+
+
+        if (SDIO_STATUS_SDREQ_QUEUE_FAILED == status) {
+            handleFailedReqSubmit = TRUE;
+                /* no need to continue, clean up at the end */
+            break;
+        }
+
+            /* at this point, the request was either queued or was processed by the
+             * HCD */
+
+        DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: HCD returned status:%d on request: 0x%X, (CMD:%d) \n",
+                  status, (INT)pReq, pReq->Command));
+
+        if (status != SDIO_STATUS_PENDING) {
+            /* the HCD completed the request within the HCD request callback,
+             * check and see if this is a synchronous request */
+            if (pSignal != NULL) {
+                    /* it was synchronous */
+                DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: Sync-Op signal wait bypassed \n"));
+                    /* NULL out completion info, there's no need to
+                     * signal the semaphore */
+                pReq->pCompletion = NULL;
+
+            } else {
+                DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: Async operation completed in-line \n"));
+                    /* this was an async call, always return pending */
+                status = SDIO_STATUS_PENDING;
+            }
+                /* process this completed transfer on behalf of the HCD */
+            _SDIO_HandleHcdEvent(pHcd, EVENT_HCD_TRANSFER_DONE);
+
+                /* done processing */
+            break;
+        }
+                /* I/O is now pending, could be sync or async */
+                /* check for synch op */
+        if (pSignal != NULL) {
+                /* wait for completion */
+            DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: Sync-Op signal waiting....\n"));
+                /* this is not interruptable, as the HCD must complete it. */
+            status = SignalWait(&pSignal->Signal);
+                /* don't need the signal anymore */
+            FreeSignal(pSignal);
+            pSignal = NULL;
+
+            /* note: it is safe to touch pReq since we own
+             * the completion routine for synch transfers */
+
+                /* check signal wait status */
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_TRACE,
+                ("SDIO Bus Driver - IssueRequestToHCD: Synch transfer - signal wait failed, cancelling req 0X%X\n",
+                (UINT)pReq));
+                pReq->Status = SDIO_STATUS_CANCELED;
+                status = SDIO_STATUS_CANCELED;
+                break;
+            }
+            DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: Sync-Op woke up\n"));
+                /* return the completion status of the request */
+            status = pReq->Status;
+        } else {
+            DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: Async operation Pending \n"));
+        }
+
+    } while (FALSE);
+
+        /* see if we need to clean up failed submissions */
+    if (handleFailedReqSubmit) {
+            /* make sure this is cleared */
+        AtomicTest_Clear(&pReq->InternalFlags, SDBD_PENDING);
+            /* the  request processing failed before it was submitted to the HCD */
+            /* note: since it never made it to the queue we can touch pReq */
+        if (pReq->Flags & SDREQ_FLAGS_TRANS_ASYNC) {
+            /* for ASYNC requests, we need to call the completion routine */
+            DoRequestCompletion(pReq, pHcd);
+                /* return pending for all ASYNC requests */
+            status = SDIO_STATUS_PENDING;
+        }
+    }
+
+        /* check if we need to clean up the signal */
+    if (pSignal != NULL) {
+            /* make sure this is freed */
+        FreeSignal(pSignal);
+    }
+        /* return status */
+    return status;
+}
+
+/* documentation for configuration requests */
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Enable or Disable the SDIO Function
+
+  @function name: SDCONFIG_FUNC_ENABLE_DISABLE
+  @prototype: SDCONFIG_FUNC_ENABLE_DISABLE
+  @category: PD_Reference
+
+  @input:  SDCONFIG_FUNC_ENABLE_DISABLE_DATA - Enable Data structure
+
+  @output: none
+
+  @return: SDIO Status
+
+  @notes: This command code is used in the SDLIB_IssueConfig() API.  The command
+          uses the SDCONFIG_FUNC_ENABLE_DISABLE_DATA structure.  The caller must set the
+          EnableFlags and specify the TimeOut value in milliseconds.   The TimeOut
+          value is used for polling the I/O ready bit.  This command returns a status
+          of SDIO_STATUS_FUNC_ENABLE_TIMEOUT if the ready bit was not set/cleared
+          by the card within the timeout period.
+
+  @example: Example of enabling an I/O function:
+        fData.EnableFlags = SDCONFIG_ENABLE_FUNC;
+        fData.TimeOut = 500;
+        status = SDLIB_IssueConfig(pInstance->pDevice,
+                                   SDCONFIG_FUNC_ENABLE_DISABLE,
+                                   &fData,
+                                   sizeof(fData));
+
+  @see also: SDLIB_IssueConfig
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Unmask the function's IRQ
+
+  @function name: SDCONFIG_FUNC_UNMASK_IRQ
+  @prototype: SDCONFIG_FUNC_UNMASK_IRQ
+  @category: PD_Reference
+
+  @input:  none
+
+  @output: none
+
+  @return: SDIO Status
+
+  @notes: This command code is used in the SDLIB_IssueConfig() API.  The command
+          unmasks the IRQ for the I/O function. This request sets the function's
+          interrupt enable bit in the INTENABLE register in the
+          common register space.
+
+  @example: Example of unmasking interrupt :
+        status = SDLIB_IssueConfig(pInstance->pDevice,
+                                   SDCONFIG_FUNC_UNMASK_IRQ,
+                                   NULL,
+                                   0);
+
+  @see also: SDCONFIG_FUNC_MASK_IRQ
+  @see also: SDLIB_IssueConfig
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Mask the function's IRQ
+
+  @function name: SDCONFIG_FUNC_MASK_IRQ
+  @prototype: SDCONFIG_FUNC_MASK_IRQ
+  @category: PD_Reference
+
+  @input:  none
+
+  @output: none
+
+  @return: SDIO Status
+
+  @notes: This command code is used in the SDLIB_IssueConfig() API.  The command
+          masks the IRQ for the I/O function.
+
+  @example: Example of unmasking interrupt :
+        status = SDLIB_IssueConfig(pInstance->pDevice,
+                                   SDCONFIG_FUNC_MASK_IRQ,
+                                   NULL,
+                                   0);
+
+  @see also: SDCONFIG_FUNC_UNMASK_IRQ
+  @see also: SDLIB_IssueConfig
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Acknowledge that the function's IRQ has been handled
+
+  @function name: SDCONFIG_FUNC_ACK_IRQ
+  @prototype: SDCONFIG_FUNC_ACK_IRQ
+  @category: PD_Reference
+
+  @input:  none
+
+  @output: none
+
+  @return: SDIO Status
+
+  @notes: This command code is used in the SDLIB_IssueConfig() API.  The command
+          indicates to the bus driver that the function driver has handled the
+          interrupt.  The bus driver will notify the host controller to unmask the
+          interrupt source.  SDIO interrupts are level triggered and are masked at the
+          host controller level until all function drivers have indicated that they
+          have handled their respective interrupt. This command can be issued in either
+          the IRQ handler or asynchronous IRQ handler.
+
+  @example: Example of acknowledging an interrupt :
+        status = SDLIB_IssueConfig(pInstance->pDevice,
+                                   SDCONFIG_FUNC_ACK_IRQ,
+                                   NULL,
+                                   0);
+
+  @see also: SDLIB_IssueConfig
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Disable SD/MMC/SDIO card CRC checking.
+
+  @function name: SDCONFIG_FUNC_SPI_MODE_DISABLE_CRC
+  @prototype: SDCONFIG_FUNC_SPI_MODE_DISABLE_CRC
+  @category: PD_Reference
+
+  @input:  none
+
+  @output: none
+
+  @return: SDIO Status
+
+  @notes: This command code is used in the SDLIB_IssueConfig() API.  The command
+          issues CMD59 to disable SPI-CRC checking and requests the host controller
+          driver to stop checking the CRC. This is typically used in systems where
+          CRC checking is not required and performance is improved if the CRC checking
+          is ommitted (i.e. SPI implementations without hardware CRC support).
+
+  @example: Example of disabling SPI CRC checking:
+        status = SDLIB_IssueConfig(pInstance->pDevice,
+                                   SDCONFIG_FUNC_SPI_MODE_DISABLE_CRC,
+                                   NULL,
+                                   0);
+
+  @see also: SDCONFIG_FUNC_SPI_MODE_ENABLE_CRC
+  @see also: SDLIB_IssueConfig
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Enable SD/MMC/SDIO card CRC checking.
+
+  @function name: SDCONFIG_FUNC_SPI_MODE_ENABLE_CRC
+  @prototype: SDCONFIG_FUNC_SPI_MODE_ENABLE_CRC
+  @category: PD_Reference
+
+  @input:  none
+
+  @output: none
+
+  @return: SDIO Status
+
+  @notes: This command code is used in the SDLIB_IssueConfig() API.  The command
+          issues CMD59 to enable SPI-CRC checking and requests the host controller
+          driver to generate valid CRCs for commands and data as well as
+          check the CRC in responses and incomming data blocks.
+
+  @example: Example of enabling SPI CRC checking:
+        status = SDLIB_IssueConfig(pInstance->pDevice,
+                                   SDCONFIG_FUNC_SPI_MODE_ENABLE_CRC,
+                                   NULL,
+                                   0);
+
+  @see also: SDCONFIG_FUNC_SPI_MODE_DISABLE_CRC
+  @see also: SDLIB_IssueConfig
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Allocate slot current for a card function.
+
+  @function name: SDCONFIG_FUNC_ALLOC_SLOT_CURRENT
+  @prototype: SDCONFIG_FUNC_ALLOC_SLOT_CURRENT
+  @category: PD_Reference
+
+  @input:  SDCONFIG_FUNC_SLOT_CURRENT_DATA
+
+  @output: SDCONFIG_FUNC_SLOT_CURRENT_DATA
+
+  @return: SDIO Status
+
+  @notes: This command code is used in the SDLIB_IssueConfig() API.  The command
+          requests an allocation of slot current to satisfy the power requirements
+          of the function.  The command uses the SDCONFIG_FUNC_SLOT_CURRENT_DATA
+          data structure to pass the required current in mA. Slot current allocation
+          is not cummulative and this command should only be issued once by each function
+          driver with the worse case slot current usage.
+          The command returns SDIO_STATUS_NO_RESOURCES if the
+          requirement cannot be met by the host hardware.  The SlotCurrent field will
+          contain the remaining current available to the slot.  The slot current should
+          be allocated before the function is enabled using SDCONFIG_FUNC_ENABLE_DISABLE.
+          When a function driver is unloaded it should free the slot current allocation
+          by using the SDCONFIG_FUNC_FREE_SLOT_CURRENT command.
+
+  @example: Example of allocating slot current:
+        slotCurrent.SlotCurrent = 150;  // 150 mA
+        status = SDLIB_IssueConfig(pInstance->pDevice,
+                                   SDCONFIG_FUNC_ALLOC_SLOT_CURRENT,
+                                   &slotCurrent,
+                                   sizeof(slotCurrent));
+
+
+  @see also: SDCONFIG_FUNC_FREE_SLOT_CURRENT
+  @see also: SDLIB_IssueConfig
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Free slot current for a card function.
+
+  @function name: SDCONFIG_FUNC_FREE_SLOT_CURRENT
+  @prototype: SDCONFIG_FUNC_FREE_SLOT_CURRENT
+  @category: PD_Reference
+
+  @input:  none
+
+  @output: none
+
+  @return: SDIO Status
+
+  @notes: This command code is used in the SDLIB_IssueConfig() API.  The command
+          frees the allocated current for a card function.  This command should be
+          issued only once (per function) and only after an allocation was successfully made.
+
+  @example: Example of freeing slot current:
+        status = SDLIB_IssueConfig(pInstance->pDevice,
+                                   SDCONFIG_FUNC_FREE_SLOT_CURRENT,
+                                   NULL,
+                                   0);
+
+  @see also: SDCONFIG_FUNC_ALLOC_SLOT_CURRENT
+  @see also: SDLIB_IssueConfig
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Set the bus mode for the SD/SDIO card.
+
+  @function name: SDCONFIG_FUNC_CHANGE_BUS_MODE
+  @prototype: SDCONFIG_FUNC_CHANGE_BUS_MODE
+  @category: PD_Reference
+
+  @input:  none
+
+  @output: none
+
+  @return: SDIO Status
+
+  @notes:     This command code is used in the SDLIB_IssueConfig() API.  The command
+          alters the card's bus mode (width and clock rate) to a driver specified
+          value.  The driver must read the current bus mode flags, modify if necessary
+          and pass the value in the SDCONFIG_BUS_MODE_DATA structure.
+              If the bus width is changed (1 or 4 bit) the caller must adjust the mode flags
+          for the new width. Cards cannot be switched between 1/4 bit and SPI mode.
+          Switching to or from SPI mode requires a power cycle. Adjustments to the clock
+          rate is immediate on the next bus transaction.  The actual clock rate value is
+          limited by the host controller and is reported in the ClockRate field when the
+          command completes successfully.
+              The bus mode change is card wide and may affect other SDIO functions on
+          multi-function cards. Use this feature with caution. This feature should NOT be
+          used to dynamically control clock rates during runtime and should only be used
+          at card initialization. Changing the bus mode must be done with SDIO function
+          interrupts masked.
+              This request can block and must only be called from a schedulable context.
+
+  @example: Example of changing the clock rate:
+    SDCONFIG_BUS_MODE_DATA  busSettings;
+    ZERO_OBJECT(busSettings);
+       // get current bus flags and keep the same bus width
+    busSettings.BusModeFlags = SDDEVICE_GET_BUSMODE_FLAGS(pInstance->pDevice);
+    busSettings.ClockRate = 8000000;  // adjust clock to 8 Mhz
+       // issue config request to override clock rate
+    status = SDLIB_IssueConfig(pInstance->pDevice,
+                               SDCONFIG_FUNC_CHANGE_BUS_MODE,
+                               &busSettings,
+                               sizeof(SDCONFIG_BUS_MODE_DATA));
+
+  @see also: SDDEVICE_GET_BUSMODE_FLAGS
+  @see also: SDLIB_IssueConfig
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get the debug level of the underlying host controller driver.
+
+  @function name: SDCONFIG_GET_HCD_DEBUG
+  @prototype: SDCONFIG_GET_HCD_DEBUG
+  @category: PD_Reference
+
+  @input:  none
+
+  @output: CT_DEBUG_LEVEL
+
+  @return: SDIO Status
+
+  @notes: This command code is used in the SDLIB_IssueConfig() API.  The command
+          requests the current debug level of the HCD driver.  This API is useful for
+          saving the current debug level of the HCD prior to issuing SDCONFIG_SET_HCD_DEBUG
+          in order to increase the verbosity of the HCD. This API should be used only for
+          debugging purposes.  If multiple functions attempt to save and set the HCD debug
+          level simultanously, the final debug level will be unknown. Not all HCDs support
+          this command.
+
+  @example: Example of saving the debug level:
+        CT_DEBUG_LEVEL savedDebug;
+        status = SDLIB_IssueConfig(pInstance->pDevice,
+                                   SDCONFIG_GET_HCD_DEBUG,
+                                   &savedDebug,
+                                   sizeof(savedDebug));
+
+  @see also: SDCONFIG_SET_HCD_DEBUG
+  @see also: SDLIB_IssueConfig
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Set the debug level of the underlying host controller driver.
+
+  @function name: SDCONFIG_SET_HCD_DEBUG
+  @prototype: SDCONFIG_SET_HCD_DEBUG
+  @category: PD_Reference
+
+  @input:  CT_DEBUG_LEVEL
+
+  @output: none
+
+  @return: SDIO Status
+
+  @notes: This command code is used in the SDLIB_IssueConfig() API.  The command
+          sets the current debug level of the HCD driver.  This API is useful for
+          setting the debug level of the HCD programatically for debugging purposes.
+          If multiple functions attempt to save and set the HCD debug
+          level simultanously, the final debug level will be unknown. Not all HCDs support
+          this request.
+
+  @example: Example of setting the debug level:
+        CT_DEBUG_LEVEL setDebug = 15;
+        status = SDLIB_IssueConfig(pInstance->pDevice,
+                                   SDCONFIG_GET_HCD_DEBUG,
+                                   &setDebug,
+                                   sizeof(setDebug));
+
+  @see also: SDCONFIG_GET_HCD_DEBUG
+  @see also: SDLIB_IssueConfig
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Instruct the bus driver to not check the SDIO card interrupt pending
+             register on card interrupts, if possible.
+
+  @function name: SDCONFIG_FUNC_NO_IRQ_PEND_CHECK
+  @prototype: SDCONFIG_FUNC_NO_IRQ_PEND_CHECK
+  @category: PD_Reference
+
+  @input:  none
+
+  @output: none
+
+  @return: SDIO Status
+
+  @notes: This command code is used in the SDLIB_IssueConfig() API.  The command instructs the
+          bus driver to skip checking the card interrupt pending register on each card
+          interrupt.  The bus driver will assume the function is interrupting and immediately start
+          the interrupt processing stage. This option is only valid for single function cards.
+          The bus driver will reject the command for a card with more than 1 function.
+          For single function cards, this can improve interrupt response time.
+
+  @example: Example of skipping IRQ pending checks:
+
+        status = SDLIB_IssueConfig(pInstance->pDevice,
+                                   SDCONFIG_FUNC_NO_IRQ_PEND_CHECK,
+                                   NULL,
+                                   0);
+
+  @see also: SDLIB_IssueConfig
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
Index: linux-2.6/drivers/sdio/busdriver/sdio_bus_events.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/busdriver/sdio_bus_events.c
@@ -0,0 +1,1049 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdio_bus_events.c
+
+@abstract: OS independent bus driver support
+
+#notes: this file contains various event handlers and helpers
+
+@notice: Copyright (c), 2004-2006 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define MODULE_NAME  SDBUSDRIVER
+#include <linux/sdio/ctsystem.h>
+#include <linux/sdio/sdio_busdriver.h>
+#include <linux/sdio/sdio_lib.h>
+#include "_busdriver.h"
+#include <linux/sdio/_sdio_defs.h>
+#include <linux/sdio/mmc_defs.h>
+
+static SDIO_STATUS ScanSlotForCard(PSDHCD pHcd,
+                                   PBOOL  pCardPresent);
+static void GetPendingIrqComplete(PSDREQUEST pReq);
+static void ProcessPendingIrqs(PSDHCD  pHcd, UINT8 IntPendingMsk);
+
+/*
+ * DeviceDetach - tell core a device was removed from a slot
+*/
+SDIO_STATUS DeviceDetach(PSDHCD pHcd)
+{
+    SDCONFIG_SDIO_INT_CTRL_DATA irqData;
+
+    ZERO_OBJECT(irqData);
+
+    DBG_PRINT(SDDBG_TRACE, ("+SDIO Bus Driver: DeviceDetach\n"));
+        /* tell any function drivers we are gone */
+    RemoveHcdFunctions(pHcd);
+        /* delete the devices associated with this HCD */
+    DeleteDevices(pHcd);
+        /* check and see if there are any IRQs that were left enabled */
+    if (pHcd->IrqsEnabled) {
+        irqData.SlotIRQEnable = FALSE;
+            /* turn off IRQ detection in HCD */
+        _IssueConfig(pHcd,SDCONFIG_SDIO_INT_CTRL,(PVOID)&irqData, sizeof(irqData));
+    }
+
+        /* reset hcd state */
+    ResetHcdState(pHcd);
+
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO Bus Driver: DeviceDetach\n"));
+    return SDIO_STATUS_SUCCESS;
+}
+
+/*
+ * DeviceAttach - tell core a device was inserted into a slot
+*/
+SDIO_STATUS DeviceAttach(PSDHCD pHcd)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    PSDDEVICE pDevice = NULL;
+    UINT      ii;
+
+
+    if (IS_CARD_PRESENT(pHcd)) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: DeviceAttach called on occupied slot!\n"));
+        return SDIO_STATUS_ERROR;
+    }
+
+    DBG_PRINT(SDDBG_TRACE, ("+SDIO Bus Driver: DeviceAttach bdctxt:0x%X \n", (UINT32)pBusContext));
+
+    if (IS_HCD_RAW(pHcd)) {
+         DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: RAW HCD (%s) device attach \n",pHcd->pName));
+            /* this is a raw HCD */
+        memset(&pHcd->CardProperties,0,sizeof(pHcd->CardProperties));
+        pHcd->CardProperties.Flags = CARD_RAW;
+        pHcd->CardProperties.IOFnCount = 0;
+          /* for raw HCD, set up minimum parameters
+           * since we cannot determine these values using any standard, use values
+           * reported by the HCD */
+            /* the operational rate is just the max clock rate reported */
+        pHcd->CardProperties.OperBusClock =  pHcd->MaxClockRate;
+            /* the max bytes per data transfer is just the max bytes per block */
+        pHcd->CardProperties.OperBlockLenLimit = pHcd->MaxBytesPerBlock;
+            /* if the raw HCD uses blocks to transfer, report the operational size
+             * from the HCD max value */
+        pHcd->CardProperties.OperBlockCountLimit = pHcd->MaxBlocksPerTrans;
+            /* set the slot preferred voltage */
+        pHcd->CardProperties.CardVoltage = pHcd->SlotVoltagePreferred;
+    } else {
+            /* initialize this card and get card properties  */
+        if (!SDIO_SUCCESS((status = SDInitializeCard(pHcd)))) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: DeviceAttach, failed to initialize card, %d\n",
+                                   status));
+            return status;
+        }
+    }
+
+        /* check for SD or MMC, this must be done first as the query may involve
+         * de-selecting the card */
+    do {
+        if (!(pHcd->CardProperties.Flags & (CARD_MMC | CARD_SD | CARD_RAW))) {
+                /* none of these were discovered */
+            break;
+        }
+        pDevice = AllocateDevice(pHcd);
+        if (NULL == pDevice) {
+            break;
+        }
+        if (pHcd->CardProperties.Flags & CARD_RAW) {
+                /* set function number to 1 for IRQ processing */
+            SDDEVICE_SET_SDIO_FUNCNO(pDevice,1);
+        } else {
+                /* get the ID info for the SD/MMC Card */
+            if (!SDIO_SUCCESS((status = SDQuerySDMMCInfo(pDevice)))) {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: DeviceAttach, query SDMMC Info failed \n"));
+                FreeDevice(pDevice);
+                break;
+            }
+        }
+        AddDeviceToList(pDevice);
+            /* look for a function driver to handle this card */
+        ProbeForFunction(pDevice, pHcd);
+    } while (FALSE);
+
+        /* create a device for each I/O function */
+    for(ii= 1; ii <= pHcd->CardProperties.IOFnCount; ii++) {
+        pDevice = AllocateDevice(pHcd);
+        if (NULL == pDevice) {
+            break;
+        }
+            /* set the function number */
+        SDDEVICE_SET_SDIO_FUNCNO(pDevice,ii);
+            /* get the ID info for each I/O function */
+        if (!SDIO_SUCCESS((status = SDQuerySDIOInfo(pDevice)))) {
+            DBG_PRINT(SDDBG_ERROR,
+                    ("SDIO Bus Driver: DeviceAttach, could not query SDIO Info, funcNo:%d status:%d \n",
+                    ii, status));
+            FreeDevice(pDevice);
+                /* keep loading other functions */
+            continue;
+        }
+        AddDeviceToList(pDevice);
+            /* look for a function driver to handle this card */
+        ProbeForFunction(pDevice, pHcd);
+    }
+
+
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO Bus Driver: DeviceAttach \n"));
+    return status;
+}
+
+static INLINE void CompleteRequestCheckCancel(PSDHCD pHcd, PSDREQUEST pReqToComplete)
+{
+    BOOL cancel = FALSE;
+    PSDFUNCTION pFunc = NULL;
+
+        /* handle cancel of current request */
+    if (pReqToComplete->Flags & SDREQ_FLAGS_CANCELED) {
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver - _SDIO_HandleHcdEvent: cancelling req 0X%X\n", (UINT)pReqToComplete));
+        cancel = TRUE;
+        pReqToComplete->Status = SDIO_STATUS_CANCELED;
+        pFunc = pReqToComplete->pFunction;
+        DBG_ASSERT(pFunc != NULL);
+    }
+
+    DoRequestCompletion(pReqToComplete, pHcd);
+
+    if (cancel) {
+        SignalSet(&pFunc->CleanupReqSig);
+    }
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Indicate to the SDIO bus driver (core) of an event in the host controller
+             driver.
+
+  @function name: SDIO_HandleHcdEvent
+  @prototype: SDIO_STATUS SDIO_HandleHcdEvent(PSDHCD pHcd, HCD_EVENT Event)
+  @category: HD_Reference
+
+  @input:  pHcd - the host controller structure that was registered
+           HCD_EVENT - event code
+
+  @output: none
+
+  @return: SDIO_STATUS
+
+  @notes:
+          The host controller driver can indicate asynchronous events by calling this
+          function with an appropriate event code. Refer to the HDK help manual for
+          more information on the event types
+
+  @example: Example of indicating a card insertion event:
+            SDIO_HandleHcdEvent(&Hcd, EVENT_HCD_ATTACH);
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS _SDIO_HandleHcdEvent(PSDHCD pHcd, HCD_EVENT Event)
+{
+    PSDREQUEST       pReq;
+    PSDREQUEST       pReqToComplete = NULL;
+    PSDREQUEST       pNextReq = NULL;
+    SDIO_STATUS      status;
+    CT_DECLARE_IRQ_SYNC_CONTEXT();
+
+    DBG_PRINT(SDIODBG_HCD_EVENTS, ("SDIO Bus Driver: _SDIO_HandleHcdEvent, event type 0x%X, HCD:0x%X\n",
+                         Event, (UINT)pHcd));
+
+    if (Event == EVENT_HCD_TRANSFER_DONE) {
+        pReq = GET_CURRENT_REQUEST(pHcd);
+        if (NULL == pReq) {
+            DBG_ASSERT(FALSE);
+            return SDIO_STATUS_ERROR;
+        }
+
+        status = _AcquireHcdLock(pHcd);
+        if (SDIO_SUCCESS(status)) {
+                /* null out the current request */
+            SET_CURRENT_REQUEST(pHcd, NULL);
+            status = _ReleaseHcdLock(pHcd);
+        } else {
+            DBG_PRINT(SDDBG_ERROR,
+              ("SDIO Bus Driver: SDIO_HandleHcdEvent Failed to acquire HCD lock \n"));
+            return SDIO_STATUS_ERROR;
+        }
+
+            /* note: the queue is still marked busy to prevent other threads/tasks from starting
+             * new requests while we are handling completion , some completed requests are
+             * marked as barrier requests which must be handled atomically */
+
+        status = pReq->Status;
+        DBG_PRINT(SDIODBG_REQUESTS,
+            ("+SDIO Bus Driver: Handling Transfer Done (CMD:%d, Status:%d) from HCD:0x%08X \n",
+                  pReq->Command, status, (INT)pHcd));
+            /* check SPI mode conversion */
+        if (IS_HCD_BUS_MODE_SPI(pHcd) && SDIO_SUCCESS(status)) {
+            if (!(pReq->Flags & SDREQ_FLAGS_RESP_SKIP_SPI_FILT) && !(pReq->Flags & SDREQ_FLAGS_PSEUDO) &&
+                (GET_SDREQ_RESP_TYPE(pReq->Flags) != SDREQ_FLAGS_NO_RESP)) {
+                ConvertSPI_Response(pReq, NULL);
+            }
+        }
+
+        DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: Completing Request:0x%08X \n",(INT)pReq));
+
+        if (!SDIO_SUCCESS(status) &&
+            (status != SDIO_STATUS_CANCELED)  &&
+            !(pReq->Flags & SDREQ_FLAGS_CANCELED) &&
+            (pReq->RetryCount > 0)) {
+                /* retry the request if it failed, was NOT cancelled and the retry count
+                 * is greater than zero */
+            pReq->RetryCount--;
+            pReqToComplete = NULL;
+                /* clear SPI converted flag */
+            pReq->Flags &= ~SDREQ_FLAGS_RESP_SPI_CONVERTED;
+            pNextReq = pReq;
+        } else {
+                /* complete the request */
+            if (pReq->Flags & SDREQ_FLAGS_BARRIER) {
+                    /* a barrier request must be completed before the next bus request is
+                     * started */
+                CompleteRequestCheckCancel(pHcd, pReq);
+                if (!ForceAllRequestsAsync()) {
+                    if (CHECK_API_VERSION_COMPAT(pHcd,2,6)) {
+                            /* the request was completed, decrement recursion count */
+                        status = _AcquireHcdLock(pHcd);
+                        if (!SDIO_SUCCESS(status)) {
+                            return status;
+                        }
+                        pHcd->Recursion--;
+                        DBG_ASSERT(pHcd->Recursion >= 0);
+                        status = _ReleaseHcdLock(pHcd);
+                    } else {
+                            /* reset bit */
+                        AtomicTest_Clear(&pHcd->HcdFlags, HCD_REQUEST_CALL_BIT);
+                    }
+                }
+                pReqToComplete = NULL;
+            } else {
+                    /* complete this after the next request has
+                     * been started */
+                pReqToComplete = pReq;
+            }
+        }
+
+            /* acquire the hcd lock to look at the queues */
+        status = _AcquireHcdLock(pHcd);
+        if (SDIO_SUCCESS(status)) {
+            if (pReqToComplete != NULL) {
+                    /* queue the request that was completed */
+                QueueRequest(&pHcd->CompletedRequestQueue, pReqToComplete);
+            }
+            if (NULL == pNextReq) {
+                    /* check the queue for the next request */
+                DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: Checking queue.. \n"));
+                    /* check to see if the HCD was already working on one.  This occurs if
+                     * the current request being completed was a barrier request and the
+                     * barrier completion routine submitted a new request to the head of the
+                     * queue */
+                if (GET_CURRENT_REQUEST(pHcd) == NULL) {
+                    pNextReq = DequeueRequest(&pHcd->RequestQueue);
+                    if (NULL == pNextReq) {
+                            /* nothing in the queue, mark it not busy */
+                        MarkQueueNotBusy(&pHcd->RequestQueue);
+                        DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: Queue idle \n"));
+                    } else {
+                        DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: Next request in queue: 0x%X \n",
+                            (INT)pNextReq));
+                    }
+                } else {
+                    DBG_PRINT(SDIODBG_REQUESTS,
+                        ("SDIO Bus Driver: Busy Queue from barrier request \n"));
+                }
+            }
+
+            if (pNextReq != NULL) {
+                    /* a new request will be submitted to the HCD below,
+                     * check recursion while we have the lock */
+                if (CHECK_API_VERSION_COMPAT(pHcd,2,6)) {
+                    CHECK_HCD_RECURSE(pHcd,pNextReq);
+                }
+            }
+            status = _ReleaseHcdLock(pHcd);
+        } else {
+            DBG_PRINT(SDDBG_ERROR,
+              ("SDIO Bus Driver: SDIO_HandleHcdEvent Failed to acquire HCD lock \n"));
+            return SDIO_STATUS_ERROR;
+        }
+            /* check for the next request to issue */
+        if (pNextReq != NULL) {
+            DBG_PRINT(SDIODBG_REQUESTS, ("SDIO Bus Driver: Starting Next Request: 0x%X \n",
+                        (INT)pNextReq));
+            SET_CURRENT_REQUEST(pHcd,pNextReq);
+            status = CallHcdRequest(pHcd);
+                /* check and see if the HCD completed the request in the callback */
+            if (status != SDIO_STATUS_PENDING) {
+                    /* recurse and process the request */
+                _SDIO_HandleHcdEvent(pHcd, EVENT_HCD_TRANSFER_DONE);
+            }
+        }
+
+        /* now empty the completed request queue
+         * - this guarantees in-order completion even during recursion */
+        status = _AcquireHcdLock(pHcd);
+        if (SDIO_SUCCESS(status)) {
+            while (1) {
+                pReqToComplete = DequeueRequest(&pHcd->CompletedRequestQueue);
+                status = _ReleaseHcdLock(pHcd);
+                if (pReqToComplete != NULL) {
+                    CompleteRequestCheckCancel(pHcd, pReqToComplete);
+                    if (!CHECK_API_VERSION_COMPAT(pHcd,2,6)) {
+                        if (!ForceAllRequestsAsync()) {
+                                /* reset bit */
+                            AtomicTest_Clear(&pHcd->HcdFlags, HCD_REQUEST_CALL_BIT);
+                        }
+                    }
+                        /* re-acquire lock */
+                    status = _AcquireHcdLock(pHcd);
+                    if (!SDIO_SUCCESS(status)) {
+                        return SDIO_STATUS_ERROR;
+                    }
+                    if (CHECK_API_VERSION_COMPAT(pHcd,2,6)) {
+                        if (!ForceAllRequestsAsync()) {
+                            /* while we have the lock, decrement recursion count each time
+                             * we complete a request */
+                            pHcd->Recursion--;
+                            DBG_ASSERT(pHcd->Recursion >= 0);
+                        }
+                    }
+                }  else {
+                        /* we're done */
+                    break;
+                }
+            }
+        } else {
+            DBG_PRINT(SDDBG_ERROR,
+              ("SDIO Bus Driver: SDIO_HandleHcdEvent Failed to acquire HCD lock \n"));
+            return SDIO_STATUS_ERROR;
+        }
+        DBG_PRINT(SDIODBG_REQUESTS, ("-SDIO Bus Driver: Transfer Done Handled \n"));
+        return SDIO_STATUS_SUCCESS;
+    }
+
+    switch(Event) {
+        case EVENT_HCD_ATTACH:
+        case EVENT_HCD_DETACH:
+                /* card detect helper does the actual attach detach */
+            return PostCardDetectEvent(pBusContext,Event,pHcd);
+        case EVENT_HCD_SDIO_IRQ_PENDING:
+            return DeviceInterrupt(pHcd);
+        default:
+            DBG_PRINT(SDDBG_ERROR, ("-SDIO Bus Driver: SDIO_HandleHcdEvent, invalid event type 0x%X, HCD:0x%X\n",
+                                    Event, (UINT)pHcd));
+        return SDIO_STATUS_INVALID_PARAMETER;
+    }
+
+}
+
+/* card detect helper function */
+THREAD_RETURN CardDetectHelperFunction(POSKERNEL_HELPER pHelper)
+{
+    SDIO_STATUS       status;
+    HCD_EVENT_MESSAGE message;
+    INT               length;
+
+    DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver - CardDetectHelperFunction starting up: 0x%X \n", (INT)pHelper));
+
+    while (1) {
+
+            /* wait for wake up event */
+        status = SD_WAIT_FOR_WAKEUP(pHelper);
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver - Card Detect Helper Semaphore Pend Error:%d \n",
+                                    status));
+            break;
+        }
+
+        if (SD_IS_HELPER_SHUTTING_DOWN(pHelper)) {
+                /* cleanup message queue on shutdown */
+            while (1) {
+                length = sizeof(message);
+                    /* get a message */
+                status = SDLIB_GetMessage(pBusContext->pCardDetectMsgQueue,
+                                          &message, &length);
+                if (!SDIO_SUCCESS(status)) {
+                    break;
+                }
+                if (message.pHcd != NULL) {
+                        /* decrement HCD reference count */
+                    OS_DecHcdReference(message.pHcd);
+                }
+            }
+
+            break;
+        }
+
+	while (down_interruptible(&athsdio_init_lock))
+	    ;
+
+        while (1) {
+            length = sizeof(message);
+                /* get a message */
+            status = SDLIB_GetMessage(pBusContext->pCardDetectMsgQueue,
+                                      &message, &length);
+            if (!SDIO_SUCCESS(status)) {
+                break;
+            }
+
+            switch (message.Event) {
+                case EVENT_HCD_ATTACH:
+                    DeviceAttach(message.pHcd);
+                    break;
+                case EVENT_HCD_DETACH:
+                    DeviceDetach(message.pHcd);
+                    break;
+                case EVENT_HCD_CD_POLLING:
+                        /* run detector */
+                    RunCardDetect();
+                    break;
+                default:
+                    DBG_ASSERT(FALSE);
+                    break;
+            }
+
+            if (message.pHcd != NULL) {
+                    /* message was processed, decrement reference count */
+                OS_DecHcdReference(message.pHcd);
+            }
+        }
+
+        up(&athsdio_init_lock);
+    }
+
+    DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver - Card Detect Helper Exiting.. \n"));
+    return 0;
+}
+
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  RunCardDetect - run card detect on host controller slots that require polling
+  Input:
+  Output:
+  Return:
+  Notes: This function is called from the card detect timer thread
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void RunCardDetect(void)
+{
+    BOOL       CDPollingRequired = FALSE;
+    PSDLIST    pListItem;
+    PSDHCD     pHcd;
+    BOOL       cardPresent;
+
+    DBG_PRINT(SDIODBG_CD_TIMER, ("+SDIO Bus Driver: RunCardDetect\n"));
+
+       /* protect the HCD list */
+    if (!SDIO_SUCCESS(SemaphorePendInterruptable(&pBusContext->HcdListSem))) {
+        DBG_ASSERT(FALSE);
+        return;  /* wait interrupted */
+    }
+        /* while we are running the detector we are blocking HCD removal*/
+    SDITERATE_OVER_LIST(&pBusContext->HcdList, pListItem) {
+        pHcd = CONTAINING_STRUCT(pListItem, SDHCD, SDList);
+            /* does the HCD require polling ? */
+        if (pHcd->Attributes & SDHCD_ATTRIB_SLOT_POLLING) {
+            DBG_PRINT(SDIODBG_CD_TIMER, ("SDIO Bus Driver: Found HCD requiring polling \n"));
+                /* set flag to queue the timer */
+            CDPollingRequired = TRUE;
+            if (IS_CARD_PRESENT(pHcd)) {
+                    /* there is a device in the slot */
+                cardPresent = TRUE;
+                if (SDIO_SUCCESS(ScanSlotForCard(pHcd,&cardPresent))) {
+                    if (!cardPresent) {
+                        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver CD Polling.. Card Removal Detected\n"));
+                        DeviceDetach(pHcd);
+                    }
+                }
+            } else {
+                cardPresent = FALSE;
+                if (SDIO_SUCCESS(ScanSlotForCard(pHcd,&cardPresent))) {
+                     if (cardPresent) {
+                        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver CD Polling.. Card Detected\n"));
+                        DeviceAttach(pHcd);
+                    }
+                }
+            }
+        }
+
+        DBG_PRINT(SDIODBG_CD_TIMER, ("SDIO Bus Driver: moving to next hcd:0x%X \n",
+                                     (INT)pListItem->pNext));
+    }
+
+        /* check if we need to queue the timer */
+    if (CDPollingRequired && !pBusContext->CDTimerQueued) {
+        pBusContext->CDTimerQueued = TRUE;
+        DBG_PRINT(SDIODBG_CD_TIMER, ("SDIO Bus Driver: Queuing Card detect timer \n"));
+        if (!SDIO_SUCCESS(
+            QueueTimer(SDIOBUS_CD_TIMER_ID, pBusContext->CDPollingInterval))) {
+            DBG_PRINT(SDDBG_WARN, ("SDIO Bus Driver: failed to queue CD timer \n"));
+            pBusContext->CDTimerQueued = FALSE;
+        }
+    }
+        /* release HCD list lock */
+    SemaphorePost(&pBusContext->HcdListSem);
+    DBG_PRINT(SDIODBG_CD_TIMER, ("-SDIO Bus Driver: RunCardDetect\n"));
+}
+
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  ScanSlotForCard - scan slot for a card
+  Input:  pHcd - the hcd
+  Output: pCardPresent - card present flag (set/cleared on return)
+  Return:
+  Notes:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static SDIO_STATUS ScanSlotForCard(PSDHCD pHcd,PBOOL pCardPresent)
+{
+    SDIO_STATUS         status = SDIO_STATUS_SUCCESS;
+    UINT8               temp;
+
+    DBG_PRINT(SDIODBG_CD_TIMER, ("+SDIO Bus Driver: ScanSlotForCard\n"));
+
+    do {
+        if (!IS_CARD_PRESENT(pHcd)) {
+            INT   dbgLvl;
+            dbgLvl = DBG_GET_DEBUG_LEVEL();
+            DBG_SET_DEBUG_LEVEL(SDDBG_WARN);
+            status = CardInitSetup(pHcd);
+            DBG_SET_DEBUG_LEVEL(dbgLvl);
+            if (!SDIO_SUCCESS(status)) {
+                break;
+            }
+                /* issue go-idle */
+            if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+                _IssueSimpleBusRequest(pHcd,CMD0,0,SDREQ_FLAGS_RESP_R1,NULL);
+            } else {
+                _IssueSimpleBusRequest(pHcd,CMD0,0,SDREQ_FLAGS_NO_RESP,NULL);
+            }
+                /* try SDIO */
+            status = TestPresence(pHcd,CARD_SDIO,NULL);
+            if (SDIO_SUCCESS(status)) {
+                *pCardPresent = TRUE;
+                break;
+            }
+                /* issue go-idle */
+            if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+                _IssueSimpleBusRequest(pHcd,CMD0,0,SDREQ_FLAGS_RESP_R1,NULL);
+            } else {
+                _IssueSimpleBusRequest(pHcd,CMD0,0,SDREQ_FLAGS_NO_RESP,NULL);
+            }
+                /* try SD */
+            status = TestPresence(pHcd,CARD_SD,NULL);
+            if (SDIO_SUCCESS(status)) {
+                *pCardPresent = TRUE;
+                break;
+            }
+                /* issue go-idle */
+            if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+                _IssueSimpleBusRequest(pHcd,CMD0,0,SDREQ_FLAGS_RESP_R1,NULL);
+            } else {
+                _IssueSimpleBusRequest(pHcd,CMD0,0,SDREQ_FLAGS_NO_RESP,NULL);
+            }
+                /* try MMC */
+            status = TestPresence(pHcd,CARD_MMC,NULL);
+            if (SDIO_SUCCESS(status)) {
+                *pCardPresent = TRUE;
+                break;
+            }
+        } else {
+            if (pHcd->CardProperties.Flags & CARD_SDIO) {
+#ifdef DUMP_INT_PENDING
+                temp = 0;
+                    /* handy debug prints to check interrupt status and print pending register */
+                status = Cmd52ReadByteCommon(pHcd->pPseudoDev, SDIO_INT_ENABLE_REG, &temp);
+                if (SDIO_SUCCESS(status) && (temp != 0)) {
+                    DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: INT Enable Reg: 0x%2.2X\n", temp));
+                    status = Cmd52ReadByteCommon(pHcd->pPseudoDev, SDIO_INT_PENDING_REG, &temp);
+                    if (SDIO_SUCCESS(status)) {
+                        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: INT Pend Reg: 0x%2.2X\n", temp));
+                    }
+                }
+#endif
+                    /* for SDIO cards, read the revision register */
+                status = Cmd52ReadByteCommon(pHcd->pPseudoDev, CCCR_SDIO_REVISION_REG, &temp);
+            } else if (pHcd->CardProperties.Flags & (CARD_SD | CARD_MMC)) {
+                    /* for SD/MMC cards, issue SEND_STATUS */
+                if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+                        /* SPI uses the SPI R2 response */
+                    status = _IssueSimpleBusRequest(pHcd,
+                                                    CMD13,
+                                                    0,
+                                                    SDREQ_FLAGS_RESP_R2,
+                                                    NULL);
+                } else {
+                    status = _IssueSimpleBusRequest(pHcd,
+                                                    CMD13,
+                                                    (pHcd->CardProperties.RCA << 16),
+                                                    SDREQ_FLAGS_RESP_R1,NULL);
+                }
+            } else {
+                DBG_ASSERT(FALSE);
+            }
+            if (!SDIO_SUCCESS(status)) {
+                    /* card is gone */
+                *pCardPresent = FALSE;
+            }
+        }
+    } while (FALSE);
+
+    if (status == SDIO_STATUS_BUS_RESP_TIMEOUT) {
+        status = SDIO_STATUS_SUCCESS;
+    }
+
+    DBG_PRINT(SDIODBG_CD_TIMER, ("-SDIO Bus Driver: ScanSlotForCard status:%d\n",
+                                 status));
+
+    return status;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  DeviceInterrupt - handle device interrupt
+  Input:  pHcd -  host controller
+  Output:
+  Return:
+  Notes:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS DeviceInterrupt(PSDHCD pHcd)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    SDIO_STATUS status2;
+    PSDREQUEST pReq = NULL;
+    CT_DECLARE_IRQ_SYNC_CONTEXT();
+
+    DBG_PRINT(SDIODBG_FUNC_IRQ, ("+SDIO Bus Driver: DeviceInterrupt\n"));
+
+    if (!IS_CARD_PRESENT(pHcd)) {
+        DBG_PRINT(SDDBG_ERROR, ("-SDIO Bus Driver: Device interrupt asserted on empty slot!\n"));
+        return SDIO_STATUS_ERROR;
+    }
+
+    do {
+            /* for RAW HCDs or HCDs flagged for single-function IRQ optimization */
+        if (IS_HCD_RAW(pHcd) || (pHcd->HcdFlags & (1 << HCD_IRQ_NO_PEND_CHECK))) {
+            status = _AcquireHcdLock(pHcd);
+            if (!SDIO_SUCCESS(status)) {
+                return status;
+            }
+            if (pHcd->IrqProcState != SDHCD_IDLE) {
+                DBG_PRINT(SDDBG_ERROR, ("-SDIO Bus Driver: Already processing interrupts! (state = %d) \n",
+                                    pHcd->IrqProcState));
+                status = SDIO_STATUS_ERROR;
+                status2 = _ReleaseHcdLock(pHcd);
+            } else {
+                DBG_PRINT(SDIODBG_FUNC_IRQ, ("SDIO Bus Driver :  Device Interrupt \n"));
+                    /* mark that we are processing */
+                pHcd->IrqProcState = SDHCD_IRQ_PENDING;
+                status2 = _ReleaseHcdLock(pHcd);
+                    /* process Irqs for raw hcds or HCDs with the single function optimization */
+                    /* force processing of function 1 interrupt */
+                ProcessPendingIrqs(pHcd, (1 << 1));
+            }
+            DBG_PRINT(SDIODBG_FUNC_IRQ, ("-SDIO Bus Driver: DeviceInterrupt: %d\n", status));
+                /* done with RAW irqs */
+            return status;
+        }
+
+            /* pre-allocate a request to get the pending bits, we have to do this outside the
+              * hcd lock acquisition */
+        pReq = AllocateRequest();
+
+        if (NULL == pReq) {
+            status = SDIO_STATUS_NO_RESOURCES;
+            break;
+        }
+
+        status = _AcquireHcdLock(pHcd);
+
+        if (!SDIO_SUCCESS(status)) {
+            break;
+        }
+
+        if (pHcd->IrqProcState != SDHCD_IDLE) {
+            DBG_PRINT(SDDBG_ERROR, ("-SDIO Bus Driver: Already processing interrupts! (state = %d) \n",
+                                    pHcd->IrqProcState));
+            status = SDIO_STATUS_ERROR;
+        } else {
+                /* mark that we are processing */
+            pHcd->IrqProcState = SDHCD_IRQ_PENDING;
+                /* build argument to read IRQ pending register */
+            SDIO_SET_CMD52_READ_ARG(pReq->Argument,0,SDIO_INT_PENDING_REG);
+            pReq->Command = CMD52;
+            pReq->Flags = SDREQ_FLAGS_TRANS_ASYNC | SDREQ_FLAGS_RESP_SDIO_R5;
+            pReq->pCompleteContext = (PVOID)pHcd;
+            pReq->pCompletion = GetPendingIrqComplete;
+            pReq->RetryCount = SDBUS_MAX_RETRY;
+        }
+
+        status2 = _ReleaseHcdLock(pHcd);
+
+        if (!SDIO_SUCCESS(status2)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: lock release error: %d\n", status2));
+        }
+
+    } while (FALSE);
+
+    if (SDIO_SUCCESS(status)) {
+        DBG_ASSERT(pReq != NULL);
+        IssueRequestToHCD(pHcd,pReq);
+        status = SDIO_STATUS_PENDING;
+    } else {
+        if (pReq != NULL) {
+            FreeRequest(pReq);
+        }
+    }
+
+    DBG_PRINT(SDIODBG_FUNC_IRQ, ("-SDIO Bus Driver: DeviceInterrupt: %d\n", status));
+    return status;
+}
+
+
+/* SDIO IRQ helper */
+THREAD_RETURN SDIOIrqHelperFunction(POSKERNEL_HELPER pHelper)
+{
+    PSDHCD            pHcd;
+    SDIO_STATUS       status;
+    PSDLIST           pListItem;
+    PSDDEVICE         pDevice;
+    UINT8             funcMask;
+    PSDDEVICE         pDeviceIRQ[7];
+    UINT              deviceIrqCount = 0;
+    UINT              ii;
+
+    DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver - SDIOIrqHelperFunction starting up \n"));
+
+    pHcd = (PSDHCD)pHelper->pContext;
+    DBG_ASSERT(pHcd != NULL);
+
+    while (1) {
+
+            /* wait for wake up event */
+        status = SD_WAIT_FOR_WAKEUP(pHelper);
+
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver - SDIOIrqHelperFunction Pend Error:%d \n",
+                                    status));
+            break;
+        }
+
+        if (SD_IS_HELPER_SHUTTING_DOWN(pHelper)) {
+            break;
+        }
+
+        DBG_PRINT(SDIODBG_FUNC_IRQ, ("SDIO Bus Driver - Pending IRQs:0x%X \n",
+                                     pHcd->PendingHelperIrqs));
+
+         /* take the device list lock as we iterate through the list, this blocks
+             * device removals */
+        status = SemaphorePendInterruptable(&pBusContext->DeviceListSem);
+        if (!SDIO_SUCCESS(status)) {
+            break;
+        }
+            /* walk through the device list matching HCD and interrupting function */
+        SDITERATE_OVER_LIST(&pBusContext->DeviceList, pListItem) {
+            pDevice = CONTAINING_STRUCT(pListItem, SDDEVICE, SDList);
+                /* check if device belongs to the HCD */
+            if (pDevice->pHcd != pHcd){
+                    /* not on this hcd */
+                continue;
+            }
+            funcMask = 1 << SDDEVICE_GET_SDIO_FUNCNO(pDevice);
+                /* check device function against the pending mask */
+            if (!(funcMask & pHcd->PendingHelperIrqs)) {
+                    /* this one is not scheduled for the helper */
+                continue;
+            }
+                /* clear bit */
+            pHcd->PendingHelperIrqs &= ~funcMask;
+                /* check for sync IRQ and call handler */
+            if (pDevice->pIrqFunction != NULL) {
+                DBG_PRINT(SDIODBG_FUNC_IRQ, ("SDIO Bus Driver: Calling IRQ Handler. Fn:%d\n",
+                                             SDDEVICE_GET_SDIO_FUNCNO(pDevice)));
+                /* save the device so we can process it without holding any locks */
+                pDeviceIRQ[deviceIrqCount++] = pDevice;
+            } else {
+                    /* this is actually okay if the device is removing, the callback
+                     * is NULLed out */
+                DBG_PRINT(SDIODBG_FUNC_IRQ, ("SDIO Bus Driver: No IRQ handler Fn:%d\n",
+                                             SDDEVICE_GET_SDIO_FUNCNO(pDevice)));
+            }
+        }
+            /* should have handled all these */
+        DBG_ASSERT(pHcd->PendingHelperIrqs == 0);
+        pHcd->PendingHelperIrqs = 0;
+        SemaphorePost(&pBusContext->DeviceListSem);
+        for (ii = 0; ii < deviceIrqCount; ii++) {
+            /* now call the function */
+            SDDEVICE_CALL_IRQ_HANDLER(pDeviceIRQ[ii]);
+        }
+        deviceIrqCount = 0;
+    }
+
+    DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver - SDIOIrqHelperFunction Exiting.. \n"));
+    return 0;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  GetPendingIrqComplete - completion routine for getting pending IRQs
+  Input:  pRequest -  completed request
+  Output:
+  Return:
+  Notes:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static void GetPendingIrqComplete(PSDREQUEST pReq)
+{
+    UINT8       intPendingMsk;
+    PSDHCD      pHcd;
+
+    do {
+        pHcd = (PSDHCD)pReq->pCompleteContext;
+        DBG_ASSERT(pHcd != NULL);
+
+        if (!SDIO_SUCCESS(pReq->Status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to get Interrupt pending register Err:%d\n",
+                                    pReq->Status));
+            break;
+        }
+
+        if (SD_R5_GET_RESP_FLAGS(pReq->Response) & SD_R5_ERRORS) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: CMD52 resp error: 0x%X \n",
+                                    SD_R5_GET_RESP_FLAGS(pReq->Response)));
+            break;
+        }
+            /* extract the pending mask */
+        intPendingMsk =  SD_R5_GET_READ_DATA(pReq->Response) & SDIO_INT_PEND_MASK;
+            /* process them */
+        ProcessPendingIrqs(pHcd, intPendingMsk);
+
+    } while (FALSE);
+
+    FreeRequest(pReq);
+
+    DBG_PRINT(SDIODBG_FUNC_IRQ, ("-SDIO Bus Driver: GetPendingIrqComplete \n"));
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  ProcessPendingIrqs - processing pending Irqs
+  Input:  pHcd - host controller
+  Input:  IntPendingMsk -  pending irq bit mask
+  Output:
+  Return:
+  Notes:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static void ProcessPendingIrqs(PSDHCD pHcd, UINT8 IntPendingMsk)
+{
+    PSDLIST     pListItem;
+    PSDDEVICE   pDevice;
+    UINT8       funcMask;
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    CT_DECLARE_IRQ_SYNC_CONTEXT();
+
+    DBG_PRINT(SDIODBG_FUNC_IRQ, ("+SDIO Bus Driver: ProcessPendingIrqs \n"));
+    do {
+            /* acquire lock to protect configuration and irq enables */
+        status = _AcquireHcdLock(pHcd);
+        if (!SDIO_SUCCESS(status)) {
+            break;
+        }
+
+            /* sanity check */
+        if ((IntPendingMsk & pHcd->IrqsEnabled) != IntPendingMsk) {
+            DBG_PRINT(SDDBG_ERROR,
+                ("SDIO Bus Driver: IRQs asserting when not enabled : curr:0x%X , card reports: 0x%X\n",
+                     pHcd->IrqsEnabled, IntPendingMsk));
+                /* remove the pending IRQs that are not enabled */
+            IntPendingMsk &= pHcd->IrqsEnabled;
+                /* fall through */
+        }
+
+        if (!IntPendingMsk) {
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: No interrupts on HCD:0x%X \n", (INT)pHcd));
+            pHcd->IrqProcState = SDHCD_IDLE;
+            if (pHcd->IrqsEnabled) {
+                    /* only re-arm if there are IRQs enabled */
+                _IssueConfig(pHcd,SDCONFIG_SDIO_REARM_INT,NULL,0);
+            }
+            status = _ReleaseHcdLock(pHcd);
+            break;
+        }
+            /* reset helper IRQ bits */
+        pHcd->PendingHelperIrqs = 0;
+            /* save pending IRQ acks */
+        pHcd->PendingIrqAcks = IntPendingMsk;
+        status = _ReleaseHcdLock(pHcd);
+        DBG_PRINT(SDIODBG_FUNC_IRQ, ("SDIO Bus Driver: INTs Pending - 0x%2.2X \n", IntPendingMsk));
+            /* take the device list lock as we iterate through the list, this blocks
+             * device removals */
+        status = SemaphorePendInterruptable(&pBusContext->DeviceListSem);
+        if (!SDIO_SUCCESS(status)) {
+            break;
+        }
+            /* walk through the device list matching HCD and interrupting function */
+        SDITERATE_OVER_LIST(&pBusContext->DeviceList, pListItem) {
+            pDevice = CONTAINING_STRUCT(pListItem, SDDEVICE, SDList);
+                /* check if device belongs to the HCD */
+            if (pDevice->pHcd != pHcd){
+                    /* not on this hcd */
+                continue;
+            }
+            funcMask = 1 << SDDEVICE_GET_SDIO_FUNCNO(pDevice);
+                /* check device function against the pending mask */
+            if (!(funcMask & IntPendingMsk)) {
+                    /* this one is not interrupting */
+                continue;
+            }
+                /* check for async IRQ and call handler */
+            if (pDevice->pIrqAsyncFunction != NULL) {
+                DBG_PRINT(SDIODBG_FUNC_IRQ, ("SDIO Bus Driver: Calling Async IRQ Handler. Fn:%d\n",
+                                             SDDEVICE_GET_SDIO_FUNCNO(pDevice)));
+                SDDEVICE_CALL_IRQ_ASYNC_HANDLER(pDevice);
+            } else {
+                    /* this one needs the helper */
+                pHcd->PendingHelperIrqs |= funcMask;
+                DBG_PRINT(SDIODBG_FUNC_IRQ, ("SDIO Bus Driver: No Async IRQ, Pending Helper Fn:%d\n",
+                                             SDDEVICE_GET_SDIO_FUNCNO(pDevice)));
+            }
+        }
+            /* release HCD list lock */
+        SemaphorePost(&pBusContext->DeviceListSem);
+            /* check for helper IRQs */
+        if (pHcd->PendingHelperIrqs) {
+            pHcd->IrqProcState = SDHCD_IRQ_HELPER;
+            DBG_PRINT(SDIODBG_FUNC_IRQ, ("SDIO Bus Driver: Waking IRQ Helper \n"));
+            if (!SDIO_SUCCESS(SD_WAKE_OS_HELPER(&pHcd->SDIOIrqHelper))) {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: failed to wake helper! \n"));
+            }
+        }
+    } while (FALSE);
+
+    DBG_PRINT(SDIODBG_FUNC_IRQ, ("-SDIO Bus Driver: ProcessPendingIrqs \n"));
+}
+
+SDIO_STATUS TryNoIrqPendingCheck(PSDDEVICE pDevice)
+{
+    if (pDevice->pHcd->CardProperties.IOFnCount > 1) {
+            /* not supported on multi-function cards */
+        DBG_PRINT(SDDBG_WARN, ("SDIO Bus Driver: IRQ Pending Check cannot be bypassed, (Funcs:%d)\n",
+            pDevice->pHcd->CardProperties.IOFnCount));
+        return SDIO_STATUS_UNSUPPORTED;
+    }
+
+    DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: pending IRQ check bypassed \n"));
+        /* set flag to optimize this */
+    AtomicTest_Set(&pDevice->pHcd->HcdFlags, HCD_IRQ_NO_PEND_CHECK);
+    return SDIO_STATUS_SUCCESS;
+}
+
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  SDIO_NotifyTimerTriggered - notification handler that a timer expired
+  Input:  TimerID - ID of timer that expired
+  Output:
+  Return:
+  Notes:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void SDIO_NotifyTimerTriggered(INT TimerID)
+{
+
+    switch (TimerID) {
+        case SDIOBUS_CD_TIMER_ID:
+            pBusContext->CDTimerQueued = FALSE;
+                /* post an HCD polling event to the helper thread */
+            PostCardDetectEvent(pBusContext, EVENT_HCD_CD_POLLING, NULL);
+            break;
+        default:
+            DBG_ASSERT(FALSE);
+    }
+
+}
Index: linux-2.6/drivers/sdio/busdriver/sdio_bus_misc.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/busdriver/sdio_bus_misc.c
@@ -0,0 +1,3122 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdio_bus_misc.c
+
+@abstract: OS independent bus driver support
+
+#notes: this file contains miscellaneous control functions
+
+@notice: Copyright (c), 2004-2006 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define MODULE_NAME  SDBUSDRIVER
+#include <linux/sdio/ctsystem.h>
+#include <linux/sdio/sdio_busdriver.h>
+#include <linux/sdio/sdio_lib.h>
+#include "_busdriver.h"
+#include <linux/sdio/_sdio_defs.h>
+#include <linux/sdio/mmc_defs.h>
+
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  IssueBusRequestBd - issue a bus request
+  Input:  pHcd - HCD object
+          Cmd - command to issue
+          Argument - command argument
+          Flags - request flags
+
+  Output: pReqToUse - request to use (if caller wants response data)
+  Return: SDIO Status
+  Notes:  This function only issues 1 block data transfers
+          This function issues the request synchronously
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS _IssueBusRequestBd(PSDHCD           pHcd,
+                               UINT8            Cmd,
+                               UINT32           Argument,
+                               SDREQUEST_FLAGS  Flags,
+                               PSDREQUEST       pReqToUse,
+                               PVOID            pData,
+                               INT              Length)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    PSDREQUEST  pReq;
+
+    if (NULL == pReqToUse) {
+            /* caller doesn't care about the response data, allocate locally */
+        pReq = AllocateRequest();
+        if (NULL == pReq) {
+            return SDIO_STATUS_NO_RESOURCES;
+        }
+    } else {
+            /* use the caller's request buffer */
+        pReq = pReqToUse;
+    }
+
+    pReq->Argument = Argument;
+    pReq->Flags = Flags;
+    pReq->Command = Cmd;
+    if (pReq->Flags & SDREQ_FLAGS_DATA_TRANS) {
+        pReq->pDataBuffer  = pData;
+        pReq->BlockCount = 1;
+        pReq->BlockLen = Length;
+    }
+
+    status = IssueRequestToHCD(pHcd,pReq);
+
+    if (NULL == pReqToUse) {
+        DBG_ASSERT(pReq != NULL);
+        FreeRequest(pReq);
+    }
+    return status;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  ConvertVoltageCapsToOCRMask - initialize card
+  Input:  VoltageCaps - voltage cap to look up
+  Return: 32 bit OCR mask
+  Notes:  this function sets voltage for +- 10%
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static UINT32 ConvertVoltageCapsToOCRMask(SLOT_VOLTAGE_MASK VoltageCaps)
+{
+    UINT32 ocrMask;
+
+    ocrMask = 0;
+
+    if (VoltageCaps & SLOT_POWER_3_3V) {
+        ocrMask |= SD_OCR_3_2_TO_3_3_VDD | SD_OCR_3_3_TO_3_4_VDD;
+    }
+    if (VoltageCaps & SLOT_POWER_3_0V) {
+        ocrMask |= SD_OCR_2_9_TO_3_0_VDD | SD_OCR_3_0_TO_3_1_VDD;
+    }
+    if (VoltageCaps & SLOT_POWER_2_8V) {
+        ocrMask |= SD_OCR_2_7_TO_2_8_VDD | SD_OCR_2_8_TO_2_9_VDD;
+    }
+    if (VoltageCaps & SLOT_POWER_2_0V) {
+        ocrMask |= SD_OCR_1_9_TO_2_0_VDD | SD_OCR_2_0_TO_2_1_VDD;
+    }
+    if (VoltageCaps & SLOT_POWER_1_8V) {
+        ocrMask |= SD_OCR_1_7_TO_1_8_VDD | SD_OCR_1_8_TO_1_9_VDD;
+    }
+    if (VoltageCaps & SLOT_POWER_1_6V) {
+        ocrMask |= SD_OCR_1_6_TO_1_7_VDD;
+    }
+
+    return ocrMask;
+}
+
+static UINT32 GetUsableOCRValue(UINT32 CardOCR, UINT32 SlotOCRMask)
+{
+    INT    i;
+    UINT32 mask = 0;
+
+    for (i = 0; i < 32; i++) {
+        mask = 1 << i;
+        if ((SlotOCRMask & mask) && (CardOCR & mask)) {
+            return mask;
+        }
+    }
+
+    return mask;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  GetPowerSetting - power up the SDIO card
+  Input:  pHcd - HCD object
+          pOCRvalue - OCR value of the card
+  Output: pOCRvalue - OCR to actually use
+  Return: power setting for HCD based on card's OCR, zero indicates unsupported
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static SLOT_VOLTAGE_MASK GetPowerSetting(PSDHCD pHcd, UINT32 *pOCRvalue)
+{
+    UINT32                      ocrMask;
+    SLOT_VOLTAGE_MASK           hcdVoltage = 0;
+    SLOT_VOLTAGE_MASK           hcdVMask;
+    INT                         i;
+
+        /* check preferred value */
+    ocrMask = ConvertVoltageCapsToOCRMask(pHcd->SlotVoltagePreferred);
+    if (ocrMask & *pOCRvalue) {
+            /* using preferred voltage */
+        *pOCRvalue = GetUsableOCRValue(*pOCRvalue, ocrMask);
+        hcdVoltage = pHcd->SlotVoltagePreferred;
+    } else {
+            /* walk through the slot voltage caps and find a match */
+        for (i = 0; i < 8; i++) {
+            hcdVMask = (1 << i);
+            if (hcdVMask & pHcd->SlotVoltageCaps) {
+                ocrMask = ConvertVoltageCapsToOCRMask((SLOT_VOLTAGE_MASK)(pHcd->SlotVoltageCaps & hcdVMask));
+                if (ocrMask & *pOCRvalue) {
+                        /* found a match */
+                    *pOCRvalue = GetUsableOCRValue(*pOCRvalue, ocrMask);
+                    hcdVoltage = pHcd->SlotVoltageCaps & hcdVMask;
+                    break;
+                }
+            }
+        }
+    }
+
+    return hcdVoltage;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  TestPresence - test the presence of a card/function
+  Input:  pHcd - HCD object
+          TestType - type of test to perform
+  Output: pReq - Request to use (optional)
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS TestPresence(PSDHCD          pHcd,
+                         CARD_INFO_FLAGS TestType,
+                         PSDREQUEST      pReq)
+{
+    SDIO_STATUS status = SDIO_STATUS_ERROR;
+
+     switch (TestType) {
+        case CARD_SDIO:
+                /* issue CMD5 */
+            status = _IssueSimpleBusRequest(pHcd,CMD5,0,
+                        SDREQ_FLAGS_RESP_SDIO_R4 | SDREQ_FLAGS_RESP_SKIP_SPI_FILT,pReq);
+            break;
+        case CARD_SD:
+            if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+                 /* ACMD41 just starts initialization when in SPI mode, argument is ignored
+                 * Note: In SPI mode ACMD41 uses an R1 response */
+                status = _IssueSimpleBusRequest(pHcd,ACMD41,0,
+                                                SDREQ_FLAGS_APP_CMD | SDREQ_FLAGS_RESP_R1,pReq);
+
+            } else {
+                /* issue ACMD41 with OCR value of zero */
+                /* ACMD41 on SD uses an R3 response */
+                status = _IssueSimpleBusRequest(pHcd,ACMD41,0,
+                                                SDREQ_FLAGS_APP_CMD | SDREQ_FLAGS_RESP_R3,pReq);
+            }
+            break;
+        case CARD_MMC:
+                 /* issue CMD1 */
+            if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+                    /* note: in SPI mode an R1 response is used */
+                status = _IssueSimpleBusRequest(pHcd,CMD1,0,SDREQ_FLAGS_RESP_R1,pReq);
+            } else {
+                status = _IssueSimpleBusRequest(pHcd,CMD1,0,SDREQ_FLAGS_RESP_R3,pReq);
+            }
+            break;
+        default:
+            DBG_ASSERT(FALSE);
+            break;
+    }
+
+    return status;
+}
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  ReadOCR - read the OCR
+  Input:  pHcd - HCD object
+          ReadType - type of read to perform
+          OCRValue - OCR value to use as an argument
+  Output: pReq - Request to use
+          pOCRValueRd - OCR value read back (can be NULL)
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static SDIO_STATUS ReadOCR(PSDHCD          pHcd,
+                           CARD_INFO_FLAGS ReadType,
+                           PSDREQUEST      pReq,
+                           UINT32          OCRValue,
+                           UINT32          *pOCRValueRd)
+{
+    SDIO_STATUS status = SDIO_STATUS_ERROR;
+
+     switch (ReadType) {
+        case CARD_SDIO:
+                /* CMD5 for SDIO cards */
+            if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+                    /* skip the SPI filter, we will decode the response here  */
+                status = _IssueSimpleBusRequest(pHcd,CMD5,
+                                                OCRValue,
+                                                SDREQ_FLAGS_RESP_SDIO_R4 |
+                                                SDREQ_FLAGS_RESP_SKIP_SPI_FILT,
+                                                pReq);
+            } else {
+                    /* native SD */
+                status = _IssueSimpleBusRequest(pHcd,CMD5,
+                                                OCRValue,
+                                                SDREQ_FLAGS_RESP_SDIO_R4,
+                                                pReq);
+            }
+            break;
+        case CARD_SD:
+            if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+                    /* CMD58 is used to read the OCR */
+                status = _IssueSimpleBusRequest(pHcd,CMD58,
+                                                0, /* argument ignored */
+                                                (SDREQ_FLAGS_RESP_R3 | SDREQ_FLAGS_RESP_SKIP_SPI_FILT),
+                                                pReq);
+            } else {
+                    /* SD Native uses ACMD41 */
+                status = _IssueSimpleBusRequest(pHcd,ACMD41,
+                                                OCRValue,
+                                                SDREQ_FLAGS_APP_CMD | SDREQ_FLAGS_RESP_R3,
+                                                pReq);
+            }
+            break;
+        case CARD_MMC:
+            if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+                    /* CMD58 is used to read the OCR  */
+                status = _IssueSimpleBusRequest(pHcd,CMD58,
+                                                0, /* argument ignored */
+                                                (SDREQ_FLAGS_RESP_R3 | SDREQ_FLAGS_RESP_SKIP_SPI_FILT),
+                                                pReq);
+            } else {
+                    /* MMC Native uses CMD1 */
+                status = _IssueSimpleBusRequest(pHcd,CMD1,
+                                                OCRValue, SDREQ_FLAGS_RESP_R3,
+                                                pReq);
+            }
+            break;
+        default:
+            DBG_ASSERT(FALSE);
+            break;
+    }
+
+    if (SDIO_SUCCESS(status) && (pOCRValueRd != NULL)) {
+        *pOCRValueRd = 0;
+            /* someone wants the OCR read back */
+        switch (ReadType) {
+            case CARD_SDIO:
+                if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+                    *pOCRValueRd = SPI_SDIO_R4_GET_OCR(pReq->Response);
+                } else {
+                    *pOCRValueRd = SD_SDIO_R4_GET_OCR(pReq->Response);
+                }
+                break;
+            case CARD_SD:
+            case CARD_MMC:
+                if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+                    *pOCRValueRd = SPI_R3_GET_OCR(pReq->Response);
+                } else {
+                    *pOCRValueRd = SD_R3_GET_OCR(pReq->Response);
+                }
+                break;
+            default:
+                DBG_ASSERT(FALSE);
+                break;
+        }
+    }
+    return status;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  PollCardReady - poll card till it's ready
+  Input:  pHcd - HCD object
+          OCRValue - OCR value to poll with
+          PollType - polling type (based on card type)
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS PollCardReady(PSDHCD pHcd, UINT32 OCRValue, CARD_INFO_FLAGS PollType)
+{
+    INT             cardReadyRetry;
+    SDIO_STATUS     status;
+    PSDREQUEST      pReq;
+
+    if (!((PollType == CARD_SDIO) || (PollType == CARD_SD) || (PollType == CARD_MMC))) {
+        DBG_ASSERT(FALSE);
+        return SDIO_STATUS_INVALID_PARAMETER;
+    }
+
+    pReq = AllocateRequest();
+    if (NULL == pReq) {
+        return SDIO_STATUS_NO_RESOURCES;
+    }
+
+    status = SDIO_STATUS_SUCCESS;
+    cardReadyRetry = pBusContext->CardReadyPollingRetry;
+    DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Polling card ready, Using OCR:0x%8.8X, Poll Type:0x%X\n",
+                            OCRValue,PollType));
+
+        /* now issue CMD with the actual OCR as an argument until the card is ready */
+    while (cardReadyRetry) {
+        if (IS_HCD_BUS_MODE_SPI(pHcd) && !(PollType == CARD_SDIO)) {
+            if (PollType == CARD_MMC) {
+                /* under SPI mode for MMC cards, we need to issue CMD1 and
+                 * check the response for the "in-idle" bit */
+                status = _IssueSimpleBusRequest(pHcd,
+                                                CMD1,
+                                                0,
+                                                SDREQ_FLAGS_RESP_R1 | SDREQ_FLAGS_RESP_SKIP_SPI_FILT,
+                                                pReq);
+            } else if (PollType == CARD_SD) {
+                 /* under SPI mode for SD cards, we need to issue ACMD41 and
+                 * check the response for the "in-idle" bit */
+                 status = _IssueSimpleBusRequest(pHcd,
+                                                 ACMD41,
+                                                 0,
+                                                 SDREQ_FLAGS_RESP_R1 |
+                                                 SDREQ_FLAGS_APP_CMD |
+                                                 SDREQ_FLAGS_RESP_SKIP_SPI_FILT,
+                                                 pReq);
+            } else {
+                DBG_ASSERT(FALSE);
+            }
+        } else {
+                /* for SD/MMC in native mode and SDIO (all modes) we need to read the OCR register */
+                /* read the OCR using the supplied OCR value as an argument, we don't care about the
+                  * actual OCR read-back, but we are interested in the response */
+            status = ReadOCR(pHcd,PollType,pReq,OCRValue,NULL);
+        }
+
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to issue CMD to poll ready \n"));
+            break;
+        }
+        if (PollType == CARD_SDIO)  {
+            if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+                if (SPI_SDIO_R4_IS_CARD_READY(pReq->Response)) {
+                    DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: SDIO Card Ready! (SPI) \n"));
+                    break;
+                }
+            } else {
+                if (SD_SDIO_R4_IS_CARD_READY(pReq->Response)) {
+                    DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: SDIO Card Ready! \n"));
+                    break;
+                }
+            }
+        } else if ((PollType == CARD_SD) || (PollType == CARD_MMC)) {
+            if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+                    /* check response when MMC or SD cards operate in SPI mode */
+                if (!(GET_SPI_R1_RESP_TOKEN(pReq->Response) & SPI_CS_STATE_IDLE)) {
+                        /* card is no longer in idle */
+                    DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: SD/MMC Card (SPI mode) is ready! \n"));
+                    break;
+                }
+            } else {
+                    /* check the OCR busy bit */
+                if (SD_R3_IS_CARD_READY(pReq->Response)) {
+                    DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: SD/MMC (Native Mode) Card Ready! \n"));
+                    break;
+                }
+            }
+        } else {
+            DBG_ASSERT(FALSE);
+        }
+        cardReadyRetry--;
+            /* delay */
+        status = OSSleep(OCR_READY_CHECK_DELAY_MS);
+        if (!SDIO_SUCCESS(status)){
+            break;
+        }
+    }
+
+    if (0 == cardReadyRetry) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Card Ready timeout! \n"));
+        status = SDIO_STATUS_DEVICE_ERROR;
+    }
+
+    FreeRequest(pReq);
+
+    return status;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  AdjustSlotPower - adjust slot power
+  Input:  pHcd - HCD object
+  Output: pOCRvalue - ocr value to use
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static SDIO_STATUS AdjustSlotPower(PSDHCD pHcd, UINT32 *pOCRvalue)
+{
+    SDCONFIG_POWER_CTRL_DATA    pwrSetting;
+    SDIO_STATUS                 status = SDIO_STATUS_SUCCESS;
+
+    ZERO_OBJECT(pwrSetting);
+    DBG_PRINT(SDDBG_TRACE,
+        ("SDIO Bus Driver: Adjusting Slot Power, Requesting adjustment for OCR:0x%8.8X \n",
+         *pOCRvalue));
+
+    do {
+        pwrSetting.SlotPowerEnable = TRUE;
+            /* get optimal power setting */
+        pwrSetting.SlotPowerVoltageMask = GetPowerSetting(pHcd, pOCRvalue);
+        if (0 == pwrSetting.SlotPowerVoltageMask) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: No matching voltage for OCR \n"));
+            status = SDIO_STATUS_DEVICE_ERROR;
+            break;
+        }
+
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Slot Pwr Mask 0x%X for OCR:0x%8.8X \n",
+                                pwrSetting.SlotPowerVoltageMask,*pOCRvalue));
+        status = _IssueConfig(pHcd,SDCONFIG_POWER_CTRL,&pwrSetting,sizeof(pwrSetting));
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to set power in hcd \n"));
+            break;
+        }
+            /* delay for power to settle */
+        OSSleep(pBusContext->PowerSettleDelay);
+            /* save off for drivers */
+        pHcd->CardProperties.CardVoltage  = pwrSetting.SlotPowerVoltageMask;
+
+    } while (FALSE);
+
+    return status;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  ConvertEncodedTransSpeed - convert encoded TRANS_SPEED value to a clock rate
+  Input:  TransSpeedValue - encoded transfer speed value
+  Output:
+  Return: appropriate SD clock rate
+  Notes: This function returns a rate of 0, if it could not be determined.
+         This function can check tran speed values for SD,SDIO and MMC cards
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static SD_BUSCLOCK_RATE ConvertEncodedTransSpeed(UINT8 TransSpeedValue)
+{
+    SD_BUSCLOCK_RATE transfMul = 0;
+    UINT8            timeVal = 0;
+
+    switch (TransSpeedValue & TRANSFER_UNIT_MULTIPIER_MASK) {
+        case 0:
+            transfMul = 10000;
+            break;
+        case 1:
+            transfMul = 100000;
+            break;
+        case 2:
+            transfMul = 1000000;
+            break;
+        case 3:
+            transfMul = 10000000;
+            break;
+        default:
+            transfMul = 0;
+            DBG_PRINT(SDDBG_WARN, ("SDIO Bus Driver: Card transfer multipler is wrong (val=0x%X)! \n",
+                                   TransSpeedValue));
+            break;
+    }
+
+    switch ((TransSpeedValue & TIME_VALUE_MASK) >> TIME_VALUE_SHIFT) {
+        case 1: timeVal = 10; break;
+        case 2: timeVal = 12; break;
+        case 3: timeVal = 13; break;
+        case 4: timeVal = 15; break;
+        case 5: timeVal = 20; break;
+        case 6: timeVal = 25; break;
+        case 7: timeVal = 30; break;
+        case 8: timeVal = 35; break;
+        case 9: timeVal = 40; break;
+        case 10: timeVal = 45; break;
+        case 11: timeVal = 50; break;
+        case 12: timeVal = 55; break;
+        case 13: timeVal = 60; break;
+        case 14: timeVal = 70; break;
+        case 15: timeVal = 80; break;
+        default: timeVal = 0;
+        DBG_PRINT(SDDBG_WARN, ("SDIO Bus Driver: Card time value is wrong (val=0x%X)! \n",
+                               TransSpeedValue));
+        break;
+    }
+
+    if ((transfMul != 0) && (timeVal != 0)) {
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Card Reported Max: %d Hz (0x%X) \n",
+                                (timeVal*transfMul), TransSpeedValue));
+        return timeVal*transfMul;
+    }
+
+    return 0;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  SelectDeselectCard - Select or deselect a card
+  Input:  pHcd - HCD object
+          Select - select the card
+  Output:
+  Return: status
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static SDIO_STATUS SelectDeselectCard(PSDHCD pHcd, BOOL Select)
+{
+    SDIO_STATUS status;
+
+    if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+            /* SPI mode cards do not support selection */
+        status = SDIO_STATUS_SUCCESS;
+    } else {
+        if (!Select) {
+                /* deselect, note that deselecting a card does not return a response */
+            status = _IssueSimpleBusRequest(pHcd,
+                                            CMD7,0,
+                                            SDREQ_FLAGS_NO_RESP,NULL);
+        } else {
+                /* select */
+            status = _IssueSimpleBusRequest(pHcd,
+                                            CMD7,(pHcd->CardProperties.RCA << 16),
+                                            SDREQ_FLAGS_RESP_R1B,NULL);
+        }
+    }
+
+    if (!SDIO_SUCCESS(status)) {
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Failed to %s card, RCA:0x%X Err:%d \n",
+            (Select ? "Select":"Deselect"), pHcd->CardProperties.RCA, status));
+    }
+    return status;
+}
+
+/* reorder a buffer by swapping MSB with LSB */
+static void ReorderBuffer(UINT8 *pBuffer, INT Bytes)
+{
+    UINT8 *pEnd;
+    UINT8 temp;
+
+    DBG_ASSERT(!(Bytes & 1));
+        /* point to the end */
+    pEnd = &pBuffer[Bytes - 1];
+        /* divide in half */
+    Bytes = Bytes >> 1;
+
+    while (Bytes) {
+        temp = *pBuffer;
+            /* swap bytes */
+        *pBuffer = *pEnd;
+        *pEnd = temp;
+        pBuffer++;
+        pEnd--;
+        Bytes--;
+    }
+}
+
+#define ADJUST_OPER_CLOCK(pBusMode,Clock) \
+    (pBusMode)->ClockRate = min((SD_BUSCLOCK_RATE)(Clock),(pBusMode)->ClockRate)
+#define ADJUST_OPER_BLOCK_LEN(pCaps,Length) \
+    (pCaps)->OperBlockLenLimit = min((UINT16)(Length),(pCaps)->OperBlockLenLimit)
+#define ADJUST_OPER_BLOCK_COUNT(pCaps,Count) \
+    (pCaps)->OperBlockCountLimit = min((UINT16)(Count),(pCaps)->OperBlockCountLimit)
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  GetBusParameters - Get bus parameters for a card
+  Input:  pHcd - HCD object
+          pBusMode - current bus mode on entry
+  Output: pBusMode - new adjusted bus mode
+  Return: status
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static SDIO_STATUS GetBusParameters(PSDHCD pHcd, PSDCONFIG_BUS_MODE_DATA pBusMode)
+{
+    SDIO_STATUS                        status = SDIO_STATUS_SUCCESS;
+    UINT8                              temp;
+    UINT32                             tplAddr;
+    struct SDIO_FUNC_EXT_COMMON_TPL    func0ext;
+    UINT8                              scrRegister[SD_SCR_BYTES];
+    SD_BUSCLOCK_RATE                   cardReportedRate = 0;
+    PSDREQUEST                         pReq = NULL;
+    BOOL                               spiMode = FALSE;
+
+
+    if (SDCONFIG_GET_BUSWIDTH(pBusMode->BusModeFlags) == SDCONFIG_BUS_WIDTH_SPI) {
+        spiMode = TRUE;
+    }
+
+    if (!spiMode) {
+            /* set highest bus mode bus driver is allowing (non-SPI), the code below will
+               * adjust to lower or equal settings */
+        pBusMode->BusModeFlags = pBusContext->DefaultBusMode;
+    }
+        /* set operational parameters */
+    pBusMode->ClockRate = pBusContext->DefaultOperClock;
+    pHcd->CardProperties.OperBlockLenLimit = pBusContext->DefaultOperBlockLen;
+    pHcd->CardProperties.OperBlockCountLimit = pBusContext->DefaultOperBlockCount;
+
+        /* adjust operational block counts and length to match HCD */
+    ADJUST_OPER_BLOCK_LEN(&pHcd->CardProperties,pHcd->MaxBytesPerBlock);
+    ADJUST_OPER_BLOCK_COUNT(&pHcd->CardProperties,pHcd->MaxBlocksPerTrans);
+        /* limit operational clock to the max clock rate */
+    ADJUST_OPER_CLOCK(pBusMode,pHcd->MaxClockRate);
+
+    if (!spiMode) {
+            /* check HCD bus mode */
+        if (!(pHcd->Attributes & SDHCD_ATTRIB_BUS_4BIT) ||
+            ((pHcd->CardProperties.Flags & CARD_SDIO) &&
+             (pHcd->Attributes & SDHCD_ATTRIB_NO_4BIT_IRQ)) ) {
+
+            if (pHcd->Attributes & SDHCD_ATTRIB_BUS_4BIT) {
+                DBG_PRINT(SDDBG_WARN,
+                ("SDIO Card Detected, but host does not support IRQs in 4 bit mode - dropping to 1 bit. \n"));
+            }
+                /* force to 1 bit mode */
+            SDCONFIG_SET_BUS_WIDTH(pBusMode->BusModeFlags, SDCONFIG_BUS_WIDTH_1_BIT);
+        }
+    }
+
+        /* now do various card inquiries to drop the bus mode or clock
+         * none of these checks can raise the bus mode or clock higher that what
+         * was initialized above */
+    do {
+        if (pHcd->CardProperties.Flags & (CARD_SD | CARD_MMC)) {
+                /* allocate a request for response data we'll need */
+            pReq = AllocateRequest();
+            if (NULL == pReq) {
+                status = SDIO_STATUS_NO_RESOURCES;
+                break;
+            }
+        }
+
+        if (!spiMode && (pHcd->CardProperties.Flags & CARD_MMC)) {
+                /* MMC cards all run in 1 bit mode */
+            SDCONFIG_SET_BUS_WIDTH(pBusMode->BusModeFlags, SDCONFIG_BUS_WIDTH_1_BIT);
+        }
+
+        if (pHcd->CardProperties.Flags & CARD_SD) {
+            DBG_ASSERT(pReq != NULL);
+            DBG_PRINT(SDDBG_TRACE, ("Getting SCR from SD Card..\n"));
+                /* read SCR (requires data transfer) to get supported modes */
+            status = _IssueBusRequestBd(pHcd,ACMD51,0,
+                                        SDREQ_FLAGS_RESP_R1 | SDREQ_FLAGS_APP_CMD |
+                                        SDREQ_FLAGS_DATA_TRANS,
+                                        pReq,&scrRegister,SD_SCR_BYTES);
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_WARN, ("SD card does not have SCR. \n"));
+                if (!spiMode) {
+                        /* switch it to 1 bit mode */
+                    SDCONFIG_SET_BUS_WIDTH(pBusMode->BusModeFlags, SDCONFIG_BUS_WIDTH_1_BIT);
+                }
+                status = SDIO_STATUS_SUCCESS;
+            } else {
+                    /* we have to reorder this buffer since the SCR is sent MSB first on the data
+                     * data bus */
+                ReorderBuffer(scrRegister,SD_SCR_BYTES);
+                    /* got the SCR */
+                DBG_PRINT(SDDBG_TRACE, ("SD SCR StructRev:0x%X, Flags:0x%X \n",
+                        GET_SD_SCR_STRUCT_VER(scrRegister),
+                        GET_SD_SCR_BUSWIDTHS_FLAGS(scrRegister)));
+                    /* set the revision */
+                switch (GET_SD_SCR_SDSPEC_VER(scrRegister)) {
+                    case SCR_SD_SPEC_1_00:
+                        DBG_PRINT(SDDBG_TRACE, ("SD Spec Revision 1.01 \n"));
+                        pHcd->CardProperties.SD_MMC_Revision = SD_REVISION_1_01;
+                        break;
+                    case SCR_SD_SPEC_1_10:
+                        DBG_PRINT(SDDBG_TRACE, ("SD Spec Revision 1.10 \n"));
+                        pHcd->CardProperties.SD_MMC_Revision = SD_REVISION_1_10;
+                        break;
+                    default:
+                        DBG_PRINT(SDDBG_WARN, ("SD Spec Revision is greater than 1.10 \n"));
+                        pHcd->CardProperties.SD_MMC_Revision = SD_REVISION_1_10;
+                        break;
+                }
+
+                if (!(GET_SD_SCR_BUSWIDTHS(scrRegister) & SCR_BUS_SUPPORTS_4_BIT)) {
+                    if (!spiMode) {
+                        DBG_PRINT(SDDBG_WARN, ("SD SCR reports 1bit only Mode \n"));
+                            /* switch it to 1 bit mode */
+                        SDCONFIG_SET_BUS_WIDTH(pBusMode->BusModeFlags, SDCONFIG_BUS_WIDTH_1_BIT);
+                    }
+                }
+            }
+        }
+
+        if (pHcd->CardProperties.Flags & (CARD_SD | CARD_MMC)) {
+            DBG_ASSERT(pReq != NULL);
+                /* de-select the card in order to get the CSD */
+            status = SelectDeselectCard(pHcd,FALSE);
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to deselect card before getting CSD \n"));
+                break;
+            }
+                /* Get CSD for SD or MMC cards */
+            if (spiMode) {
+                    /* in SPI mode, getting the CSD requires a read data transfer */
+                status = _IssueBusRequestBd(pHcd,CMD9,0,
+                                            SDREQ_FLAGS_RESP_R1 | SDREQ_FLAGS_DATA_TRANS,
+                                            pReq,
+                                            pHcd->CardProperties.CardCSD,
+                                            MAX_CSD_CID_BYTES);
+                if (SDIO_SUCCESS(status)) {
+                        /* when the CSD is sent over in SPI data mode, it comes to us in MSB first
+                         * and thus is not ordered correctly as defined in the SD spec */
+                    ReorderBuffer(pHcd->CardProperties.CardCSD,MAX_CSD_CID_BYTES);
+                }
+            } else {
+                status = _IssueSimpleBusRequest(pHcd,
+                                                CMD9,
+                                                (pHcd->CardProperties.RCA << 16),
+                                                SDREQ_FLAGS_RESP_R2,
+                                                pReq);
+                if (SDIO_SUCCESS(status)) {
+                        /* save the CSD */
+                    memcpy(pHcd->CardProperties.CardCSD,pReq->Response,MAX_CARD_RESPONSE_BYTES);
+                }
+            }
+
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to get CSD, Err:%d \n",
+                                        status));
+                break;
+            }
+                /* for MMC cards, the spec version is in the CSD */
+            if (pHcd->CardProperties.Flags & CARD_MMC) {
+                DBG_PRINT(SDDBG_TRACE, ("MMC Spec version : (0x%2.2X) \n",
+                            GET_MMC_SPEC_VERSION(pHcd->CardProperties.CardCSD)));
+                switch (GET_MMC_SPEC_VERSION(pHcd->CardProperties.CardCSD)) {
+                    case MMC_SPEC_1_0_TO_1_2:
+                    case MMC_SPEC_1_4:
+                    case MMC_SPEC_2_0_TO_2_2:
+                        DBG_PRINT(SDDBG_WARN, ("MMC Spec version less than 3.1 \n"));
+                        pHcd->CardProperties.SD_MMC_Revision = MMC_REVISION_1_0_2_2;
+                        break;
+                    case MMC_SPEC_3_1:
+                        DBG_PRINT(SDDBG_TRACE, ("MMC Spec version 3.1 \n"));
+                        pHcd->CardProperties.SD_MMC_Revision = MMC_REVISION_3_1;
+                        break;
+                    case MMC_SPEC_4_0_TO_4_1:
+                        DBG_PRINT(SDDBG_TRACE, ("MMC Spec version 4.0-4.1 \n"));
+                        pHcd->CardProperties.SD_MMC_Revision = MMC_REVISION_4_0;
+                        break;
+                    default:
+                        pHcd->CardProperties.SD_MMC_Revision = MMC_REVISION_3_1;
+                        DBG_PRINT(SDDBG_WARN, ("MMC Spec version greater than 4.1\n"));
+                        break;
+                }
+            }
+                /* re-select the card  */
+            status = SelectDeselectCard(pHcd,TRUE);
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to re-select card after getting CSD \n"));
+                break;
+            }
+        }
+
+        if ((pHcd->CardProperties.Flags & CARD_SD) &&
+            !(pHcd->CardProperties.Flags & CARD_SDIO) &&
+             SDDEVICE_IS_SD_REV_GTEQ_1_10(pHcd->pPseudoDev) &&
+             (pHcd->Attributes & SDHCD_ATTRIB_SD_HIGH_SPEED) &&
+             !spiMode)  {
+            UINT32 arg;
+            PUINT8 pSwitchStatusBlock = KernelAlloc(SD_SWITCH_FUNC_STATUS_BLOCK_BYTES);
+
+            if (NULL == pSwitchStatusBlock) {
+                status = SDIO_STATUS_NO_RESOURCES;
+                break;
+            }
+
+            arg = SD_SWITCH_FUNC_ARG_GROUP_CHECK(SD_SWITCH_HIGH_SPEED_GROUP,
+                                                 SD_SWITCH_HIGH_SPEED_FUNC_NO);
+
+                /* for 1.10 SD cards, check if high speed mode is supported */
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Checking SD Card for switchable functions (CMD6 arg:0x%X)\n",arg));
+
+                /* issue simple data transfer request to read the switch status */
+            status = _IssueBusRequestBd(pHcd,
+                                        CMD6,
+                                        arg,
+                                        SDREQ_FLAGS_RESP_R1 | SDREQ_FLAGS_DATA_TRANS,
+                                        pReq,
+                                        pSwitchStatusBlock,
+                                        SD_SWITCH_FUNC_STATUS_BLOCK_BYTES);
+
+            if (SDIO_SUCCESS(status)) {
+                UINT16 switchGroupMask;
+                    /* need to reorder this since cards send this MSB first */
+                ReorderBuffer(pSwitchStatusBlock,SD_SWITCH_FUNC_STATUS_BLOCK_BYTES);
+                switchGroupMask = SD_SWITCH_FUNC_STATUS_GET_GRP_BIT_MASK(pSwitchStatusBlock,SD_SWITCH_HIGH_SPEED_GROUP);
+                DBG_PRINT(SDDBG_TRACE, ("SD Card Switch Status Group1 Mask:0x%X Max Current:%d\n",
+                        switchGroupMask, SD_SWITCH_FUNC_STATUS_GET_MAX_CURRENT(pSwitchStatusBlock) ));
+                if (SD_SWITCH_FUNC_STATUS_GET_MAX_CURRENT(pSwitchStatusBlock) == 0) {
+                    DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: SD Switch Status block has zero max current \n"));
+                    SDLIB_PrintBuffer(pSwitchStatusBlock,
+                                      SD_SWITCH_FUNC_STATUS_BLOCK_BYTES,
+                                      "SDIO Bus Driver: SD Switch Status Block Error");
+                } else {
+                        /* check HS support */
+                    if (switchGroupMask & (1 << SD_SWITCH_HIGH_SPEED_FUNC_NO)) {
+                        DBG_PRINT(SDDBG_TRACE, ("SD Card Supports High Speed Mode\n"));
+                            /* set the rate, this will override the CSD value */
+                        cardReportedRate = SD_HS_MAX_BUS_CLOCK;
+                        pBusMode->BusModeFlags |= SDCONFIG_BUS_MODE_SD_HS;
+                    }
+                }
+            } else {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to get SD Switch Status block (%d)\n", status));
+                    /* just fall through, we'll handle this like a normal SD card */
+                status = SDIO_STATUS_SUCCESS;
+            }
+
+            KernelFree(pSwitchStatusBlock);
+        }
+
+        if ((pHcd->CardProperties.Flags & CARD_MMC) &&
+             SDDEVICE_IS_MMC_REV_GTEQ_4_0(pHcd->pPseudoDev) &&
+             (pHcd->Attributes & SDHCD_ATTRIB_MMC_HIGH_SPEED) &&
+             !spiMode)  {
+                /* for MMC cards, get the Extended CSD to get the High speed and
+                 * wide bus paramaters */
+
+            PUINT8 pExtData = KernelAlloc(MMC_EXT_CSD_SIZE);
+
+            if (NULL == pExtData) {
+                status = SDIO_STATUS_NO_RESOURCES;
+                break;
+            }
+                /* issue simple data transfer request to read the extended CSD */
+            status = _IssueBusRequestBd(pHcd,MMC_CMD8,0,
+                                        SDREQ_FLAGS_RESP_R1 | SDREQ_FLAGS_DATA_TRANS,
+                                        pReq,
+                                        pExtData,
+                                        MMC_EXT_CSD_SIZE);
+            if (SDIO_SUCCESS(status)) {
+                 DBG_PRINT(SDDBG_TRACE, ("MMC Ext CSD Version: 0x%X Card Type: 0x%X\n",
+                        pExtData[MMC_EXT_VER_OFFSET],pExtData[MMC_EXT_CARD_TYPE_OFFSET]));
+                    /* check HS support */
+                if (pExtData[MMC_EXT_CARD_TYPE_OFFSET] & MMC_EXT_CARD_TYPE_HS_52) {
+                        /* try 52 Mhz */
+                    cardReportedRate = 52000000;
+                    pBusMode->BusModeFlags |= SDCONFIG_BUS_MODE_MMC_HS;
+                } else if (pExtData[MMC_EXT_CARD_TYPE_OFFSET] & MMC_EXT_CARD_TYPE_HS_26) {
+                        /* try 26MHZ */
+                    cardReportedRate = 26000000;
+                    pBusMode->BusModeFlags |= SDCONFIG_BUS_MODE_MMC_HS;
+                } else {
+                        /* doesn't report high speed capable */
+                    cardReportedRate = 0;
+                }
+
+                if (cardReportedRate && !spiMode) {
+                        /* figure out the bus mode */
+                    if (pHcd->Attributes & SDHCD_ATTRIB_BUS_MMC8BIT) {
+                        SDCONFIG_SET_BUS_WIDTH(pBusMode->BusModeFlags, SDCONFIG_BUS_WIDTH_MMC8_BIT);
+                    } else if (pHcd->Attributes & SDHCD_ATTRIB_BUS_4BIT) {
+                        SDCONFIG_SET_BUS_WIDTH(pBusMode->BusModeFlags, SDCONFIG_BUS_WIDTH_4_BIT);
+                    } else {
+                        /* we leave it to default to 1 bit mode */
+                    }
+                }
+            } else {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to get MMC Extended CSD \n"));
+                    /* just fall through, we'll do without the extended information
+                     * and run it like a legacy MMC card */
+                status = SDIO_STATUS_SUCCESS;
+            }
+
+            KernelFree(pExtData);
+        }
+
+        if (pHcd->CardProperties.Flags & (CARD_SD | CARD_MMC)) {
+
+            if (0 == cardReportedRate) {
+                    /* extract rate from CSD only if it was not set by earlier tests */
+                cardReportedRate = ConvertEncodedTransSpeed(
+                                GET_SD_CSD_TRANS_SPEED(pHcd->CardProperties.CardCSD));
+                    /* fall through and test for zero again */
+            }
+
+            if (cardReportedRate != 0) {
+                     /* adjust clock based on what the card can handle */
+                ADJUST_OPER_CLOCK(pBusMode,cardReportedRate);
+            } else {
+                    /* something is wrong with the CSD */
+                if (DBG_GET_DEBUG_LEVEL() >= SDDBG_TRACE) {
+                    SDLIB_PrintBuffer(pHcd->CardProperties.CardCSD,
+                                      MAX_CARD_RESPONSE_BYTES,
+                                      "SDIO Bus Driver: CSD Dump");
+                }
+                    /* can't figure out the card rate, so set reasonable defaults */
+                if (pHcd->CardProperties.Flags & CARD_SD) {
+                    ADJUST_OPER_CLOCK(pBusMode,SD_MAX_BUS_CLOCK);
+                } else {
+                    ADJUST_OPER_CLOCK(pBusMode,MMC_MAX_BUS_CLOCK);
+                }
+            }
+        }
+
+            /* note, we do SDIO card "after" SD in case this is a combo card */
+        if (pHcd->CardProperties.Flags & CARD_SDIO) {
+                /* read card capabilities */
+            status = Cmd52ReadByteCommon(pHcd->pPseudoDev,
+                                         SDIO_CARD_CAPS_REG,
+                                         &pHcd->CardProperties.SDIOCaps);
+            if (!SDIO_SUCCESS(status)) {
+                break;
+            }
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Card Caps: 0x%X \n",pHcd->CardProperties.SDIOCaps));
+            if (pHcd->CardProperties.SDIOCaps & SDIO_CAPS_LOW_SPEED) {
+                    /* adjust max clock for LS device */
+                ADJUST_OPER_CLOCK(pBusMode,SDIO_LOW_SPEED_MAX_BUS_CLOCK);
+                    /* adjust bus if LS device does not support 4 bit mode */
+                if (!(pHcd->CardProperties.SDIOCaps & SDIO_CAPS_4BIT_LS)) {
+                    if (!spiMode) {
+                            /* low speed device does not support 4 bit mode, force us to 1 bit */
+                        SDCONFIG_SET_BUS_WIDTH(pBusMode->BusModeFlags,
+                                               SDCONFIG_BUS_WIDTH_1_BIT);
+                    }
+                }
+            }
+
+                /* check if 1.2 card supports high speed mode, checking HCD as well*/
+            if (SDDEVICE_IS_SDIO_REV_GTEQ_1_20(pHcd->pPseudoDev) &&
+                (pHcd->Attributes & SDHCD_ATTRIB_SD_HIGH_SPEED) &&
+                !spiMode) {
+                UCHAR hsControl = 0;
+
+                status = Cmd52ReadByteCommon(pHcd->pPseudoDev,
+                                             SDIO_HS_CONTROL_REG,
+                                             &hsControl);
+
+                if (!SDIO_SUCCESS(status)) {
+                    DBG_PRINT(SDDBG_TRACE,
+                        ("SDIO Failed to read high speed control (%d) \n",status));
+                        /* reset status and continue */
+                    status = SDIO_STATUS_SUCCESS;
+                } else {
+                    if (hsControl & SDIO_HS_CONTROL_SHS) {
+                        DBG_PRINT(SDDBG_TRACE, ("SDIO Card Supports High Speed Mode\n"));
+                        pBusMode->BusModeFlags |= SDCONFIG_BUS_MODE_SD_HS;
+                    }
+                }
+
+            }
+
+            cardReportedRate = 0;
+            temp = sizeof(func0ext);
+            tplAddr = pHcd->CardProperties.CommonCISPtr;
+                /* get the FUNCE tuple */
+            status = SDLIB_FindTuple(pHcd->pPseudoDev,
+                                     CISTPL_FUNCE,
+                                     &tplAddr,
+                                     (PUINT8)&func0ext,
+                                     &temp);
+            if (!SDIO_SUCCESS(status) || (temp < sizeof(func0ext))) {
+                DBG_PRINT(SDDBG_WARN, ("SDIO Function 0 Ext. Tuple Missing (Got size:%d) \n", temp));
+                    /* reset status */
+                status = SDIO_STATUS_SUCCESS;
+            } else {
+                    /* convert encoded value to rate */
+                cardReportedRate = ConvertEncodedTransSpeed(func0ext.MaxTransSpeed);
+            }
+
+            if (cardReportedRate != 0) {
+                if (pBusMode->BusModeFlags & SDCONFIG_BUS_MODE_SD_HS) {
+                    if (cardReportedRate <= SD_MAX_BUS_CLOCK) {
+                        DBG_PRINT(SDDBG_WARN,
+                            ("SDIO Function tuple reports clock:%d Hz, with advertised High Speed support \n", cardReportedRate));
+                            /* back off high speed support */
+                        pBusMode->BusModeFlags &= ~SDCONFIG_BUS_MODE_SD_HS;
+                    }
+                } else {
+                    if (cardReportedRate > SD_MAX_BUS_CLOCK) {
+                        DBG_PRINT(SDDBG_WARN,
+                            ("SDIO Function tuple reports clock:%d Hz, without advertising High Speed support..using 25Mhz \n", cardReportedRate));
+                        cardReportedRate = SD_MAX_BUS_CLOCK;
+                    }
+                }
+                    /* adjust clock based on what the card can handle */
+                ADJUST_OPER_CLOCK(pBusMode,cardReportedRate);
+
+            } else {
+                    /* set a reasonable default */
+                ADJUST_OPER_CLOCK(pBusMode,SD_MAX_BUS_CLOCK);
+            }
+        }
+    } while (FALSE);
+
+    if (pReq != NULL) {
+        FreeRequest(pReq);
+    }
+    return status;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  SetOperationalBusMode - set operational bus mode
+  Input:  pDevice - pDevice that is requesting the change
+          pBusMode - operational bus mode
+  Output: pBusMode - on return will have the actual clock rate set
+  Return: status
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS SetOperationalBusMode(PSDDEVICE                pDevice,
+                                  PSDCONFIG_BUS_MODE_DATA  pBusMode)
+{
+    SDIO_STATUS     status = SDIO_STATUS_SUCCESS;
+    UCHAR           regData;
+    UINT32          arg;
+    UINT32          switcharg;
+    PSDHCD          pHcd = pDevice->pHcd;
+
+    /* synchronize access for updating bus mode settings */
+    status = SemaphorePendInterruptable(&pDevice->pHcd->ConfigureOpsSem);
+    if (!SDIO_SUCCESS(status)) {
+        return status;
+    }
+
+    do {
+
+        if (!IS_CARD_PRESENT(pHcd)) {
+                /* for an empty slot (a Pseudo dev was passed in) we still allow the
+                 * bus mode to be set for the card detect
+                 * polling */
+            status = _IssueConfig(pHcd,SDCONFIG_BUS_MODE_CTRL,pBusMode,sizeof(SDCONFIG_BUS_MODE_DATA));
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to set bus mode in hcd : Err:%d \n",
+                                        status));
+            }
+                /* nothing more to do */
+            break;
+        }
+
+
+        if ((pBusMode->BusModeFlags == SDDEVICE_GET_BUSMODE_FLAGS(pDevice)) &&
+            (pBusMode->ClockRate == SDDEVICE_GET_OPER_CLOCK(pDevice))) {
+            DBG_PRINT(SDDBG_TRACE,
+               ("SDIO Bus Driver: Bus mode already set, nothing to do\n"));
+            pBusMode->ActualClockRate = SDDEVICE_GET_OPER_CLOCK(pDevice);
+            break;
+        }
+
+        if (pBusMode->BusModeFlags & SDCONFIG_BUS_MODE_MMC_HS) {
+            if (!(pHcd->Attributes & SDHCD_ATTRIB_MMC_HIGH_SPEED)) {
+                status = SDIO_STATUS_INVALID_PARAMETER;
+                DBG_PRINT(SDDBG_ERROR,
+                        ("SDIO Bus Driver: HCD does not support MMC High Speed\n"));
+                break;
+            }
+        }
+
+        if (pBusMode->BusModeFlags & SDCONFIG_BUS_MODE_SD_HS) {
+            if (!(pHcd->Attributes & SDHCD_ATTRIB_SD_HIGH_SPEED)) {
+                status = SDIO_STATUS_INVALID_PARAMETER;
+                DBG_PRINT(SDDBG_ERROR,
+                        ("SDIO Bus Driver: HCD does not support SD High Speed\n"));
+                break;
+            }
+        }
+
+            /* before we set the operational clock and mode, configure the clock for high
+             * speed mode on the card , if necessary */
+        if ((pHcd->CardProperties.Flags & CARD_MMC) &&
+            (pBusMode->BusModeFlags & SDCONFIG_BUS_MODE_MMC_HS) &&
+            !(SDDEVICE_GET_BUSMODE_FLAGS(pDevice) & SDCONFIG_BUS_MODE_MMC_HS)) {
+
+            switcharg = MMC_SWITCH_BUILD_ARG(MMC_SWITCH_CMD_SET0,
+                                             MMC_SWITCH_WRITE_BYTE,
+                                             MMC_EXT_HS_TIMING_OFFSET,
+                                             MMC_EXT_HS_TIMING_ENABLE);
+            status = _IssueSimpleBusRequest(pHcd,
+                                            MMC_CMD_SWITCH,
+                                            switcharg,
+                                            SDREQ_FLAGS_RESP_R1B,
+                                            NULL);
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_ERROR,
+                 ("SDIO Bus Driver: Failed to switch MMC High Speed Mode (arg:0x%X): %d \n",
+                                        switcharg, status));
+                break;
+            }
+
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: High Speed MMC enabled (arg:0x%X)\n",
+                switcharg));
+        }
+
+            /* before setting bus mode and clock in the HCD, switch card to high speed mode
+             * if necessary */
+        if ((pHcd->CardProperties.Flags & CARD_SD) &&
+            (pBusMode->BusModeFlags & SDCONFIG_BUS_MODE_SD_HS) &&
+            !(SDDEVICE_GET_BUSMODE_FLAGS(pDevice) & SDCONFIG_BUS_MODE_SD_HS)) {
+            UINT32     arg;
+            PUINT8     pSwitchStatusBlock;
+
+            pSwitchStatusBlock = KernelAlloc(SD_SWITCH_FUNC_STATUS_BLOCK_BYTES);
+
+            if (NULL == pSwitchStatusBlock) {
+                status = SDIO_STATUS_NO_RESOURCES;
+                break;
+            }
+
+                /* set high speed group */
+            arg = SD_SWITCH_FUNC_ARG_GROUP_SET(SD_SWITCH_HIGH_SPEED_GROUP,
+                                               SD_SWITCH_HIGH_SPEED_FUNC_NO);
+
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Setting SD Card for High Speed mode (CMD6 arg:0x%X)\n",arg));
+
+                /* issue simple data transfer request to switch modes */
+            status = _IssueBusRequestBd(pHcd,
+                                        CMD6,
+                                        arg,
+                                        SDREQ_FLAGS_RESP_R1 | SDREQ_FLAGS_DATA_TRANS,
+                                        NULL,
+                                        pSwitchStatusBlock,
+                                        SD_SWITCH_FUNC_STATUS_BLOCK_BYTES);
+
+            if (SDIO_SUCCESS(status)) {
+                ReorderBuffer(pSwitchStatusBlock,SD_SWITCH_FUNC_STATUS_BLOCK_BYTES);
+                DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: SD High Speed Result, Got Max Current:%d mA, SwitchResult:0x%X \n",
+                      SD_SWITCH_FUNC_STATUS_GET_MAX_CURRENT(pSwitchStatusBlock),
+                      SDSwitchGetSwitchResult(pSwitchStatusBlock, SD_SWITCH_HIGH_SPEED_GROUP)));
+                if (SD_SWITCH_FUNC_STATUS_GET_MAX_CURRENT(pSwitchStatusBlock) == 0) {
+                    DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Error in Status Block after High Speed Switch (current==0) \n"));
+                    status = SDIO_STATUS_DEVICE_ERROR;
+                }
+                if (SDSwitchGetSwitchResult(pSwitchStatusBlock, SD_SWITCH_HIGH_SPEED_GROUP) !=
+                    SD_SWITCH_HIGH_SPEED_FUNC_NO) {
+                    DBG_PRINT(SDDBG_ERROR,
+                        ("SDIO Bus Driver: Error in Status Block after High Speed Switch (Group1 did not switch) \n"));
+                    status = SDIO_STATUS_DEVICE_ERROR;
+                }
+                if (SDIO_SUCCESS(status)) {
+                    DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: SD High Speed Mode Enabled \n"));
+                } else {
+                    SDLIB_PrintBuffer(pSwitchStatusBlock,
+                                      SD_SWITCH_FUNC_STATUS_BLOCK_BYTES,
+                                       "SDIO Bus Driver: SD Switch Status Block Error");
+                }
+            } else {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to Set SD High Speed Mode (%d) \n",status));
+            }
+            KernelFree(pSwitchStatusBlock);
+
+            if (!SDIO_SUCCESS(status)) {
+                break;
+            }
+        }
+
+            /* enable/disable high speed mode for SDIO card */
+        if (pHcd->CardProperties.Flags & CARD_SDIO) {
+            BOOL doSet = TRUE;
+
+            if ((pBusMode->BusModeFlags & SDCONFIG_BUS_MODE_SD_HS) &&
+                !(SDDEVICE_GET_BUSMODE_FLAGS(pDevice) & SDCONFIG_BUS_MODE_SD_HS)) {
+                    /* enable */
+                regData = SDIO_HS_CONTROL_EHS;
+            } else if (!(pBusMode->BusModeFlags & SDCONFIG_BUS_MODE_SD_HS) &&
+                       (SDDEVICE_GET_BUSMODE_FLAGS(pDevice) & SDCONFIG_BUS_MODE_SD_HS)) {
+                    /* disable */
+                regData = 0;
+            } else {
+                    /* do nothing */
+                doSet = FALSE;
+            }
+
+            if (doSet) {
+                status = Cmd52WriteByteCommon(pDevice,
+                                              SDIO_HS_CONTROL_REG,
+                                              &regData);
+
+                if (!SDIO_SUCCESS(status)) {
+                    DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to %s HS mode in SDIO card : Err:%d\n",
+                                            (SDIO_HS_CONTROL_EHS == regData) ? "enable":"disable" , status));
+                    break;
+                } else {
+                    DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver:SDIO Card %s for High Speed mode \n",
+                                    (SDIO_HS_CONTROL_EHS == regData) ? "enabled":"disabled" ));
+                }
+            }
+        }
+
+            /* use synchronize-with-bus request version, this may have been requested by a
+             * function driver */
+        status = SDLIB_IssueConfig(pDevice,
+                                   SDCONFIG_BUS_MODE_CTRL,
+                                   pBusMode,
+                                   sizeof(SDCONFIG_BUS_MODE_DATA));
+
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to set bus mode in hcd : Err:%d \n",
+                                    status));
+            break;
+        }
+
+             /* check requested bus width against the current mode */
+        if (SDCONFIG_GET_BUSWIDTH(pBusMode->BusModeFlags) ==
+                SDCONFIG_GET_BUSWIDTH(pHcd->CardProperties.BusMode)) {
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Bus mode set, no width change\n"));
+            break;
+        }
+
+        if (SDCONFIG_GET_BUSWIDTH(pBusMode->BusModeFlags) == SDCONFIG_BUS_WIDTH_SPI) {
+                /* nothing more to do for SPI */
+            break;
+        }
+
+            /* set the bus width for SD and combo cards */
+        if (pHcd->CardProperties.Flags & CARD_SD) {
+            if (SDCONFIG_GET_BUSWIDTH(pBusMode->BusModeFlags) == SDCONFIG_BUS_WIDTH_4_BIT) {
+                    /* turn off card detect resistor */
+                status = _IssueSimpleBusRequest(pHcd,
+                                                ACMD42,
+                                                0, /* disable CD */
+                                                SDREQ_FLAGS_APP_CMD | SDREQ_FLAGS_RESP_R1,
+                                                NULL);
+                if (!SDIO_SUCCESS(status)) {
+                    DBG_PRINT(SDDBG_WARN, ("SDIO Bus Driver: Failed to disable CD Res: %d \n",
+                                           status)); /* this should be okay */
+                }
+                arg = SD_ACMD6_BUS_WIDTH_4_BIT;
+            } else {
+                    /* don't need to turn off CD in 1 bit mode, just set mode */
+                arg = SD_ACMD6_BUS_WIDTH_1_BIT;
+
+            }
+                /* set the bus width */
+            status = _IssueSimpleBusRequest(pHcd,
+                                            ACMD6,
+                                            arg, /* set bus mode */
+                                            SDREQ_FLAGS_APP_CMD | SDREQ_FLAGS_RESP_R1,
+                                            NULL);
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to set bus width: %d \n",
+                                        status));
+                break;
+            }
+        }
+            /* set bus width for SDIO cards */
+        if (pHcd->CardProperties.Flags & CARD_SDIO) {
+                /* default */
+            regData = CARD_DETECT_DISABLE | SDIO_BUS_WIDTH_1_BIT;
+
+            if (SDCONFIG_GET_BUSWIDTH(pBusMode->BusModeFlags) == SDCONFIG_BUS_WIDTH_4_BIT) {
+                    /* turn off card detect resistor and set buswidth */
+                regData = CARD_DETECT_DISABLE | SDIO_BUS_WIDTH_4_BIT;
+                DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Enabling 4 bit mode on card \n"));
+            } else {
+                DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Enabling 1 bit mode on card \n"));
+            }
+            status = Cmd52WriteByteCommon(pDevice,
+                                          SDIO_BUS_IF_REG,
+                                          &regData);
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to set bus mode in Card : Err:%d\n",
+                                        status));
+                break;
+            }
+
+                /* check for 4-bit interrupt detect mode */
+            if ((SDCONFIG_GET_BUSWIDTH(pBusMode->BusModeFlags) == SDCONFIG_BUS_WIDTH_4_BIT) &&
+                (pHcd->CardProperties.SDIOCaps & SDIO_CAPS_INT_MULTI_BLK) &&
+                (pHcd->Attributes & SDHCD_ATTRIB_MULTI_BLK_IRQ)) {
+                    /* enable interrupts between blocks, this doesn't actually turn on interrupts
+                     * it merely allows interrupts to be asserted in the inter-block gap */
+                pHcd->CardProperties.SDIOCaps |= SDIO_CAPS_ENB_INT_MULTI_BLK;
+
+                DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: 4-Bit Multi-blk Interrupt support enabled\n"));
+            } else {
+                    /* make sure this is disabled */
+                pHcd->CardProperties.SDIOCaps &= ~SDIO_CAPS_ENB_INT_MULTI_BLK;
+            }
+
+            status = Cmd52WriteByteCommon(pDevice,
+                                          SDIO_CARD_CAPS_REG,
+                                          &pHcd->CardProperties.SDIOCaps);
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to update Card Caps register Err:%d\n",
+                                        status));
+                break;
+            }
+        }
+
+            /* set data bus width for MMC */
+        if (pHcd->CardProperties.Flags & CARD_MMC) {
+            UINT8  buswidth = 0;
+
+            if (SDCONFIG_GET_BUSWIDTH(pBusMode->BusModeFlags) == SDCONFIG_BUS_WIDTH_4_BIT) {
+                buswidth = MMC_EXT_BUS_WIDTH_4_BIT;
+            } else if (SDCONFIG_GET_BUSWIDTH(pBusMode->BusModeFlags) == SDCONFIG_BUS_WIDTH_MMC8_BIT) {
+                buswidth = MMC_EXT_BUS_WIDTH_8_BIT;
+            } else {
+                /* normal 1 bit mode .. nothing to do */
+                break;
+            }
+                /* now set the bus mode on the card */
+            switcharg = MMC_SWITCH_BUILD_ARG(MMC_SWITCH_CMD_SET0,
+                                             MMC_SWITCH_WRITE_BYTE,
+                                             MMC_EXT_BUS_WIDTH_OFFSET,
+                                             buswidth);
+
+            status = _IssueSimpleBusRequest(pHcd,
+                                            MMC_CMD_SWITCH,
+                                            switcharg,
+                                            SDREQ_FLAGS_RESP_R1B,
+                                            NULL);
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to set MMC bus width (arg:0x%X): %d \n",
+                                        switcharg, status));
+                break;
+            }
+
+            if (SDCONFIG_GET_BUSWIDTH(pBusMode->BusModeFlags) == SDCONFIG_BUS_WIDTH_4_BIT) {
+                DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: 4 bit MMC mode enabled (arg:0x%X) \n",
+                      switcharg));
+            } else if (SDCONFIG_GET_BUSWIDTH(pBusMode->BusModeFlags) == SDCONFIG_BUS_WIDTH_MMC8_BIT) {
+                DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: 8-Bit MMC mode enabled (arg:0x%X) \n",
+                      switcharg));
+            }
+        }
+
+    } while (FALSE);
+
+    if (SDIO_SUCCESS(status)) {
+            /* set the operating mode */
+        pHcd->CardProperties.BusMode = pBusMode->BusModeFlags;
+            /* set the actual clock rate */
+        pHcd->CardProperties.OperBusClock = pBusMode->ActualClockRate;
+    }
+
+    SemaphorePost(&pDevice->pHcd->ConfigureOpsSem);
+
+    return status;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  CardInitSetup - setup host for card initialization
+  Input:  pHcd - HCD object
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS CardInitSetup(PSDHCD pHcd)
+{
+    SDCONFIG_INIT_CLOCKS_DATA   initClocks;
+    SDCONFIG_BUS_MODE_DATA      busMode;
+    UINT32                      OCRvalue;
+    SDIO_STATUS                 status = SDIO_STATUS_SUCCESS;
+
+    ZERO_OBJECT(initClocks);
+    ZERO_OBJECT(busMode);
+        /* setup defaults */
+    initClocks.NumberOfClocks = SDMMC_MIN_INIT_CLOCKS;
+    busMode.ClockRate = SD_INIT_BUS_CLOCK;
+
+        /* check for SPI only */
+    if (pHcd->Attributes & SDHCD_ATTRIB_BUS_SPI) {
+            /* SPI cards startup in non-CRC mode with the exception of CMD0, the
+             * HCDs must issue CMD0 with the correct CRC , the spec shows that a
+             * CMD 0 sequence is 0x40,0x00,0x00,0x00,0x00,0x95 */
+        busMode.BusModeFlags = SDCONFIG_BUS_WIDTH_SPI | SDCONFIG_BUS_MODE_SPI_NO_CRC;
+    }
+        /* check if host supports 1 bit mode */
+        /* TODO : if host supports power switching, we can
+         * could initialize cards in SPI mode first */
+    if (pHcd->Attributes & SDHCD_ATTRIB_BUS_1BIT) {
+        busMode.BusModeFlags = SDCONFIG_BUS_WIDTH_1_BIT;
+    }
+
+        /* set initial VDD, starting at the highest allowable voltage and working
+         * our way down */
+    if (pHcd->SlotVoltageCaps & SLOT_POWER_3_3V) {
+        OCRvalue = SD_OCR_3_2_TO_3_3_VDD;
+    } else if (pHcd->SlotVoltageCaps & SLOT_POWER_3_0V) {
+        OCRvalue = SD_OCR_2_9_TO_3_0_VDD;
+    } else if (pHcd->SlotVoltageCaps & SLOT_POWER_2_8V) {
+        OCRvalue = SD_OCR_2_7_TO_2_8_VDD;
+    } else if (pHcd->SlotVoltageCaps & SLOT_POWER_2_0V) {
+        OCRvalue = SD_OCR_1_9_TO_2_0_VDD;
+    } else if (pHcd->SlotVoltageCaps & SLOT_POWER_1_8V) {
+        OCRvalue = SD_OCR_1_7_TO_1_8_VDD;
+    } else if (pHcd->SlotVoltageCaps & SLOT_POWER_1_6V) {
+        OCRvalue = SD_OCR_1_6_TO_1_7_VDD;
+    } else {
+        DBG_ASSERT(FALSE);
+        OCRvalue = 0;
+    }
+
+    do {
+            /* power up the card */
+        status = AdjustSlotPower(pHcd, &OCRvalue);
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to adjust slot power \n"));
+            break;
+        }
+        status = SetOperationalBusMode(pHcd->pPseudoDev,&busMode);
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to set bus mode \n"));
+            break;
+        }
+        status = _IssueConfig(pHcd,SDCONFIG_SEND_INIT_CLOCKS,&initClocks,sizeof(initClocks));
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to send init clocks in hcd \n"));
+            break;
+        }
+
+    } while(FALSE);
+
+    return status;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  SDInitializeCard - initialize card
+  Input:  pHcd - HCD object
+  Output: pProperties - card properties
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS SDInitializeCard(PSDHCD pHcd)
+{
+    SDCONFIG_BUS_MODE_DATA      busMode;
+    SDIO_STATUS                 status = SDIO_STATUS_SUCCESS;
+    PSDREQUEST                  pReq = NULL;
+    UINT32                      OCRvalue;
+    UINT32                      tplAddr;
+    UINT8                       temp;
+    struct SDIO_MANFID_TPL      manfid;
+    SDCONFIG_WP_VALUE           wpValue;
+    UINT8                       cisBuffer[3];
+
+    OCRvalue = 0;
+
+    do {
+        if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Initializing card in SPI mode \n"));
+        } else {
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Initializing card in MMC/SD mode \n"));
+        }
+
+        pReq = AllocateRequest();
+        if (NULL == pReq) {
+            status = SDIO_STATUS_NO_RESOURCES;
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: failed to allocate bus request \n"));
+            break;
+        }
+        memset(pReq, 0, sizeof(SDREQUEST));
+
+        status = CardInitSetup(pHcd);
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to setup card \n"));
+            break;
+        }
+        status = _IssueConfig(pHcd,SDCONFIG_GET_WP,&wpValue,sizeof(wpValue));
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_WARN, ("SDIO Bus Driver: host doesn't support Write Protect \n"));
+        } else {
+            if (wpValue) {
+                pHcd->CardProperties.Flags |= CARD_SD_WP;
+                DBG_PRINT(SDDBG_WARN, ("SDIO Bus Driver: SD WP switch is on \n"));
+            }
+        }
+
+        if (!(pHcd->Attributes & SDHCD_ATTRIB_SLOT_POLLING) &&
+            IS_HCD_BUS_MODE_SPI(pHcd)) {
+                /* for non-slot polling HCDs operating in SPI mode
+                 * issue CMD0 to reset card state and to place the card
+                 * in SPI mode.  If slot polling is used, the polling thread
+                 * will have already issued a CMD0 to place the card in SPI mode*/
+            if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+                INT ii = 256;
+                status = SDIO_STATUS_ERROR;
+                /* if the CMD0 fails, retry it. Some cards have a hard time getting into SPI mode.*/
+                while ((!SDIO_SUCCESS(status)) && (ii-- >= 0)) {
+                    status = _IssueSimpleBusRequest(pHcd,CMD0,0,SDREQ_FLAGS_RESP_R1,pReq);
+                    OSSleep(20);
+                }
+                DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: cmd0 go SPI retries:(256) %d\n", ii));
+
+            } else {
+                status = _IssueSimpleBusRequest(pHcd,CMD0,0,SDREQ_FLAGS_NO_RESP,pReq);
+            }
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: go-idle failed! \n"));
+                break;
+            }
+        }
+
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Looking for SDIO.. \n"));
+            /* check for SDIO card by trying to read it's OCR */
+        status = ReadOCR(pHcd,CARD_SDIO,pReq,0,&OCRvalue);
+        if (SDIO_SUCCESS(status)) {
+                /* we got a response, this is an SDIO card */
+            if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+                    /* handle SPI */
+                pHcd->CardProperties.IOFnCount = SPI_SDIO_R4_GET_IO_FUNC_COUNT(pReq->Response);
+                if (SPI_SDIO_R4_IS_MEMORY_PRESENT(pReq->Response)) {
+                        /* flag an SD function exists */
+                    pHcd->CardProperties.Flags |= CARD_SD;
+                }
+            } else {
+                    /* handle native SD */
+                pHcd->CardProperties.IOFnCount = SD_SDIO_R4_GET_IO_FUNC_COUNT(pReq->Response);
+                if (SD_SDIO_R4_IS_MEMORY_PRESENT(pReq->Response)) {
+                        /* flag an SD function exists */
+                    pHcd->CardProperties.Flags |= CARD_SD;
+                }
+
+            }
+            if (0 == pHcd->CardProperties.IOFnCount) {
+                DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: SDIO Card reports no functions \n"));
+                status = SDIO_STATUS_DEVICE_ERROR;
+                pHcd->CardProperties.Flags = 0;
+                break;
+            }
+            pHcd->CardProperties.Flags |= CARD_SDIO;
+
+            DBG_PRINT(SDDBG_TRACE,
+                ("SDIO Bus Driver: SDIO Card, Functions: %d Card Info Flags:0x%X OCR:0x%8.8X\n",
+                      pHcd->CardProperties.IOFnCount, pHcd->CardProperties.Flags, OCRvalue));
+                /* adjust slot power for this SDIO card */
+            status = AdjustSlotPower(pHcd, &OCRvalue);
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to set power in hcd \n"));
+                break;
+            }
+                /* poll for SDIO card ready */
+            status = PollCardReady(pHcd,OCRvalue,CARD_SDIO);
+            if (!SDIO_SUCCESS(status)) {
+                break;
+            }
+        } else if (status != SDIO_STATUS_BUS_RESP_TIMEOUT){
+                /* major error in hcd, bail */
+            break;
+        }
+
+            /* check if this is an SDIO-only card before continuing  */
+        if (!(pHcd->CardProperties.Flags & CARD_SD) && (pHcd->CardProperties.Flags & CARD_SDIO)) {
+                /* this is an SDIO card with no memory function */
+            goto prepareCard;
+        }
+
+        if (!(pHcd->CardProperties.Flags & CARD_SDIO)) {
+                /* issue go idle only if we did not find an SDIO function in our earlier test */
+            if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+                status = _IssueSimpleBusRequest(pHcd,CMD0,0,SDREQ_FLAGS_RESP_R1,pReq);
+            } else {
+                status = _IssueSimpleBusRequest(pHcd,CMD0,0,SDREQ_FLAGS_NO_RESP,pReq);
+            }
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: go-idle failed! \n"));
+                break;
+            }
+        }
+
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Looking for SD Memory.. \n"));
+            /* SD Memory Card checking */
+            /* test for present of SD card (stand-alone or combo card) */
+        status = TestPresence(pHcd, CARD_SD, pReq);
+        if (SDIO_SUCCESS(status)) {
+                /* there is an SD Card present, could be part of a combo system */
+            pHcd->CardProperties.Flags |= CARD_SD;
+            if (0 == OCRvalue) {
+                DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: SD Memory card detected. \n"));
+                    /* no OCR value on entry this is a stand-alone card, go and get it*/
+                status = ReadOCR(pHcd,CARD_SD,pReq,0,&OCRvalue);
+                if (!SDIO_SUCCESS(status) || (OCRvalue == 0)) {
+                    DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to get OCR (status:%d) \n",
+                                            status));
+                    break;
+                }
+                DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: SD Card Reports OCR:0x%8.8X \n", OCRvalue));
+                status = AdjustSlotPower(pHcd, &OCRvalue);
+                if (!SDIO_SUCCESS(status)) {
+                    DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to adjust power \n"));
+                    break;
+                }
+            } else {
+                 DBG_ASSERT((pHcd->CardProperties.Flags & (CARD_SD | CARD_SDIO)));
+                 DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: SDIO Combo Card detected \n"));
+            }
+                /* poll for SD card ready */
+            status = PollCardReady(pHcd,OCRvalue,CARD_SD);
+            if (!SDIO_SUCCESS(status)) {
+                    /* check if this card has an SDIO function */
+                if (pHcd->CardProperties.Flags & CARD_SDIO) {
+                    DBG_PRINT(SDDBG_WARN, ("SDIO Bus Driver: Combo Detected but SD memory function failed \n"));
+                        /* allow SDIO functions to load normally */
+                    status = SDIO_STATUS_SUCCESS;
+                        /* remove SD flag */
+                    pHcd->CardProperties.Flags &= ~CARD_SD;
+                } else {
+                    break;
+                }
+            } else {
+                DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: SD Memory ready. \n"));
+            }
+                /* we're done, no need to check for MMC */
+            goto prepareCard;
+        } else if (status != SDIO_STATUS_BUS_RESP_TIMEOUT){
+                /* major error in hcd, bail */
+            break;
+        }
+
+        /* MMC card checking */
+        /* if we get here, these better not be set */
+        DBG_ASSERT(!(pHcd->CardProperties.Flags & (CARD_SD | CARD_SDIO)));
+           /* issue go idle */
+        if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+            status = _IssueSimpleBusRequest(pHcd,CMD0,0,SDREQ_FLAGS_RESP_R1,pReq);
+        } else {
+            status = _IssueSimpleBusRequest(pHcd,CMD0,0,SDREQ_FLAGS_NO_RESP,pReq);
+        }
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: go-idle failed! \n"));
+            break;
+        }
+
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Looking for MMC.. \n"));
+        status = TestPresence(pHcd, CARD_MMC, pReq);
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: unknown card detected \n"));
+            break;
+        }
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: MMC Card Detected \n"));
+        pHcd->CardProperties.Flags |= CARD_MMC;
+            /* read the OCR value */
+        status = ReadOCR(pHcd,CARD_MMC,pReq,0,&OCRvalue);
+        if (!SDIO_SUCCESS(status) || (OCRvalue == 0)) {
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Failed to get OCR (status:%d)",
+                                    status));
+            break;
+        }
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: MMC Card Reports OCR:0x%8.8X \n", OCRvalue));
+            /* adjust power */
+        status = AdjustSlotPower(pHcd, &OCRvalue);
+        if (!SDIO_SUCCESS(status)) {
+             DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to adjust power \n"));
+             break;
+        }
+            /* poll for MMC card ready */
+        status = PollCardReady(pHcd,OCRvalue,CARD_MMC);
+        if (!SDIO_SUCCESS(status)) {
+            break;
+        }
+            /* fall through and prepare MMC card */
+
+prepareCard:
+            /* we're done figuring out what was inserted, and setting up
+             * optimal slot voltage, now we need to prepare the card */
+        if (!IS_HCD_BUS_MODE_SPI(pHcd) &&
+            (pHcd->CardProperties.Flags & (CARD_SD | CARD_MMC))) {
+                /* non-SPI SD or MMC cards need to be moved to the "ident" state before we can get the
+                 * RCA or select the card using the new RCA */
+            status = _IssueSimpleBusRequest(pHcd,CMD2,0,SDREQ_FLAGS_RESP_R2,pReq);
+            if (!SDIO_SUCCESS(status)){
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: failed to move SD/MMC card into ident state \n"));
+                break;
+            }
+        }
+
+        if (!IS_HCD_BUS_MODE_SPI(pHcd)) {
+                /* non-SPI mode cards need their RCA's setup */
+            if (pHcd->CardProperties.Flags & (CARD_SD | CARD_SDIO)) {
+                    /* issue CMD3 to get RCA on SD/SDIO cards */
+                status = _IssueSimpleBusRequest(pHcd,CMD3,0,SDREQ_FLAGS_RESP_R6,pReq);
+                if (!SDIO_SUCCESS(status)){
+                    DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: failed to get RCA for SD/SDIO card \n"));
+                    break;
+                }
+                pHcd->CardProperties.RCA = SD_R6_GET_RCA(pReq->Response);
+                DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: SD/SDIO RCA:0x%X \n",
+                                        pHcd->CardProperties.RCA));
+            } else if (pHcd->CardProperties.Flags & CARD_MMC) {
+                    /* for MMC cards, we have to assign a relative card address */
+                    /* just a non-zero number */
+                pHcd->CardProperties.RCA = 1;
+                    /* issue CMD3 to set the RCA for MMC cards */
+                status = _IssueSimpleBusRequest(pHcd,
+                                                CMD3,(pHcd->CardProperties.RCA << 16),
+                                                SDREQ_FLAGS_RESP_R1,pReq);
+                if (!SDIO_SUCCESS(status)){
+                    DBG_PRINT(SDDBG_ERROR,
+                            ("SDIO Bus Driver: failed to set RCA for MMC card! (err=%d) \n",status));
+                    break;
+                }
+            } else {
+                DBG_ASSERT(FALSE);
+            }
+        }
+            /* select the card in order to get the rest of the card info, applies
+             * to SDIO/SD/MMC cards*/
+        status = SelectDeselectCard(pHcd, TRUE);
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: failed to select card! \n"));
+            break;
+        }
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver, Card now Selected.. \n"));
+
+        if (pHcd->CardProperties.Flags & CARD_SDIO) {
+                /* read SDIO revision register */
+            status = Cmd52ReadByteCommon(pHcd->pPseudoDev, CCCR_SDIO_REVISION_REG, &temp);
+            if (!SDIO_SUCCESS(status)) {
+                break;
+            }
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Revision Reg: 0x%X \n", temp));
+            switch (temp & SDIO_REV_MASK) {
+                case SDIO_REV_1_00:
+                    DBG_PRINT(SDDBG_TRACE, ("SDIO Spec Revision 1.00 \n"));
+                    pHcd->CardProperties.SDIORevision = SDIO_REVISION_1_00;
+                    break;
+                case SDIO_REV_1_10:
+                    DBG_PRINT(SDDBG_TRACE, ("SDIO Spec Revision 1.10 \n"));
+                    pHcd->CardProperties.SDIORevision = SDIO_REVISION_1_10;
+                    break;
+                case SDIO_REV_1_20:
+                    DBG_PRINT(SDDBG_TRACE, ("SDIO Spec Revision 1.20 \n"));
+                    pHcd->CardProperties.SDIORevision = SDIO_REVISION_1_20;
+                    break;
+                default:
+                    DBG_PRINT(SDDBG_WARN, ("SDIO Warning: unknown SDIO revision, treating like 1.0 device \n"));
+                    pHcd->CardProperties.SDIORevision = SDIO_REVISION_1_00;
+                    break;
+            }
+                /* get the common CIS ptr */
+            status = Cmd52ReadMultipleCommon(pHcd->pPseudoDev,
+                                             SDIO_CMN_CIS_PTR_LOW_REG,
+                                             cisBuffer,
+                                             3);
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to get CIS ptr, Err:%d", status));
+                break;
+            }
+                /* this is endian-safe*/
+            pHcd->CardProperties.CommonCISPtr = ((UINT32)cisBuffer[0]) |
+                                                (((UINT32)cisBuffer[1]) << 8) |
+                                                (((UINT32)cisBuffer[2]) << 16);
+
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Card CIS Ptr: 0x%X \n", pHcd->CardProperties.CommonCISPtr));
+            temp = sizeof(manfid);
+            tplAddr = pHcd->CardProperties.CommonCISPtr;
+                /* get the MANFID tuple */
+            status = SDLIB_FindTuple(pHcd->pPseudoDev,
+                                     CISTPL_MANFID,
+                                     &tplAddr,
+                                     (PUINT8)&manfid,
+                                     &temp);
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_WARN, ("SDIO Bus Driver: Failed to get MANFID tuple err:%d \n", status));
+                status = SDIO_STATUS_SUCCESS;
+            } else {
+                    /* save this off so that it can be copied into each SDIO Func's SDDEVICE structure */
+                pHcd->CardProperties.SDIO_ManufacturerCode =
+                                        CT_LE16_TO_CPU_ENDIAN(manfid.ManufacturerCode);
+                pHcd->CardProperties.SDIO_ManufacturerID =
+                                        CT_LE16_TO_CPU_ENDIAN(manfid.ManufacturerInfo);
+                DBG_PRINT(SDDBG_TRACE, ("SDIO MANFID:0x%X, MANFINFO:0x%X \n",
+                                        pHcd->CardProperties.SDIO_ManufacturerID,
+                                        pHcd->CardProperties.SDIO_ManufacturerCode));
+            }
+
+            if (pHcd->CardProperties.SDIORevision >= SDIO_REVISION_1_10) {
+                    /* read power control */
+                status = Cmd52ReadByteCommon(pHcd->pPseudoDev, SDIO_POWER_CONTROL_REG, &temp);
+                if (SDIO_SUCCESS(status)) {
+                        /* check for power control support which indicates the card may use more
+                         * than 200 mA */
+                    if (temp & SDIO_POWER_CONTROL_SMPC) {
+                            /* check that the host can support this. */
+                        if (pHcd->MaxSlotCurrent >= SDIO_EMPC_CURRENT_THRESHOLD) {
+                            temp = SDIO_POWER_CONTROL_EMPC;
+                                /* enable power control on the card */
+                            status = Cmd52WriteByteCommon(pHcd->pPseudoDev, SDIO_POWER_CONTROL_REG, &temp);
+                            if (!SDIO_SUCCESS(status)) {
+                                DBG_PRINT(SDDBG_ERROR,
+                                        ("SDIO Busdriver: failed to enable power control (%d) \n",status));
+                                break;
+                            }
+                                /* mark that the card is high power */
+                            pHcd->CardProperties.Flags |= CARD_HIPWR;
+
+                            DBG_PRINT(SDDBG_TRACE,
+                               ("SDIO Busdriver: Power Control Enabled on SDIO (1.10 or greater) card \n"));
+                        } else {
+                            DBG_PRINT(SDDBG_WARN,
+                               ("SDIO Busdriver: Card can operate higher than 200mA, host cannot (max:%d) \n",
+                               pHcd->MaxSlotCurrent));
+                            /* this is not fatal, the card should operate at a reduced rate */
+                        }
+                    } else {
+                        DBG_PRINT(SDDBG_TRACE,
+                            ("SDIO Busdriver: SDIO 1.10 (or greater) card draws less than 200mA \n"));
+                    }
+                } else {
+                    DBG_PRINT(SDDBG_WARN,
+                            ("SDIO Busdriver: failed to get POWER CONTROL REG (%d) \n",status));
+                    /* fall through and continue on at reduced mode */
+                }
+            }
+        }
+            /* get the current bus parameters */
+        busMode.BusModeFlags = pHcd->CardProperties.BusMode;
+        busMode.ClockRate =  pHcd->CardProperties.OperBusClock;
+            /* get the rest of the bus parameters like clock and supported bus width */
+        status = GetBusParameters(pHcd,&busMode);
+        if (!SDIO_SUCCESS(status)) {
+            break;
+        }
+
+        if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+                /* check HCD if it wants to run without SPI CRC */
+            if (pHcd->Attributes & SDHCD_ATTRIB_NO_SPI_CRC) {
+                    /* hcd would rather not run with CRC we don't need to tell the card since SPI mode
+                     * cards power up with CRC initially disabled */
+                busMode.BusModeFlags |= SDCONFIG_BUS_MODE_SPI_NO_CRC;
+            } else {
+                    /* first enable SPI CRC checking if the HCD can handle it */
+                status = SDSPIModeEnableDisableCRC(pHcd->pPseudoDev, TRUE);
+                if (!SDIO_SUCCESS(status)) {
+                    DBG_PRINT(SDDBG_ERROR,
+                                ("SDIO Bus Driver: Failed to set Enable SPI CRC on card \n"));
+                    break;
+                }
+            }
+        }
+
+        status = SetOperationalBusMode(pHcd->pPseudoDev, &busMode);
+
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to set operational bus mode\n"));
+            break;
+        }
+
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Oper. Mode: Clock:%d, Bus:0x%X \n",
+                                pHcd->CardProperties.OperBusClock,pHcd->CardProperties.BusMode));
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Card in TRANS state, Ready: CardInfo Flags 0x%X \n",
+                                pHcd->CardProperties.Flags));
+
+    } while (FALSE);
+
+    if (pReq != NULL) {
+        FreeRequest(pReq);
+    }
+
+    return status;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  SDQuerySDMMCInfo - query MMC card info
+  Input:  pDevice - device
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS SDQuerySDMMCInfo(PSDDEVICE pDevice)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    PSDREQUEST  pReq = NULL;
+    UINT8       CID[MAX_CSD_CID_BYTES];
+
+    do {
+        pReq = AllocateRequest();
+        if (NULL == pReq) {
+            status = SDIO_STATUS_NO_RESOURCES;
+            break;
+        }
+            /* de-select the card */
+        status = SelectDeselectCard(pDevice->pHcd,FALSE);
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to deselect card before getting CID \n"));
+            break;
+        }
+
+        if (SDDEVICE_IS_BUSMODE_SPI(pDevice)) {
+                /* in SPI mode, getting the CSD requires a data transfer */
+            status = _IssueBusRequestBd(pDevice->pHcd,CMD10,0,
+                                        SDREQ_FLAGS_RESP_R1 | SDREQ_FLAGS_DATA_TRANS,
+                                        pReq,
+                                        CID,
+                                        MAX_CSD_CID_BYTES);
+            if (SDIO_SUCCESS(status)) {
+                    /* in SPI mode we need to reorder to the CID since SPI data comes in MSB first*/
+                ReorderBuffer(CID,MAX_CSD_CID_BYTES);
+            }
+        } else {
+                /* get the CID */
+            status = _IssueSimpleBusRequest(pDevice->pHcd,
+                                            CMD10,
+                                            (SDDEVICE_GET_CARD_RCA(pDevice) << 16),
+                                            SDREQ_FLAGS_RESP_R2,
+                                            pReq);
+            if (SDIO_SUCCESS(status)) {
+                    /* extract it from the reponse */
+                memcpy(CID,pReq->Response,MAX_CSD_CID_BYTES);
+            }
+        }
+
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_WARN, ("SDQuerySDMMCInfo: failed to get CID. \n"));
+            status = SDIO_STATUS_SUCCESS;
+        } else {
+            pDevice->pId[0].SDMMC_ManfacturerID = GET_SD_CID_MANFID(CID);
+            pDevice->pId[0].SDMMC_OEMApplicationID = GET_SD_CID_OEMID(CID);
+#ifdef DEBUG
+            {
+                char pBuf[7];
+
+                pBuf[0] = GET_SD_CID_PN_1(CID);
+                pBuf[1] = GET_SD_CID_PN_2(CID);
+                pBuf[2] = GET_SD_CID_PN_3(CID);
+                pBuf[3] = GET_SD_CID_PN_4(CID);
+                pBuf[4] = GET_SD_CID_PN_5(CID);
+                if (pDevice->pHcd->CardProperties.Flags & CARD_MMC) {
+                    pBuf[5] = GET_SD_CID_PN_6(CID);
+                    pBuf[6] = 0;
+                } else {
+                    pBuf[5] = 0;
+                }
+                DBG_PRINT(SDDBG_TRACE, ("SDQuerySDMMCInfo: Product String: %s\n", pBuf));
+            }
+#endif
+            DBG_PRINT(SDDBG_TRACE, ("SDQuerySDMMCInfo: ManfID: 0x%X, OEMID:0x%X \n",
+                       pDevice->pId[0].SDMMC_ManfacturerID, pDevice->pId[0].SDMMC_OEMApplicationID));
+        }
+            /* re-select card */
+        status = SelectDeselectCard(pDevice->pHcd,TRUE);
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to re-select card after getting CID \n"));
+            break;
+        }
+    } while (FALSE);
+
+    if (pReq != NULL) {
+        FreeRequest(pReq);
+    }
+
+    return status;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  SDQuerySDIOInfo - query SDIO card info
+  Input:  pDevice - the device
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS SDQuerySDIOInfo(PSDDEVICE pDevice)
+{
+    SDIO_STATUS     status = SDIO_STATUS_SUCCESS;
+    UINT32          faddress;
+    UINT8           fInfo;
+    UINT32          nextTpl;
+    UINT8           tplLength;
+    UINT8           cisPtrBuffer[3];
+    struct SDIO_FUNC_EXT_FUNCTION_TPL_1_1 funcTuple;
+
+        /* use the card-wide SDIO manufacturer code and ID previously read.*/
+    pDevice->pId[0].SDIO_ManufacturerCode = pDevice->pHcd->CardProperties.SDIO_ManufacturerCode;
+    pDevice->pId[0].SDIO_ManufacturerID = pDevice->pHcd->CardProperties.SDIO_ManufacturerID;
+
+        /* calculate function base address */
+    faddress = CalculateFBROffset(SDDEVICE_GET_SDIO_FUNCNO(pDevice));
+    DBG_ASSERT(faddress != 0);
+
+    do {
+        status = Cmd52ReadByteCommon(pDevice,
+                                     FBR_FUNC_INFO_REG_OFFSET(faddress),
+                                     &fInfo);
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to get function info, Err:%d , using Class:UNKNOWN\n", status));
+            fInfo = 0;
+            pDevice->pId[0].SDIO_FunctionClass = 0;
+            status = SDIO_STATUS_SUCCESS;
+        } else {
+            pDevice->pId[0].SDIO_FunctionClass = fInfo & FUNC_INFO_DEVICE_CODE_MASK;
+        }
+
+        if ((FUNC_INFO_DEVICE_CODE_LAST == pDevice->pId[0].SDIO_FunctionClass) &&
+            SDDEVICE_IS_SDIO_REV_GTEQ_1_10(pDevice)) {
+                /* if the device code is the last one, check for 1.1 revision and get the
+                 * extended code */
+            status = Cmd52ReadByteCommon(pDevice,
+                                         FBR_FUNC_EXT_DEVICE_CODE_OFFSET(faddress),
+                                         &(pDevice->pId[0].SDIO_FunctionClass));
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to get 1.1 extended DC, Err:%d\n",
+                                        status));
+                break;
+            }
+        }
+
+            /* get the function CIS ptr */
+        status = Cmd52ReadMultipleCommon(pDevice,
+                                         FBR_FUNC_CIS_LOW_OFFSET(faddress),
+                                         cisPtrBuffer,
+                                         3);
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to get FN CIS ptr, Err:%d\n", status));
+            break;
+        }
+            /* endian safe */
+        pDevice->DeviceInfo.AsSDIOInfo.FunctionCISPtr = ((UINT32)cisPtrBuffer[0]) |
+                                                        (((UINT32)cisPtrBuffer[1]) << 8) |
+                                                        (((UINT32)cisPtrBuffer[2]) << 16);
+
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Function:%d, Class:%d FnCISPtr:0x%X \n",
+                  SDDEVICE_GET_SDIO_FUNCNO(pDevice),
+                  pDevice->pId[0].SDIO_FunctionClass,pDevice->DeviceInfo.AsSDIOInfo.FunctionCISPtr));
+
+        if (fInfo & FUNC_INFO_SUPPORTS_CSA_MASK) {
+               /* get the function CSA ptr */
+            status = Cmd52ReadMultipleCommon(pDevice,
+                                             FBR_FUNC_CSA_LOW_OFFSET(faddress),
+                                             cisPtrBuffer,
+                                             3);
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to get FN CSA ptr, Err:%d \n", status));
+                break;
+            }
+                /* endian safe */
+            pDevice->DeviceInfo.AsSDIOInfo.FunctionCSAPtr = ((UINT32)cisPtrBuffer[0]) |
+                                                            (((UINT32)cisPtrBuffer[1]) << 8) |
+                                                            (((UINT32)cisPtrBuffer[2]) << 16);
+
+        }
+
+        nextTpl = SDDEVICE_GET_SDIO_FUNC_CISPTR(pDevice);
+            /* look for the funce TPL */
+        tplLength = sizeof(funcTuple);
+            /* go get the func CE tuple */
+        status = SDLIB_FindTuple(pDevice,
+                                 CISTPL_FUNCE,
+                                 &nextTpl,
+                                 (PUINT8)&funcTuple,
+                                 &tplLength);
+
+        if (!SDIO_SUCCESS(status)){
+            /* handles case of bad CIS or missing tupple, allow function driver to handle */
+            DBG_PRINT(SDDBG_WARN, ("SDIO Bus Driver: Failed to get FuncCE Tuple: %d \n", status));
+            status = SDIO_STATUS_SUCCESS;
+            break;
+        }
+            /* set the max block size */
+        pDevice->DeviceInfo.AsSDIOInfo.FunctionMaxBlockSize =
+                                CT_LE16_TO_CPU_ENDIAN(funcTuple.CommonInfo.MaxBlockSize);
+
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Function:%d, MaxBlocks:%d \n",
+                  SDDEVICE_GET_SDIO_FUNCNO(pDevice),
+                  pDevice->DeviceInfo.AsSDIOInfo.FunctionMaxBlockSize));
+
+            /* check for MANFID function tuple (SDIO 1.1 or greater) */
+        if (SDDEVICE_IS_SDIO_REV_GTEQ_1_10(pDevice)) {
+            struct SDIO_MANFID_TPL      manfid;
+            nextTpl = SDDEVICE_GET_SDIO_FUNC_CISPTR(pDevice);
+            tplLength = sizeof(manfid);
+                /* get the MANFID tuple */
+            status = SDLIB_FindTuple(pDevice,
+                                     CISTPL_MANFID,
+                                     &nextTpl,
+                                     (PUINT8)&manfid,
+                                     &tplLength);
+            if (SDIO_SUCCESS(status)) {
+                    /* this function has a MANFID tuple */
+                pDevice->pId[0].SDIO_ManufacturerCode =
+                                        CT_LE16_TO_CPU_ENDIAN(manfid.ManufacturerCode);
+                pDevice->pId[0].SDIO_ManufacturerID =
+                                        CT_LE16_TO_CPU_ENDIAN(manfid.ManufacturerInfo);
+                DBG_PRINT(SDDBG_TRACE, ("SDIO 1.1 (Function Specific) MANFID:0x%X, MANFINFO:0x%X \n",
+                                        pDevice->pId[0].SDIO_ManufacturerID,
+                                        pDevice->pId[0].SDIO_ManufacturerCode));
+            } else {
+                DBG_PRINT(SDDBG_WARN, ("SDIO 1.1, No CISTPL_MANFID Tuple in FUNC CIS \n"));
+                status = SDIO_STATUS_SUCCESS;
+            }
+        }
+    } while (FALSE);
+
+    return status;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  SDEnableFunction - enable function
+  Input:  pDevice - the device/function
+          pEnData - enable data;
+  Output:
+  Return: status
+  Notes: Note, this performs synchronous calls
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS SDEnableFunction(PSDDEVICE pDevice, PSDCONFIG_FUNC_ENABLE_DISABLE_DATA pEnData)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    UINT8       registerValue;
+    UINT8       mask;
+    FUNC_ENABLE_TIMEOUT  retry;
+
+        /* take the configure op lock to make this atomic */
+    status = SemaphorePendInterruptable(&pDevice->pHcd->ConfigureOpsSem);
+    if (!SDIO_SUCCESS(status)) {
+        return status;
+    }
+
+    status = SDIO_STATUS_INVALID_PARAMETER;
+    do {
+        if (!(pDevice->pHcd->CardProperties.Flags & CARD_SDIO)){
+                /* nothing to do if it's not an SDIO card */
+            break;
+        }
+
+        if (!((SDDEVICE_GET_SDIO_FUNCNO(pDevice) >= SDIO_FIRST_FUNCTION_NUMBER) &&
+              (SDDEVICE_GET_SDIO_FUNCNO(pDevice) <= SDIO_LAST_FUNCTION_NUMBER))){
+            DBG_ASSERT(FALSE);
+            break;
+        }
+            /* make sure there is a timeout value */
+        if (0 == pEnData->TimeOut) {
+            break;
+        }
+
+        mask = 1 << SDDEVICE_GET_SDIO_FUNCNO(pDevice);
+            /* read the enable register */
+        status = Cmd52ReadByteCommon(pDevice, SDIO_ENABLE_REG, &registerValue);
+        if (!SDIO_SUCCESS(status)){
+            break;
+        }
+        if (pEnData->EnableFlags & SDCONFIG_ENABLE_FUNC) {
+                /* set the enable register bit */
+            registerValue |= mask;
+        } else {
+               /* clear the bit */
+            registerValue &= ~mask;
+        }
+
+        DBG_PRINT(SDDBG_TRACE,
+                ("SDIO Bus Driver %s Function, Mask:0x%X Enable Reg Value:0x%2.2X\n",
+                 (pEnData->EnableFlags & SDCONFIG_ENABLE_FUNC) ? "Enabling":"Disabling",
+                 mask,
+                 registerValue));
+
+            /* write it back out */
+        status = Cmd52WriteByteCommon(pDevice, SDIO_ENABLE_REG, &registerValue);
+        if (!SDIO_SUCCESS(status)){
+            break;
+        }
+            /* now poll the ready bit until it sets or clears */
+        retry = pEnData->TimeOut;
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Function Enable/Disable Polling: %d retries \n",
+                                retry));
+        while (retry) {
+            status = Cmd52ReadByteCommon(pDevice, SDIO_READY_REG, &registerValue);
+            if (!SDIO_SUCCESS(status)){
+                break;
+            }
+            if (pEnData->EnableFlags & SDCONFIG_ENABLE_FUNC) {
+                    /* if the bit is set, the device is ready */
+                if (registerValue & mask) {
+                        /* device ready */
+                    break;
+                }
+            } else {
+                if (!(registerValue & mask)) {
+                        /* device is no longer ready */
+                    break;
+                }
+            }
+                /* sleep before trying again */
+            status = OSSleep(1);
+            if (!SDIO_SUCCESS(status)) {
+                DBG_PRINT(SDDBG_ERROR, ("OSSleep Failed! \n"));
+                break;
+            }
+            retry--;
+        }
+
+        if (0 == retry) {
+            status = SDIO_STATUS_FUNC_ENABLE_TIMEOUT;
+            break;
+        }
+
+    } while (FALSE);
+
+    SemaphorePost(&pDevice->pHcd->ConfigureOpsSem);
+    return status;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  SDAllocFreeSlotCurrent - allocate or free slot current
+  Input:  pDevice - the device/function
+          Allocate - Allocate current, else free
+          pData - slotcurrent data (non-NULL if Allocate is TRUE)
+  Output:
+  Return: status
+  Notes:  if the function returns SDIO_STATUS_NO_RESOURCES, the pData->SlotCurrent field is
+          updated with the available current
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS SDAllocFreeSlotCurrent(PSDDEVICE pDevice, BOOL Allocate, PSDCONFIG_FUNC_SLOT_CURRENT_DATA pData)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+
+    DBG_PRINT(SDDBG_TRACE, ("+SDIO Bus Driver: SDAllocFreeSlotCurrent\n"));
+
+        /* take the configure op lock to make this atomic */
+    status = SemaphorePendInterruptable(&pDevice->pHcd->ConfigureOpsSem);
+    if (!SDIO_SUCCESS(status)) {
+        return status;
+    }
+
+    status = SDIO_STATUS_INVALID_PARAMETER;
+    do {
+            /* check the current budget and allocate */
+        if (Allocate) {
+            if (0 == pData->SlotCurrent) {
+                /* caller must specify current requirement for the power mode */
+                break;
+            }
+            if (pDevice->SlotCurrentAlloc != 0) {
+               /* slot current has already been allocated, caller needs to free
+                * first */
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Slot Current Already allocated! \n"));
+                break;
+            }
+            if (((UINT32)pDevice->pHcd->SlotCurrentAllocated + (UINT32)pData->SlotCurrent) >
+                (UINT32)pDevice->pHcd->MaxSlotCurrent) {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Slot Current Budget exceeded, Requesting: %d, Allocated already: %d, Max: %d \n",
+                            pData->SlotCurrent, pDevice->pHcd->SlotCurrentAllocated,
+                            pDevice->pHcd->MaxSlotCurrent));
+                status = SDIO_STATUS_NO_RESOURCES;
+                    /* return remaining */
+                pData->SlotCurrent = pDevice->pHcd->MaxSlotCurrent -
+                                     pDevice->pHcd->SlotCurrentAllocated;
+                break;
+            }
+                /* bump up allocation */
+            pDevice->pHcd->SlotCurrentAllocated += pData->SlotCurrent;
+                /* save this off for the call to free slot current */
+            pDevice->SlotCurrentAlloc = pData->SlotCurrent;
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Slot Current Requested: %d, New Total: %d, Max: %d \n",
+                            pData->SlotCurrent, pDevice->pHcd->SlotCurrentAllocated,
+                            pDevice->pHcd->MaxSlotCurrent));
+
+        } else {
+            if (0 == pDevice->SlotCurrentAlloc) {
+                    /* no allocation */
+                break;
+            }
+                /* return the allocation back */
+            if (pDevice->SlotCurrentAlloc <= pDevice->pHcd->SlotCurrentAllocated) {
+                pDevice->pHcd->SlotCurrentAllocated -= pDevice->SlotCurrentAlloc;
+                DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Slot Current Freed: %d, New Total: %d, Max: %d \n",
+                            pDevice->SlotCurrentAlloc, pDevice->pHcd->SlotCurrentAllocated,
+                            pDevice->pHcd->MaxSlotCurrent));
+            } else {
+                DBG_ASSERT(FALSE);
+            }
+
+                /* make sure this is zeroed */
+            pDevice->SlotCurrentAlloc = 0;
+        }
+
+        status = SDIO_STATUS_SUCCESS;
+
+    } while (FALSE);
+
+    SemaphorePost(&pDevice->pHcd->ConfigureOpsSem);
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO Bus Driver: SDAllocFreeSlotCurrent, %d\n", status));
+    return status;
+}
+
+static void RawHcdIrqControl(PSDHCD pHcd, BOOL Enable)
+{
+    SDIO_STATUS status;
+    SDCONFIG_SDIO_INT_CTRL_DATA irqData;
+    CT_DECLARE_IRQ_SYNC_CONTEXT();
+
+    ZERO_OBJECT(irqData);
+
+    status = _AcquireHcdLock(pHcd);
+    if (!SDIO_SUCCESS(status)) {
+        return;
+    }
+
+    do {
+            /* for raw devices, we simply enable/disable in the HCD only */
+        if (Enable) {
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver (RAW) Unmasking Int \n"));
+            irqData.IRQDetectMode = IRQ_DETECT_RAW;
+            irqData.SlotIRQEnable = TRUE;
+        } else {
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver (RAW) Masking Int \n"));
+            irqData.SlotIRQEnable = FALSE;
+        }
+
+        status = _IssueConfig(pHcd,SDCONFIG_SDIO_INT_CTRL,
+                              (PVOID)&irqData, sizeof(irqData));
+
+        if (!SDIO_SUCCESS(status)){
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver failed to enable/disable IRQ in (RAW) hcd :%d\n",
+                                    status));
+        }
+
+    } while (FALSE);
+
+    status = _ReleaseHcdLock(pHcd);
+}
+
+static void RawHcdEnableIrqPseudoComplete(PSDREQUEST pReq)
+{
+    if (SDIO_SUCCESS(pReq->Status)) {
+        RawHcdIrqControl((PSDHCD)pReq->pCompleteContext, TRUE);
+    }
+    FreeRequest(pReq);
+}
+
+static void RawHcdDisableIrqPseudoComplete(PSDREQUEST pReq)
+{
+    RawHcdIrqControl((PSDHCD)pReq->pCompleteContext, FALSE);
+    FreeRequest(pReq);
+}
+
+static void HcdIrqControl(PSDHCD pHcd, BOOL Enable)
+{
+    SDIO_STATUS                 status;
+    SDCONFIG_SDIO_INT_CTRL_DATA irqData;
+    CT_DECLARE_IRQ_SYNC_CONTEXT();
+
+    ZERO_OBJECT(irqData);
+
+    status = _AcquireHcdLock(pHcd);
+    if (!SDIO_SUCCESS(status)) {
+        return;
+    }
+
+    do {
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: HcdIrqControl (%s), IrqsEnabled:0x%X \n",
+                        Enable ? "Enable":"Disable",pHcd->IrqsEnabled ));
+
+        if (Enable) {
+            irqData.SlotIRQEnable = TRUE;
+        } else {
+            irqData.SlotIRQEnable = FALSE;
+        }
+                /* setup HCD to enable/disable it's detection hardware */
+        if (irqData.SlotIRQEnable) {
+                /* set the IRQ detection mode */
+            switch (SDCONFIG_GET_BUSWIDTH(pHcd->CardProperties.BusMode)) {
+                case SDCONFIG_BUS_WIDTH_SPI:
+                    irqData.IRQDetectMode = IRQ_DETECT_SPI;
+                    break;
+                case SDCONFIG_BUS_WIDTH_1_BIT:
+                    irqData.IRQDetectMode = IRQ_DETECT_1_BIT;
+                    break;
+                case SDCONFIG_BUS_WIDTH_4_BIT:
+                    irqData.IRQDetectMode = IRQ_DETECT_4_BIT;
+                        /* check card and HCD for 4bit multi-block interrupt support */
+                    if ((pHcd->CardProperties.SDIOCaps & SDIO_CAPS_INT_MULTI_BLK) &&
+                        (pHcd->Attributes & SDHCD_ATTRIB_MULTI_BLK_IRQ)) {
+                            /* note: during initialization of the card, the mult-blk IRQ support
+                             * is enabled in card caps register */
+                        irqData.IRQDetectMode |= IRQ_DETECT_MULTI_BLK;
+                        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver enabling IRQ in multi-block mode:\n"));
+                    }
+                    break;
+                default:
+                    DBG_ASSERT(FALSE);
+                    break;
+            }
+
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver enabling IRQ in HCD Mode:0x%X\n",
+                                     irqData.IRQDetectMode));
+        }
+
+        status = _IssueConfig(pHcd,SDCONFIG_SDIO_INT_CTRL,
+                                (PVOID)&irqData, sizeof(irqData));
+        if (!SDIO_SUCCESS(status)){
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver failed to enable/disable IRQ in hcd %d\n",
+                                    status));
+        }
+
+    } while (FALSE);
+
+    status = _ReleaseHcdLock(pHcd);
+}
+
+static BOOL CheckWriteIntEnableSuccess(PSDREQUEST pReq)
+{
+    if (!SDIO_SUCCESS(pReq->Status)){
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to get write INT Enable register Err:%d\n",
+                                     pReq->Status));
+        return FALSE;
+    }
+
+    if (SD_R5_GET_RESP_FLAGS(pReq->Response) & SD_R5_ERRORS) {
+       DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: WriteIntEnableComplete CMD52 resp error: 0x%X \n",
+                  SD_R5_GET_RESP_FLAGS(pReq->Response)));
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static void HcdIrqEnableComplete(PSDREQUEST pReq)
+{
+    if (CheckWriteIntEnableSuccess(pReq)) {
+            /* configure HCD */
+        HcdIrqControl((PSDHCD)pReq->pCompleteContext, TRUE);
+    }
+    FreeRequest(pReq);
+}
+
+static void HcdIrqDisableComplete(PSDREQUEST pReq)
+{
+    CheckWriteIntEnableSuccess(pReq);
+    HcdIrqControl((PSDHCD)pReq->pCompleteContext, FALSE);
+    FreeRequest(pReq);
+}
+
+static void WriteIntEnableComplete(PSDREQUEST pReq)
+{
+   if (CheckWriteIntEnableSuccess(pReq)) {
+       DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: Wrote INT Enable value:0x%X \n",
+                    (INT)pReq->pCompleteContext));
+   }
+   FreeRequest(pReq);
+}
+
+static void HcdAckComplete(PSDREQUEST pReq)
+{
+    SDIO_STATUS status;
+    DBG_PRINT(SDIODBG_FUNC_IRQ, ("SDIO Bus Driver: Hcd (0x%X) Irq Ack \n",
+                    (INT)pReq->pCompleteContext));
+        /* re-arm the HCD */
+    status = _IssueConfig((PSDHCD)pReq->pCompleteContext,SDCONFIG_SDIO_REARM_INT,NULL,0);
+
+    if (!SDIO_SUCCESS(status)) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: HCD Re-Arm failed : %d\n",
+                    status));
+    }
+    FreeRequest(pReq);
+}
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  SDFunctionAckInterrupt - handle device interrupt acknowledgement
+  Input:  pDevice - the device
+  Output:
+  Return:
+  Notes:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS SDFunctionAckInterrupt(PSDDEVICE pDevice)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    UCHAR       mask;
+    PSDREQUEST  pReq = NULL;
+    BOOL        setHcd = FALSE;
+    SDIO_STATUS status2;
+    CT_DECLARE_IRQ_SYNC_CONTEXT();
+
+    pReq = AllocateRequest();
+    if (NULL == pReq) {
+        return SDIO_STATUS_NO_RESOURCES;
+    }
+
+    status = _AcquireHcdLock(pDevice->pHcd);
+
+    if (!SDIO_SUCCESS(status)) {
+        FreeRequest(pReq);
+        return status;
+    }
+
+    do {
+        if (!((SDDEVICE_GET_SDIO_FUNCNO(pDevice) >= SDIO_FIRST_FUNCTION_NUMBER) &&
+              (SDDEVICE_GET_SDIO_FUNCNO(pDevice) <= SDIO_LAST_FUNCTION_NUMBER))){
+            status = SDIO_STATUS_INVALID_PARAMETER;
+            DBG_ASSERT(FALSE);
+            break;
+        }
+        mask = 1 << SDDEVICE_GET_SDIO_FUNCNO(pDevice);
+        if (pDevice->pHcd->PendingIrqAcks & mask) {
+                /* clear the ack bit in question */
+            pDevice->pHcd->PendingIrqAcks &= ~mask;
+            if (0 == pDevice->pHcd->PendingIrqAcks) {
+                pDevice->pHcd->IrqProcState = SDHCD_IDLE;
+                    /* no pending acks, so re-arm if irqs are stilled enabled */
+                if (pDevice->pHcd->IrqsEnabled) {
+                    setHcd = TRUE;
+                        /* issue pseudo request to sync this with bus requests */
+                    pReq->Status = SDIO_STATUS_SUCCESS;
+                    pReq->pCompletion = HcdAckComplete;
+                    pReq->pCompleteContext = pDevice->pHcd;
+                    pReq->Flags = SD_PSEUDO_REQ_FLAGS;
+                }
+            }
+        } else {
+            DBG_PRINT(SDDBG_WARN, ("SDIO Bus Driver: AckInterrupt: no IRQ pending on Function :%d, \n",
+                        SDDEVICE_GET_SDIO_FUNCNO(pDevice)));
+        }
+    } while (FALSE);
+
+    status2 = ReleaseHcdLock(pDevice);
+
+    if (pReq != NULL) {
+        if (SDIO_SUCCESS(status) && (setHcd)) {
+                /* issue request */
+            IssueRequestToHCD(pDevice->pHcd,pReq);
+        } else {
+            FreeRequest(pReq);
+        }
+    }
+
+    return status;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  SDMaskUnmaskFunctionIRQ - mask/unmask function IRQ
+  Input:  pDevice - the device/function
+          MaskInt - mask interrupt
+  Output:
+  Return: status
+  Notes:  Note, this function can be called from an ISR or completion context
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS SDMaskUnmaskFunctionIRQ(PSDDEVICE pDevice, BOOL MaskInt)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    UINT8       mask;
+    UINT8       controlVal;
+    BOOL        setHcd;
+    PSDREQUEST  pReq = NULL;
+    SDIO_STATUS status2;
+
+    CT_DECLARE_IRQ_SYNC_CONTEXT();
+
+    setHcd = FALSE;
+
+    pReq = AllocateRequest();
+    if (NULL == pReq) {
+        return SDIO_STATUS_NO_RESOURCES;
+    }
+
+    status = _AcquireHcdLock(pDevice->pHcd);
+
+    if (!SDIO_SUCCESS(status)) {
+        FreeRequest(pReq);
+        return status;
+    }
+
+    do {
+
+        if (pDevice->pHcd->CardProperties.Flags & CARD_RAW) {
+            if (!MaskInt) {
+                if (!pDevice->pHcd->IrqsEnabled) {
+                    pReq->pCompletion = RawHcdEnableIrqPseudoComplete;
+                    setHcd = TRUE;
+                    pDevice->pHcd->IrqsEnabled = 1 << 1;
+                }
+            } else {
+                if (pDevice->pHcd->IrqsEnabled) {
+                    pReq->pCompletion = RawHcdDisableIrqPseudoComplete;
+                    setHcd = TRUE;
+                    pDevice->pHcd->IrqsEnabled = 0;
+                }
+            }
+
+            if (setHcd) {
+                    /* hcd IRQ control requests must be synched with outstanding
+                     * bus requests so we issue a pseudo bus request  */
+                pReq->pCompleteContext = pDevice->pHcd;
+                pReq->Flags = SD_PSEUDO_REQ_FLAGS;
+                pReq->Status = SDIO_STATUS_SUCCESS;
+            } else {
+                    /* no request to submit, just free it */
+                FreeRequest(pReq);
+                pReq = NULL;
+            }
+                /* we're done, submit the bus request if any */
+            break;
+        }
+
+        if (!(pDevice->pHcd->CardProperties.Flags & CARD_SDIO)){
+                /* nothing to do if it's not an SDIO card */
+            DBG_ASSERT(FALSE);
+            status = SDIO_STATUS_INVALID_PARAMETER;
+            break;
+        }
+
+        if (!((SDDEVICE_GET_SDIO_FUNCNO(pDevice) >= SDIO_FIRST_FUNCTION_NUMBER) &&
+              (SDDEVICE_GET_SDIO_FUNCNO(pDevice) <= SDIO_LAST_FUNCTION_NUMBER))){
+            status = SDIO_STATUS_INVALID_PARAMETER;
+            DBG_ASSERT(FALSE);
+            break;
+        }
+
+        mask = 1 << SDDEVICE_GET_SDIO_FUNCNO(pDevice);
+        if (!MaskInt) {
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver Unmasking Int, Mask:0x%X\n", mask));
+                /* check interrupts that were enabled on entry */
+            if (0 == pDevice->pHcd->IrqsEnabled) {
+                    /* need to turn on interrupts in HCD */
+                setHcd = TRUE;
+                    /* use this completion routine */
+                pReq->pCompletion = HcdIrqEnableComplete;
+            }
+                /* set the enable bit, in the shadow register */
+            pDevice->pHcd->IrqsEnabled |= mask;
+                /* make sure control value includes the master enable */
+            controlVal = pDevice->pHcd->IrqsEnabled | SDIO_INT_MASTER_ENABLE;
+        } else {
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver Masking Int, Mask:0x%X\n", mask));
+                /* clear the bit */
+            pDevice->pHcd->IrqsEnabled &= ~mask;
+                /* check and see if this clears all the bits */
+            if (0 == pDevice->pHcd->IrqsEnabled){
+                    /* if none of the functions are enabled, clear this register */
+                controlVal = 0;
+                    /* disable in host */
+                setHcd = TRUE;
+                    /* use this completion routine */
+                pReq->pCompletion = HcdIrqDisableComplete;
+            } else {
+                    /* set control value making sure master enable is left on */
+                controlVal = pDevice->pHcd->IrqsEnabled | SDIO_INT_MASTER_ENABLE;
+            }
+        }
+
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver INT_ENABLE_REG value:0x%X\n", controlVal));
+            /* setup bus request to update the mask register */
+        SDIO_SET_CMD52_WRITE_ARG(pReq->Argument,0,SDIO_INT_ENABLE_REG,controlVal);
+        pReq->Command = CMD52;
+        pReq->Flags = SDREQ_FLAGS_TRANS_ASYNC | SDREQ_FLAGS_RESP_SDIO_R5;
+
+        if (setHcd) {
+                /* make this a barrier request and set context*/
+            pReq->Flags |= SDREQ_FLAGS_BARRIER;
+            pReq->pCompleteContext = pDevice->pHcd;
+        } else {
+                /* does not require an update to the HCD  */
+            pReq->pCompleteContext = (PVOID)(UINT32)controlVal;
+            pReq->pCompletion = WriteIntEnableComplete;
+        }
+
+    } while (FALSE);
+
+    status2 = _ReleaseHcdLock(pDevice->pHcd);
+
+    if (pReq != NULL) {
+        if (SDIO_SUCCESS(status)) {
+                /* issue request */
+            IssueRequestToHCD(pDevice->pHcd,pReq);
+        } else {
+            FreeRequest(pReq);
+        }
+    }
+
+    return status;
+}
+
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  SDSPIModeEnableDisableCRC - Enable/Disable SPI Mode CRC checking
+  Input:  pDevice - the device/function
+          Enable - Enable CRC
+  Output:
+  Return: status
+  Notes:  Note, this function can be called from an ISR or completion context
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS SDSPIModeEnableDisableCRC(PSDDEVICE pDevice,BOOL Enable)
+{
+    SDCONFIG_BUS_MODE_DATA busMode;
+    SDIO_STATUS            status = SDIO_STATUS_SUCCESS;
+    UINT32                 cmdARG = 0;
+
+    if (!SDDEVICE_IS_BUSMODE_SPI(pDevice)) {
+        return SDIO_STATUS_INVALID_PARAMETER;
+    }
+       //??we should make these atomic using a barrier
+
+        /* get the current mode and clock */
+    busMode.BusModeFlags = pDevice->pHcd->CardProperties.BusMode;
+    busMode.ClockRate = pDevice->pHcd->CardProperties.OperBusClock;
+
+    if (Enable) {
+            /* clear the no-CRC flag */
+        busMode.BusModeFlags &= ~SDCONFIG_BUS_MODE_SPI_NO_CRC;
+        cmdARG = SD_CMD59_CRC_ON;
+    } else {
+        busMode.BusModeFlags |= SDCONFIG_BUS_MODE_SPI_NO_CRC;
+        cmdARG = SD_CMD59_CRC_OFF;
+    }
+
+    do {
+            /* issue CMD59 to turn on/off CRC */
+        status = _IssueSimpleBusRequest(pDevice->pHcd,
+                                        CMD59,
+                                        cmdARG,
+                                        SDREQ_FLAGS_RESP_R1,
+                                        NULL);
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed issue CMD59 (arg=0x%X) Err:%d \n",
+                                    cmdARG, status));
+            break;
+        }
+        if (Enable) {
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: CRC Enabled in SPI mode \n"));
+        } else {
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: CRC Disabled in SPI mode \n"));
+        }
+        status = SetOperationalBusMode(pDevice,&busMode);
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Failed to set SPI NO CRC mode in hcd : Err:%d \n",
+                                    status));
+            break;
+        }
+    } while (FALSE);
+
+    return status;
+}
+
+
+static UINT32 ConvertSPIStatusToSDCardStatus(UINT8 SpiR1, UINT8 SpiR2)
+{
+    UINT32 cardStatus = 0;
+
+    if (SpiR1 != 0) {
+            /* convert the error */
+        if (SpiR1 & SPI_CS_ERASE_RESET) {
+            cardStatus |= SD_CS_ERASE_RESET;
+        }
+        if (SpiR1 & SPI_CS_ILLEGAL_CMD) {
+            cardStatus |= SD_CS_ILLEGAL_CMD_ERR;
+        }
+        if (SpiR1 & SPI_CS_CMD_CRC_ERR) {
+            cardStatus |= SD_CS_PREV_CMD_CRC_ERR;
+        }
+        if (SpiR1 & SPI_CS_ERASE_SEQ_ERR) {
+            cardStatus |= SD_CS_ERASE_SEQ_ERR;
+        }
+        if (SpiR1 & SPI_CS_ADDRESS_ERR) {
+            cardStatus |= SD_CS_ADDRESS_ERR;
+        }
+        if (SpiR1 & SPI_CS_PARAM_ERR) {
+            cardStatus |= SD_CS_CMD_OUT_OF_RANGE;
+        }
+    }
+
+    if (SpiR2 != 0) {
+            /* convert the error */
+        if (SpiR2 & SPI_CS_CARD_IS_LOCKED) {
+            cardStatus |= SD_CS_CARD_LOCKED;
+        }
+        if (SpiR2 & SPI_CS_LOCK_UNLOCK_FAILED) {
+                /* this bit is shared, just set both */
+            cardStatus |= (SD_CS_LK_UNLK_FAILED | SD_CS_WP_ERASE_SKIP);
+        }
+        if (SpiR2 & SPI_CS_ERROR) {
+            cardStatus |= SD_CS_GENERAL_ERR;
+        }
+        if (SpiR2 & SPI_CS_INTERNAL_ERROR) {
+            cardStatus |= SD_CS_CARD_INTERNAL_ERR;
+        }
+        if (SpiR2 & SPI_CS_ECC_FAILED) {
+            cardStatus |= SD_CS_ECC_FAILED;
+        }
+        if (SpiR2 & SPI_CS_WP_VIOLATION) {
+            cardStatus |= SD_CS_WP_ERR;
+        }
+        if (SpiR2 & SPI_CS_ERASE_PARAM_ERR) {
+            cardStatus |= SD_CS_ERASE_PARAM_ERR;
+        }
+        if (SpiR2 & SPI_CS_OUT_OF_RANGE) {
+            cardStatus |= SD_CS_CMD_OUT_OF_RANGE;
+        }
+    }
+
+    return cardStatus;
+}
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  ConvertSPI_Response - filter the SPI response and convert it to an SD Response
+  Input:  pReq - request
+  Output: pReq - modified response, if pRespBuffer is not NULL
+          pRespBuffer - converted response (optional)
+  Return:
+  Notes:  This function converts a SPI response into an SD response.  A caller
+          can supply a buffer instead.
+          For SPI bus operation the HCD must send the SPI response as
+          a stream of bytes, the highest byte contains the first received byte from the
+          card.  This function only filters simple responses (R1 primarily).
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void ConvertSPI_Response(PSDREQUEST pReq, UINT8 *pRespBuffer)
+{
+
+    UINT32  cardStatus;
+
+    if (pReq->Flags & SDREQ_FLAGS_RESP_SPI_CONVERTED) {
+            /* already converted */
+        return;
+    }
+    if (NULL == pRespBuffer) {
+        pRespBuffer = pReq->Response;
+    }
+
+    switch (GET_SDREQ_RESP_TYPE(pReq->Flags)) {
+        case SDREQ_FLAGS_RESP_R1:
+        case SDREQ_FLAGS_RESP_R1B:
+            cardStatus = ConvertSPIStatusToSDCardStatus(GET_SPI_R1_RESP_TOKEN(pReq->Response),
+                                                        0);
+            if (CMD55 == pReq->Command) {
+                    /* we emulate this since SPI does not have such a bit */
+                cardStatus |= SD_CS_APP_CMD;
+            }
+                /* stuff the SD card status */
+            SD_R1_SET_CMD_STATUS(pRespBuffer,cardStatus);
+                /* stuff the command */
+            SD_R1_SET_CMD(pRespBuffer,pReq->Command);
+            pReq->Flags |= SDREQ_FLAGS_RESP_SPI_CONVERTED;
+            break;
+        case SDREQ_FLAGS_RESP_SDIO_R5:
+            {
+                UINT8 respFlags;
+                UINT8 readData;
+
+                readData = GET_SPI_SDIO_R5_RESPONSE_RDATA(pReq->Response);
+                respFlags = GET_SPI_SDIO_R5_RESP_TOKEN(pReq->Response);
+
+                pRespBuffer[SD_R5_RESP_FLAGS_OFFSET] = 0;
+                if (respFlags != 0) {
+                    if (respFlags & SPI_R5_ILLEGAL_CMD) {
+                        pRespBuffer[SD_R5_RESP_FLAGS_OFFSET] |= SD_R5_ILLEGAL_CMD;
+                    }
+                    if (respFlags & SPI_R5_CMD_CRC) {
+                        pRespBuffer[SD_R5_RESP_FLAGS_OFFSET] |= SD_R5_RESP_CMD_ERR;
+                    }
+                    if (respFlags & SPI_R5_FUNC_ERR) {
+                        pRespBuffer[SD_R5_RESP_FLAGS_OFFSET] |= SD_R5_INVALID_FUNC;
+                    }
+                    if (respFlags & SPI_R5_PARAM_ERR) {
+                        pRespBuffer[SD_R5_RESP_FLAGS_OFFSET] |= SD_R5_ARG_RANGE_ERR;
+                    }
+                }
+                    /* stuff read data */
+                pRespBuffer[SD_SDIO_R5_READ_DATA_OFFSET] = readData;
+                    /* stuff the command */
+                SD_R5_SET_CMD(pRespBuffer,pReq->Command);
+            }
+            pReq->Flags |= SDREQ_FLAGS_RESP_SPI_CONVERTED;
+            break;
+        case SDREQ_FLAGS_RESP_R2:
+                /* for CMD13 and ACMD13 , SPI uses it's own R2 response format (2 bytes) */
+                /* the issue of CMD13 needs to change the response flag to R2 */
+            if (CMD13 == pReq->Command) {
+                cardStatus = ConvertSPIStatusToSDCardStatus(
+                                    GET_SPI_R2_RESP_TOKEN(pReq->Response),
+                                    GET_SPI_R2_STATUS_TOKEN(pReq->Response));
+                    /* stuff the SD card status */
+                SD_R1_SET_CMD_STATUS(pRespBuffer,cardStatus);
+                    /* stuff the command */
+                SD_R1_SET_CMD(pRespBuffer,pReq->Command);
+                pReq->Flags |= SDREQ_FLAGS_RESP_SPI_CONVERTED;
+                break;
+            }
+                /* no other commands should be using R2 when using SPI, if they are
+                 * they should be bypassing the filter  */
+            DBG_ASSERT(FALSE);
+            break;
+        default:
+                /* for all others:
+                 *
+                 * SDREQ_FLAGS_RESP_R6 - SPI mode does not use RCA
+                 * SDREQ_FLAGS_RESP_R3 - bus driver handles this internally
+                 * SDREQ_FLAGS_RESP_SDIO_R4 - bus driver handles this internally
+                 *
+                 */
+            DBG_PRINT(SDDBG_ERROR, ("ConvertSPI_Response - invalid response type:0x%2.2X",
+                                    GET_SDREQ_RESP_TYPE(pReq->Flags)));
+            DBG_ASSERT(FALSE);
+            break;
+    }
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Check an SD/MMC/SDIO response.
+
+  @function name: SDIO_CheckResponse
+  @prototype: SDIO_STATUS SDIO_CheckResponse(PSDHCD pHcd, PSDREQUEST pReq, SDHCD_RESPONSE_CHECK_MODE CheckMode)
+  @category: HD_Reference
+
+  @input:  pHcd - the host controller definition structure.
+  @input:  pReq - request containing the response
+  @input:  CheckMode - mode
+
+  @return: SDIO_STATUS
+
+  @notes: Host controller drivers must call into this function to validate various command
+          responses before continuing with data transfers or for decoding received SPI tokens.
+          The CheckMode option determines the type of validation to perform.
+          if (CheckMode == SDHCD_CHECK_DATA_TRANS_OK) :
+             The host controller must check the card response to determine whether it
+          is safe to perform a data transfer.  This API only checks commands that
+          involve data transfers and checks various status fields in the command response.
+          If the card cannot accept data, this function will return a non-successful status that
+          should be treated as a request failure.  The host driver should complete the request with the
+          returned status. Host controller should only call this function in preparation for a
+          data transfer.
+          if (CheckMode == SDHCD_CHECK_SPI_TOKEN) :
+             This API checks the SPI token and returns a timeout status if the illegal command bit is
+          set.  This simulates the behavior of SD 1/4 bit operation where illegal commands result in
+          a command timeout.  A driver that supports SPI mode should pass every response to this
+          function to determine the appropriate error status to complete the request with.  If the
+          API returns success, the response indicates that the card accepted the command.
+
+  @example: Checking the response before starting the data transfer :
+        if (SDIO_SUCCESS(status) && (pReq->Flags & SDREQ_FLAGS_DATA_TRANS)) {
+                // check the response to see if we should continue with data
+            status = SDIO_CheckResponse(pHcd, pReq, SDHCD_CHECK_DATA_TRANS_OK);
+            if (SDIO_SUCCESS(status)) {
+                .... start data transfer phase
+            } else {
+               ... card response indicates that the card cannot handle data
+                  // set completion status
+               pRequest->Status = status;
+            }
+        }
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  _SDIO_CheckResponse - check response on behalf of the host controller
+  Input:  pHcd - host controller
+          pReq - request containing the response
+          CheckMode - mode
+  Output:
+  Return: status
+  Notes:
+
+    CheckMode == SDHCD_CHECK_DATA_TRANS_OK :
+    The host controller requests a check on the response to determine whether it
+    is okay to perform a data transfer.  This function only filters on commands that
+    involve data.  Host controller should only call this function in preparation for a
+    data transfer.
+
+    CheckMode == SDHCD_CHECK_SPI_TOKEN :
+    The bus driver checks the SPI token and returns a timeout status if the illegal command bit is
+    set.  This simulates the behavior of SD native operation.
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS _SDIO_CheckResponse(PSDHCD pHcd, PSDREQUEST pReq, SDHCD_RESPONSE_CHECK_MODE CheckMode)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+
+    if (CheckMode == SDHCD_CHECK_DATA_TRANS_OK) {
+        UINT32      cardStatus;
+        UINT8       *pResponse;
+        UINT8       convertedResponse[MAX_CARD_RESPONSE_BYTES];
+
+        if (!(pReq->Flags & SDREQ_FLAGS_DATA_TRANS) ||
+             (pReq->Flags & SDREQ_FLAGS_DATA_SKIP_RESP_CHK) ||
+             (GET_SDREQ_RESP_TYPE(pReq->Flags) ==  SDREQ_FLAGS_NO_RESP)) {
+            return SDIO_STATUS_SUCCESS;
+        }
+        pResponse = pReq->Response;
+            /* check SPI mode */
+        if (IS_HCD_BUS_MODE_SPI(pHcd)) {
+            if (!(pReq->Flags & SDREQ_FLAGS_RESP_SKIP_SPI_FILT)) {
+                    /* apply conversion */
+                ConvertSPI_Response(pReq, NULL);
+            } else {
+                    /* temporarily convert the response, without altering the original */
+                ConvertSPI_Response(pReq, convertedResponse);
+                    /* point to the converted one */
+                pResponse = convertedResponse;
+            }
+        }
+
+        switch (GET_SDREQ_RESP_TYPE(pReq->Flags)) {
+            case SDREQ_FLAGS_RESP_R1:
+            case SDREQ_FLAGS_RESP_R1B:
+                cardStatus = SD_R1_GET_CARD_STATUS(pResponse);
+                if (!(cardStatus &
+                     (SD_CS_ILLEGAL_CMD_ERR | SD_CS_CARD_INTERNAL_ERR | SD_CS_GENERAL_ERR))) {
+                        /* okay for data */
+                    break;
+                }
+                    /* figure out what it was */
+                if (cardStatus & SD_CS_ILLEGAL_CMD_ERR) {
+                    status = SDIO_STATUS_DATA_STATE_INVALID;
+                } else {
+                    status = SDIO_STATUS_DATA_ERROR_UNKNOWN;
+                }
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Check Response Error. R1 CardStatus:0x%X \n",
+                                        cardStatus));
+                break;
+            case SDREQ_FLAGS_RESP_SDIO_R5:
+                cardStatus = SD_R5_GET_RESP_FLAGS(pResponse);
+                if (!(cardStatus & SD_R5_CURRENT_CMD_ERRORS)){
+                        /* all okay */
+                    break;
+                }
+
+                status = ConvertCMD52ResponseToSDIOStatus((UINT8)cardStatus);
+                DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: Check Response Error. R5 CardStatus:0x%X \n",
+                                        cardStatus));
+                break;
+            default:
+                break;
+        }
+
+        return status;
+    }
+
+    {
+        UINT8       spiToken;
+
+            /* handle SPI token validation */
+        switch (GET_SDREQ_RESP_TYPE(pReq->Flags)) {
+            case SDREQ_FLAGS_RESP_R2:
+                spiToken = GET_SPI_R2_RESP_TOKEN(pReq->Response);
+                break;
+            case SDREQ_FLAGS_RESP_SDIO_R5:
+                spiToken = GET_SPI_SDIO_R5_RESP_TOKEN(pReq->Response);
+                break;
+            case SDREQ_FLAGS_RESP_R3:
+                spiToken = GET_SPI_R3_RESP_TOKEN(pReq->Response);
+                break;
+            case SDREQ_FLAGS_RESP_SDIO_R4:
+                spiToken = GET_SPI_SDIO_R4_RESP_TOKEN(pReq->Response);
+                break;
+            default:
+                    /* all other tokesn are SPI R1 type */
+                spiToken = GET_SPI_R1_RESP_TOKEN(pReq->Response);
+                break;
+        }
+
+        if ((GET_SDREQ_RESP_TYPE(pReq->Flags) == SDREQ_FLAGS_RESP_SDIO_R5) ||
+            (GET_SDREQ_RESP_TYPE(pReq->Flags) == SDREQ_FLAGS_RESP_SDIO_R4)) {
+                /* handle SDIO status tokens */
+            if ((spiToken & SPI_R5_ILLEGAL_CMD) ||
+                (spiToken & SPI_R5_CMD_CRC)) {
+                status = SDIO_STATUS_BUS_RESP_TIMEOUT;
+            }
+        } else {
+                /* handle all other status tokens */
+            if ((spiToken & SPI_CS_ILLEGAL_CMD) ||
+                (spiToken & SPI_CS_CMD_CRC_ERR)) {
+                status = SDIO_STATUS_BUS_RESP_TIMEOUT;
+            }
+       }
+    }
+
+    return status;
+}
+
Index: linux-2.6/drivers/sdio/busdriver/sdio_bus_os.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/busdriver/sdio_bus_os.c
@@ -0,0 +1,876 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdio_bus_os.c
+
+@abstract: Linux implementation module
+
+#notes: includes module load and unload functions
+
+@notice: Copyright (c), 2004-2006 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+/* debug level for this module*/
+#define DBG_DECLARE 3;
+
+#include <linux/sdio/ctsystem.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <linux/kthread.h>
+#ifdef SDIO_USE_LINUX_PNP
+#include <linux/pnp.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
+void pnp_remove_device(struct pnp_dev *dev);
+#endif
+#endif
+#endif
+
+#include <linux/sdio/sdio_busdriver.h>
+#include <linux/sdio/sdio_lib.h>
+#include "_busdriver.h"
+
+#define DESCRIPTION "SDIO Bus Driver"
+#define AUTHOR "Atheros Communications, Inc."
+
+/* debug print parameter */
+module_param(debuglevel, int, 0644);
+MODULE_PARM_DESC(debuglevel, "debuglevel 0-7, controls debug prints");
+/* configuration and default parameters */
+static int RequestRetries = SDMMC_DEFAULT_CMD_RETRIES;
+module_param(RequestRetries, int, 0644);
+MODULE_PARM_DESC(RequestRetries, "number of command retries");
+static int CardReadyPollingRetry = SDMMC_DEFAULT_CARD_READY_RETRIES;
+module_param(CardReadyPollingRetry, int, 0644);
+MODULE_PARM_DESC(CardReadyPollingRetry, "number of card ready retries");
+static int PowerSettleDelay = SDMMC_POWER_SETTLE_DELAY;
+module_param(PowerSettleDelay, int, 0644);
+MODULE_PARM_DESC(PowerSettleDelay, "delay in ms for power to settle after power changes");
+static int DefaultOperClock = 52000000;
+module_param(DefaultOperClock, int, 0644);
+MODULE_PARM_DESC(DefaultOperClock, "maximum operational clock limit");
+static int DefaultBusMode = SDCONFIG_BUS_WIDTH_4_BIT;
+module_param(DefaultBusMode, int, 0644);
+MODULE_PARM_DESC(DefaultBusMode, "default bus mode: see SDCONFIG_BUS_WIDTH_xxx");
+static int RequestListSize = SDBUS_DEFAULT_REQ_LIST_SIZE;
+module_param(RequestListSize, int, 0644);
+MODULE_PARM_DESC(RequestListSize, "");
+static int SignalSemListSize = SDBUS_DEFAULT_REQ_SIG_SIZE;
+module_param(SignalSemListSize, int, 0644);
+MODULE_PARM_DESC(SignalSemListSize, "");
+static int CDPollingInterval = SDBUS_DEFAULT_CD_POLLING_INTERVAL;
+module_param(CDPollingInterval, int, 0644);
+MODULE_PARM_DESC(CDPollingInterval, "");
+static int DefaultOperBlockLen = SDMMC_DEFAULT_BYTES_PER_BLOCK;
+module_param(DefaultOperBlockLen, int, 0644);
+MODULE_PARM_DESC(DefaultOperBlockLen, "operational block length");
+static int DefaultOperBlockCount = SDMMC_DEFAULT_BLOCKS_PER_TRANS;
+module_param(DefaultOperBlockCount, int, 0644);
+MODULE_PARM_DESC(DefaultOperBlockCount, "operational block count");
+static int ConfigFlags = BD_DEFAULT_CONFIG_FLAGS;
+module_param(ConfigFlags, int, 0644);
+MODULE_PARM_DESC(ConfigFlags, "config flags");
+
+static int HcdRCount = MAX_HCD_REQ_RECURSION;
+module_param(HcdRCount, int, 0644);
+MODULE_PARM_DESC(HcdRCount, "HCD request recursion count");
+
+static void CardDetect_WorkItem(
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+void *context);
+#else
+struct work_struct *ignored);
+#endif
+static void CardDetect_TimerFunc(unsigned long Context);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static DECLARE_WORK(CardDetectPollWork, CardDetect_WorkItem
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+, 0);
+#else
+);
+#endif
+#endif
+static int RegisterDriver(PSDFUNCTION pFunction);
+static int UnregisterDriver(PSDFUNCTION pFunction);
+
+static struct timer_list CardDetectTimer;
+
+struct semaphore athsdio_init_lock;
+
+#define SDDEVICE_FROM_OSDEVICE(pOSDevice)  container_of(pOSDevice, SDDEVICE, Device)
+#define SDFUNCTION_FROM_OSDRIVER(pOSDriver)  container_of(pOSDriver, SDFUNCTION, Driver)
+
+
+/*
+ * SDIO_RegisterHostController - register a host controller bus driver
+*/
+SDIO_STATUS SDIO_RegisterHostController(PSDHCD pHcd) {
+    /* we are the exported verison, call the internal verison */
+    return _SDIO_RegisterHostController(pHcd);
+}
+
+/*
+ * SDIO_UnregisterHostController - unregister a host controller bus driver
+*/
+SDIO_STATUS SDIO_UnregisterHostController(PSDHCD pHcd) {
+    /* we are the exported verison, call the internal verison */
+    return _SDIO_UnregisterHostController(pHcd);
+}
+
+/*
+ * SDIO_RegisterFunction - register a function driver
+*/
+SDIO_STATUS SDIO_RegisterFunction(PSDFUNCTION pFunction) {
+    int error;
+    SDIO_STATUS status;
+
+    DBG_PRINT(SDDBG_TRACE, ("SDIO BusDriver - SDIO_RegisterFunction\n"));
+
+        /* since we do PnP registration first, we need to check the version */
+    if (!CHECK_FUNCTION_DRIVER_VERSION(pFunction)) {
+        DBG_PRINT(SDDBG_ERROR,
+           ("SDIO Bus Driver: Function Major Version Mismatch (hcd = %d, bus driver = %d)\n",
+           GET_SDIO_STACK_VERSION_MAJOR(pFunction), CT_SDIO_STACK_VERSION_MAJOR(g_Version)));
+        return SDIO_STATUS_INVALID_PARAMETER;
+    }
+
+    /* we are the exported verison, call the internal verison after registering with the bus
+       we handle probes internally to the bus driver */
+    if ((error = RegisterDriver(pFunction)) < 0) {
+        DBG_PRINT(SDDBG_ERROR,
+            ("SDIO BusDriver - SDIO_RegisterFunction, failed to register with system bus driver: %d\n",
+            error));
+        status = OSErrorToSDIOError(error);
+    } else {
+        status = _SDIO_RegisterFunction(pFunction);
+        if (!SDIO_SUCCESS(status)) {
+            UnregisterDriver(pFunction);
+        }
+    }
+
+    return status;
+}
+
+/*
+ * SDIO_UnregisterFunction - unregister a function driver
+*/
+SDIO_STATUS SDIO_UnregisterFunction(PSDFUNCTION pFunction) {
+    SDIO_STATUS status;
+    /* we are the exported verison, call the internal verison */
+    status = _SDIO_UnregisterFunction(pFunction);
+    UnregisterDriver(pFunction);
+    return  status;
+}
+
+/*
+ * SDIO_HandleHcdEvent - tell core an event occurred
+*/
+SDIO_STATUS SDIO_HandleHcdEvent(PSDHCD pHcd, HCD_EVENT Event) {
+    /* we are the exported verison, call the internal verison */
+    DBG_PRINT(SDIODBG_HCD_EVENTS, ("SDIO Bus Driver: SDIO_HandleHcdEvent, event type 0x%X, HCD:0x%X\n",
+                         Event, (UINT)pHcd));
+    return _SDIO_HandleHcdEvent(pHcd, Event);
+}
+
+/* get default settings */
+SDIO_STATUS _SDIO_BusGetDefaultSettings(PBDCONTEXT pBdc)
+{
+    /* these defaults are module params */
+    pBdc->RequestRetries = RequestRetries;
+    pBdc->CardReadyPollingRetry = CardReadyPollingRetry;
+    pBdc->PowerSettleDelay = PowerSettleDelay;
+    pBdc->DefaultOperClock = DefaultOperClock;
+    pBdc->DefaultBusMode = DefaultBusMode;
+    pBdc->RequestListSize = RequestListSize;
+    pBdc->SignalSemListSize = SignalSemListSize;
+    pBdc->CDPollingInterval = CDPollingInterval;
+    pBdc->DefaultOperBlockLen = DefaultOperBlockLen;
+    pBdc->DefaultOperBlockCount = DefaultOperBlockCount;
+    pBdc->ConfigFlags = ConfigFlags;
+    pBdc->MaxHcdRecursion = HcdRCount;
+    return SDIO_STATUS_SUCCESS;
+}
+
+static void CardDetect_TimerFunc(unsigned long Context)
+{
+    DBG_PRINT(SDIODBG_CD_TIMER, ("+ SDIO BusDriver Card Detect Timer\n"));
+
+        /* timers run in an ISR context and cannot block or sleep, so we need
+         * to queue a work item to call the bus driver timer notification */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    if (schedule_work(&CardDetectPollWork) <= 0) {
+        DBG_PRINT(SDDBG_ERROR, ("Failed to queue Card Detect timer!\n"));
+    }
+#else
+    CardDetect_WorkItem(NULL);
+#endif
+    DBG_PRINT(SDIODBG_CD_TIMER, ("- SDIO BusDriver  Card Detect Timer\n"));
+}
+
+/*
+ * Initialize any timers we are using
+*/
+SDIO_STATUS InitializeTimers(void)
+{
+    init_timer(&CardDetectTimer);
+    CardDetectTimer.function = CardDetect_TimerFunc;
+    CardDetectTimer.data = 0;
+    return SDIO_STATUS_SUCCESS;
+}
+
+/*
+ * cleanup timers
+*/
+SDIO_STATUS CleanupTimers(void)
+{
+    del_timer(&CardDetectTimer);
+    return SDIO_STATUS_SUCCESS;
+}
+
+
+/*
+ * Queue a timer, Timeout is in milliseconds
+*/
+SDIO_STATUS QueueTimer(INT TimerID, UINT32 TimeOut)
+{
+    UINT32 delta;
+
+        /* convert timeout to ticks */
+    delta = (TimeOut * HZ)/1000;
+    if (delta == 0) {
+        delta = 1;
+    }
+    DBG_PRINT(SDIODBG_CD_TIMER, ("SDIO BusDriver - SDIO_QueueTimer System Ticks Per Sec:%d \n",HZ));
+    DBG_PRINT(SDIODBG_CD_TIMER, ("SDIO BusDriver - SDIO_QueueTimer TimerID: %d TimeOut:%d MS, requires %d Ticks\n",
+                TimerID,TimeOut,delta));
+    switch (TimerID) {
+        case SDIOBUS_CD_TIMER_ID:
+            CardDetectTimer.expires = jiffies + delta;
+            add_timer(&CardDetectTimer);
+            break;
+        default:
+            return SDIO_STATUS_INVALID_PARAMETER;
+    }
+
+    return SDIO_STATUS_SUCCESS;
+}
+
+/* check a response on behalf of the host controller, to allow it to proceed with a
+ * data transfer */
+SDIO_STATUS SDIO_CheckResponse(PSDHCD pHcd, PSDREQUEST pReq, SDHCD_RESPONSE_CHECK_MODE CheckMode)
+{
+    return _SDIO_CheckResponse(pHcd,pReq,CheckMode);
+}
+
+/*
+ * CardDetect_WorkItem - the work item for handling card detect polling interrupt
+*/
+static void CardDetect_WorkItem(
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+void *context)
+#else
+struct work_struct *ignored)
+#endif
+{
+        /* call bus driver function */
+    SDIO_NotifyTimerTriggered(SDIOBUS_CD_TIMER_ID);
+}
+
+/*
+ * OS_IncHcdReference - increment host controller driver reference count
+*/
+SDIO_STATUS Do_OS_IncHcdReference(PSDHCD pHcd)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+
+    do {
+        if (NULL == pHcd->pModule) {
+                /* hcds that are 2.3 or higher should set this */
+            DBG_PRINT(SDDBG_WARN, ("SDIO Bus Driver: HCD:%s should set module ptr!\n",
+                (pHcd->pName != NULL) ? pHcd->pName : "Unknown"));
+            break;
+        }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        if (!try_module_get(pHcd->pModule)) {
+            status = SDIO_STATUS_ERROR;
+        }
+#else
+        if (!try_inc_mod_count(pHcd->pModule)) {
+            status = SDIO_STATUS_ERROR;
+        }
+#endif
+
+    } while (FALSE);
+
+    if (!SDIO_SUCCESS(status)) {
+        DBG_PRINT(SDDBG_WARN, ("SDIO Bus Driver: HCD:%s failed to get module\n",
+            (pHcd->pName != NULL) ? pHcd->pName : "Unknown"));
+    }
+
+    return status;
+}
+
+/*
+ * OS_DecHcdReference - decrement host controller driver reference count
+*/
+SDIO_STATUS Do_OS_DecHcdReference(PSDHCD pHcd)
+{
+    if (pHcd->pModule != NULL) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        module_put(pHcd->pModule);
+#else
+            /* 2.4 or lower */
+        __MOD_DEC_USE_COUNT(pHcd->pModule);
+#endif
+    }
+    return SDIO_STATUS_SUCCESS;
+}
+
+/****************************************************************************************/
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+
+#ifdef SDIO_USE_LINUX_PNP
+#include <linux/pnp.h>
+
+#if !defined(CONFIG_PNP)
+#error "CONFIG_PNP not defined"
+#endif
+
+static ULONG InUseDevices = 0;
+static spinlock_t InUseDevicesLock = SPIN_LOCK_UNLOCKED;
+
+static const struct pnp_device_id pnp_idtable[] = {
+    {"SD_XXXX",  0}
+};
+static int sdio_get_resources(struct pnp_dev * pDev, struct pnp_resource_table * res)
+{
+    DBG_PRINT(SDDBG_TRACE,
+        ("SDIO BusDriver - sdio_get_resources: %s\n",
+        pDev->dev.bus_id));
+    return 0;
+}
+static int sdio_set_resources(struct pnp_dev * pDev, struct pnp_resource_table * res)
+{
+    DBG_PRINT(SDDBG_TRACE,
+        ("SDIO BusDriver - sdio_set_resources: %s\n",
+        pDev->dev.bus_id));
+    return 0;
+}
+
+static int sdio_disable_resources(struct pnp_dev *pDev)
+{
+    DBG_PRINT(SDDBG_TRACE,
+        ("SDIO BusDriver - sdio_disable_resources: %s\n",
+        pDev->dev.bus_id));
+    if (pDev != NULL) {
+        pDev->active = 0;
+    }
+    return 0;
+}
+void    release(struct device * pDev) {
+    DBG_PRINT(SDDBG_TRACE,
+        ("SDIO BusDriver - release: %s\n",
+        pDev->bus_id));
+    return;
+}
+struct pnp_protocol sdio_protocol = {
+    .name   = "SDIO",
+    .get    = sdio_get_resources,
+    .set    = sdio_set_resources,
+    .disable = sdio_disable_resources,
+    .dev.release = release,
+};
+
+/*
+ * driver_probe - probe for OS based driver
+*/
+static int driver_probe(struct pnp_dev* pOSDevice, const struct pnp_device_id *pId)
+{
+    PSDDEVICE pDevice = SDDEVICE_FROM_OSDEVICE(pOSDevice);
+    PSDFUNCTION pFunction = pDevice->Device.dev.driver_data;
+
+    if (pFunction == NULL) {
+        return -1;
+    }
+
+    if (strcmp(pFunction->pName, pOSDevice->dev.driver->name) == 0) {
+        DBG_PRINT(SDDBG_TRACE,
+            ("SDIO BusDriver - driver_probe, match: %s/%s driver: %s\n",
+            pOSDevice->dev.bus_id, pFunction->pName, pOSDevice->dev.driver->name));
+        return 1;
+    } else {
+        DBG_PRINT(SDDBG_TRACE,
+            ("SDIO BusDriver - driver_probe, no match: %s/%s driver: %s\n",
+            pOSDevice->dev.bus_id, pFunction->pName, pOSDevice->dev.driver->name));
+        return -1;
+    }
+/*    if (pOSDevice->id != NULL) {
+        if (strcmp(pOSDevice->id->id, pId->id) == 0) {
+            DBG_PRINT(SDDBG_TRACE,
+                ("SDIO BusDriver - driver_probe, match: %s/%s\n",
+                pOSDevice->dev.bus_id, pId->id));
+            return 1;
+        }
+        DBG_PRINT(SDDBG_TRACE,
+            ("SDIO BusDriver - driver_probe, did not match: %s/%s/%s\n",
+            pOSDevice->dev.bus_id, pId->id, pOSDevice->id->id));
+    } else {
+        DBG_PRINT(SDDBG_TRACE,
+            ("SDIO BusDriver - driver_probe, did not match: %s/%s\n",
+            pOSDevice->dev.bus_id, pId->id));
+    }
+    return -1;
+*/
+//??    if (pDevice->Device.dev.driver_data != NULL) {
+//??        if (pDevice->Device.dev.driver_data == pFunction) {
+//??    if (pDevice->Device.data != NULL) {
+//??        if (pDevice->Device.data == pFunction) {
+//??            DBG_PRINT(SDDBG_TRACE,
+//??                ("SDIO BusDriver - driver_probe, match: %s\n",
+//??                pOSDevice->dev.bus_id));
+//??            return 1;
+//??        }
+//??    }
+   DBG_PRINT(SDDBG_TRACE,
+        ("SDIO BusDriver - driver_probe,  match: %s\n",
+        pOSDevice->dev.bus_id));
+    return 1;
+}
+
+#endif
+
+static int RegisterDriver(PSDFUNCTION pFunction)
+{
+#ifdef  SDIO_USE_LINUX_PNP
+    memset(&pFunction->Driver, 0, sizeof(pFunction->Driver));
+    pFunction->Driver.name = pFunction->pName;
+    pFunction->Driver.probe = driver_probe;
+    pFunction->Driver.id_table = pnp_idtable;
+    pFunction->Driver.flags = PNP_DRIVER_RES_DO_NOT_CHANGE;
+
+    DBG_PRINT(SDDBG_TRACE,
+            ("SDIO BusDriver - SDIO_RegisterFunction, registering driver: %s\n",
+            pFunction->Driver.name));
+    return pnp_register_driver(&pFunction->Driver);
+#else
+    return 0;
+#endif
+
+}
+
+static int UnregisterDriver(PSDFUNCTION pFunction)
+{
+#ifdef  SDIO_USE_LINUX_PNP
+    DBG_PRINT(SDDBG_TRACE,
+            ("+SDIO BusDriver - UnregisterDriver, driver: %s\n",
+            pFunction->Driver.name));
+    pnp_unregister_driver(&pFunction->Driver);
+    DBG_PRINT(SDDBG_TRACE,
+            ("-SDIO BusDriver - UnregisterDriver\n"));
+#endif
+   return 0;
+}
+
+/*
+ * OS_InitializeDevice - initialize device that will be registered
+*/
+SDIO_STATUS OS_InitializeDevice(PSDDEVICE pDevice, PSDFUNCTION pFunction)
+{
+#ifdef SDIO_USE_LINUX_PNP
+    struct pnp_id *pFdname;
+    memset(&pDevice->Device, 0, sizeof(pDevice->Device));
+    pDevice->Device.dev.driver_data = (PVOID)pFunction;
+//??    pDevice->Device.data = (PVOID)pFunction;
+//??    pDevice->Device.dev.driver = &pFunction->Driver.driver;
+//??    pDevice->Device.driver = &pFunction->Driver;
+//??    pDevice->Device.dev.release = release;
+    /* get a unique device number, must be done with locks held */
+    spin_lock(&InUseDevicesLock);
+    pDevice->Device.number = FirstClearBit(&InUseDevices);
+    SetBit(&InUseDevices, pDevice->Device.number);
+    spin_unlock(&InUseDevicesLock);
+    pDevice->Device.capabilities = PNP_REMOVABLE | PNP_DISABLE;
+    pDevice->Device.protocol = &sdio_protocol;
+    pDevice->Device.active = 1;
+
+    pnp_init_resource_table(&pDevice->Device.res);
+
+    pFdname = KernelAlloc(sizeof(struct pnp_id));
+
+    if (NULL == pFdname) {
+        return SDIO_STATUS_NO_RESOURCES;
+    }
+    /* set the id as slot number/function number */
+    snprintf(pFdname->id, sizeof(pFdname->id), "SD_%02X%02X",
+             pDevice->pHcd->SlotNumber, (UINT)SDDEVICE_GET_SDIO_FUNCNO(pDevice));
+    pFdname->next = NULL;
+    DBG_PRINT(SDDBG_TRACE, ("SDIO BusDriver - OS_InitializeDevice adding id: %s\n",
+                             pFdname->id));
+    pnp_add_id(pFdname, &pDevice->Device);
+
+        /* deal with DMA settings */
+    if (pDevice->pHcd->pDmaDescription != NULL) {
+        pDevice->Device.dev.dma_mask = &pDevice->pHcd->pDmaDescription->Mask;
+        pDevice->Device.dev.coherent_dma_mask = pDevice->pHcd->pDmaDescription->Mask;
+    }
+
+#endif
+    return SDIO_STATUS_SUCCESS;
+}
+
+/*
+ * OS_AddDevice - must be pre-initialized with OS_InitializeDevice
+*/
+SDIO_STATUS OS_AddDevice(PSDDEVICE pDevice, PSDFUNCTION pFunction)
+{
+#ifdef SDIO_USE_LINUX_PNP
+    int error;
+    DBG_PRINT(SDDBG_TRACE, ("SDIO BusDriver - OS_AddDevice adding function: %s\n",
+                               pFunction->pName));
+    error = pnp_add_device(&pDevice->Device);
+    if (error < 0) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO BusDriver - OS_AddDevice failed pnp_add_device: %d\n",
+                               error));
+    }
+        /* replace the buggy pnp's release */
+    pDevice->Device.dev.release = release;
+
+    return OSErrorToSDIOError(error);
+#else
+    return SDIO_STATUS_SUCCESS;
+#endif
+}
+
+/*
+ * OS_RemoveDevice - unregister device with driver and bus
+*/
+void OS_RemoveDevice(PSDDEVICE pDevice)
+{
+    DBG_PRINT(SDDBG_TRACE, ("SDIO BusDriver - OS_RemoveDevice \n"));
+#ifdef SDIO_USE_LINUX_PNP
+    pnp_remove_device(&pDevice->Device);
+    spin_lock(&InUseDevicesLock);
+    ClearBit(&InUseDevices, pDevice->Device.number);
+    spin_unlock(&InUseDevicesLock);
+
+    if (pDevice->Device.id != NULL) {
+        KernelFree(pDevice->Device.id);
+        pDevice->Device.id = NULL;
+    }
+#endif
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Add OS device to bus driver.
+
+  @function name: SDIO_BusAddOSDevice
+  @category: HD_Reference
+
+  @output: pDma    - descrip[tion of support DMA or NULL
+  @output: pDriver - assigned driver object
+  @output: pDevice - assigned device object
+
+  @return: SDIO_STATUS - SDIO_STATUS_SUCCESS when successful.
+
+  @notes: If the HCD does not register with the driver sub-system directly (like in the PCI case),
+          then it should register with the bus driver to obtain OS dependent device objects.
+          All input structures should be maintained throughout the life of the driver.
+
+  @example: getting device objects:
+    typedef struct _SDHCD_DRIVER {
+        OS_PNPDEVICE   HcdDevice;     / * the OS device for this HCD * /
+        OS_PNPDRIVER   HcdDriver;     / * the OS driver for this HCD * /
+        SDDMA_DESCRIPTION Dma;        / * driver DMA description * /
+    }SDHCD_DRIVER, *PSDHCD_DRIVER;
+
+    typedef struct _SDHCD_DRIVER_CONTEXT {
+        PTEXT        pDescription;       / * human readable device decsription * /
+        SDLIST       DeviceList;         / * the list of current devices handled by this driver * /
+        OS_SEMAPHORE DeviceListSem;      / * protection for the DeviceList * /
+        UINT         DeviceCount;        / * number of devices currently installed * /
+        SDHCD_DRIVER Driver;             / * OS dependent driver specific info * /
+    }SDHCD_DRIVER_CONTEXT, *PSDHCD_DRIVER_CONTEXT;
+
+    static SDHCD_DRIVER_CONTEXT HcdContext = {
+        .pDescription  = DESCRIPTION,
+        .DeviceCount   = 0,
+        .Driver.HcdDevice.name = "sdio_xxx_hcd",
+        .Driver.HcdDriver.name = "sdio_xxx_hcd",
+    }
+    .....
+    status = SDIO_BusAddOSDevice(NULL, &HcdContext.Driver, &HcdContext.Device);
+    if (SDIO_SUCCESS(status) {
+        return Probe(&HcdContext.Device);
+    }
+    return SDIOErrorToOSError(status);
+
+  @see also: SDIO_BusRemoveOSDevice
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS SDIO_BusAddOSDevice(PSDDMA_DESCRIPTION pDma, POS_PNPDRIVER pDriver, POS_PNPDEVICE pDevice)
+{
+#ifdef SDIO_USE_LINUX_PNP
+    int err;
+    struct pnp_id *pFdname;
+    struct pnp_device_id *pFdid;
+    static int slotNumber = 0; /* we just use an increasing count for the slots number */
+
+    if (pDma != NULL) {
+        pDevice->dev.dma_mask = &pDma->Mask;
+        pDevice->dev.coherent_dma_mask = pDma->Mask;
+    }
+    DBG_PRINT(SDDBG_ERROR,
+            ("SDIO BusDriver - SDIO_GetBusOSDevice, registering driver: %s DMAmask: 0x%x\n",
+            pDriver->name, (UINT)*pDevice->dev.dma_mask));
+    pFdid = KernelAlloc(sizeof(struct pnp_device_id)*2);
+    /* set the id as slot number/function number */
+    snprintf(pFdid[0].id, sizeof(pFdid[0].id), "SD_%02X08",
+             slotNumber++);
+    pFdid[0].driver_data = 0;
+    pFdid[1].id[0] = '\0';
+    pFdid[1].driver_data = 0;
+
+    pDriver->id_table = pFdid;
+    pDriver->flags = PNP_DRIVER_RES_DO_NOT_CHANGE;
+    err = pnp_register_driver(pDriver);
+    if (err < 0) {
+        DBG_PRINT(SDDBG_ERROR,
+            ("SDIO BusDriver - SDIO_GetBusOSDevice, failed registering driver: %s, err: %d\n",
+            pDriver->name, err));
+        return OSErrorToSDIOError(err);
+    }
+
+    pDevice->protocol = &sdio_protocol;
+    pDevice->capabilities = PNP_REMOVABLE | PNP_DISABLE;
+    pDevice->active = 1;
+
+    pFdname = KernelAlloc(sizeof(struct pnp_id));
+    /* set the id as slot number/function number */
+    snprintf(pFdname->id, sizeof(pFdname->id), "SD_%02X08",
+             0); //??pDevice->pHcd->SlotNumber);//?????fix this, slotnumber isn't vaialble yet
+    pFdname->next = NULL;
+    pnp_add_id(pFdname, pDevice);
+
+    /* get a unique device number */
+    spin_lock(&InUseDevicesLock);
+    pDevice->number = FirstClearBit(&InUseDevices);
+    SetBit(&InUseDevices, pDevice->number);
+    spin_unlock(&InUseDevicesLock);
+    pnp_init_resource_table(&pDevice->res);
+    err = pnp_add_device(pDevice);
+    if (err < 0) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO BusDriver - SDIO_GetBusOSDevice failed pnp_device_add: %d\n",
+                               err));
+        pnp_unregister_driver(pDriver);
+    }
+    /* replace the buggy pnp's release */
+    pDevice->dev.release = release;
+    return OSErrorToSDIOError(err);
+#else
+    return SDIO_STATUS_SUCCESS;
+#endif
+}
+
+/**+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Return OS device from bus driver.
+
+  @function name: SDIO_BusRemoveOSDevice
+  @category: HD_Reference
+
+  @input: pDriver - setup PNP driver object
+  @input: pDevice - setup PNP device object
+
+  @return: none
+
+
+  @example: returning device objects:
+        SDIO_BusRemoveOSDevice(&HcdContext.Driver, &HcdContext.Device);
+
+
+  @see also: SDIO_BusAddOSDevice
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void SDIO_BusRemoveOSDevice(POS_PNPDRIVER pDriver, POS_PNPDEVICE pDevice)
+{
+#ifdef SDIO_USE_LINUX_PNP
+    DBG_PRINT(SDDBG_ERROR,
+            ("SDIO BusDriver - SDIO_PutBusOSDevice, unregistering driver: %s\n",
+            pDriver->name));
+
+    pnp_remove_device(pDevice);
+    if (pDevice->id != NULL) {
+        KernelFree(pDevice->id);
+        pDevice->id = NULL;
+    }
+
+    spin_lock(&InUseDevicesLock);
+    ClearBit(&InUseDevices, pDevice->number);
+    spin_unlock(&InUseDevicesLock);
+
+    pnp_unregister_driver(pDriver);
+    if (pDriver->id_table != NULL) {
+        KernelFree((void *)pDriver->id_table);
+        pDriver->id_table = NULL;
+    }
+#endif
+}
+
+
+/*
+ * module init
+*/
+static int __init sdio_busdriver_init(void) {
+    SDIO_STATUS status;
+#ifdef SDIO_USE_LINUX_PNP
+    int error = 0;
+#endif
+    REL_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: loaded\n"));
+    if (!SDIO_SUCCESS((status = _SDIO_BusDriverInitialize()))) {
+        return SDIOErrorToOSError(status);
+    }
+#ifdef SDIO_USE_LINUX_PNP
+    /* register the sdio bus */
+    error = pnp_register_protocol(&sdio_protocol);
+    if (error < 0) {
+        REL_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: failed to register bus device, %d\n", error));
+        _SDIO_BusDriverCleanup();
+        return error;
+    }
+#endif
+    sema_init(&athsdio_init_lock, 1);
+    return 0;
+}
+
+/*
+ * module cleanup
+*/
+static void __exit sdio_busdriver_cleanup(void) {
+    REL_PRINT(SDDBG_TRACE, ("SDIO unloaded\n"));
+    _SDIO_BusDriverCleanup();
+#ifdef SDIO_USE_LINUX_PNP
+    pnp_unregister_protocol(&sdio_protocol);
+#endif
+DBG_PRINT(SDDBG_TRACE,
+            ("SDIO BusDriver - unloaded 1\n"));
+}
+EXPORT_SYMBOL(SDIO_BusAddOSDevice);
+EXPORT_SYMBOL(SDIO_BusRemoveOSDevice);
+
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    /* 2.4 */
+static int RegisterDriver(PSDFUNCTION pFunction)
+{
+    return 0;
+}
+
+static int UnregisterDriver(PSDFUNCTION pFunction)
+{
+    DBG_PRINT(SDDBG_TRACE,
+            ("+-SDIO BusDriver - UnregisterDriver, driver: \n"));
+   return 0;
+}
+
+/*
+ * OS_InitializeDevice - initialize device that will be registered
+*/
+SDIO_STATUS OS_InitializeDevice(PSDDEVICE pDevice, PSDFUNCTION pFunction)
+{
+    return SDIO_STATUS_SUCCESS;
+}
+
+/*
+ * OS_AddDevice - must be pre-initialized with OS_InitializeDevice
+*/
+SDIO_STATUS OS_AddDevice(PSDDEVICE pDevice, PSDFUNCTION pFunction)
+{
+    DBG_PRINT(SDDBG_TRACE, ("SDIO BusDriver - OS_AddDevice adding function: %s\n",
+                               pFunction->pName));
+    return SDIO_STATUS_SUCCESS;
+
+}
+
+/*
+ * OS_RemoveDevice - unregister device with driver and bus
+*/
+void OS_RemoveDevice(PSDDEVICE pDevice)
+{
+    DBG_PRINT(SDDBG_TRACE, ("SDIO BusDriver - OS_RemoveDevice \n"));
+}
+
+/*
+ * module init
+*/
+static int __init sdio_busdriver_init(void) {
+    SDIO_STATUS status;
+    REL_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: loaded\n"));
+    if (!SDIO_SUCCESS((status = _SDIO_BusDriverInitialize()))) {
+        return SDIOErrorToOSError(status);
+    }
+    return 0;
+}
+
+/*
+ * module cleanup
+*/
+static void __exit sdio_busdriver_cleanup(void) {
+    REL_PRINT(SDDBG_TRACE, ("SDIO unloaded\n"));
+    _SDIO_BusDriverCleanup();
+}
+#else  ////KERNEL_VERSION
+#error "unsupported kernel version: "UTS_RELEASE
+#endif //KERNEL_VERSION
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_DESCRIPTION(DESCRIPTION);
+MODULE_AUTHOR(AUTHOR);
+
+module_init(sdio_busdriver_init);
+module_exit(sdio_busdriver_cleanup);
+EXPORT_SYMBOL(SDIO_RegisterHostController);
+EXPORT_SYMBOL(SDIO_UnregisterHostController);
+EXPORT_SYMBOL(SDIO_HandleHcdEvent);
+EXPORT_SYMBOL(SDIO_CheckResponse);
+EXPORT_SYMBOL(SDIO_RegisterFunction);
+EXPORT_SYMBOL(SDIO_UnregisterFunction);
+
+EXPORT_SYMBOL(athsdio_init_lock);
Index: linux-2.6/drivers/sdio/busdriver/sdio_function.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/busdriver/sdio_function.c
@@ -0,0 +1,715 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdio_function.c
+
+@abstract: OS independent bus driver support for function drivers
+
+@notes: This file supports the interface between SDIO function drivers and the bus driver.
+
+@notice: Copyright (c), 2004-2005 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define MODULE_NAME  SDBUSDRIVER
+#include <linux/sdio/ctsystem.h>
+#include <linux/sdio/sdio_busdriver.h>
+#include <linux/sdio/sdio_lib.h>
+#include "_busdriver.h"
+
+static SDIO_STATUS ProbeForDevice(PSDFUNCTION pFunction);
+
+#ifdef CT_MAN_CODE_CHECK
+static UINT16 ManCodeCheck = CT_MAN_CODE_CHECK;
+#endif
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Register a function driver with the bus driver.
+
+  @function name: SDIO_RegisterFunction
+  @prototype: SDIO_STATUS SDIO_RegisterFunction(PSDFUNCTION pFunction)
+  @category: PD_Reference
+  @input:  pFunction - the function definition structure.
+
+  @output: none
+
+  @return: SDIO_STATUS - SDIO_STATUS_SUCCESS when succesful.
+
+  @notes: Each function driver must register with the bus driver once upon loading.
+          The calling function must be prepared to receive a Probe callback before
+          this function returns. This will occur when an perpheral device is already
+          pluugged in that is supported by this function.
+          The function driver should unregister itself when exiting.
+          The bus driver checks for possible function drivers to support a device
+          in reverse registration order.
+
+  @example: Registering a function driver:
+            //list of devices supported by this function driver
+       static SD_PNP_INFO Ids[] = {
+            {.SDIO_ManufacturerID = 0xaa55,
+             .SDIO_ManufacturerCode = 0x5555,
+             .SDIO_FunctionNo = 1},
+            {}                      //list is null termintaed
+        };
+        static GENERIC_FUNCTION_CONTEXT FunctionContext = {
+            .Function.pName    = "sdio_generic", //name of the device
+            .Function.Version  = CT_SDIO_STACK_VERSION_CODE, // set stack version
+            .Function.MaxDevices = 1,    //maximum number of devices supported by this driver
+            .Function.NumDevices = 0,    //current number of devices, always zero to start
+            .Function.pIds     = Ids,    //the list of devices supported by this device
+            .Function.pProbe   = Probe,  //pointer to the function drivers Probe function
+                                         //  that will be called when a possibly supported device
+                                         //  is inserted.
+            .Function.pRemove  = Remove, //pointer to the function drivers Remove function
+                                         /  that will be called when a device is removed.
+            .Function.pContext = &FunctionContext, //data value that will be passed into Probe and
+                                         //  Remove callbacks.
+        };
+        SDIO_STATUS status;
+        status = SDIO_RegisterFunction(&FunctionContext.Function)
+        if (!SDIO_SUCCESS(status)) {
+            ...failed to register
+        }
+
+  @see also: SDIO_UnregisterFunction
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS _SDIO_RegisterFunction(PSDFUNCTION pFunction)
+{
+	SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+
+#ifdef CT_MAN_CODE_CHECK
+    DBG_PRINT(SDDBG_TRACE,
+        ("SDIO Bus Driver: _SDIO_RegisterFunction: WARNING, this version is locked to Memory cards and SDIO cards with JEDEC IDs of: 0x%X\n",
+            ManCodeCheck));
+#else
+    DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: _SDIO_RegisterFunction\n"));
+#endif
+
+	DBG_PRINT(SDDBG_TRACE, ("+SDIO Bus Driver: Function Driver Stack Version: %d.%d \n",
+        GET_SDIO_STACK_VERSION_MAJOR(pFunction),GET_SDIO_STACK_VERSION_MINOR(pFunction)));
+
+    if (!CHECK_FUNCTION_DRIVER_VERSION(pFunction)) {
+        DBG_PRINT(SDDBG_ERROR,
+           ("SDIO Bus Driver: Function Major Version Mismatch (hcd = %d, bus driver = %d)\n",
+           GET_SDIO_STACK_VERSION_MAJOR(pFunction), CT_SDIO_STACK_VERSION_MAJOR(g_Version)));
+        return SDIO_STATUS_INVALID_PARAMETER;
+    }
+
+
+	/* sanity check the driver */
+	if ((pFunction == NULL) ||
+		(pFunction->pProbe == NULL) ||
+		(pFunction->pIds == NULL)) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: _SDIO_RegisterFunction, invalid registration data\n"));
+	    return SDIO_STATUS_INVALID_PARAMETER;
+	}
+    /* protect the function list and add the function */
+    if (!SDIO_SUCCESS((status = SemaphorePendInterruptable(&pBusContext->FunctionListSem)))) {
+      goto cleanup;   /* wait interrupted */
+    }
+    SignalInitialize(&pFunction->CleanupReqSig);
+    SDLIST_INIT(&pFunction->DeviceList);
+    SDListAdd(&pBusContext->FunctionList, &pFunction->SDList);
+    if (!SDIO_SUCCESS((status = SemaphorePost(&pBusContext->FunctionListSem)))) {
+      goto cleanup;   /* wait interrupted */
+    }
+
+	/* see if we have devices for this new function driver */
+	ProbeForDevice(pFunction);
+
+	return status;
+cleanup:
+    DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: _SDIO_RegisterFunction, error exit 0x%X\n", status));
+    return status;
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Unregister a function driver with the bus driver.
+
+  @function name: SDIO_UnregisterFunction
+  @prototype: SDIO_STATUS SDIO_UnregisterFunction(PSDFUNCTION pFunction)
+  @category: PD_Reference
+
+  @input:  pFunction - the function definition structure.
+
+  @output: none
+
+  @return: SDIO_STATUS - SDIO_STATUS_SUCCESS when succesful.
+
+  @notes: Each function driver must unregister from the bus driver when the function driver
+          exits.
+          A function driver must disconnect from any interrupts before calling this function.
+
+  @example: Unregistering a function driver:
+        SDIO_UnregisterFunction(&FunctionContext.Function);
+
+  @see also: SDIO_RegisterFunction
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS _SDIO_UnregisterFunction(PSDFUNCTION pFunction)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    PSDDEVICE pDevice;
+
+    DBG_PRINT(SDDBG_TRACE, ("+SDIO Bus Driver: _SDIO_UnregisterFunction\n"));
+
+    /* protect the function list and synchronize with Probe() and Remove()*/
+    if (!SDIO_SUCCESS((status = SemaphorePendInterruptable(&pBusContext->FunctionListSem)))) {
+        goto cleanup;   /* wait interrupted */
+    }
+        /* remove this function from the function list */
+    SDListRemove(&pFunction->SDList);
+        /* now remove this function as the handler for any of its devices */
+    SDITERATE_OVER_LIST_ALLOW_REMOVE(&pFunction->DeviceList, pDevice, SDDEVICE,FuncListLink)  {
+        if (pDevice->pFunction == pFunction) {
+                /* notify removal */
+            NotifyDeviceRemove(pDevice);
+        }
+    }SDITERATE_END;
+
+    SignalDelete(&pFunction->CleanupReqSig);
+
+    if (!SDIO_SUCCESS((status = SemaphorePost(&pBusContext->FunctionListSem)))) {
+        goto cleanup;   /* wait interrupted */
+    }
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO Bus Driver: _SDIO_UnregisterFunction\n"));
+	return status;
+
+cleanup:
+    DBG_PRINT(SDDBG_ERROR, ("-SDIO Bus Driver: _SDIO_UnregisterFunction, error exit 0x%X\n", status));
+    return status;
+}
+
+/* documentation headers only for Probe and Remove */
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: This function is called by the Busdriver when a device is inserted that can be supported by this function driver.
+
+  @function name: Probe
+  @prototype: BOOL (*pProbe)(struct _SDFUNCTION *pFunction, struct _SDDEVICE *pDevice)
+  @category: PD_Reference
+
+  @input:  pFunction - the function definition structure that was passed to Busdriver
+                       via the SDIO_RegisterFunction.
+  @input:  pDevice   - the description of the newly inserted device.
+
+  @output: none
+
+  @return: TRUE  - this function driver will suport this device
+           FALSE - this function driver will not support this device
+
+  @notes: The Busdriver calls the Probe function of a function driver to inform it that device is
+          available for the function driver to control. The function driver should initialize the
+          device and be pepared to acceopt any interrupts from the device before returning.
+
+  @example: Example of typical Probe function callback:
+  static BOOL Probe(PSDFUNCTION pFunction, PSDDEVICE pDevice) {
+       ...get the our context info passed into the SDIO_RegisterFunction
+    PSDXXX_DRIVER_CONTEXT pFunctionContext =
+                                (PSDXXX_DRIVER_CONTEXT)pFunction->pContext;
+    SDIO_STATUS status;
+       //test the identification of this device and ensure we want to support it
+       // we can test based on class, or use more specific tests on SDIO_ManufacturerID, etc.
+    if (pDevice->pId[0].SDIO_FunctionClass == XXX) {
+        DBG_PRINT(SDDBG_TRACE, ("SDIO XXX Function: Probe - card matched (0x%X/0x%X/0x%X)\n",
+                                pDevice->pId[0].SDIO_ManufacturerID,
+                                pDevice->pId[0].SDIO_ManufacturerCode,
+                                pDevice->pId[0].SDIO_FunctionNo));
+        ...
+
+  @see also: SDIO_RegisterFunction
+  @see also: Remove
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+BOOL FilterPnpInfo(PSDDEVICE pDevice)
+{
+#ifdef CT_MAN_CODE_CHECK
+    if (pDevice->pId[0].CardFlags & CARD_SDIO) {
+        if (pDevice->pId[0].SDIO_ManufacturerCode != ManCodeCheck) {
+            DBG_PRINT(SDDBG_ERROR,
+             ("SDIO Card with JEDEC ID:0x%X , not Allowed! Driver check halted. "
+              "Please Contact sales@codetelligence.com.\n",
+                    pDevice->pId[0].SDIO_ManufacturerCode));
+            return FALSE;
+        }
+    }
+    return TRUE;
+#else
+    return TRUE;
+#endif
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: This function is called by the Busdriver when a device controlled by this function
+             function driver is removed.
+
+  @function name: Remove
+  @prototype: void (*pRemove)(struct _SDFUNCTION *pFunction, struct _SDDEVICE *pDevice)
+  @category: PD_Reference
+
+  @input:  pFunction - the function definition structure that was passed to Busdriver
+                       via the SDIO_RegisterFunction.
+  @input:  pDevice   - the description of the device being removed.
+
+  @output: none
+
+  @return: none
+
+  @notes: The Busdriver calls the Remove function of a function driver to inform it that device it
+          was supporting has been removed. The device has already been removed, so no further I/O
+          to the device can be performed.
+
+  @example: Example of typical Remove function callback:
+    void Remove(PSDFUNCTION pFunction, PSDDEVICE pDevice) {
+            // get the our context info passed into the SDIO_RegisterFunction
+        PSDXXX_DRIVER_CONTEXT pFunctionContext =
+                             (PSDXXX_DRIVER_CONTEXT)pFunction->pContext;
+           ...free any acquired resources.
+
+  @see also: SDIO_RegisterFunction
+  @see also: Probe
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+/*
+ * ProbeForFunction - look for a function driver to handle this card
+ *
+*/
+SDIO_STATUS ProbeForFunction(PSDDEVICE pDevice, PSDHCD pHcd) {
+    SDIO_STATUS status;
+    PSDLIST pList;
+    PSDFUNCTION pFunction;
+
+    DBG_PRINT(SDDBG_TRACE, ("+SDIO Bus Driver: ProbeForFunction\n"));
+    DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: ProbeForFunction - Dump of Device PNP Data: \n"));
+    DBG_PRINT(SDDBG_TRACE, (" Card Flags 0x%X \n", pDevice->pId[0].CardFlags));
+    if (pDevice->pId[0].CardFlags & CARD_SDIO) {
+        DBG_PRINT(SDDBG_TRACE, (" SDIO MANF:      0x%X \n", pDevice->pId[0].SDIO_ManufacturerID));
+        DBG_PRINT(SDDBG_TRACE, (" SDIO MANFCODE:  0x%X \n", pDevice->pId[0].SDIO_ManufacturerCode));
+        DBG_PRINT(SDDBG_TRACE, (" SDIO FuncNo:    %d \n", pDevice->pId[0].SDIO_FunctionNo));
+        DBG_PRINT(SDDBG_TRACE, (" SDIO FuncClass: %d \n", pDevice->pId[0].SDIO_FunctionClass));
+    }
+    if (pDevice->pId[0].CardFlags & (CARD_MMC | CARD_SD)) {
+        DBG_PRINT(SDDBG_TRACE, (" SDMMC MANFID: 0x%X \n",pDevice->pId[0].SDMMC_ManfacturerID));
+        DBG_PRINT(SDDBG_TRACE, (" SDMMC OEMID:  0x%X \n",pDevice->pId[0].SDMMC_OEMApplicationID));
+    }
+
+    if (!FilterPnpInfo(pDevice)) {
+        status = SDIO_STATUS_SUCCESS;
+        goto cleanup;
+    }
+
+    /* protect the function list */
+    if (!SDIO_SUCCESS((status = SemaphorePendInterruptable(&pBusContext->FunctionListSem)))) {
+        goto cleanup;   /* wait interrupted */
+    }
+
+    /* protect against ProbeForDevice */
+    if (!SDIO_SUCCESS((status = SemaphorePendInterruptable(&pBusContext->DeviceListSem)))) {
+            /* release the function list semaphore we just took */
+        SemaphorePost(&pBusContext->FunctionListSem);
+        goto cleanup;
+    }
+
+    if (pDevice->pFunction != NULL) {
+            /* device already has a function driver handling it */
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: ProbeForFunction, device already has function\n"));
+            /* release function list */
+        SemaphorePost(&pBusContext->DeviceListSem);
+            /* release function list */
+        SemaphorePost(&pBusContext->FunctionListSem);
+            /* just return success */
+        status = SDIO_STATUS_SUCCESS;
+        goto cleanup;
+    }
+
+        /* release device list */
+    SemaphorePost(&pBusContext->DeviceListSem);
+
+    /* walk functions looking for one that can handle this device */
+    SDITERATE_OVER_LIST(&pBusContext->FunctionList, pList) {
+        pFunction = CONTAINING_STRUCT(pList, SDFUNCTION, SDList);
+        if (pFunction->NumDevices >=  pFunction->MaxDevices) {
+            /* function can't support any more devices */
+            continue;
+        }
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: ProbeForFunction - checking: %s \n",
+                                pFunction->pName));
+
+        /* see if this function handles this device */
+        if (IsPotentialIdMatch(pDevice->pId, pFunction->pIds)) {
+            if (!FilterPnpInfo(pDevice)) {
+                break;
+            }
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: ProbeForFunction -Got Match, probing: %s \n",
+                                    pFunction->pName));
+            /* we need to setup with the OS bus driver before the probe, so probe can
+              do OS operations. */
+            OS_InitializeDevice(pDevice, pFunction);
+            if (!SDIO_SUCCESS(OS_AddDevice(pDevice, pFunction))) {
+                break;
+            }
+            /* close enough match, ask the function driver if it supports us */
+            if (pFunction->pProbe(pFunction, pDevice)) {
+                /* she accepted the device, add to list */
+                pDevice->pFunction = pFunction;
+                SDListAdd(&pFunction->DeviceList, &pDevice->FuncListLink);
+                pFunction->NumDevices++;
+                break;
+            } else {
+                DBG_PRINT(SDDBG_WARN, ("SDIO Bus Driver: %s did not claim the device \n",
+                  pFunction->pName));
+                /* didn't take this device */
+                OS_RemoveDevice(pDevice);
+            }
+
+        }
+    }
+    if (!SDIO_SUCCESS((status = SemaphorePost(&pBusContext->FunctionListSem)))) {
+        goto cleanup;   /* wait interrupted */
+    }
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO Bus Driver: ProbeForFunction\n"));
+	return status;
+cleanup:
+    DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: ProbeForFunction, error exit 0x%X\n", status));
+    return status;
+}
+
+/*
+ * ProbeForDevice - look for a device that this function driver supports
+ *
+*/
+static SDIO_STATUS ProbeForDevice(PSDFUNCTION pFunction) {
+    SDIO_STATUS status;
+    PSDLIST pList;
+    PSDDEVICE pDevice;
+
+    DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: ProbeForDevice\n"));
+    if (pFunction->NumDevices >=  pFunction->MaxDevices) {
+        /* function can't support any more devices */
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: ProbeForDevice, too many devices in function\n"));
+        return SDIO_STATUS_SUCCESS;
+    }
+
+     /* protect the driver list */
+    if (!SDIO_SUCCESS((status = SemaphorePendInterruptable(&pBusContext->DeviceListSem)))) {
+      goto cleanup;   /* wait interrupted */
+    }
+    /* walk device list */
+    SDITERATE_OVER_LIST(&pBusContext->DeviceList, pList) {
+        pDevice = CONTAINING_STRUCT(pList, SDDEVICE, SDList);
+        if (pDevice->pFunction != NULL) {
+            /* device already has a function driver handling it */
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: ProbeForDevice, device already has function\n"));
+            continue;
+        }
+        /* see if this function handles this device */
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: ProbeForDevice, matching ID:%d %d class:%d\n",
+                                pDevice->pId[0].SDIO_ManufacturerID,
+                                pDevice->pId[0].SDIO_FunctionNo,
+                                pDevice->pId[0].SDIO_FunctionClass));
+        if (IsPotentialIdMatch(pDevice->pId, pFunction->pIds)) {
+            if (!FilterPnpInfo(pDevice)) {
+                break;
+            }
+            /* we need to setup with the OS bus driver before the probe, so probe can
+              do OS operations. */
+            OS_InitializeDevice(pDevice, pFunction);
+            if (!SDIO_SUCCESS(OS_AddDevice(pDevice, pFunction))) {
+                break;
+            }
+            /* close enough match, ask the function driver if it supports us */
+            if (pFunction->pProbe(pFunction, pDevice)) {
+                /* she accepted the device, add to list */
+                pDevice->pFunction = pFunction;
+                SDListAdd(&pFunction->DeviceList, &pDevice->FuncListLink);
+                pFunction->NumDevices++;
+                break;
+            } else {
+                DBG_PRINT(SDDBG_WARN, ("SDIO Bus Driver: %s did not claim the device \n",
+                  pFunction->pName));
+                /* didn't take this device */
+                OS_RemoveDevice(pDevice);
+            }
+        }
+    }
+    if (!SDIO_SUCCESS((status = SemaphorePost(&pBusContext->DeviceListSem)))) {
+      goto cleanup;   /* wait interrupted */
+    }
+
+	return status;
+cleanup:
+    DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: ProbeForDevice, error exit 0x%X\n", status));
+    return status;
+}
+
+#if 0
+static void DumpPnpEntry(PSD_PNP_INFO pInfo)
+{
+    DBG_PRINT(SDDBG_TRACE, ("Function PnpInfo Dump: \n"));
+    DBG_PRINT(SDDBG_TRACE, (" Card Flags      0x%X \n", pInfo->CardFlags));
+    DBG_PRINT(SDDBG_TRACE, (" SDIO MANF:      0x%X \n", pInfo->SDIO_ManufacturerID));
+    DBG_PRINT(SDDBG_TRACE, (" SDIO MANFCODE:  0x%X \n", pInfo->SDIO_ManufacturerCode));
+    DBG_PRINT(SDDBG_TRACE, (" SDIO FuncNo:    %d \n", pInfo->SDIO_FunctionNo));
+    DBG_PRINT(SDDBG_TRACE, (" SDIO FuncClass: %d \n", pInfo->SDIO_FunctionClass));
+    DBG_PRINT(SDDBG_TRACE, (" SDMMC MANFID:   0x%X \n", pInfo->SDMMC_ManfacturerID));
+    DBG_PRINT(SDDBG_TRACE, (" SDMMC OEMID:    0x%X \n", pInfo->SDMMC_OEMApplicationID));
+}
+#endif
+/*
+ * IsPotentialIdMatch - test for potential device match
+ *
+*/
+BOOL IsPotentialIdMatch(PSD_PNP_INFO pIdsDev, PSD_PNP_INFO pIdsFuncList) {
+    PSD_PNP_INFO pTFn;
+	BOOL match = FALSE;
+
+	for (pTFn = pIdsFuncList;!IS_LAST_SDPNPINFO_ENTRY(pTFn);pTFn++) {
+        //DumpPnpEntry(pTFn);
+            /* check specific SDIO Card manufacturer ID, Code and Function number */
+		if ((pIdsDev->SDIO_ManufacturerID != 0) &&
+		    (pTFn->SDIO_ManufacturerID != 0) &&
+		    (pIdsDev->SDIO_ManufacturerID == pTFn->SDIO_ManufacturerID) &&
+		    (pIdsDev->SDIO_ManufacturerCode == pTFn->SDIO_ManufacturerCode) &&
+            ((pIdsDev->SDIO_FunctionNo == pTFn->SDIO_FunctionNo) ||
+             (pTFn->SDIO_FunctionNo == 0)) ) {
+		    match = TRUE;
+            break;
+		}
+            /* check generic function class */
+        if ((pIdsDev->SDIO_FunctionClass != 0) &&
+            (pTFn->SDIO_FunctionClass != 0) &&
+            (pIdsDev->SDIO_FunctionClass == pTFn->SDIO_FunctionClass)) {
+            match = TRUE;
+            break;
+        }
+            /* check specific SDMMC MANFID and APPLICATION ID, NOTE SANDISK
+             * uses a MANFID of zero! */
+        if ((pTFn->SDMMC_OEMApplicationID != 0) &&
+            (pIdsDev->SDMMC_ManfacturerID == pTFn->SDMMC_ManfacturerID) &&
+            (pIdsDev->SDMMC_OEMApplicationID == pTFn->SDMMC_OEMApplicationID)) {
+            match = TRUE;
+            break;
+        }
+
+            /* check generic SD Card */
+        if ((pIdsDev->CardFlags & CARD_SD) &&
+            (pTFn->CardFlags & CARD_SD)){
+            match = TRUE;
+            break;
+        }
+
+            /* check generic MMC Card */
+        if ((pIdsDev->CardFlags & CARD_MMC) &&
+            (pTFn->CardFlags & CARD_MMC)){
+            match = TRUE;
+            break;
+        }
+
+             /* check raw Card */
+        if ((pIdsDev->CardFlags & CARD_RAW) &&
+            (pTFn->CardFlags & CARD_RAW)){
+            match = TRUE;
+            break;
+        }
+	}
+
+    return match;
+}
+
+/*
+ * NotifyDeviceRemove - tell function driver on this device that the device is being removed
+ *
+*/
+SDIO_STATUS NotifyDeviceRemove(PSDDEVICE pDevice) {
+    SDIO_STATUS     status;
+    SDREQUESTQUEUE  cancelQueue;
+    PSDREQUEST      pReq;
+    CT_DECLARE_IRQ_SYNC_CONTEXT();
+
+    InitializeRequestQueue(&cancelQueue);
+
+	if ((pDevice->pFunction != NULL) &&
+        (pDevice->pFunction->pRemove != NULL)){
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: removing device 0x%X\n", (INT)pDevice));
+            /* fail any outstanding requests for this device */
+            /* acquire lock for request queue */
+        status = _AcquireHcdLock(pDevice->pHcd);
+        if (!SDIO_SUCCESS(status)) {
+            return status;
+        }
+            /* mark the function to block any more requests comming down */
+        pDevice->pFunction->Flags |= SDFUNCTION_FLAG_REMOVING;
+            /* walk through HCD queue and remove this function's requests */
+        SDITERATE_OVER_LIST_ALLOW_REMOVE(&pDevice->pHcd->RequestQueue.Queue, pReq, SDREQUEST, SDList) {
+            if (pReq->pFunction == pDevice->pFunction) {
+                /* cancel this request, as this device or function is being removed */
+                /* note that these request are getting completed out of order */
+                DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver - NotifyDeviceRemove: canceling req 0x%X\n", (UINT)pReq));
+                pReq->Status = SDIO_STATUS_CANCELED;
+                    /* remove it from the HCD queue */
+                SDListRemove(&pReq->SDList);
+                    /* add it to the cancel queue */
+                QueueRequest(&cancelQueue, pReq);
+            }
+        }SDITERATE_END;
+
+        status = _ReleaseHcdLock(pDevice->pHcd);
+
+           /* now empty the cancel queue if anything is in there */
+        while (TRUE) {
+            pReq = DequeueRequest(&cancelQueue);
+            if (NULL == pReq) {
+                break;
+            }
+                /* complete the request */
+            DoRequestCompletion(pReq, pDevice->pHcd);
+        }
+            /* re-acquire the lock to deal with the current request */
+        status = _AcquireHcdLock(pDevice->pHcd);
+        if (!SDIO_SUCCESS(status)) {
+            return status;
+        }
+            /* now deal with the current request */
+        pReq = GET_CURRENT_REQUEST(pDevice->pHcd);
+        if ((pReq !=NULL) && (pReq->pFunction == pDevice->pFunction) && (pReq->pFunction != NULL)) {
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver - NotifyDeviceRemove: Outstanding Req 0x%X on HCD: 0x%X.. waiting...\n",
+                (UINT)pReq, (UINT)pDevice->pHcd));
+                /* the outstanding request on this device is for the function being removed */
+            pReq->Flags |= SDREQ_FLAGS_CANCELED;
+                /* wait for this request to get completed normally */
+            status = _ReleaseHcdLock(pDevice->pHcd);
+            SignalWait(&pDevice->pFunction->CleanupReqSig);
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver - NotifyDeviceRemove: Outstanding HCD Req 0x%X completed \n", (UINT)pReq));
+        }  else {
+                /* release lock */
+            status = _ReleaseHcdLock(pDevice->pHcd);
+        }
+
+            /* synchronize with ISR SYNC Handlers */
+	 	status = SemaphorePendInterruptable(&pBusContext->DeviceListSem);
+        if (!SDIO_SUCCESS(status)) {
+            return status;
+        }
+            /* call this devices Remove function */
+        pDevice->pFunction->pRemove(pDevice->pFunction,pDevice);
+        pDevice->pFunction->NumDevices--;
+            /* make sure the sync handler is NULLed out */
+        pDevice->pIrqFunction = NULL;
+        SemaphorePost(&pBusContext->DeviceListSem);
+
+        OS_RemoveDevice(pDevice);
+            /* detach this device from the function list it belongs to */
+        SDListRemove(&pDevice->FuncListLink);
+        pDevice->pFunction->Flags &= ~SDFUNCTION_FLAG_REMOVING;
+		pDevice->pFunction = NULL;
+	}
+	return SDIO_STATUS_SUCCESS;
+}
+
+
+/*
+ * RemoveHcdFunctions - remove all functions attached to an HCD
+ *
+*/
+SDIO_STATUS RemoveHcdFunctions(PSDHCD pHcd) {
+    SDIO_STATUS status;
+    PSDLIST pList;
+    PSDFUNCTION pFunction;
+    PSDDEVICE pDevice;
+    DBG_PRINT(SDDBG_TRACE, ("+SDIO Bus Driver: RemoveHcdFunctions\n"));
+
+    /* walk through the functions and remove the ones associated with this HCD */
+    /* protect the driver list */
+    if (!SDIO_SUCCESS((status = SemaphorePend(&pBusContext->FunctionListSem)))) {
+        goto cleanup;   /* wait interrupted */
+    }
+        /* mark that card is being removed */
+    pHcd->CardProperties.CardState |= CARD_STATE_REMOVED;
+    SDITERATE_OVER_LIST(&pBusContext->FunctionList, pList) {
+        pFunction = CONTAINING_STRUCT(pList, SDFUNCTION, SDList);
+        DBG_PRINT(SDDBG_TRACE, ("SDIO Bus Driver: scanning function 0x%X, %s\n", (INT)pFunction,
+                                (pFunction == NULL)?"NULL":pFunction->pName));
+
+        /* walk the devices on this function and look for a match */
+        SDITERATE_OVER_LIST_ALLOW_REMOVE(&pFunction->DeviceList, pDevice, SDDEVICE,FuncListLink) {
+            if (pDevice->pHcd == pHcd) {
+                /* match, remove it */
+                NotifyDeviceRemove(pDevice);
+            }
+        SDITERATE_END;
+    SDITERATE_END;
+    if (!SDIO_SUCCESS((status = SemaphorePost(&pBusContext->FunctionListSem)))) {
+        goto cleanup;   /* wait interrupted */
+    }
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO Bus Driver: RemoveHcdFunctions\n"));
+    return SDIO_STATUS_SUCCESS;
+
+cleanup:
+    DBG_PRINT(SDDBG_ERROR, ("-SDIO Bus Driver: RemoveHcdFunctions, error exit 0x%X\n", status));
+    return status;
+}
+
+/*
+ * RemoveAllFunctions - remove all functions attached
+ *
+*/
+SDIO_STATUS RemoveAllFunctions()
+{
+    SDIO_STATUS status;
+    PSDLIST pList;
+    PSDHCD pHcd;
+
+    /* walk through the HCDs  */
+    /* protect the driver list */
+    if (!SDIO_SUCCESS((status = SemaphorePend(&pBusContext->HcdListSem)))) {
+        goto cleanup;   /* wait interrupted */
+    }
+    SDITERATE_OVER_LIST(&pBusContext->HcdList, pList) {
+        pHcd = CONTAINING_STRUCT(pList, SDHCD, SDList);
+            /* remove the functions */
+        RemoveHcdFunctions(pHcd);
+    }
+    if (!SDIO_SUCCESS((status = SemaphorePost(&pBusContext->HcdListSem)))) {
+        goto cleanup;   /* wait interrupted */
+    }
+    return SDIO_STATUS_SUCCESS;
+cleanup:
+    DBG_PRINT(SDDBG_ERROR, ("SDIO Bus Driver: RemoveAllFunctions, error exit 0x%X\n", status));
+    return status;
+}
+
Index: linux-2.6/drivers/sdio/functions/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/Kconfig
@@ -0,0 +1,13 @@
+
+menu "SDIO function drivers"
+
+
+config SDIO_AR6000_WLAN
+        tristate "ar6000 wireless networking over sdio"
+        default m
+        help
+          good luck.
+
+
+endmenu
+
Index: linux-2.6/drivers/sdio/functions/Makefile
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/Makefile
@@ -0,0 +1,5 @@
+#
+# SDIO function drivers Makefile
+#
+obj-$(CONFIG_SDIO_AR6000_WLAN)          += wlan/
+
Index: linux-2.6/drivers/sdio/functions/wlan/Makefile
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/Makefile
@@ -0,0 +1,5 @@
+#
+# SDIO wlan ar600 card function driver
+#
+obj-$(CONFIG_SDIO_AR6000_WLAN)          += ar6000/
+
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/Makefile
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/Makefile
@@ -0,0 +1,39 @@
+#
+# AR6K Kernel Module makefile.
+#
+REV ?= 2
+
+#EXTRA_CFLAGS += -DDEBUG
+
+EXTRA_CFLAGS += -DLINUX -D__KERNEL__ -DHTC_RAW_INTERFACE \
+        -DSEND_EVENT_TO_APP -DUSER_KEYS \
+        -DAR6000REV$(REV) \
+        -DBLOCK_TX_PATH_FLAG \
+
+EXTRA_CFLAGS += -DKERNEL_2_6
+
+obj-dir         := /bmi /htc /hif /wlan /ar6000
+
+obj-$(CONFIG_SDIO_AR6000_WLAN) += ar6000.o
+ar6000-objs += htc/htc.o                \
+        htc/htc_send.o                  \
+        htc/htc_recv.o                  \
+        htc/htc_services.o              \
+        htc/ar6k_events.o               \
+        htc/ar6k.o                      \
+        bmi/bmi.o                       \
+        hif/hif.o                       \
+        ar6000/ar6000_drv.o             \
+        ar6000/ioctl.o                  \
+        ar6000/engine.o                 \
+        ar6000/eeprom.o                 \
+        ar6000/netbuf.o                 \
+        ar6000/wireless_ext.o           \
+        ar6000/ar6000_raw_if.o          \
+        ar6000/common_drv.o             \
+        ar6000/credit_dist.o            \
+        wmi/wmi.o                       \
+        wlan/wlan_node.o                \
+        wlan/wlan_recv_beacon.o         \
+        wlan/wlan_utils.o
+
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/ar6000/ar6000_drv.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/ar6000/ar6000_drv.c
@@ -0,0 +1,3377 @@
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+/*
+ * This driver is a pseudo ethernet driver to access the Atheros AR6000
+ * WLAN Device
+ */
+
+#include "../include/ar6000_drv.h"
+#include "../include/ar6000_diag.h"
+#include "../include/htc.h"
+#include "../include/engine.h"
+
+#ifndef SET_MODULE_OWNER
+#define SET_MODULE_OWNER(dev) do { } while (0)
+#endif
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,21)
+static inline void skb_reset_mac_header(struct sk_buff *skb)
+{
+	skb->mac.raw = skb->data;
+}
+#endif
+
+MODULE_LICENSE("GPL and additional rights");
+
+#ifndef REORG_APTC_HEURISTICS
+#undef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+#endif /* REORG_APTC_HEURISTICS */
+
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+#define APTC_TRAFFIC_SAMPLING_INTERVAL     100  /* msec */
+#define APTC_UPPER_THROUGHPUT_THRESHOLD    3000 /* Kbps */
+#define APTC_LOWER_THROUGHPUT_THRESHOLD    2000 /* Kbps */
+
+typedef struct aptc_traffic_record {
+    A_BOOL timerScheduled;
+    struct timeval samplingTS;
+    unsigned long bytesReceived;
+    unsigned long bytesTransmitted;
+} APTC_TRAFFIC_RECORD;
+
+A_TIMER aptcTimer;
+APTC_TRAFFIC_RECORD aptcTR;
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+
+int bmienable = 0;
+unsigned int bypasswmi = 0;
+#ifdef CONFIG_SDIO_AR6000_WLAN_MODULE
+unsigned int debuglevel = 0;
+#else
+static unsigned int debuglevel = 0;
+#endif
+int tspecCompliance = ATHEROS_COMPLIANCE;
+unsigned int busspeedlow = 0;
+unsigned int onebitmode = 0;
+unsigned int skipflash = 0;
+unsigned int wmitimeout = 2;
+unsigned int wlanNodeCaching = 1;
+unsigned int enableuartprint = 0;
+unsigned int logWmiRawMsgs = 0;
+unsigned int enabletimerwar = 0;
+unsigned int mbox_yield_limit = 99;
+int reduce_credit_dribble = 1 + HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_ONE_HALF;
+int allow_trace_signal = 0;
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+unsigned int testmode =0;
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+module_param(bmienable, int, 0644);
+module_param(bypasswmi, int, 0644);
+module_param(debuglevel, int, 0644);
+module_param(tspecCompliance, int, 0644);
+module_param(onebitmode, int, 0644);
+module_param(busspeedlow, int, 0644);
+module_param(skipflash, int, 0644);
+module_param(wmitimeout, int, 0644);
+module_param(wlanNodeCaching, int, 0644);
+module_param(logWmiRawMsgs, int, 0644);
+module_param(enableuartprint, int, 0644);
+module_param(enabletimerwar, int, 0644);
+module_param(mbox_yield_limit, int, 0644);
+module_param(reduce_credit_dribble, int, 0644);
+module_param(allow_trace_signal, int, 0644);
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+module_param(testmode, int, 0644);
+#endif
+#else
+
+#define __user
+/* for linux 2.4 and lower */
+MODULE_PARM(bmienable,"i");
+MODULE_PARM(bypasswmi,"i");
+MODULE_PARM(debuglevel, "i");
+MODULE_PARM(onebitmode,"i");
+MODULE_PARM(busspeedlow, "i");
+MODULE_PARM(skipflash, "i");
+MODULE_PARM(wmitimeout, "i");
+MODULE_PARM(wlanNodeCaching, "i");
+MODULE_PARM(enableuartprint,"i");
+MODULE_PARM(logWmiRawMsgs, "i");
+MODULE_PARM(enabletimerwar,"i");
+MODULE_PARM(mbox_yield_limit,"i");
+MODULE_PARM(reduce_credit_dribble,"i");
+MODULE_PARM(allow_trace_signal,"i");
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+MODULE_PARM(testmode, "i");
+#endif
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,10)
+/* in 2.6.10 and later this is now a pointer to a uint */
+unsigned int _mboxnum = HTC_MAILBOX_NUM_MAX;
+#define mboxnum &_mboxnum
+#else
+unsigned int mboxnum = HTC_MAILBOX_NUM_MAX;
+#endif
+
+#ifdef DEBUG
+A_UINT32 g_dbg_flags = DBG_DEFAULTS;
+unsigned int debugflags = 0;
+int debugdriver = 1;
+unsigned int debughtc = 128;
+unsigned int debugbmi = 1;
+unsigned int debughif = 2;
+unsigned int txcreditsavailable[HTC_MAILBOX_NUM_MAX] = {0};
+unsigned int txcreditsconsumed[HTC_MAILBOX_NUM_MAX] = {0};
+unsigned int txcreditintrenable[HTC_MAILBOX_NUM_MAX] = {0};
+unsigned int txcreditintrenableaggregate[HTC_MAILBOX_NUM_MAX] = {0};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+module_param(debugflags, int, 0644);
+module_param(debugdriver, int, 0644);
+module_param(debughtc, int, 0644);
+module_param(debugbmi, int, 0644);
+module_param(debughif, int, 0644);
+module_param_array(txcreditsavailable, int, mboxnum, 0644);
+module_param_array(txcreditsconsumed, int, mboxnum, 0644);
+module_param_array(txcreditintrenable, int, mboxnum, 0644);
+module_param_array(txcreditintrenableaggregate, int, mboxnum, 0644);
+#else
+/* linux 2.4 and lower */
+MODULE_PARM(debugflags,"i");
+MODULE_PARM(debugdriver, "i");
+MODULE_PARM(debughtc, "i");
+MODULE_PARM(debugbmi, "i");
+MODULE_PARM(debughif, "i");
+MODULE_PARM(txcreditsavailable, "0-3i");
+MODULE_PARM(txcreditsconsumed, "0-3i");
+MODULE_PARM(txcreditintrenable, "0-3i");
+MODULE_PARM(txcreditintrenableaggregate, "0-3i");
+#endif
+
+#endif /* DEBUG */
+
+unsigned int resetok = 1;
+unsigned int tx_attempt[HTC_MAILBOX_NUM_MAX] = {0};
+unsigned int tx_post[HTC_MAILBOX_NUM_MAX] = {0};
+unsigned int tx_complete[HTC_MAILBOX_NUM_MAX] = {0};
+unsigned int hifBusRequestNumMax = 40;
+unsigned int war23838_disabled = 0;
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+unsigned int enableAPTCHeuristics = 1;
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+module_param_array(tx_attempt, int, mboxnum, 0644);
+module_param_array(tx_post, int, mboxnum, 0644);
+module_param_array(tx_complete, int, mboxnum, 0644);
+module_param(hifBusRequestNumMax, int, 0644);
+module_param(war23838_disabled, int, 0644);
+module_param(resetok, int, 0644);
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+module_param(enableAPTCHeuristics, int, 0644);
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+#else
+MODULE_PARM(tx_attempt, "0-3i");
+MODULE_PARM(tx_post, "0-3i");
+MODULE_PARM(tx_complete, "0-3i");
+MODULE_PARM(hifBusRequestNumMax, "i");
+MODULE_PARM(war23838_disabled, "i");
+MODULE_PARM(resetok, "i");
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+MODULE_PARM(enableAPTCHeuristics, "i");
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+#endif
+
+#ifdef BLOCK_TX_PATH_FLAG
+int blocktx = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+module_param(blocktx, int, 0644);
+#else
+MODULE_PARM(blocktx, "i");
+#endif
+#endif /* BLOCK_TX_PATH_FLAG */
+
+
+int reconnect_flag = 0;
+
+/* Function declarations */
+static int ar6000_init_module(void);
+static void ar6000_cleanup_module(void);
+
+int ar6000_init(struct net_device *dev);
+static int ar6000_open(struct net_device *dev);
+static int ar6000_close(struct net_device *dev);
+static void ar6000_init_control_info(AR_SOFTC_T *ar);
+static int ar6000_data_tx(struct sk_buff *skb, struct net_device *dev);
+
+static void ar6000_destroy(struct net_device *dev, unsigned int unregister);
+static void ar6000_detect_error(unsigned long ptr);
+static struct net_device_stats *ar6000_get_stats(struct net_device *dev);
+static struct iw_statistics *ar6000_get_iwstats(struct net_device * dev);
+
+/*
+ * HTC service connection handlers
+ */
+static void ar6000_avail_ev(HTC_HANDLE HTCHandle);
+
+static void ar6000_unavail_ev(void *Instance);
+
+static void ar6000_target_failure(void *Instance, A_STATUS Status);
+
+static void ar6000_rx(void *Context, HTC_PACKET *pPacket);
+
+static void ar6000_rx_refill(void *Context,HTC_ENDPOINT_ID Endpoint);
+
+static void ar6000_tx_complete(void *Context, HTC_PACKET *pPacket);
+
+static HTC_SEND_FULL_ACTION ar6000_tx_queue_full(void *Context, HTC_PACKET *pPacket);
+
+/*
+ * Static variables
+ */
+
+static struct net_device *ar6000_devices[MAX_AR6000];
+extern struct iw_handler_def ath_iw_handler_def;
+DECLARE_WAIT_QUEUE_HEAD(arEvent);
+static void ar6000_cookie_init(AR_SOFTC_T *ar);
+static void ar6000_cookie_cleanup(AR_SOFTC_T *ar);
+static void ar6000_free_cookie(AR_SOFTC_T *ar, struct ar_cookie * cookie);
+static struct ar_cookie *ar6000_alloc_cookie(AR_SOFTC_T *ar);
+static void ar6000_TxDataCleanup(AR_SOFTC_T *ar);
+
+#ifdef USER_KEYS
+static A_STATUS ar6000_reinstall_keys(AR_SOFTC_T *ar,A_UINT8 key_op_ctrl);
+#endif
+
+
+static struct ar_cookie s_ar_cookie_mem[MAX_COOKIE_NUM];
+
+#define HOST_INTEREST_ITEM_ADDRESS(ar, item)    \
+((ar->arTargetType == TARGET_TYPE_AR6001) ?     \
+   AR6001_HOST_INTEREST_ITEM_ADDRESS(item) :    \
+   AR6002_HOST_INTEREST_ITEM_ADDRESS(item))
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+/* Looks like we need this for 2.4 kernels */
+static inline void *netdev_priv(struct net_device *dev)
+{
+    return(dev->priv);
+}
+#endif
+
+/* Debug log support */
+
+/*
+ * Flag to govern whether the debug logs should be parsed in the kernel
+ * or reported to the application.
+ */
+#define REPORT_DEBUG_LOGS_TO_APP
+
+A_STATUS
+ar6000_set_host_app_area(AR_SOFTC_T *ar)
+{
+    A_UINT32 address, data;
+    struct host_app_area_s host_app_area;
+
+    /* Fetch the address of the host_app_area_s instance in the host interest area */
+    address = HOST_INTEREST_ITEM_ADDRESS(ar, hi_app_host_interest);
+    if (ar6000_ReadRegDiag(ar->arHifDevice, &address, &data) != A_OK) {
+        return A_ERROR;
+    }
+    address = data;
+    host_app_area.wmi_protocol_ver = WMI_PROTOCOL_VERSION;
+    if (ar6000_WriteDataDiag(ar->arHifDevice, address,
+                             (A_UCHAR *)&host_app_area,
+                             sizeof(struct host_app_area_s)) != A_OK)
+    {
+        return A_ERROR;
+    }
+
+    return A_OK;
+}
+
+A_UINT32
+dbglog_get_debug_hdr_ptr(AR_SOFTC_T *ar)
+{
+    A_UINT32 param;
+    A_UINT32 address;
+    A_STATUS status;
+
+    address = HOST_INTEREST_ITEM_ADDRESS(ar, hi_dbglog_hdr);
+    if ((status = ar6000_ReadDataDiag(ar->arHifDevice, address,
+                                      (A_UCHAR *)&param, 4)) != A_OK)
+    {
+        param = 0;
+    }
+
+    return param;
+}
+
+/*
+ * The dbglog module has been initialized. Its ok to access the relevant
+ * data stuctures over the diagnostic window.
+ */
+void
+ar6000_dbglog_init_done(AR_SOFTC_T *ar)
+{
+    ar->dbglog_init_done = TRUE;
+}
+
+A_UINT32
+dbglog_get_debug_fragment(A_INT8 *datap, A_UINT32 len, A_UINT32 limit)
+{
+    A_INT32 *buffer;
+    A_UINT32 count;
+    A_UINT32 numargs;
+    A_UINT32 length;
+    A_UINT32 fraglen;
+
+    count = fraglen = 0;
+    buffer = (A_INT32 *)datap;
+    length = (limit >> 2);
+
+    if (len <= limit) {
+        fraglen = len;
+    } else {
+        while (count < length) {
+            numargs = DBGLOG_GET_NUMARGS(buffer[count]);
+            fraglen = (count << 2);
+            count += numargs + 1;
+        }
+    }
+
+    return fraglen;
+}
+
+void
+dbglog_parse_debug_logs(A_INT8 *datap, A_UINT32 len)
+{
+    A_INT32 *buffer;
+    A_UINT32 count;
+    A_UINT32 timestamp;
+    A_UINT32 debugid;
+    A_UINT32 moduleid;
+    A_UINT32 numargs;
+    A_UINT32 length;
+
+    count = 0;
+    buffer = (A_INT32 *)datap;
+    length = (len >> 2);
+    while (count < length) {
+        debugid = DBGLOG_GET_DBGID(buffer[count]);
+        moduleid = DBGLOG_GET_MODULEID(buffer[count]);
+        numargs = DBGLOG_GET_NUMARGS(buffer[count]);
+        timestamp = DBGLOG_GET_TIMESTAMP(buffer[count]);
+        switch (numargs) {
+            case 0:
+            AR_DEBUG_PRINTF("%d %d (%d)\n", moduleid, debugid, timestamp);
+            break;
+
+            case 1:
+            AR_DEBUG_PRINTF("%d %d (%d): 0x%x\n", moduleid, debugid,
+                            timestamp, buffer[count+1]);
+            break;
+
+            case 2:
+            AR_DEBUG_PRINTF("%d %d (%d): 0x%x, 0x%x\n", moduleid, debugid,
+                            timestamp, buffer[count+1], buffer[count+2]);
+            break;
+
+            default:
+            AR_DEBUG_PRINTF("Invalid args: %d\n", numargs);
+        }
+        count += numargs + 1;
+    }
+}
+
+int
+ar6000_dbglog_get_debug_logs(AR_SOFTC_T *ar)
+{
+    struct dbglog_hdr_s debug_hdr;
+    struct dbglog_buf_s debug_buf;
+    A_UINT32 address;
+    A_UINT32 length;
+    A_UINT32 dropped;
+    A_UINT32 firstbuf;
+    A_UINT32 debug_hdr_ptr;
+
+    if (!ar->dbglog_init_done) return A_ERROR;
+
+
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    if (ar->dbgLogFetchInProgress) {
+        AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+        return A_EBUSY;
+    }
+
+        /* block out others */
+    ar->dbgLogFetchInProgress = TRUE;
+
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+
+    debug_hdr_ptr = dbglog_get_debug_hdr_ptr(ar);
+    printk("debug_hdr_ptr: 0x%x\n", debug_hdr_ptr);
+
+    /* Get the contents of the ring buffer */
+    if (debug_hdr_ptr) {
+        address = debug_hdr_ptr;
+        length = sizeof(struct dbglog_hdr_s);
+        ar6000_ReadDataDiag(ar->arHifDevice, address,
+                            (A_UCHAR *)&debug_hdr, length);
+        address = (A_UINT32)debug_hdr.dbuf;
+        firstbuf = address;
+        dropped = debug_hdr.dropped;
+        length = sizeof(struct dbglog_buf_s);
+        ar6000_ReadDataDiag(ar->arHifDevice, address,
+                            (A_UCHAR *)&debug_buf, length);
+
+        do {
+            address = (A_UINT32)debug_buf.buffer;
+            length = debug_buf.length;
+            if ((length) && (debug_buf.length <= debug_buf.bufsize)) {
+                /* Rewind the index if it is about to overrun the buffer */
+                if (ar->log_cnt > (DBGLOG_HOST_LOG_BUFFER_SIZE - length)) {
+                    ar->log_cnt = 0;
+                }
+                if(A_OK != ar6000_ReadDataDiag(ar->arHifDevice, address,
+                                    (A_UCHAR *)&ar->log_buffer[ar->log_cnt], length))
+                {
+                    break;
+                }
+                ar6000_dbglog_event(ar, dropped, &ar->log_buffer[ar->log_cnt], length);
+                ar->log_cnt += length;
+            } else {
+                AR_DEBUG_PRINTF("Length: %d (Total size: %d)\n",
+                                debug_buf.length, debug_buf.bufsize);
+            }
+
+            address = (A_UINT32)debug_buf.next;
+            length = sizeof(struct dbglog_buf_s);
+            if(A_OK != ar6000_ReadDataDiag(ar->arHifDevice, address,
+                                (A_UCHAR *)&debug_buf, length))
+            {
+                break;
+            }
+
+        } while (address != firstbuf);
+    }
+
+    ar->dbgLogFetchInProgress = FALSE;
+
+    return A_OK;
+}
+
+void
+ar6000_dbglog_event(AR_SOFTC_T *ar, A_UINT32 dropped,
+                    A_INT8 *buffer, A_UINT32 length)
+{
+#ifdef REPORT_DEBUG_LOGS_TO_APP
+    #define MAX_WIRELESS_EVENT_SIZE 252
+    /*
+     * Break it up into chunks of MAX_WIRELESS_EVENT_SIZE bytes of messages.
+     * There seems to be a limitation on the length of message that could be
+     * transmitted to the user app via this mechanism.
+     */
+    A_UINT32 send, sent;
+
+    sent = 0;
+    send = dbglog_get_debug_fragment(&buffer[sent], length - sent,
+                                     MAX_WIRELESS_EVENT_SIZE);
+    while (send) {
+        ar6000_send_event_to_app(ar, WMIX_DBGLOG_EVENTID, &buffer[sent], send);
+        sent += send;
+        send = dbglog_get_debug_fragment(&buffer[sent], length - sent,
+                                         MAX_WIRELESS_EVENT_SIZE);
+    }
+#else
+    AR_DEBUG_PRINTF("Dropped logs: 0x%x\nDebug info length: %d\n",
+                    dropped, length);
+
+    /* Interpret the debug logs */
+    dbglog_parse_debug_logs(buffer, length);
+#endif /* REPORT_DEBUG_LOGS_TO_APP */
+}
+
+
+
+static int __init
+ar6000_init_module(void)
+{
+    static int probed = 0;
+    A_STATUS status;
+    HTC_INIT_INFO initInfo;
+
+    A_MEMZERO(&initInfo,sizeof(initInfo));
+    initInfo.AddInstance = ar6000_avail_ev;
+    initInfo.DeleteInstance = ar6000_unavail_ev;
+    initInfo.TargetFailure = ar6000_target_failure;
+
+
+#ifdef DEBUG
+    /* Set the debug flags if specified at load time */
+    if(debugflags != 0)
+    {
+        g_dbg_flags = debugflags;
+    }
+#endif
+
+    if (probed) {
+        return -ENODEV;
+    }
+    probed++;
+
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+    memset(&aptcTR, 0, sizeof(APTC_TRAFFIC_RECORD));
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+
+#ifdef CONFIG_HOST_GPIO_SUPPORT
+    ar6000_gpio_init();
+#endif /* CONFIG_HOST_GPIO_SUPPORT */
+
+    status = HTCInit(&initInfo);
+    if(status != A_OK)
+        return -ENODEV;
+
+    return 0;
+}
+
+static void __exit
+ar6000_cleanup_module(void)
+{
+    int i = 0;
+    struct net_device *ar6000_netdev;
+
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+    /* Delete the Adaptive Power Control timer */
+    if (timer_pending(&aptcTimer)) {
+        del_timer_sync(&aptcTimer);
+    }
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+
+    for (i=0; i < MAX_AR6000; i++) {
+        if (ar6000_devices[i] != NULL) {
+            ar6000_netdev = ar6000_devices[i];
+            ar6000_devices[i] = NULL;
+            ar6000_destroy(ar6000_netdev, 1);
+        }
+    }
+
+        /* shutting down HTC will cause the HIF layer to detach from the
+         * underlying bus driver which will cause the subsequent deletion of
+         * all HIF and HTC instances */
+    HTCShutDown();
+
+    AR_DEBUG_PRINTF("ar6000_cleanup: success\n");
+}
+
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+void
+aptcTimerHandler(unsigned long arg)
+{
+    A_UINT32 numbytes;
+    A_UINT32 throughput;
+    AR_SOFTC_T *ar;
+    A_STATUS status;
+
+    ar = (AR_SOFTC_T *)arg;
+    A_ASSERT(ar != NULL);
+    A_ASSERT(!timer_pending(&aptcTimer));
+
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    /* Get the number of bytes transferred */
+    numbytes = aptcTR.bytesTransmitted + aptcTR.bytesReceived;
+    aptcTR.bytesTransmitted = aptcTR.bytesReceived = 0;
+
+    /* Calculate and decide based on throughput thresholds */
+    throughput = ((numbytes * 8)/APTC_TRAFFIC_SAMPLING_INTERVAL); /* Kbps */
+    if (throughput < APTC_LOWER_THROUGHPUT_THRESHOLD) {
+        /* Enable Sleep and delete the timer */
+        A_ASSERT(ar->arWmiReady == TRUE);
+        AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+        status = wmi_powermode_cmd(ar->arWmi, REC_POWER);
+        AR6000_SPIN_LOCK(&ar->arLock, 0);
+        A_ASSERT(status == A_OK);
+        aptcTR.timerScheduled = FALSE;
+    } else {
+        A_TIMEOUT_MS(&aptcTimer, APTC_TRAFFIC_SAMPLING_INTERVAL, 0);
+    }
+
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+}
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+
+#ifdef FW_AUTOLOAD
+extern int fwengine(const unsigned char *img, int size, void *ar);
+extern int ar6k_reg_preload( int reg, unsigned int value );
+
+/* Linux driver dependent utilities for fwengine */
+int load_binary(unsigned int addr, const unsigned char *cp, void *arg)
+{
+    int size = 0;
+    int adv  = 5;
+    AR_SOFTC_T *ar;
+
+    ar = (AR_SOFTC_T *)arg;
+
+    cp++;
+    size |= ( *cp & 0xFF );       cp++;
+    size |= ( *cp & 0xFF ) <<  8; cp++;
+    size |= ( *cp & 0xFF ) << 16; cp++;
+    size |= ( *cp & 0xFF ) << 24; cp++;
+
+    if (BMIWriteMemory(ar->arHifDevice, addr, cp, size) != A_OK)
+        return(-1);
+
+    adv += size;
+    return(adv);
+}
+
+int execute_on_target( unsigned int address, unsigned int parm, void *arg )
+{
+    int ret ;
+    AR_SOFTC_T *ar;
+
+    ar = (AR_SOFTC_T *)arg;
+    ret = BMIExecute(ar->arHifDevice, address, &parm);
+
+    return(ret);
+}
+
+int get_target_reg( unsigned address, unsigned *val, void *arg )
+{
+    int ret;
+    AR_SOFTC_T *ar;
+
+    ar = (AR_SOFTC_T *)arg;
+    ret = BMIReadMemory(ar->arHifDevice, address, (A_UCHAR *) val, 4);
+    return ret;
+}
+
+int write_target_reg( unsigned address, unsigned value, void *arg )
+{
+    int ret;
+    AR_SOFTC_T *ar;
+
+    ar = (AR_SOFTC_T *)arg;
+    ret = BMIWriteMemory(ar->arHifDevice, address, (A_UCHAR *)&value, 4);
+    return ret;
+}
+
+void bmidone( void *arg )
+{
+    AR_SOFTC_T *ar;
+
+    ar = (AR_SOFTC_T *)arg;
+    BMIDone(ar->arHifDevice);
+}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+static struct device ar6kfwdev = {
+        .bus_id    = "sdio0",
+};
+#endif
+#endif /* FW_AUTOLOAD */
+
+static void ar6000_tx_timeout(struct net_device *dev)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *) dev->priv;
+    dev_err(HIFGetOSDevice(ar->arHifDevice), "ar6000_tx_timeout\n");
+}
+
+/*
+ * HTC Event handlers
+ */
+static void
+ar6000_avail_ev(HTC_HANDLE HTCHandle)
+{
+    int i;
+    struct net_device *dev;
+    AR_SOFTC_T *ar;
+    int device_index = 0;
+    A_UINT32 param;
+
+    AR_DEBUG_PRINTF("ar6000_available\n");
+
+    for (i=0; i < MAX_AR6000; i++) {
+        if (ar6000_devices[i] == NULL) {
+            break;
+        }
+    }
+
+    if (i == MAX_AR6000) {
+        AR_DEBUG_PRINTF("ar6000_available: max devices reached\n");
+        return;
+    }
+
+    /* Save this. It gives a bit better readability especially since */
+    /* we use another local "i" variable below.                      */
+    device_index = i;
+
+    A_ASSERT(HTCHandle != NULL);
+
+    dev = alloc_etherdev(sizeof(AR_SOFTC_T));
+    if (dev == NULL) {
+        AR_DEBUG_PRINTF("ar6000_available: can't alloc etherdev\n");
+        return;
+    }
+#ifdef SET_MODULE_OWNER
+    SET_MODULE_OWNER(dev);
+#endif
+    ether_setup(dev);
+
+    if (dev->priv == NULL) {
+        printk(KERN_CRIT "ar6000_available: Could not allocate memory\n");
+        return;
+    }
+
+    A_MEMZERO(dev->priv, sizeof(AR_SOFTC_T));
+
+    ar                       = (AR_SOFTC_T *)dev->priv;
+    ar->arNetDev             = dev;
+    ar->arHtcTarget          = HTCHandle;
+    ar->arHifDevice          = HTCGetHifDevice(HTCHandle);
+    ar->arWlanState          = WLAN_ENABLED;
+    ar->arDeviceIndex        = device_index;
+
+    A_INIT_TIMER(&ar->arHBChallengeResp.timer, ar6000_detect_error, dev);
+    ar->arHBChallengeResp.seqNum = 0;
+    ar->arHBChallengeResp.outstanding = FALSE;
+    ar->arHBChallengeResp.missCnt = 0;
+    ar->arHBChallengeResp.frequency = AR6000_HB_CHALLENGE_RESP_FREQ_DEFAULT;
+    ar->arHBChallengeResp.missThres = AR6000_HB_CHALLENGE_RESP_MISS_THRES_DEFAULT;
+
+    ar6000_init_control_info(ar);
+    init_waitqueue_head(&arEvent);
+    sema_init(&ar->arSem, 1);
+
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+    A_INIT_TIMER(&aptcTimer, aptcTimerHandler, ar);
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+
+    /*
+     * If requested, perform some magic which requires no cooperation from
+     * the Target.  It causes the Target to ignore flash and execute to the
+     * OS from ROM.
+     *
+     * This is intended to support recovery from a corrupted flash on Targets
+     * that support flash.
+     */
+    if (skipflash)
+    {
+#if defined(CONFIG_AR6002_REV1_FORCE_HOST)
+        extern A_STATUS ar6002_REV1_reset_force_host(HIF_DEVICE *hifDevice);
+        ar6002_REV1_reset_force_host(ar->arHifDevice);
+#else
+        ar6000_reset_device_skipflash(ar->arHifDevice);
+#endif /* CONFIG_AR6002_REV1_FORCE_HOST */
+            }
+
+    BMIInit();
+    {
+        struct bmi_target_info targ_info;
+
+        if (BMIGetTargetInfo(ar->arHifDevice, &targ_info) != A_OK) {
+            return;
+        }
+
+        ar->arVersion.target_ver = targ_info.target_ver;
+        ar->arTargetType = targ_info.target_type;
+
+            /* do any target-specific preparation that can be done through BMI */
+        if (ar6000_prepare_target(ar->arHifDevice,
+                                  targ_info.target_type,
+                                  targ_info.target_ver) != A_OK) {
+            return;
+        }
+
+    }
+
+    if (enableuartprint) {
+        param = 1;
+        if (BMIWriteMemory(ar->arHifDevice,
+                           HOST_INTEREST_ITEM_ADDRESS(ar, hi_serial_enable),
+                           (A_UCHAR *)&param,
+                           4)!= A_OK)
+        {
+             AR_DEBUG_PRINTF("BMIWriteMemory for enableuartprint failed \n");
+             return ;
+        }
+        AR_DEBUG_PRINTF("Serial console prints enabled\n");
+    }
+
+    /* Tell target which HTC version it is used*/
+    param = HTC_PROTOCOL_VERSION;
+    if (BMIWriteMemory(ar->arHifDevice,
+                       HOST_INTEREST_ITEM_ADDRESS(ar, hi_app_host_interest),
+                       (A_UCHAR *)&param,
+                       4)!= A_OK)
+    {
+         AR_DEBUG_PRINTF("BMIWriteMemory for htc version failed \n");
+         return ;
+    }
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+    if(testmode) {
+        ar->arTargetMode = AR6000_TCMD_MODE;
+    }else {
+        ar->arTargetMode = AR6000_WLAN_MODE;
+    }
+#endif
+    if (enabletimerwar) {
+        A_UINT32 param;
+
+        if (BMIReadMemory(ar->arHifDevice,
+            HOST_INTEREST_ITEM_ADDRESS(ar, hi_option_flag),
+            (A_UCHAR *)&param,
+            4)!= A_OK)
+        {
+            AR_DEBUG_PRINTF("BMIReadMemory for enabletimerwar failed \n");
+            return;
+        }
+
+        param |= HI_OPTION_TIMER_WAR;
+
+        if (BMIWriteMemory(ar->arHifDevice,
+            HOST_INTEREST_ITEM_ADDRESS(ar, hi_option_flag),
+            (A_UCHAR *)&param,
+            4) != A_OK)
+        {
+            AR_DEBUG_PRINTF("BMIWriteMemory for enabletimerwar failed \n");
+            return;
+        }
+        AR_DEBUG_PRINTF("Timer WAR enabled\n");
+    }
+
+    // No need to reserve RAM space for patch as AR6001 is flash based
+    if (ar->arTargetType == TARGET_TYPE_AR6001) {
+        param = 0;
+        if (BMIWriteMemory(ar->arHifDevice,
+            HOST_INTEREST_ITEM_ADDRESS(ar, hi_end_RAM_reserve_sz),
+            (A_UCHAR *)&param,
+            4) != A_OK)
+        {
+            AR_DEBUG_PRINTF("BMIWriteMemory for hi_end_RAM_reserve_sz failed \n");
+            return;
+        }
+    }
+
+
+        /* since BMIInit is called in the driver layer, we have to set the block
+         * size here for the target */
+
+    if (A_FAILED(ar6000_set_htc_params(ar->arHifDevice,
+                                       ar->arTargetType,
+                                       mbox_yield_limit,
+                                       0 /* use default number of control buffers */
+                                       ))) {
+        return;
+    }
+
+    spin_lock_init(&ar->arLock);
+
+    /* Don't install the init function if BMI is requested */
+    if(!bmienable)
+    {
+        dev->init = ar6000_init;
+    } else {
+        AR_DEBUG_PRINTF(" BMI enabled \n");
+    }
+
+    dev->open = &ar6000_open;
+    dev->stop = &ar6000_close;
+    dev->hard_start_xmit = &ar6000_data_tx;
+    dev->get_stats = &ar6000_get_stats;
+
+    dev->tx_timeout = ar6000_tx_timeout;
+    dev->do_ioctl = &ar6000_ioctl;
+    dev->watchdog_timeo = AR6000_TX_TIMEOUT;
+    ar6000_ioctl_iwsetup(&ath_iw_handler_def);
+    dev->wireless_handlers = &ath_iw_handler_def;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+    dev->get_wireless_stats = ar6000_get_iwstats; /*Displayed via proc fs */
+#else
+    ath_iw_handler_def.get_wireless_stats = ar6000_get_iwstats; /*Displayed via proc fs */
+#endif
+
+    /*
+     * We need the OS to provide us with more headroom in order to
+     * perform dix to 802.3, WMI header encap, and the HTC header
+     */
+    dev->hard_header_len = ETH_HLEN + sizeof(ATH_LLC_SNAP_HDR) +
+        sizeof(WMI_DATA_HDR) + HTC_HEADER_LEN;
+
+    netif_carrier_off(dev);
+
+    /* This runs the init function */
+    SET_NETDEV_DEV(dev, HIFGetOSDevice(ar->arHifDevice));
+    if (register_netdev(dev)) {
+        AR_DEBUG_PRINTF("ar6000_avail: register_netdev failed\n");
+        ar6000_destroy(dev, 0);
+        return;
+    }
+
+    HTCSetInstance(ar->arHtcTarget, ar);
+
+    /* We only register the device in the global list if we succeed. */
+    /* If the device is in the global list, it will be destroyed     */
+    /* when the module is unloaded.                                  */
+    ar6000_devices[device_index] = dev;
+
+    AR_DEBUG_PRINTF("ar6000_avail: name=%s htcTarget=0x%x, dev=0x%x (%d), ar=0x%x\n",
+                    dev->name, (A_UINT32)HTCHandle, (A_UINT32)dev, device_index,
+                    (A_UINT32)ar);
+}
+
+static void ar6000_target_failure(void *Instance, A_STATUS Status)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)Instance;
+    WMI_TARGET_ERROR_REPORT_EVENT errEvent;
+    static A_BOOL sip = FALSE;
+
+    if (Status != A_OK) {
+        if (timer_pending(&ar->arHBChallengeResp.timer)) {
+            A_UNTIMEOUT(&ar->arHBChallengeResp.timer);
+        }
+
+        /* try dumping target assertion information (if any) */
+        ar6000_dump_target_assert_info(ar->arHifDevice,ar->arTargetType);
+
+        /*
+         * Fetch the logs from the target via the diagnostic
+         * window.
+         */
+        ar6000_dbglog_get_debug_logs(ar);
+
+        /* Report the error only once */
+        if (!sip) {
+            sip = TRUE;
+            errEvent.errorVal = WMI_TARGET_COM_ERR |
+                                WMI_TARGET_FATAL_ERR;
+            ar6000_send_event_to_app(ar, WMI_ERROR_REPORT_EVENTID,
+                                     (A_UINT8 *)&errEvent,
+                                     sizeof(WMI_TARGET_ERROR_REPORT_EVENT));
+        }
+    }
+}
+
+static void
+ar6000_unavail_ev(void *Instance)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)Instance;
+        /* NULL out it's entry in the global list */
+    ar6000_devices[ar->arDeviceIndex] = NULL;
+    ar6000_destroy(ar->arNetDev, 1);
+}
+
+/*
+ * We need to differentiate between the surprise and planned removal of the
+ * device because of the following consideration:
+ * - In case of surprise removal, the hcd already frees up the pending
+ *   for the device and hence there is no need to unregister the function
+ *   driver inorder to get these requests. For planned removal, the function
+ *   driver has to explictly unregister itself to have the hcd return all the
+ *   pending requests before the data structures for the devices are freed up.
+ *   Note that as per the current implementation, the function driver will
+ *   end up releasing all the devices since there is no API to selectively
+ *   release a particular device.
+ * - Certain commands issued to the target can be skipped for surprise
+ *   removal since they will anyway not go through.
+ */
+static void
+ar6000_destroy(struct net_device *dev, unsigned int unregister)
+{
+    AR_SOFTC_T *ar;
+
+    AR_DEBUG_PRINTF("+ar6000_destroy \n");
+
+    if((dev == NULL) || ((ar = netdev_priv(dev)) == NULL))
+    {
+        AR_DEBUG_PRINTF("%s(): Failed to get device structure.\n", __func__);
+        return;
+    }
+
+    /* Stop the transmit queues */
+    netif_stop_queue(dev);
+    netif_carrier_off(dev);
+
+    /* Disable the target and the interrupts associated with it */
+    if (ar->arWmiReady == TRUE)
+    {
+        if (!bypasswmi)
+        {
+            if (ar->arConnected == TRUE || ar->arConnectPending == TRUE)
+            {
+                AR_DEBUG_PRINTF("%s(): Disconnect\n", __func__);
+                AR6000_SPIN_LOCK(&ar->arLock, 0);
+                ar6000_init_profile_info(ar);
+                AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+                wmi_disconnect_cmd(ar->arWmi);
+            }
+
+            ar->arWmiReady  = FALSE;
+            ar->arConnected = FALSE;
+            ar->arConnectPending = FALSE;
+            wmi_shutdown(ar->arWmi);
+            ar->arWmiEnabled = FALSE;
+            ar->arWmi = NULL;
+            ar->arWlanState = WLAN_ENABLED;
+#ifdef USER_KEYS
+            ar->user_savedkeys_stat = USER_SAVEDKEYS_STAT_INIT;
+            ar->user_key_ctrl      = 0;
+#endif
+        }
+
+         AR_DEBUG_PRINTF("%s(): WMI stopped\n", __func__);
+    }
+    else
+    {
+        AR_DEBUG_PRINTF("%s(): WMI not ready 0x%08x 0x%08x\n",
+            __func__, (unsigned int) ar, (unsigned int) ar->arWmi);
+
+        /* Shut down WMI if we have started it */
+        if(ar->arWmiEnabled == TRUE)
+        {
+            AR_DEBUG_PRINTF("%s(): Shut down WMI\n", __func__);
+            wmi_shutdown(ar->arWmi);
+            ar->arWmiEnabled = FALSE;
+            ar->arWmi = NULL;
+        }
+    }
+
+    /* stop HTC */
+    HTCStop(ar->arHtcTarget);
+
+    /* set the instance to NULL so we do not get called back on remove incase we
+     * we're explicity destroyed by module unload */
+    HTCSetInstance(ar->arHtcTarget, NULL);
+
+    if (resetok) {
+        /* try to reset the device if we can
+         * The driver may have been configure NOT to reset the target during
+         * a debug session */
+        AR_DEBUG_PRINTF(" Attempting to reset target on instance destroy.... \n");
+        ar6000_reset_device(ar->arHifDevice, ar->arTargetType, TRUE);
+    } else {
+        AR_DEBUG_PRINTF(" Host does not want target reset. \n");
+    }
+
+       /* Done with cookies */
+    ar6000_cookie_cleanup(ar);
+
+    /* Cleanup BMI */
+    BMIInit();
+
+    /* Clear the tx counters */
+    memset(tx_attempt, 0, sizeof(tx_attempt));
+    memset(tx_post, 0, sizeof(tx_post));
+    memset(tx_complete, 0, sizeof(tx_complete));
+
+
+    /* Free up the device data structure */
+    if (unregister)
+	    unregister_netdev(dev);
+#ifndef free_netdev
+    kfree(dev);
+#else
+    free_netdev(dev);
+#endif
+
+    AR_DEBUG_PRINTF("-ar6000_destroy \n");
+}
+
+static void ar6000_detect_error(unsigned long ptr)
+{
+    struct net_device *dev = (struct net_device *)ptr;
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_TARGET_ERROR_REPORT_EVENT errEvent;
+
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    if (ar->arHBChallengeResp.outstanding) {
+        ar->arHBChallengeResp.missCnt++;
+    } else {
+        ar->arHBChallengeResp.missCnt = 0;
+    }
+
+    if (ar->arHBChallengeResp.missCnt > ar->arHBChallengeResp.missThres) {
+        /* Send Error Detect event to the application layer and do not reschedule the error detection module timer */
+        ar->arHBChallengeResp.missCnt = 0;
+        ar->arHBChallengeResp.seqNum = 0;
+        errEvent.errorVal = WMI_TARGET_COM_ERR | WMI_TARGET_FATAL_ERR;
+        AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+        ar6000_send_event_to_app(ar, WMI_ERROR_REPORT_EVENTID,
+                                 (A_UINT8 *)&errEvent,
+                                 sizeof(WMI_TARGET_ERROR_REPORT_EVENT));
+        return;
+    }
+
+    /* Generate the sequence number for the next challenge */
+    ar->arHBChallengeResp.seqNum++;
+    ar->arHBChallengeResp.outstanding = TRUE;
+
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+
+    /* Send the challenge on the control channel */
+    if (wmi_get_challenge_resp_cmd(ar->arWmi, ar->arHBChallengeResp.seqNum, DRV_HB_CHALLENGE) != A_OK) {
+        AR_DEBUG_PRINTF("Unable to send heart beat challenge\n");
+    }
+
+
+    /* Reschedule the timer for the next challenge */
+    A_TIMEOUT_MS(&ar->arHBChallengeResp.timer, ar->arHBChallengeResp.frequency * 1000, 0);
+}
+
+void ar6000_init_profile_info(AR_SOFTC_T *ar)
+{
+    ar->arSsidLen            = 0;
+    A_MEMZERO(ar->arSsid, sizeof(ar->arSsid));
+    ar->arNetworkType        = INFRA_NETWORK;
+    ar->arDot11AuthMode      = OPEN_AUTH;
+    ar->arAuthMode           = NONE_AUTH;
+    ar->arPairwiseCrypto     = NONE_CRYPT;
+    ar->arPairwiseCryptoLen  = 0;
+    ar->arGroupCrypto        = NONE_CRYPT;
+    ar->arGroupCryptoLen     = 0;
+    A_MEMZERO(ar->arWepKeyList, sizeof(ar->arWepKeyList));
+    A_MEMZERO(ar->arReqBssid, sizeof(ar->arReqBssid));
+    A_MEMZERO(ar->arBssid, sizeof(ar->arBssid));
+    ar->arBssChannel = 0;
+}
+
+static void
+ar6000_init_control_info(AR_SOFTC_T *ar)
+{
+    ar->arWmiEnabled         = FALSE;
+    ar6000_init_profile_info(ar);
+    ar->arDefTxKeyIndex      = 0;
+    A_MEMZERO(ar->arWepKeyList, sizeof(ar->arWepKeyList));
+    ar->arChannelHint        = 0;
+    ar->arListenInterval     = MAX_LISTEN_INTERVAL;
+    ar->arVersion.host_ver   = AR6K_SW_VERSION;
+    ar->arRssi               = 0;
+    ar->arTxPwr              = 0;
+    ar->arTxPwrSet           = FALSE;
+    ar->arSkipScan           = 0;
+    ar->arBeaconInterval     = 0;
+    ar->arBitRate            = 0;
+    ar->arMaxRetries         = 0;
+    ar->arWmmEnabled         = TRUE;
+}
+
+static int
+ar6000_open(struct net_device *dev)
+{
+    if (netif_carrier_ok(dev))
+        netif_start_queue(dev);
+
+    return 0;
+}
+
+static int
+ar6000_close(struct net_device *dev)
+{
+    netif_stop_queue(dev);
+
+    return 0;
+}
+
+/* connect to a service */
+static A_STATUS ar6000_connectservice(AR_SOFTC_T               *ar,
+                                      HTC_SERVICE_CONNECT_REQ  *pConnect,
+                                      char                     *pDesc)
+{
+    A_STATUS                 status;
+    HTC_SERVICE_CONNECT_RESP response;
+
+    do {
+
+        A_MEMZERO(&response,sizeof(response));
+
+        status = HTCConnectService(ar->arHtcTarget,
+                                   pConnect,
+                                   &response);
+
+        if (A_FAILED(status)) {
+            AR_DEBUG_PRINTF(" Failed to connect to %s service status:%d \n",
+                              pDesc, status);
+            break;
+        }
+        switch (pConnect->ServiceID) {
+            case WMI_CONTROL_SVC :
+                if (ar->arWmiEnabled) {
+                        /* set control endpoint for WMI use */
+                    wmi_set_control_ep(ar->arWmi, response.Endpoint);
+                }
+                    /* save EP for fast lookup */
+                ar->arControlEp = response.Endpoint;
+                break;
+            case WMI_DATA_BE_SVC :
+                arSetAc2EndpointIDMap(ar, WMM_AC_BE, response.Endpoint);
+                break;
+            case WMI_DATA_BK_SVC :
+                arSetAc2EndpointIDMap(ar, WMM_AC_BK, response.Endpoint);
+                break;
+            case WMI_DATA_VI_SVC :
+                arSetAc2EndpointIDMap(ar, WMM_AC_VI, response.Endpoint);
+                 break;
+           case WMI_DATA_VO_SVC :
+                arSetAc2EndpointIDMap(ar, WMM_AC_VO, response.Endpoint);
+                break;
+           default:
+                AR_DEBUG_PRINTF("ServiceID not mapped %d\n", pConnect->ServiceID);
+                status = A_EINVAL;
+            break;
+        }
+
+    } while (FALSE);
+
+    return status;
+}
+
+static void ar6000_TxDataCleanup(AR_SOFTC_T *ar)
+{
+        /* flush all the data (non-control) streams
+         * we only flush packets that are tagged as data, we leave any control packets that
+         * were in the TX queues alone */
+    HTCFlushEndpoint(ar->arHtcTarget,
+                     arAc2EndpointID(ar, WMM_AC_BE),
+                     AR6K_DATA_PKT_TAG);
+    HTCFlushEndpoint(ar->arHtcTarget,
+                     arAc2EndpointID(ar, WMM_AC_BK),
+                     AR6K_DATA_PKT_TAG);
+    HTCFlushEndpoint(ar->arHtcTarget,
+                     arAc2EndpointID(ar, WMM_AC_VI),
+                     AR6K_DATA_PKT_TAG);
+    HTCFlushEndpoint(ar->arHtcTarget,
+                     arAc2EndpointID(ar, WMM_AC_VO),
+                     AR6K_DATA_PKT_TAG);
+}
+
+HTC_ENDPOINT_ID
+ar6000_ac2_endpoint_id ( void * devt, A_UINT8 ac)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *) devt;
+    return(arAc2EndpointID(ar, ac));
+}
+
+A_UINT8
+ar6000_endpoint_id2_ac(void * devt, HTC_ENDPOINT_ID ep )
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *) devt;
+    return(arEndpoint2Ac(ar, ep ));
+}
+
+extern int ar6002_read_eeprom(AR_SOFTC_T *ar);
+
+/* This function does one time initialization for the lifetime of the device */
+int ar6000_init(struct net_device *dev)
+{
+    AR_SOFTC_T *ar;
+    A_STATUS    status;
+    A_INT32     timeleft;
+
+    if((ar = netdev_priv(dev)) == NULL)
+    {
+        return(-EIO);
+    }
+
+#ifdef FW_AUTOLOAD
+    if(!bmienable && (ar->arTargetType == TARGET_TYPE_AR6002)) {
+        const struct firmware *fw_entry;
+        const unsigned char *fw_name = "atheros/ar6002.bin";
+        int ret;
+
+        /* copy the eeprom contents into target memory */
+        ret = ar6002_read_eeprom(ar);
+        if (ret)
+            return -EIO;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+        if(request_firmware(&fw_entry, fw_name, &ar6kfwdev)!=0) {
+#else
+        if(request_firmware(&fw_entry, fw_name,
+            HIFGetOSDevice(ar->arHifDevice))!=0) {
+#endif
+            printk(KERN_ERR "ar6000_init: firmware %s not available\n",
+                fw_name);
+            return -EIO;
+        } else {
+            ar6k_reg_preload( 14, ar->arTargetType );
+            ar6k_reg_preload( 15, ar->arVersion.target_ver );
+            ret = fwengine(fw_entry->data, fw_entry->size, (void *)ar);
+            release_firmware(fw_entry);
+            if( ret ) {
+                printk(KERN_ERR "ar6000_init: error %d loading firmware\n",
+                    ret);
+                return -EIO;
+            }
+        }
+    }
+#endif /* FW_AUTOLOAD */
+
+    /* Do we need to finish the BMI phase */
+    if(BMIDone(ar->arHifDevice) != A_OK)
+    {
+        return -EIO;
+    }
+
+    if (!bypasswmi)
+    {
+        if (ar->arVersion.host_ver != ar->arVersion.target_ver) {
+            A_PRINTF("WARNING: Host version 0x%x does not match Target "
+                    " version 0x%x!\n",
+                    ar->arVersion.host_ver, ar->arVersion.target_ver);
+        } else {
+            A_PRINTF("ar6k: Host version 0x%x, Target version 0x%x\n",
+                    ar->arVersion.host_ver, ar->arVersion.target_ver);
+	}
+
+        /* Indicate that WMI is enabled (although not ready yet) */
+        ar->arWmiEnabled = TRUE;
+        if ((ar->arWmi = wmi_init((void *) ar)) == NULL)
+        {
+            AR_DEBUG_PRINTF("%s() Failed to initialize WMI.\n", __func__);
+            return(-EIO);
+        }
+
+        AR_DEBUG_PRINTF("%s() Got WMI @ 0x%08x.\n", __func__,
+            (unsigned int) ar->arWmi);
+    }
+
+    do {
+        HTC_SERVICE_CONNECT_REQ connect;
+
+            /* the reason we have to wait for the target here is that the driver layer
+             * has to init BMI in order to set the host block size,
+             */
+        status = HTCWaitTarget(ar->arHtcTarget);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        A_MEMZERO(&connect,sizeof(connect));
+            /* meta data is unused for now */
+        connect.pMetaData = NULL;
+        connect.MetaDataLength = 0;
+            /* these fields are the same for all service endpoints */
+        connect.EpCallbacks.pContext = ar;
+        connect.EpCallbacks.EpTxComplete = ar6000_tx_complete;
+        connect.EpCallbacks.EpRecv = ar6000_rx;
+        connect.EpCallbacks.EpRecvRefill = ar6000_rx_refill;
+        connect.EpCallbacks.EpSendFull = ar6000_tx_queue_full;
+            /* set the max queue depth so that our ar6000_tx_queue_full handler gets called.
+             * Linux has the peculiarity of not providing flow control between the
+             * NIC and the network stack. There is no API to indicate that a TX packet
+             * was sent which could provide some back pressure to the network stack.
+             * Under linux you would have to wait till the network stack consumed all sk_buffs
+             * before any back-flow kicked in. Which isn't very friendly.
+             * So we have to manage this ourselves */
+        connect.MaxSendQueueDepth = 32;
+
+            /* connect to control service */
+        connect.ServiceID = WMI_CONTROL_SVC;
+        status = ar6000_connectservice(ar,
+                                       &connect,
+                                       "WMI CONTROL");
+        if (A_FAILED(status)) {
+            break;
+        }
+
+            /* for the remaining data services set the connection flag to reduce dribbling,
+             * if configured to do so */
+        if (reduce_credit_dribble) {
+            connect.ConnectionFlags |= HTC_CONNECT_FLAGS_REDUCE_CREDIT_DRIBBLE;
+            /* the credit dribble trigger threshold is (reduce_credit_dribble - 1) for a value
+             * of 0-3 */
+            connect.ConnectionFlags &= ~HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_MASK;
+            connect.ConnectionFlags |=
+                        ((A_UINT16)reduce_credit_dribble - 1) & HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_MASK;
+        }
+            /* connect to best-effort service */
+        connect.ServiceID = WMI_DATA_BE_SVC;
+
+        status = ar6000_connectservice(ar,
+                                       &connect,
+                                       "WMI DATA BE");
+        if (A_FAILED(status)) {
+            break;
+        }
+
+            /* connect to back-ground
+             * map this to WMI LOW_PRI */
+        connect.ServiceID = WMI_DATA_BK_SVC;
+        status = ar6000_connectservice(ar,
+                                       &connect,
+                                       "WMI DATA BK");
+        if (A_FAILED(status)) {
+            break;
+        }
+
+            /* connect to Video service, map this to
+             * to HI PRI */
+        connect.ServiceID = WMI_DATA_VI_SVC;
+        status = ar6000_connectservice(ar,
+                                       &connect,
+                                       "WMI DATA VI");
+        if (A_FAILED(status)) {
+            break;
+        }
+
+            /* connect to VO service, this is currently not
+             * mapped to a WMI priority stream due to historical reasons.
+             * WMI originally defined 3 priorities over 3 mailboxes
+             * We can change this when WMI is reworked so that priorities are not
+             * dependent on mailboxes */
+        connect.ServiceID = WMI_DATA_VO_SVC;
+        status = ar6000_connectservice(ar,
+                                       &connect,
+                                       "WMI DATA VO");
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        A_ASSERT(arAc2EndpointID(ar,WMM_AC_BE) != 0);
+        A_ASSERT(arAc2EndpointID(ar,WMM_AC_BK) != 0);
+        A_ASSERT(arAc2EndpointID(ar,WMM_AC_VI) != 0);
+        A_ASSERT(arAc2EndpointID(ar,WMM_AC_VO) != 0);
+
+            /* setup access class priority mappings */
+        ar->arAcStreamPriMap[WMM_AC_BK] = 0; /* lowest  */
+        ar->arAcStreamPriMap[WMM_AC_BE] = 1; /*         */
+        ar->arAcStreamPriMap[WMM_AC_VI] = 2; /*         */
+        ar->arAcStreamPriMap[WMM_AC_VO] = 3; /* highest */
+
+    } while (FALSE);
+
+    if (A_FAILED(status)) {
+        return (-EIO);
+    }
+
+    /*
+     * give our connected endpoints some buffers
+     */
+
+    ar6000_rx_refill(ar, ar->arControlEp);
+    ar6000_rx_refill(ar, arAc2EndpointID(ar,WMM_AC_BE));
+
+    /*
+     * We will post the receive buffers only for SPE or endpoint ping testing so we are
+     * making it conditional on the 'bypasswmi' flag.
+     */
+    if (bypasswmi) {
+        ar6000_rx_refill(ar,arAc2EndpointID(ar,WMM_AC_BK));
+        ar6000_rx_refill(ar,arAc2EndpointID(ar,WMM_AC_VI));
+        ar6000_rx_refill(ar,arAc2EndpointID(ar,WMM_AC_VO));
+    }
+
+        /* setup credit distribution */
+    ar6000_setup_credit_dist(ar->arHtcTarget, &ar->arCreditStateInfo);
+
+    /* Since cookies are used for HTC transports, they should be */
+    /* initialized prior to enabling HTC.                        */
+    ar6000_cookie_init(ar);
+
+    /* start HTC */
+    status = HTCStart(ar->arHtcTarget);
+
+    if (status != A_OK) {
+        if (ar->arWmiEnabled == TRUE) {
+            wmi_shutdown(ar->arWmi);
+            ar->arWmiEnabled = FALSE;
+            ar->arWmi = NULL;
+        }
+        ar6000_cookie_cleanup(ar);
+        return -EIO;
+    }
+
+    if (!bypasswmi) {
+        /* Wait for Wmi event to be ready */
+        timeleft = wait_event_interruptible_timeout(arEvent,
+            (ar->arWmiReady == TRUE), wmitimeout * HZ);
+
+        if(!timeleft || signal_pending(current))
+        {
+            AR_DEBUG_PRINTF("WMI is not ready or wait was interrupted\n");
+#if defined(DWSIM) /* TBDXXX */
+            AR_DEBUG_PRINTF(".....but proceed anyway.\n");
+#else
+            return -EIO;
+#endif
+        }
+
+        AR_DEBUG_PRINTF("%s() WMI is ready\n", __func__);
+
+        /* Communicate the wmi protocol verision to the target */
+        if ((ar6000_set_host_app_area(ar)) != A_OK) {
+            AR_DEBUG_PRINTF("Unable to set the host app area\n");
+        }
+    }
+
+    ar->arNumDataEndPts = 1;
+
+#ifdef CONFIG_ARCH_OMAP_BLACKTOP
+    if (!bmienable && !bypasswmi) {
+        static A_UINT16 blacktop_channels[11] =
+          { 2412, 2417, 2422, 2427, 2432, 2437, 2442, 2447, 2452, 2457, 2462 };
+
+      /*
+       * Select 802.11g mode so that 802.11a frequencies are disabled.
+       * Also limit the 802.11g channels to the first 11 (of 14 total) channels.
+       * Only the first 11 channels are authorized in the USA.
+       */
+        if (wmi_set_channelParams_cmd(ar->arWmi, 0, WMI_11G_MODE, 11,
+            blacktop_channels) != A_OK)
+        {
+            A_PRINTF("Unable to select 802.11g mode.\n");
+            return -EIO;
+        } else {
+            AR_DEBUG_PRINTF("802.11g mode selected.\n");
+        }
+    }
+    if (!bmienable && !bypasswmi) {
+        WMI_POWER_PARAMS_CMD pmParams = {
+            .idle_period = 0,
+            .pspoll_number = 0,
+            .dtim_policy = 0,
+        };
+
+        if (wmi_pmparams_cmd(ar->arWmi, pmParams.idle_period,
+            pmParams.pspoll_number,
+            pmParams.dtim_policy) != A_OK)
+        {
+            A_PRINTF("Unable to set PS-Poll parameters.\n");
+            return -EIO;
+        } else {
+            AR_DEBUG_PRINTF("Set default PS-Poll parameters.\n");
+        }
+    }
+#endif
+
+    return(0);
+}
+
+
+void
+ar6000_bitrate_rx(void *devt, A_INT32 rateKbps)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)devt;
+
+    ar->arBitRate = rateKbps;
+    wake_up(&arEvent);
+}
+
+void
+ar6000_ratemask_rx(void *devt, A_UINT16 ratemask)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)devt;
+
+    ar->arRateMask = ratemask;
+    wake_up(&arEvent);
+}
+
+void
+ar6000_txPwr_rx(void *devt, A_UINT8 txPwr)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)devt;
+
+    ar->arTxPwr = txPwr;
+    wake_up(&arEvent);
+}
+
+
+void
+ar6000_channelList_rx(void *devt, A_INT8 numChan, A_UINT16 *chanList)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)devt;
+
+    A_MEMCPY(ar->arChannelList, chanList, numChan * sizeof (A_UINT16));
+    ar->arNumChannels = numChan;
+
+    wake_up(&arEvent);
+}
+
+A_UINT8
+ar6000_ibss_map_epid(struct sk_buff *skb, struct net_device *dev, A_UINT32 * mapNo)
+{
+    AR_SOFTC_T      *ar = (AR_SOFTC_T *)dev->priv;
+    A_UINT8         *datap;
+    ATH_MAC_HDR     *macHdr;
+    A_UINT32         i, eptMap;
+
+    (*mapNo) = 0;
+    datap = A_NETBUF_DATA(skb);
+    macHdr = (ATH_MAC_HDR *)(datap + sizeof(WMI_DATA_HDR));
+    if (IEEE80211_IS_MULTICAST(macHdr->dstMac)) {
+        return ENDPOINT_2;
+    }
+
+    eptMap = -1;
+    for (i = 0; i < ar->arNodeNum; i ++) {
+        if (IEEE80211_ADDR_EQ(macHdr->dstMac, ar->arNodeMap[i].macAddress)) {
+            (*mapNo) = i + 1;
+            ar->arNodeMap[i].txPending ++;
+            return ar->arNodeMap[i].epId;
+        }
+
+        if ((eptMap == -1) && !ar->arNodeMap[i].txPending) {
+            eptMap = i;
+        }
+    }
+
+    if (eptMap == -1) {
+        eptMap = ar->arNodeNum;
+        ar->arNodeNum ++;
+        A_ASSERT(ar->arNodeNum <= MAX_NODE_NUM);
+    }
+
+    A_MEMCPY(ar->arNodeMap[eptMap].macAddress, macHdr->dstMac, IEEE80211_ADDR_LEN);
+
+    for (i = ENDPOINT_2; i <= ENDPOINT_5; i ++) {
+        if (!ar->arTxPending[i]) {
+            ar->arNodeMap[eptMap].epId = i;
+            break;
+        }
+        // No free endpoint is available, start redistribution on the inuse endpoints.
+        if (i == ENDPOINT_5) {
+            ar->arNodeMap[eptMap].epId = ar->arNexEpId;
+            ar->arNexEpId ++;
+            if (ar->arNexEpId > ENDPOINT_5) {
+                ar->arNexEpId = ENDPOINT_2;
+            }
+        }
+    }
+
+    (*mapNo) = eptMap + 1;
+    ar->arNodeMap[eptMap].txPending ++;
+
+    return ar->arNodeMap[eptMap].epId;
+}
+
+#ifdef DEBUG
+static void ar6000_dump_skb(struct sk_buff *skb)
+{
+   u_char *ch;
+   for (ch = A_NETBUF_DATA(skb);
+        (A_UINT32)ch < ((A_UINT32)A_NETBUF_DATA(skb) +
+        A_NETBUF_LEN(skb)); ch++)
+    {
+         AR_DEBUG_PRINTF("%2.2x ", *ch);
+    }
+    AR_DEBUG_PRINTF("\n");
+}
+#endif
+
+static int
+ar6000_data_tx(struct sk_buff *skb, struct net_device *dev)
+{
+#define AC_NOT_MAPPED   99
+    AR_SOFTC_T        *ar = (AR_SOFTC_T *)dev->priv;
+    A_UINT8            ac = AC_NOT_MAPPED;
+    HTC_ENDPOINT_ID    eid = ENDPOINT_UNUSED;
+    A_UINT32          mapNo = 0;
+    int               len;
+    struct ar_cookie *cookie;
+    A_BOOL            checkAdHocPsMapping = FALSE;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,13)
+    skb->list = NULL;
+#endif
+
+    AR_DEBUG2_PRINTF("ar6000_data_tx start - skb=0x%x, data=0x%x, len=0x%x\n",
+                     (A_UINT32)skb, (A_UINT32)A_NETBUF_DATA(skb),
+                     A_NETBUF_LEN(skb));
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+     /* TCMD doesnt support any data, free the buf and return */
+    if(ar->arTargetMode == AR6000_TCMD_MODE) {
+        A_NETBUF_FREE(skb);
+        return 0;
+    }
+#endif
+    do {
+
+        if (ar->arWmiReady == FALSE && bypasswmi == 0) {
+            break;
+        }
+
+#ifdef BLOCK_TX_PATH_FLAG
+        if (blocktx) {
+            break;
+        }
+#endif /* BLOCK_TX_PATH_FLAG */
+
+        if (ar->arWmiEnabled) {
+            if (A_NETBUF_HEADROOM(skb) < dev->hard_header_len) {
+                struct sk_buff  *newbuf;
+                /*
+                 * We really should have gotten enough headroom but sometimes
+                 * we still get packets with not enough headroom.  Copy the packet.
+                 */
+                len = A_NETBUF_LEN(skb);
+                newbuf = A_NETBUF_ALLOC(len);
+                if (newbuf == NULL) {
+                    break;
+                }
+                A_NETBUF_PUT(newbuf, len);
+                A_MEMCPY(A_NETBUF_DATA(newbuf), A_NETBUF_DATA(skb), len);
+                A_NETBUF_FREE(skb);
+                skb = newbuf;
+                /* fall through and assemble header */
+            }
+
+            if (wmi_dix_2_dot3(ar->arWmi, skb) != A_OK) {
+                AR_DEBUG_PRINTF("ar6000_data_tx - wmi_dix_2_dot3 failed\n");
+                break;
+            }
+
+            if (wmi_data_hdr_add(ar->arWmi, skb, DATA_MSGTYPE) != A_OK) {
+                AR_DEBUG_PRINTF("ar6000_data_tx - wmi_data_hdr_add failed\n");
+                break;
+            }
+
+            if ((ar->arNetworkType == ADHOC_NETWORK) &&
+                ar->arIbssPsEnable && ar->arConnected) {
+                    /* flag to check adhoc mapping once we take the lock below: */
+                checkAdHocPsMapping = TRUE;
+
+            } else {
+                    /* get the stream mapping */
+                ac  =  wmi_implicit_create_pstream(ar->arWmi, skb, 0, ar->arWmmEnabled);
+            }
+
+        } else {
+            struct iphdr    *ipHdr;
+            /*
+             * the endpoint is directly based on the TOS field in the IP
+             * header **** only for testing ******
+             */
+            ipHdr = A_NETBUF_DATA(skb) + sizeof(ATH_MAC_HDR);
+                /* here we map the TOS field to an access class, this is for
+                 * the endpointping test application.  The application uses 0,1,2,3
+                 * for the TOS field to emulate writing to mailboxes.  The number is
+                 * used to map directly to an access class */
+            ac = (ipHdr->tos >> 1) & 0x3;
+        }
+
+    } while (FALSE);
+
+        /* did we succeed ? */
+    if ((ac == AC_NOT_MAPPED) && !checkAdHocPsMapping) {
+            /* cleanup and exit */
+        A_NETBUF_FREE(skb);
+        AR6000_STAT_INC(ar, tx_dropped);
+        AR6000_STAT_INC(ar, tx_aborted_errors);
+        return 0;
+    }
+
+    cookie = NULL;
+
+        /* take the lock to protect driver data */
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    do {
+
+        if (checkAdHocPsMapping) {
+            eid = ar6000_ibss_map_epid(skb, dev, &mapNo);
+        }else {
+            eid = arAc2EndpointID (ar, ac);
+        }
+            /* validate that the endpoint is connected */
+        if (eid == 0 || eid == ENDPOINT_UNUSED ) {
+            AR_DEBUG_PRINTF(" eid %d is NOT mapped!\n", eid);
+            break;
+        }
+            /* allocate resource for this packet */
+        cookie = ar6000_alloc_cookie(ar);
+
+        if (cookie != NULL) {
+                /* update counts while the lock is held */
+            ar->arTxPending[eid]++;
+            ar->arTotalTxDataPending++;
+        }
+
+    } while (FALSE);
+
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+
+    if (cookie != NULL) {
+        cookie->arc_bp[0] = (A_UINT32)skb;
+        cookie->arc_bp[1] = mapNo;
+        SET_HTC_PACKET_INFO_TX(&cookie->HtcPkt,
+                               cookie,
+                               A_NETBUF_DATA(skb),
+                               A_NETBUF_LEN(skb),
+                               eid,
+                               AR6K_DATA_PKT_TAG);
+
+#ifdef DEBUG
+        if (debugdriver >= 3) {
+            ar6000_dump_skb(skb);
+        }
+#endif
+            /* HTC interface is asynchronous, if this fails, cleanup will happen in
+             * the ar6000_tx_complete callback */
+        HTCSendPkt(ar->arHtcTarget, &cookie->HtcPkt);
+    } else {
+            /* no packet to send, cleanup */
+        A_NETBUF_FREE(skb);
+        AR6000_STAT_INC(ar, tx_dropped);
+        AR6000_STAT_INC(ar, tx_aborted_errors);
+    }
+
+    return 0;
+}
+
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+static void
+tvsub(register struct timeval *out, register struct timeval *in)
+{
+    if((out->tv_usec -= in->tv_usec) < 0) {
+        out->tv_sec--;
+        out->tv_usec += 1000000;
+    }
+    out->tv_sec -= in->tv_sec;
+}
+
+void
+applyAPTCHeuristics(AR_SOFTC_T *ar)
+{
+    A_UINT32 duration;
+    A_UINT32 numbytes;
+    A_UINT32 throughput;
+    struct timeval ts;
+    A_STATUS status;
+
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    if ((enableAPTCHeuristics) && (!aptcTR.timerScheduled)) {
+        do_gettimeofday(&ts);
+        tvsub(&ts, &aptcTR.samplingTS);
+        duration = ts.tv_sec * 1000 + ts.tv_usec / 1000; /* ms */
+        numbytes = aptcTR.bytesTransmitted + aptcTR.bytesReceived;
+
+        if (duration > APTC_TRAFFIC_SAMPLING_INTERVAL) {
+            /* Initialize the time stamp and byte count */
+            aptcTR.bytesTransmitted = aptcTR.bytesReceived = 0;
+            do_gettimeofday(&aptcTR.samplingTS);
+
+            /* Calculate and decide based on throughput thresholds */
+            throughput = ((numbytes * 8) / duration);
+            if (throughput > APTC_UPPER_THROUGHPUT_THRESHOLD) {
+                /* Disable Sleep and schedule a timer */
+                A_ASSERT(ar->arWmiReady == TRUE);
+                AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+                status = wmi_powermode_cmd(ar->arWmi, MAX_PERF_POWER);
+                AR6000_SPIN_LOCK(&ar->arLock, 0);
+                A_TIMEOUT_MS(&aptcTimer, APTC_TRAFFIC_SAMPLING_INTERVAL, 0);
+                aptcTR.timerScheduled = TRUE;
+            }
+        }
+    }
+
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+}
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+
+static HTC_SEND_FULL_ACTION ar6000_tx_queue_full(void *Context, HTC_PACKET *pPacket)
+{
+    AR_SOFTC_T     *ar = (AR_SOFTC_T *)Context;
+    HTC_SEND_FULL_ACTION    action = HTC_SEND_FULL_KEEP;
+    A_BOOL                  stopNet = FALSE;
+    HTC_ENDPOINT_ID         Endpoint = HTC_GET_ENDPOINT_FROM_PKT(pPacket);
+
+    do {
+
+        if (bypasswmi) {
+            /* for endpointping testing no other checks need to be made
+             * we can however still allow the network to stop */
+            stopNet = TRUE;
+            break;
+        }
+
+        if (Endpoint == ar->arControlEp) {
+                /* under normal WMI if this is getting full, then something is running rampant
+                 * the host should not be exhausting the WMI queue with too many commands
+                 * the only exception to this is during testing using endpointping */
+
+            AR6000_SPIN_LOCK(&ar->arLock, 0);
+                /* set flag to handle subsequent messages */
+            ar->arWMIControlEpFull = TRUE;
+            AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+            AR_DEBUG_PRINTF("WMI Control Endpoint is FULL!!! \n");
+                /* no need to stop the network */
+            stopNet = FALSE;
+            break;
+        }
+
+        /* if we get here, we are dealing with data endpoints getting full */
+
+        if (HTC_GET_TAG_FROM_PKT(pPacket) == AR6K_CONTROL_PKT_TAG) {
+            /* don't drop control packets issued on ANY data endpoint */
+            break;
+        }
+
+        if (ar->arNetworkType == ADHOC_NETWORK) {
+            /* in adhoc mode, we cannot differentiate traffic priorities so there is no need to
+             * continue, however we should stop the network */
+            stopNet = TRUE;
+            break;
+        }
+
+        if (ar->arAcStreamPriMap[arEndpoint2Ac(ar,Endpoint)] < ar->arHiAcStreamActivePri) {
+                /* this stream's priority is less than the highest active priority, we
+                 * give preference to the highest priority stream by directing
+                 * HTC to drop the packet that overflowed */
+            action = HTC_SEND_FULL_DROP;
+                /* since we are dropping packets, no need to stop the network */
+            stopNet = FALSE;
+            break;
+        }
+
+    } while (FALSE);
+
+    if (stopNet) {
+        /* one of the data endpoints queues is getting full..need to stop network stack
+         * the queue will resume in ar6000_tx_complete() */
+        netif_stop_queue(ar->arNetDev);
+    }
+
+    return action;
+}
+
+
+static void
+ar6000_tx_complete(void *Context, HTC_PACKET *pPacket)
+{
+    AR_SOFTC_T     *ar = (AR_SOFTC_T *)Context;
+    void           *cookie = (void *)pPacket->pPktContext;
+    struct sk_buff *skb = NULL;
+    A_UINT32        mapNo = 0;
+    A_STATUS        status;
+    struct ar_cookie * ar_cookie;
+    HTC_ENDPOINT_ID   eid;
+    A_BOOL          wakeEvent = FALSE;
+
+    status = pPacket->Status;
+    ar_cookie = (struct ar_cookie *)cookie;
+    skb = (struct sk_buff *)ar_cookie->arc_bp[0];
+    eid = pPacket->Endpoint ;
+    mapNo = ar_cookie->arc_bp[1];
+
+    A_ASSERT(skb);
+    A_ASSERT(pPacket->pBuffer == A_NETBUF_DATA(skb));
+
+    if (A_SUCCESS(status)) {
+        A_ASSERT(pPacket->ActualLength == A_NETBUF_LEN(skb));
+    }
+
+    AR_DEBUG2_PRINTF("ar6000_tx_complete skb=0x%x data=0x%x len=0x%x eid=%d ",
+                     (A_UINT32)skb, (A_UINT32)pPacket->pBuffer,
+                     pPacket->ActualLength,
+                     eid);
+
+        /* lock the driver as we update internal state */
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    ar->arTxPending[eid]--;
+
+    if ((eid  != ar->arControlEp) || bypasswmi) {
+        ar->arTotalTxDataPending--;
+    }
+
+    if (eid == ar->arControlEp)
+    {
+        if (ar->arWMIControlEpFull) {
+                /* since this packet completed, the WMI EP is no longer full */
+            ar->arWMIControlEpFull = FALSE;
+        }
+
+        if (ar->arTxPending[eid] == 0) {
+            wakeEvent = TRUE;
+        }
+    }
+
+    if (A_FAILED(status)) {
+        AR6000_STAT_INC(ar, tx_errors);
+        if (status != A_NO_RESOURCE) {
+        AR_DEBUG_PRINTF("%s() -TX ERROR, status: 0x%x\n", __func__,
+                        status);
+        }
+    } else {
+        AR_DEBUG2_PRINTF("OK\n");
+        AR6000_STAT_INC(ar, tx_packets);
+        ar->arNetStats.tx_bytes += A_NETBUF_LEN(skb);
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+        aptcTR.bytesTransmitted += a_netbuf_to_len(skb);
+        applyAPTCHeuristics(ar);
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+    }
+
+    // TODO this needs to be looked at
+    if ((ar->arNetworkType == ADHOC_NETWORK) && ar->arIbssPsEnable
+        && (eid != ar->arControlEp) && mapNo)
+    {
+        mapNo --;
+        ar->arNodeMap[mapNo].txPending --;
+
+        if (!ar->arNodeMap[mapNo].txPending && (mapNo == (ar->arNodeNum - 1))) {
+            A_UINT32 i;
+            for (i = ar->arNodeNum; i > 0; i --) {
+                if (!ar->arNodeMap[i - 1].txPending) {
+                    A_MEMZERO(&ar->arNodeMap[i - 1], sizeof(struct ar_node_mapping));
+                    ar->arNodeNum --;
+                } else {
+                    break;
+                }
+            }
+        }
+    }
+
+    /* Freeing a cookie should not be contingent on either of */
+    /* these flags, just if we have a cookie or not.           */
+    /* Can we even get here without a cookie? Fix later.       */
+    if (ar->arWmiReady == TRUE || (bypasswmi))
+    {
+        ar6000_free_cookie(ar, cookie);
+    }
+
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+
+    /* lock is released, we can freely call other kernel APIs */
+
+    A_NETBUF_FREE(skb);
+
+    if ((ar->arConnected == TRUE) || (bypasswmi)) {
+        if (status != A_ECANCELED) {
+                /* don't wake the queue if we are flushing, other wise it will just
+                 * keep queueing packets, which will keep failing */
+            netif_wake_queue(ar->arNetDev);
+        }
+    }
+
+    if (wakeEvent) {
+        wake_up(&arEvent);
+    }
+
+}
+
+/*
+ * Receive event handler.  This is called by HTC when a packet is received
+ */
+int pktcount;
+static void
+ar6000_rx(void *Context, HTC_PACKET *pPacket)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)Context;
+    struct sk_buff *skb = (struct sk_buff *)pPacket->pPktContext;
+    int minHdrLen;
+    A_STATUS        status = pPacket->Status;
+    HTC_ENDPOINT_ID   ept = pPacket->Endpoint;
+
+    A_ASSERT((status != A_OK) ||
+             (pPacket->pBuffer == (A_NETBUF_DATA(skb) + HTC_HEADER_LEN)));
+
+    AR_DEBUG2_PRINTF("ar6000_rx ar=0x%x eid=%d, skb=0x%x, data=0x%x, len=0x%x ",
+                    (A_UINT32)ar, ept, (A_UINT32)skb, (A_UINT32)pPacket->pBuffer,
+                    pPacket->ActualLength);
+    if (status != A_OK) {
+        AR_DEBUG2_PRINTF("ERR\n");
+    } else {
+        AR_DEBUG2_PRINTF("OK\n");
+    }
+
+        /* take lock to protect buffer counts
+         * and adaptive power throughput state */
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    ar->arRxBuffers[ept]--;
+
+    if (A_SUCCESS(status)) {
+        AR6000_STAT_INC(ar, rx_packets);
+        ar->arNetStats.rx_bytes += pPacket->ActualLength;
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+        aptcTR.bytesReceived += a_netbuf_to_len(skb);
+        applyAPTCHeuristics(ar);
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+
+        A_NETBUF_PUT(skb, pPacket->ActualLength +  HTC_HEADER_LEN);
+        A_NETBUF_PULL(skb, HTC_HEADER_LEN);
+
+#ifdef DEBUG
+        if (debugdriver >= 2) {
+            ar6000_dump_skb(skb);
+        }
+#endif /* DEBUG */
+    }
+
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+
+    if (status != A_OK) {
+        AR6000_STAT_INC(ar, rx_errors);
+        A_NETBUF_FREE(skb);
+    } else if (ar->arWmiEnabled == TRUE) {
+        if (ept == ar->arControlEp) {
+           /*
+            * this is a wmi control msg
+            */
+            wmi_control_rx(ar->arWmi, skb);
+        } else {
+                /*
+                 * this is a wmi data packet
+                 */
+                minHdrLen = sizeof (WMI_DATA_HDR) + sizeof(ATH_MAC_HDR) +
+                            sizeof(ATH_LLC_SNAP_HDR);
+
+                if ((pPacket->ActualLength < minHdrLen) ||
+                    (pPacket->ActualLength > AR6000_BUFFER_SIZE))
+                {
+                    /*
+                     * packet is too short or too long
+                     */
+                    AR_DEBUG_PRINTF("TOO SHORT or TOO LONG\n");
+                    AR6000_STAT_INC(ar, rx_errors);
+                    AR6000_STAT_INC(ar, rx_length_errors);
+                    A_NETBUF_FREE(skb);
+                } else {
+#if 0
+                    /* Access RSSI values here */
+                    AR_DEBUG_PRINTF("RSSI %d\n",
+                        ((WMI_DATA_HDR *) A_NETBUF_DATA(skb))->rssi);
+#endif
+                    wmi_data_hdr_remove(ar->arWmi, skb);
+                    wmi_dot3_2_dix(ar->arWmi, skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+                    /*
+                     * extra push and memcpy, for eth_type_trans() of 2.4 kernel
+                     * will pull out hard_header_len bytes of the skb.
+                     */
+                    A_NETBUF_PUSH(skb, sizeof(WMI_DATA_HDR) + sizeof(ATH_LLC_SNAP_HDR) + HTC_HEADER_LEN);
+                    A_MEMCPY(A_NETBUF_DATA(skb), A_NETBUF_DATA(skb) + sizeof(WMI_DATA_HDR) +
+                             sizeof(ATH_LLC_SNAP_HDR) + HTC_HEADER_LEN, sizeof(ATH_MAC_HDR));
+#endif
+                    if ((ar->arNetDev->flags & IFF_UP) == IFF_UP)
+                    {
+                        skb->dev = ar->arNetDev;
+                        skb->protocol = eth_type_trans(skb, ar->arNetDev);
+                        netif_rx(skb);
+                    }
+                    else
+                    {
+                        A_NETBUF_FREE(skb);
+                    }
+                }
+            }
+    } else {
+        if ((ar->arNetDev->flags & IFF_UP) == IFF_UP)
+        {
+            skb->dev = ar->arNetDev;
+            skb->protocol = eth_type_trans(skb, ar->arNetDev);
+            netif_rx(skb);
+        }
+        else
+        {
+            A_NETBUF_FREE(skb);
+        }
+    }
+
+    if (status != A_ECANCELED) {
+        /*
+         * HTC provides A_ECANCELED status when it doesn't want to be refilled
+         * (probably due to a shutdown)
+         */
+        ar6000_rx_refill(Context, ept);
+    }
+
+
+}
+
+static void
+ar6000_rx_refill(void *Context, HTC_ENDPOINT_ID Endpoint)
+{
+    AR_SOFTC_T  *ar = (AR_SOFTC_T *)Context;
+    void        *osBuf;
+    int         RxBuffers;
+    int         buffersToRefill;
+    HTC_PACKET  *pPacket;
+
+    buffersToRefill = (int)AR6000_MAX_RX_BUFFERS -
+                                    (int)ar->arRxBuffers[Endpoint];
+
+    if (buffersToRefill <= 0) {
+            /* fast return, nothing to fill */
+        return;
+    }
+
+    AR_DEBUG2_PRINTF("ar6000_rx_refill: providing htc with %d buffers at eid=%d\n",
+                    buffersToRefill, Endpoint);
+
+    for (RxBuffers = 0; RxBuffers < buffersToRefill; RxBuffers++) {
+        osBuf = A_NETBUF_ALLOC(AR6000_BUFFER_SIZE);
+        if (NULL == osBuf) {
+            break;
+        }
+            /* the HTC packet wrapper is at the head of the reserved area
+             * in the skb */
+        pPacket = (HTC_PACKET *)(A_NETBUF_HEAD(osBuf));
+            /* set re-fill info */
+        SET_HTC_PACKET_INFO_RX_REFILL(pPacket,osBuf,A_NETBUF_DATA(osBuf),AR6000_BUFFER_SIZE,Endpoint);
+            /* add this packet */
+        HTCAddReceivePkt(ar->arHtcTarget, pPacket);
+    }
+
+        /* update count */
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+    ar->arRxBuffers[Endpoint] += RxBuffers;
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+}
+
+static struct net_device_stats *
+ar6000_get_stats(struct net_device *dev)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    return &ar->arNetStats;
+}
+
+static struct iw_statistics *
+ar6000_get_iwstats(struct net_device * dev)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    TARGET_STATS *pStats = &ar->arTargetStats;
+    struct iw_statistics * pIwStats = &ar->arIwStats;
+
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    A_MEMZERO(pIwStats, sizeof(struct iw_statistics));
+
+    if ((ar->arWmiReady == FALSE) || (ar->arConnected == FALSE)) {
+        pIwStats->qual.updated =
+            IW_QUAL_ALL_UPDATED | IW_QUAL_DBM | IW_QUAL_ALL_INVALID;
+        AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+        return pIwStats;
+    }
+
+    /*
+    * qual is the signal-to-noise ratio in dB.
+    * It is an unsigned integer in the range [0, 255], but in practice it
+    * should be in the range [1, max_qual.qual], where max_qual is the
+    * value returned by the SIOCGIWRANGE ioctl.  We limit the minimum value
+    * to 1 instead of 0, because some userspace applications insist on
+    * interpreting 0 as "no measurement" and manufacture a different value
+    * instead.
+    *
+    * level is the signal strength in dBm.  It is stored as an unsigned
+    * eight-bit integer, but it is interpreted as being in the range [-192, 63].
+    *
+    * noise is the noise level in dBm.  It is represented in the same way as the
+    * signal level.
+    */
+    pIwStats->qual.qual = pStats->cs_aveBeacon_snr;
+    if (pIwStats->qual.qual == 0)
+        pIwStats->qual.qual = 1;
+    if (pStats->cs_aveBeacon_rssi < -192)
+        pIwStats->qual.level = 256 - 192;
+    else if (pStats->cs_aveBeacon_rssi < 0)
+        pIwStats->qual.level = 256 + pStats->cs_aveBeacon_rssi;
+    else if (pStats->cs_aveBeacon_rssi > 63)
+        pIwStats->qual.level = 63;
+    else
+        pIwStats->qual.level = pStats->cs_aveBeacon_rssi;
+    if (pStats->noise_floor_calibation < -192)
+        pIwStats->qual.noise = 256 - 192;
+    else if (pStats->noise_floor_calibation < 0)
+        pIwStats->qual.noise = 256 + pStats->noise_floor_calibation;
+    else if (pStats->noise_floor_calibation > 63)
+        pIwStats->qual.noise = 63;
+    else
+        pIwStats->qual.noise = pStats->noise_floor_calibation;
+    pIwStats->discard.code = pStats->rx_decrypt_err;
+    pIwStats->discard.retries = pStats->tx_retry_cnt;
+    pIwStats->miss.beacon = pStats->cs_bmiss_cnt;
+
+    if (ar->statsUpdatePending == FALSE) {
+        ar->statsUpdatePending = TRUE;
+        pIwStats->status = 1;
+        pIwStats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
+        AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+        if (wmi_get_stats_cmd(ar->arWmi) != A_OK)
+            ar->statsUpdatePending = FALSE;
+    } else {
+        AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+    }
+
+    return pIwStats;
+}
+
+void
+ar6000_ready_event(void *devt, A_UINT8 *datap, A_UINT8 phyCap, A_UINT32 vers)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)devt;
+    struct net_device *dev = ar->arNetDev;
+
+    ar->arWmiReady = TRUE;
+    wake_up(&arEvent);
+    A_MEMCPY(dev->dev_addr, datap, AR6000_ETH_ADDR_LEN);
+    AR_DEBUG_PRINTF("mac address = %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\n",
+        dev->dev_addr[0], dev->dev_addr[1],
+        dev->dev_addr[2], dev->dev_addr[3],
+        dev->dev_addr[4], dev->dev_addr[5]);
+
+    ar->arPhyCapability = phyCap;
+    ar->arVersion.wlan_ver = vers;
+}
+
+void
+ar6000_connect_event(AR_SOFTC_T *ar, A_UINT16 channel, A_UINT8 *bssid,
+                     A_UINT16 listenInterval, A_UINT16 beaconInterval,
+                     NETWORK_TYPE networkType, A_UINT8 beaconIeLen,
+                     A_UINT8 assocReqLen, A_UINT8 assocRespLen,
+                     A_UINT8 *assocInfo)
+{
+    union iwreq_data wrqu;
+    int i, beacon_ie_pos, assoc_resp_ie_pos, assoc_req_ie_pos;
+    static const char *tag1 = "ASSOCINFO(ReqIEs=";
+    static const char *tag2 = "ASSOCRESPIE=";
+    static const char *beaconIetag = "BEACONIE=";
+    char buf[WMI_CONTROL_MSG_MAX_LEN * 2 + strlen(tag1) + 1];
+    char *pos;
+    A_UINT8 key_op_ctrl;
+
+    A_MEMCPY(ar->arBssid, bssid, sizeof(ar->arBssid));
+    ar->arBssChannel = channel;
+
+    A_PRINTF("AR6000 connected event on freq %d ", channel);
+    A_PRINTF("with bssid %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x "
+            " listenInterval=%d, beaconInterval = %d, beaconIeLen = %d assocReqLen=%d"
+            " assocRespLen =%d\n",
+             bssid[0], bssid[1], bssid[2],
+             bssid[3], bssid[4], bssid[5],
+             listenInterval, beaconInterval,
+             beaconIeLen, assocReqLen, assocRespLen);
+    if (networkType & ADHOC_NETWORK) {
+        if (networkType & ADHOC_CREATOR) {
+            A_PRINTF("Network: Adhoc (Creator)\n");
+        } else {
+            A_PRINTF("Network: Adhoc (Joiner)\n");
+        }
+    } else {
+        A_PRINTF("Network: Infrastructure\n");
+    }
+
+    if (beaconIeLen && (sizeof(buf) > (9 + beaconIeLen * 2))) {
+        AR_DEBUG_PRINTF("\nBeaconIEs= ");
+
+        beacon_ie_pos = 0;
+        A_MEMZERO(buf, sizeof(buf));
+        sprintf(buf, "%s", beaconIetag);
+        pos = buf + 9;
+        for (i = beacon_ie_pos; i < beacon_ie_pos + beaconIeLen; i++) {
+            AR_DEBUG_PRINTF("%2.2x ", assocInfo[i]);
+            sprintf(pos, "%2.2x", assocInfo[i]);
+            pos += 2;
+        }
+        AR_DEBUG_PRINTF("\n");
+
+        A_MEMZERO(&wrqu, sizeof(wrqu));
+        wrqu.data.length = strlen(buf);
+        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);
+    }
+
+    if (assocRespLen && (sizeof(buf) > (12 + (assocRespLen * 2))))
+    {
+        assoc_resp_ie_pos = beaconIeLen + assocReqLen +
+                            sizeof(A_UINT16)  +  /* capinfo*/
+                            sizeof(A_UINT16)  +  /* status Code */
+                            sizeof(A_UINT16)  ;  /* associd */
+        A_MEMZERO(buf, sizeof(buf));
+        sprintf(buf, "%s", tag2);
+        pos = buf + 12;
+        AR_DEBUG_PRINTF("\nAssocRespIEs= ");
+        /*
+         * The Association Response Frame w.o. the WLAN header is delivered to
+         * the host, so skip over to the IEs
+         */
+        for (i = assoc_resp_ie_pos; i < assoc_resp_ie_pos + assocRespLen - 6; i++)
+        {
+            AR_DEBUG_PRINTF("%2.2x ", assocInfo[i]);
+            sprintf(pos, "%2.2x", assocInfo[i]);
+            pos += 2;
+        }
+        AR_DEBUG_PRINTF("\n");
+
+        A_MEMZERO(&wrqu, sizeof(wrqu));
+        wrqu.data.length = strlen(buf);
+        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);
+    }
+
+    if (assocReqLen && (sizeof(buf) > (17 + (assocReqLen * 2)))) {
+        /*
+         * assoc Request includes capability and listen interval. Skip these.
+         */
+        assoc_req_ie_pos =  beaconIeLen +
+                            sizeof(A_UINT16)  +  /* capinfo*/
+                            sizeof(A_UINT16);    /* listen interval */
+
+        A_MEMZERO(buf, sizeof(buf));
+        sprintf(buf, "%s", tag1);
+        pos = buf + 17;
+        AR_DEBUG_PRINTF("AssocReqIEs= ");
+        for (i = assoc_req_ie_pos; i < assoc_req_ie_pos + assocReqLen - 4; i++) {
+            AR_DEBUG_PRINTF("%2.2x ", assocInfo[i]);
+            sprintf(pos, "%2.2x", assocInfo[i]);
+            pos += 2;;
+        }
+        AR_DEBUG_PRINTF("\n");
+
+        A_MEMZERO(&wrqu, sizeof(wrqu));
+        wrqu.data.length = strlen(buf);
+        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);
+    }
+
+#ifdef USER_KEYS
+    if (ar->user_savedkeys_stat == USER_SAVEDKEYS_STAT_RUN &&
+        ar->user_saved_keys.keyOk == TRUE)
+    {
+
+        key_op_ctrl = KEY_OP_VALID_MASK & ~KEY_OP_INIT_TSC;
+        if (ar->user_key_ctrl & AR6000_USER_SETKEYS_RSC_UNCHANGED) {
+            key_op_ctrl &= ~KEY_OP_INIT_RSC;
+        } else {
+            key_op_ctrl |= KEY_OP_INIT_RSC;
+        }
+        ar6000_reinstall_keys(ar, key_op_ctrl);
+    }
+#endif /* USER_KEYS */
+
+        /* flush data queues */
+    ar6000_TxDataCleanup(ar);
+
+    netif_carrier_on(ar->arNetDev);
+    netif_wake_queue(ar->arNetDev);
+
+    if ((OPEN_AUTH == ar->arDot11AuthMode) &&
+        (NONE_AUTH == ar->arAuthMode)      &&
+        (WEP_CRYPT == ar->arPairwiseCrypto))
+    {
+        if (!ar->arConnected) {
+            ar6000_install_static_wep_keys(ar);
+        }
+    }
+
+    ar->arConnected  = TRUE;
+    ar->arConnectPending = FALSE;
+
+    reconnect_flag = 0;
+
+    A_MEMZERO(&wrqu, sizeof(wrqu));
+    A_MEMCPY(wrqu.addr.sa_data, bssid, IEEE80211_ADDR_LEN);
+    wrqu.addr.sa_family = ARPHRD_ETHER;
+    wireless_send_event(ar->arNetDev, SIOCGIWAP, &wrqu, NULL);
+    if ((ar->arNetworkType == ADHOC_NETWORK) && ar->arIbssPsEnable) {
+        A_MEMZERO(ar->arNodeMap, sizeof(ar->arNodeMap));
+        ar->arNodeNum = 0;
+        ar->arNexEpId = ENDPOINT_2;
+    }
+   if (!ar->arUserBssFilter) {
+        wmi_bssfilter_cmd(ar->arWmi, NONE_BSS_FILTER, 0);
+   }
+
+}
+
+void ar6000_set_numdataendpts(AR_SOFTC_T *ar, A_UINT32 num)
+{
+    A_ASSERT(num <= (HTC_MAILBOX_NUM_MAX - 1));
+    ar->arNumDataEndPts = num;
+}
+
+void
+ar6000_disconnect_event(AR_SOFTC_T *ar, A_UINT8 reason, A_UINT8 *bssid,
+                        A_UINT8 assocRespLen, A_UINT8 *assocInfo, A_UINT16 protocolReasonStatus)
+{
+    A_UINT8 i;
+    union iwreq_data wrqu;
+
+    A_PRINTF("AR6000 disconnected");
+    if (bssid[0] || bssid[1] || bssid[2] || bssid[3] || bssid[4] || bssid[5]) {
+        A_PRINTF(" from %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x ",
+                 bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], bssid[5]);
+    }
+    A_PRINTF("\n");
+
+    AR_DEBUG_PRINTF("\nDisconnect Reason is %d", reason);
+    AR_DEBUG_PRINTF("\nProtocol Reason/Status Code is %d", protocolReasonStatus);
+    AR_DEBUG_PRINTF("\nAssocResp Frame = %s",
+                    assocRespLen ? " " : "NULL");
+    for (i = 0; i < assocRespLen; i++) {
+        if (!(i % 0x10)) {
+            AR_DEBUG_PRINTF("\n");
+        }
+        AR_DEBUG_PRINTF("%2.2x ", assocInfo[i]);
+    }
+    AR_DEBUG_PRINTF("\n");
+    /*
+     * If the event is due to disconnect cmd from the host, only they the target
+     * would stop trying to connect. Under any other condition, target would
+     * keep trying to connect.
+     *
+     */
+    if( reason == DISCONNECT_CMD)
+    {
+        ar->arConnectPending = FALSE;
+        if (!ar->arUserBssFilter) {
+            wmi_bssfilter_cmd(ar->arWmi, NONE_BSS_FILTER, 0);
+        }
+    } else {
+        ar->arConnectPending = TRUE;
+        if (((reason == ASSOC_FAILED) && (protocolReasonStatus == 0x11)) ||
+            ((reason == ASSOC_FAILED) && (protocolReasonStatus == 0x0) && (reconnect_flag == 1))) {
+            ar->arConnected = TRUE;
+            return;
+        }
+    }
+    ar->arConnected = FALSE;
+
+    if( (reason != CSERV_DISCONNECT) || (reconnect_flag != 1) ) {
+        reconnect_flag = 0;
+    }
+
+#ifdef USER_KEYS
+    if (reason != CSERV_DISCONNECT)
+    {
+        ar->user_savedkeys_stat = USER_SAVEDKEYS_STAT_INIT;
+        ar->user_key_ctrl      = 0;
+    }
+#endif /* USER_KEYS */
+
+    netif_stop_queue(ar->arNetDev);
+    netif_carrier_off(ar->arNetDev);
+    A_MEMZERO(ar->arBssid, sizeof(ar->arBssid));
+    ar->arBssChannel = 0;
+    ar->arBeaconInterval = 0;
+
+    ar6000_TxDataCleanup(ar);
+
+    /* notify userspace of the disconnection */
+    A_MEMZERO(&wrqu, sizeof(wrqu));
+    wrqu.addr.sa_family = ARPHRD_ETHER;
+    wireless_send_event(ar->arNetDev, SIOCGIWAP, &wrqu, NULL);
+}
+
+void
+ar6000_regDomain_event(AR_SOFTC_T *ar, A_UINT32 regCode)
+{
+    A_PRINTF("AR6000 Reg Code = 0x%x\n", regCode);
+    ar->arRegCode = regCode;
+}
+
+void
+ar6000_neighborReport_event(AR_SOFTC_T *ar, int numAps, WMI_NEIGHBOR_INFO *info)
+{
+    static const char *tag = "PRE-AUTH";
+    char buf[128];
+    union iwreq_data wrqu;
+    int i;
+
+    AR_DEBUG_PRINTF("AR6000 Neighbor Report Event\n");
+    for (i=0; i < numAps; info++, i++) {
+        AR_DEBUG_PRINTF("bssid %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x ",
+            info->bssid[0], info->bssid[1], info->bssid[2],
+            info->bssid[3], info->bssid[4], info->bssid[5]);
+        if (info->bssFlags & WMI_PREAUTH_CAPABLE_BSS) {
+            AR_DEBUG_PRINTF("preauth-cap");
+        }
+        if (info->bssFlags & WMI_PMKID_VALID_BSS) {
+            AR_DEBUG_PRINTF(" pmkid-valid\n");
+            continue;           /* we skip bss if the pmkid is already valid */
+        }
+        AR_DEBUG_PRINTF("\n");
+        snprintf(buf, sizeof(buf), "%s%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x",
+                 tag,
+                 info->bssid[0], info->bssid[1], info->bssid[2],
+                 info->bssid[3], info->bssid[4], info->bssid[5],
+                 i, info->bssFlags);
+        A_MEMZERO(&wrqu, sizeof(wrqu));
+        wrqu.data.length = strlen(buf);
+        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);
+    }
+}
+
+void
+ar6000_tkip_micerr_event(AR_SOFTC_T *ar, A_UINT8 keyid, A_BOOL ismcast)
+{
+    static const char *tag = "MLME-MICHAELMICFAILURE.indication";
+    char buf[128];
+    union iwreq_data wrqu;
+
+    A_PRINTF("AR6000 TKIP MIC error received for keyid %d %scast\n",
+             keyid, ismcast ? "multi": "uni");
+    snprintf(buf, sizeof(buf), "%s(keyid=%d %sicast)", tag, keyid,
+             ismcast ? "mult" : "un");
+    memset(&wrqu, 0, sizeof(wrqu));
+    wrqu.data.length = strlen(buf);
+    wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);
+}
+
+void
+ar6000_scanComplete_event(AR_SOFTC_T *ar, A_STATUS status)
+{
+	union iwreq_data wrqu;
+
+        ar->siocsiwscan_timestamp = 0;
+
+    	if (!ar->arUserBssFilter) {
+		wmi_bssfilter_cmd(ar->arWmi, NONE_BSS_FILTER, 0);
+	}
+	AR_DEBUG_PRINTF("AR6000 scan complete: %d\n", status);
+
+	/* send scan complete event to userspace */
+	memset(&wrqu, 0, sizeof(wrqu));
+	wireless_send_event(ar->arNetDev, SIOCGIWSCAN, &wrqu, NULL);
+}
+
+void
+ar6000_targetStats_event(AR_SOFTC_T *ar,  WMI_TARGET_STATS *pTarget)
+{
+    TARGET_STATS *pStats = &ar->arTargetStats;
+    A_UINT8 ac;
+
+    AR_DEBUG_PRINTF("AR6000 updating target stats\n");
+
+    // Update the RSSI of the connected bss.
+    if (ar->arConnected) {
+        bss_t *pConnBss = NULL;
+
+        pConnBss = wmi_find_node(ar->arWmi,ar->arBssid);
+        if (pConnBss)
+        {
+            pConnBss->ni_rssi = pTarget->cservStats.cs_aveBeacon_rssi;
+            pConnBss->ni_snr = pTarget->cservStats.cs_aveBeacon_snr;
+            wmi_node_return(ar->arWmi, pConnBss);
+        }
+    }
+
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+    pStats->tx_packets          += pTarget->txrxStats.tx_stats.tx_packets;
+    pStats->tx_bytes            += pTarget->txrxStats.tx_stats.tx_bytes;
+    pStats->tx_unicast_pkts     += pTarget->txrxStats.tx_stats.tx_unicast_pkts;
+    pStats->tx_unicast_bytes    += pTarget->txrxStats.tx_stats.tx_unicast_bytes;
+    pStats->tx_multicast_pkts   += pTarget->txrxStats.tx_stats.tx_multicast_pkts;
+    pStats->tx_multicast_bytes  += pTarget->txrxStats.tx_stats.tx_multicast_bytes;
+    pStats->tx_broadcast_pkts   += pTarget->txrxStats.tx_stats.tx_broadcast_pkts;
+    pStats->tx_broadcast_bytes  += pTarget->txrxStats.tx_stats.tx_broadcast_bytes;
+    pStats->tx_rts_success_cnt  += pTarget->txrxStats.tx_stats.tx_rts_success_cnt;
+    for(ac = 0; ac < WMM_NUM_AC; ac++)
+        pStats->tx_packet_per_ac[ac] += pTarget->txrxStats.tx_stats.tx_packet_per_ac[ac];
+    pStats->tx_errors           += pTarget->txrxStats.tx_stats.tx_errors;
+    pStats->tx_failed_cnt       += pTarget->txrxStats.tx_stats.tx_failed_cnt;
+    pStats->tx_retry_cnt        += pTarget->txrxStats.tx_stats.tx_retry_cnt;
+    pStats->tx_mult_retry_cnt   += pTarget->txrxStats.tx_stats.tx_mult_retry_cnt;
+    pStats->tx_rts_fail_cnt     += pTarget->txrxStats.tx_stats.tx_rts_fail_cnt;
+    pStats->tx_unicast_rate      = wmi_get_rate(pTarget->txrxStats.tx_stats.tx_unicast_rate);
+
+    pStats->rx_packets          += pTarget->txrxStats.rx_stats.rx_packets;
+    pStats->rx_bytes            += pTarget->txrxStats.rx_stats.rx_bytes;
+    pStats->rx_unicast_pkts     += pTarget->txrxStats.rx_stats.rx_unicast_pkts;
+    pStats->rx_unicast_bytes    += pTarget->txrxStats.rx_stats.rx_unicast_bytes;
+    pStats->rx_multicast_pkts   += pTarget->txrxStats.rx_stats.rx_multicast_pkts;
+    pStats->rx_multicast_bytes  += pTarget->txrxStats.rx_stats.rx_multicast_bytes;
+    pStats->rx_broadcast_pkts   += pTarget->txrxStats.rx_stats.rx_broadcast_pkts;
+    pStats->rx_broadcast_bytes  += pTarget->txrxStats.rx_stats.rx_broadcast_bytes;
+    pStats->rx_fragment_pkt     += pTarget->txrxStats.rx_stats.rx_fragment_pkt;
+    pStats->rx_errors           += pTarget->txrxStats.rx_stats.rx_errors;
+    pStats->rx_crcerr           += pTarget->txrxStats.rx_stats.rx_crcerr;
+    pStats->rx_key_cache_miss   += pTarget->txrxStats.rx_stats.rx_key_cache_miss;
+    pStats->rx_decrypt_err      += pTarget->txrxStats.rx_stats.rx_decrypt_err;
+    pStats->rx_duplicate_frames += pTarget->txrxStats.rx_stats.rx_duplicate_frames;
+    pStats->rx_unicast_rate      = wmi_get_rate(pTarget->txrxStats.rx_stats.rx_unicast_rate);
+
+
+    pStats->tkip_local_mic_failure
+                                += pTarget->txrxStats.tkipCcmpStats.tkip_local_mic_failure;
+    pStats->tkip_counter_measures_invoked
+                                += pTarget->txrxStats.tkipCcmpStats.tkip_counter_measures_invoked;
+    pStats->tkip_replays        += pTarget->txrxStats.tkipCcmpStats.tkip_replays;
+    pStats->tkip_format_errors  += pTarget->txrxStats.tkipCcmpStats.tkip_format_errors;
+    pStats->ccmp_format_errors  += pTarget->txrxStats.tkipCcmpStats.ccmp_format_errors;
+    pStats->ccmp_replays        += pTarget->txrxStats.tkipCcmpStats.ccmp_replays;
+
+
+    pStats->power_save_failure_cnt += pTarget->pmStats.power_save_failure_cnt;
+    pStats->noise_floor_calibation = pTarget->noise_floor_calibation;
+
+    pStats->cs_bmiss_cnt        += pTarget->cservStats.cs_bmiss_cnt;
+    pStats->cs_lowRssi_cnt      += pTarget->cservStats.cs_lowRssi_cnt;
+    pStats->cs_connect_cnt      += pTarget->cservStats.cs_connect_cnt;
+    pStats->cs_disconnect_cnt   += pTarget->cservStats.cs_disconnect_cnt;
+    pStats->cs_aveBeacon_snr    = pTarget->cservStats.cs_aveBeacon_snr;
+    pStats->cs_aveBeacon_rssi   = pTarget->cservStats.cs_aveBeacon_rssi;
+    pStats->cs_lastRoam_msec    = pTarget->cservStats.cs_lastRoam_msec;
+    pStats->cs_snr              = pTarget->cservStats.cs_snr;
+    pStats->cs_rssi             = pTarget->cservStats.cs_rssi;
+
+    pStats->lq_val              = pTarget->lqVal;
+
+    pStats->wow_num_pkts_dropped += pTarget->wowStats.wow_num_pkts_dropped;
+    pStats->wow_num_host_pkt_wakeups += pTarget->wowStats.wow_num_host_pkt_wakeups;
+    pStats->wow_num_host_event_wakeups += pTarget->wowStats.wow_num_host_event_wakeups;
+    pStats->wow_num_events_discarded += pTarget->wowStats.wow_num_events_discarded;
+
+    ar->statsUpdatePending = FALSE;
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+    wake_up(&arEvent);
+}
+
+void
+ar6000_rssiThreshold_event(AR_SOFTC_T *ar,  WMI_RSSI_THRESHOLD_VAL newThreshold, A_INT16 rssi)
+{
+    USER_RSSI_THOLD userRssiThold;
+
+    /* Send an event to the app */
+    userRssiThold.tag = ar->rssi_map[newThreshold].tag;
+    userRssiThold.rssi = rssi + SIGNAL_QUALITY_NOISE_FLOOR;
+    A_PRINTF("rssi Threshold range = %d tag = %d  rssi = %d\n", newThreshold,
+             userRssiThold.tag, userRssiThold.rssi);
+
+    ar6000_send_event_to_app(ar, WMI_RSSI_THRESHOLD_EVENTID,(A_UINT8 *)&userRssiThold, sizeof(USER_RSSI_THOLD));
+}
+
+
+void
+ar6000_hbChallengeResp_event(AR_SOFTC_T *ar, A_UINT32 cookie, A_UINT32 source)
+{
+    if (source == APP_HB_CHALLENGE) {
+        /* Report it to the app in case it wants a positive acknowledgement */
+        ar6000_send_event_to_app(ar, WMIX_HB_CHALLENGE_RESP_EVENTID,
+                                 (A_UINT8 *)&cookie, sizeof(cookie));
+    } else {
+        /* This would ignore the replys that come in after their due time */
+        if (cookie == ar->arHBChallengeResp.seqNum) {
+            ar->arHBChallengeResp.outstanding = FALSE;
+        }
+    }
+}
+
+
+void
+ar6000_reportError_event(AR_SOFTC_T *ar, WMI_TARGET_ERROR_VAL errorVal)
+{
+    char    *errString[] = {
+                [WMI_TARGET_PM_ERR_FAIL]    "WMI_TARGET_PM_ERR_FAIL",
+                [WMI_TARGET_KEY_NOT_FOUND]  "WMI_TARGET_KEY_NOT_FOUND",
+                [WMI_TARGET_DECRYPTION_ERR] "WMI_TARGET_DECRYPTION_ERR",
+                [WMI_TARGET_BMISS]          "WMI_TARGET_BMISS",
+                [WMI_PSDISABLE_NODE_JOIN]   "WMI_PSDISABLE_NODE_JOIN"
+                };
+
+    A_PRINTF("AR6000 Error on Target. Error = 0x%x\n", errorVal);
+
+    /* One error is reported at a time, and errorval is a bitmask */
+    if(errorVal & (errorVal - 1))
+       return;
+
+    A_PRINTF("AR6000 Error type = ");
+    switch(errorVal)
+    {
+        case WMI_TARGET_PM_ERR_FAIL:
+        case WMI_TARGET_KEY_NOT_FOUND:
+        case WMI_TARGET_DECRYPTION_ERR:
+        case WMI_TARGET_BMISS:
+        case WMI_PSDISABLE_NODE_JOIN:
+            A_PRINTF("%s\n", errString[errorVal]);
+            break;
+        default:
+            A_PRINTF("INVALID\n");
+            break;
+    }
+
+}
+
+
+void
+ar6000_cac_event(AR_SOFTC_T *ar, A_UINT8 ac, A_UINT8 cacIndication,
+                 A_UINT8 statusCode, A_UINT8 *tspecSuggestion)
+{
+    WMM_TSPEC_IE    *tspecIe;
+
+    /*
+     * This is the TSPEC IE suggestion from AP.
+     * Suggestion provided by AP under some error
+     * cases, could be helpful for the host app.
+     * Check documentation.
+     */
+    tspecIe = (WMM_TSPEC_IE *)tspecSuggestion;
+
+    /*
+     * What do we do, if we get TSPEC rejection? One thought
+     * that comes to mind is implictly delete the pstream...
+     */
+    A_PRINTF("AR6000 CAC notification. "
+                "AC = %d, cacIndication = 0x%x, statusCode = 0x%x\n",
+                 ac, cacIndication, statusCode);
+}
+
+void
+ar6000_channel_change_event(AR_SOFTC_T *ar, A_UINT16 oldChannel,
+                            A_UINT16 newChannel)
+{
+    A_PRINTF("Channel Change notification\nOld Channel: %d, New Channel: %d\n",
+             oldChannel, newChannel);
+}
+
+#define AR6000_PRINT_BSSID(_pBss)  do {     \
+        A_PRINTF("%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x ",\
+                 (_pBss)[0],(_pBss)[1],(_pBss)[2],(_pBss)[3],\
+                 (_pBss)[4],(_pBss)[5]);  \
+} while(0)
+
+void
+ar6000_roam_tbl_event(AR_SOFTC_T *ar, WMI_TARGET_ROAM_TBL *pTbl)
+{
+    A_UINT8 i;
+
+    A_PRINTF("ROAM TABLE NO OF ENTRIES is %d ROAM MODE is %d\n",
+              pTbl->numEntries, pTbl->roamMode);
+    for (i= 0; i < pTbl->numEntries; i++) {
+        A_PRINTF("[%d]bssid %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x ", i,
+            pTbl->bssRoamInfo[i].bssid[0], pTbl->bssRoamInfo[i].bssid[1],
+            pTbl->bssRoamInfo[i].bssid[2],
+            pTbl->bssRoamInfo[i].bssid[3],
+            pTbl->bssRoamInfo[i].bssid[4],
+            pTbl->bssRoamInfo[i].bssid[5]);
+        A_PRINTF("RSSI %d RSSIDT %d LAST RSSI %d UTIL %d ROAM_UTIL %d"
+                 " BIAS %d\n",
+            pTbl->bssRoamInfo[i].rssi,
+            pTbl->bssRoamInfo[i].rssidt,
+            pTbl->bssRoamInfo[i].last_rssi,
+            pTbl->bssRoamInfo[i].util,
+            pTbl->bssRoamInfo[i].roam_util,
+            pTbl->bssRoamInfo[i].bias);
+    }
+}
+
+void
+ar6000_wow_list_event(struct ar6_softc *ar, A_UINT8 num_filters, WMI_GET_WOW_LIST_REPLY *wow_reply)
+{
+    A_UINT8 i,j;
+
+    /*Each event now contains exactly one filter, see bug 26613*/
+    A_PRINTF("WOW pattern %d of %d patterns\n", wow_reply->this_filter_num,                 wow_reply->num_filters);
+    A_PRINTF("wow mode = %s host mode = %s\n",
+            (wow_reply->wow_mode == 0? "disabled":"enabled"),
+            (wow_reply->host_mode == 1 ? "awake":"asleep"));
+
+
+    /*If there are no patterns, the reply will only contain generic
+      WoW information. Pattern information will exist only if there are
+      patterns present. Bug 26716*/
+
+   /* If this event contains pattern information, display it*/
+    if (wow_reply->this_filter_num) {
+        i=0;
+        A_PRINTF("id=%d size=%d offset=%d\n",
+                    wow_reply->wow_filters[i].wow_filter_id,
+                    wow_reply->wow_filters[i].wow_filter_size,
+                    wow_reply->wow_filters[i].wow_filter_offset);
+       A_PRINTF("wow pattern = ");
+       for (j=0; j< wow_reply->wow_filters[i].wow_filter_size; j++) {
+             A_PRINTF("%2.2x",wow_reply->wow_filters[i].wow_filter_pattern[j]);
+        }
+
+        A_PRINTF("\nwow mask = ");
+        for (j=0; j< wow_reply->wow_filters[i].wow_filter_size; j++) {
+            A_PRINTF("%2.2x",wow_reply->wow_filters[i].wow_filter_mask[j]);
+        }
+        A_PRINTF("\n");
+    }
+}
+
+/*
+ * Report the Roaming related data collected on the target
+ */
+void
+ar6000_display_roam_time(WMI_TARGET_ROAM_TIME *p)
+{
+    A_PRINTF("Disconnect Data : BSSID: ");
+    AR6000_PRINT_BSSID(p->disassoc_bssid);
+    A_PRINTF(" RSSI %d DISASSOC Time %d NO_TXRX_TIME %d\n",
+             p->disassoc_bss_rssi,p->disassoc_time,
+             p->no_txrx_time);
+    A_PRINTF("Connect Data: BSSID: ");
+    AR6000_PRINT_BSSID(p->assoc_bssid);
+    A_PRINTF(" RSSI %d ASSOC Time %d TXRX_TIME %d\n",
+             p->assoc_bss_rssi,p->assoc_time,
+             p->allow_txrx_time);
+    A_PRINTF("Last Data Tx Time (b4 Disassoc) %d "\
+             "First Data Tx Time (after Assoc) %d\n",
+             p->last_data_txrx_time, p->first_data_txrx_time);
+}
+
+void
+ar6000_roam_data_event(AR_SOFTC_T *ar, WMI_TARGET_ROAM_DATA *p)
+{
+    switch (p->roamDataType) {
+        case ROAM_DATA_TIME:
+            ar6000_display_roam_time(&p->u.roamTime);
+            break;
+        default:
+            break;
+    }
+}
+
+void
+ar6000_bssInfo_event_rx(AR_SOFTC_T *ar, A_UINT8 *datap, int len)
+{
+    struct sk_buff *skb;
+    WMI_BSS_INFO_HDR *bih = (WMI_BSS_INFO_HDR *)datap;
+
+
+    if (!ar->arMgmtFilter) {
+        return;
+    }
+    if (((ar->arMgmtFilter & IEEE80211_FILTER_TYPE_BEACON) &&
+        (bih->frameType != BEACON_FTYPE))  ||
+        ((ar->arMgmtFilter & IEEE80211_FILTER_TYPE_PROBE_RESP) &&
+        (bih->frameType != PROBERESP_FTYPE)))
+    {
+        return;
+    }
+
+    if ((skb = A_NETBUF_ALLOC_RAW(len)) != NULL) {
+
+        A_NETBUF_PUT(skb, len);
+        A_MEMCPY(A_NETBUF_DATA(skb), datap, len);
+        skb->dev = ar->arNetDev;
+        skb_reset_mac_header(skb);
+        skb->ip_summed = CHECKSUM_NONE;
+        skb->pkt_type = PACKET_OTHERHOST;
+        skb->protocol = __constant_htons(0x0019);
+        netif_rx(skb);
+    }
+}
+
+A_UINT32 wmiSendCmdNum;
+
+A_STATUS
+ar6000_control_tx(void *devt, void *osbuf, HTC_ENDPOINT_ID eid)
+{
+    AR_SOFTC_T       *ar = (AR_SOFTC_T *)devt;
+    A_STATUS         status = A_OK;
+    struct ar_cookie *cookie = NULL;
+    int i;
+
+        /* take lock to protect ar6000_alloc_cookie() */
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    do {
+
+        AR_DEBUG2_PRINTF("ar_contrstatus = ol_tx: skb=0x%x, len=0x%x eid =%d\n",
+                         (A_UINT32)osbuf, A_NETBUF_LEN(osbuf), eid);
+
+        if (ar->arWMIControlEpFull && (eid == ar->arControlEp)) {
+                /* control endpoint is full, don't allocate resources, we
+                 * are just going to drop this packet */
+            cookie = NULL;
+            AR_DEBUG_PRINTF(" WMI Control EP full, dropping packet : 0x%X, len:%d \n",
+                    (A_UINT32)osbuf, A_NETBUF_LEN(osbuf));
+        } else {
+            cookie = ar6000_alloc_cookie(ar);
+        }
+
+        if (cookie == NULL) {
+            status = A_NO_MEMORY;
+            break;
+        }
+
+        if(logWmiRawMsgs) {
+            A_PRINTF("WMI cmd send, msgNo %d :", wmiSendCmdNum);
+            for(i = 0; i < a_netbuf_to_len(osbuf); i++)
+                A_PRINTF("%x ", ((A_UINT8 *)a_netbuf_to_data(osbuf))[i]);
+            A_PRINTF("\n");
+        }
+
+        wmiSendCmdNum++;
+
+    } while (FALSE);
+
+    if (cookie != NULL) {
+            /* got a structure to send it out on */
+        ar->arTxPending[eid]++;
+
+        if (eid != ar->arControlEp) {
+            ar->arTotalTxDataPending++;
+        }
+    }
+
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+
+    if (cookie != NULL) {
+        cookie->arc_bp[0] = (A_UINT32)osbuf;
+        cookie->arc_bp[1] = 0;
+        SET_HTC_PACKET_INFO_TX(&cookie->HtcPkt,
+                               cookie,
+                               A_NETBUF_DATA(osbuf),
+                               A_NETBUF_LEN(osbuf),
+                               eid,
+                               AR6K_CONTROL_PKT_TAG);
+            /* this interface is asynchronous, if there is an error, cleanup will happen in the
+             * TX completion callback */
+        HTCSendPkt(ar->arHtcTarget, &cookie->HtcPkt);
+        status = A_OK;
+    }
+
+    return status;
+}
+
+/* indicate tx activity or inactivity on a WMI stream */
+void ar6000_indicate_tx_activity(void *devt, A_UINT8 TrafficClass, A_BOOL Active)
+{
+    AR_SOFTC_T  *ar = (AR_SOFTC_T *)devt;
+    HTC_ENDPOINT_ID eid ;
+    int i;
+
+    if (ar->arWmiEnabled) {
+        eid = arAc2EndpointID(ar, TrafficClass);
+
+        AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+        ar->arAcStreamActive[TrafficClass] = Active;
+
+        if (Active) {
+            /* when a stream goes active, keep track of the active stream with the highest priority */
+
+            if (ar->arAcStreamPriMap[TrafficClass] > ar->arHiAcStreamActivePri) {
+                    /* set the new highest active priority */
+                ar->arHiAcStreamActivePri = ar->arAcStreamPriMap[TrafficClass];
+            }
+
+        } else {
+            /* when a stream goes inactive, we may have to search for the next active stream
+             * that is the highest priority */
+
+            if (ar->arHiAcStreamActivePri == ar->arAcStreamPriMap[TrafficClass]) {
+
+                /* the highest priority stream just went inactive */
+
+                    /* reset and search for the "next" highest "active" priority stream */
+                ar->arHiAcStreamActivePri = 0;
+                for (i = 0; i < WMM_NUM_AC; i++) {
+                    if (ar->arAcStreamActive[i]) {
+                        if (ar->arAcStreamPriMap[i] > ar->arHiAcStreamActivePri) {
+                            /* set the new highest active priority */
+                            ar->arHiAcStreamActivePri = ar->arAcStreamPriMap[i];
+                        }
+                    }
+                }
+            }
+        }
+
+        AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+
+    } else {
+            /* for mbox ping testing, the traffic class is mapped directly as a stream ID,
+             * see handling of AR6000_XIOCTL_TRAFFIC_ACTIVITY_CHANGE in ioctl.c */
+        eid = (HTC_ENDPOINT_ID)TrafficClass;
+    }
+
+        /* notify HTC, this may cause credit distribution changes */
+
+    HTCIndicateActivityChange(ar->arHtcTarget,
+                              eid,
+                              Active);
+
+}
+
+module_init(ar6000_init_module);
+module_exit(ar6000_cleanup_module);
+
+/* Init cookie queue */
+static void
+ar6000_cookie_init(AR_SOFTC_T *ar)
+{
+    A_UINT32    i;
+
+    ar->arCookieList = NULL;
+    A_MEMZERO(s_ar_cookie_mem, sizeof(s_ar_cookie_mem));
+
+    for (i = 0; i < MAX_COOKIE_NUM; i++) {
+        ar6000_free_cookie(ar, &s_ar_cookie_mem[i]);
+    }
+}
+
+/* cleanup cookie queue */
+static void
+ar6000_cookie_cleanup(AR_SOFTC_T *ar)
+{
+    /* It is gone .... */
+    ar->arCookieList = NULL;
+}
+
+/* Init cookie queue */
+static void
+ar6000_free_cookie(AR_SOFTC_T *ar, struct ar_cookie * cookie)
+{
+    /* Insert first */
+    A_ASSERT(ar != NULL);
+    A_ASSERT(cookie != NULL);
+    cookie->arc_list_next = ar->arCookieList;
+    ar->arCookieList = cookie;
+}
+
+/* cleanup cookie queue */
+static struct ar_cookie *
+ar6000_alloc_cookie(AR_SOFTC_T  *ar)
+{
+    struct ar_cookie   *cookie;
+
+    cookie = ar->arCookieList;
+    if(cookie != NULL)
+    {
+        ar->arCookieList = cookie->arc_list_next;
+    }
+
+    return cookie;
+}
+
+#ifdef SEND_EVENT_TO_APP
+/*
+ * This function is used to send event which come from taget to
+ * the application. The buf which send to application is include
+ * the event ID and event content.
+ */
+#define EVENT_ID_LEN   2
+void ar6000_send_event_to_app(AR_SOFTC_T *ar, A_UINT16 eventId,
+                              A_UINT8 *datap, int len)
+{
+
+#if (WIRELESS_EXT >= 15)
+
+/* note: IWEVCUSTOM only exists in wireless extensions after version 15 */
+
+    char *buf;
+    A_UINT16 size;
+    union iwreq_data wrqu;
+
+    size = len + EVENT_ID_LEN;
+
+    if (size > IW_CUSTOM_MAX) {
+        AR_DEBUG_PRINTF("WMI event ID : 0x%4.4X, len = %d too big for IWEVCUSTOM (max=%d) \n",
+                eventId, size, IW_CUSTOM_MAX);
+        return;
+    }
+
+    buf = A_MALLOC_NOWAIT(size);
+    A_MEMZERO(buf, size);
+    A_MEMCPY(buf, &eventId, EVENT_ID_LEN);
+    A_MEMCPY(buf+EVENT_ID_LEN, datap, len);
+
+    //AR_DEBUG_PRINTF("event ID = %d,len = %d\n",*(A_UINT16*)buf, size);
+    A_MEMZERO(&wrqu, sizeof(wrqu));
+    wrqu.data.length = size;
+    wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);
+
+    A_FREE(buf);
+#endif
+
+
+}
+#endif
+
+
+void
+ar6000_tx_retry_err_event(void *devt)
+{
+    AR_DEBUG2_PRINTF("Tx retries reach maximum!\n");
+}
+
+void
+ar6000_snrThresholdEvent_rx(void *devt, WMI_SNR_THRESHOLD_VAL newThreshold, A_UINT8 snr)
+{
+    WMI_SNR_THRESHOLD_EVENT event;
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)devt;
+
+    event.range = newThreshold;
+    event.snr = snr;
+
+    ar6000_send_event_to_app(ar, WMI_SNR_THRESHOLD_EVENTID, (A_UINT8 *)&event,
+                             sizeof(WMI_SNR_THRESHOLD_EVENT));
+}
+
+void
+ar6000_lqThresholdEvent_rx(void *devt, WMI_LQ_THRESHOLD_VAL newThreshold, A_UINT8 lq)
+{
+    AR_DEBUG2_PRINTF("lq threshold range %d, lq %d\n", newThreshold, lq);
+}
+
+
+
+A_UINT32
+a_copy_to_user(void *to, const void *from, A_UINT32 n)
+{
+    return(copy_to_user(to, from, n));
+}
+
+A_UINT32
+a_copy_from_user(void *to, const void *from, A_UINT32 n)
+{
+    return(copy_from_user(to, from, n));
+}
+
+
+A_STATUS
+ar6000_get_driver_cfg(struct net_device *dev,
+                        A_UINT16 cfgParam,
+                        void *result)
+{
+
+    A_STATUS    ret = 0;
+
+    switch(cfgParam)
+    {
+        case AR6000_DRIVER_CFG_GET_WLANNODECACHING:
+           *((A_UINT32 *)result) = wlanNodeCaching;
+           break;
+        case AR6000_DRIVER_CFG_LOG_RAW_WMI_MSGS:
+           *((A_UINT32 *)result) = logWmiRawMsgs;
+            break;
+        default:
+           ret = EINVAL;
+           break;
+    }
+
+    return ret;
+}
+
+void
+ar6000_keepalive_rx(void *devt, A_UINT8 configured)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)devt;
+
+    ar->arKeepaliveConfigured = configured;
+    wake_up(&arEvent);
+}
+
+void
+ar6000_pmkid_list_event(void *devt, A_UINT8 numPMKID, WMI_PMKID *pmkidList,
+                        A_UINT8 *bssidList)
+{
+    A_UINT8 i, j;
+
+    A_PRINTF("Number of Cached PMKIDs is %d\n", numPMKID);
+
+    for (i = 0; i < numPMKID; i++) {
+        A_PRINTF("\nBSSID %d ", i);
+            for (j = 0; j < ATH_MAC_LEN; j++) {
+                A_PRINTF("%2.2x", bssidList[j]);
+            }
+        bssidList += (ATH_MAC_LEN + WMI_PMKID_LEN);
+        A_PRINTF("\nPMKID %d ", i);
+            for (j = 0; j < WMI_PMKID_LEN; j++) {
+                A_PRINTF("%2.2x", pmkidList->pmkid[j]);
+            }
+        pmkidList = (WMI_PMKID *)((A_UINT8 *)pmkidList + ATH_MAC_LEN +
+                                  WMI_PMKID_LEN);
+    }
+}
+
+#ifdef USER_KEYS
+static A_STATUS
+
+ar6000_reinstall_keys(AR_SOFTC_T *ar, A_UINT8 key_op_ctrl)
+{
+    A_STATUS status = A_OK;
+    struct ieee80211req_key *uik = &ar->user_saved_keys.ucast_ik;
+    struct ieee80211req_key *bik = &ar->user_saved_keys.bcast_ik;
+    CRYPTO_TYPE  keyType = ar->user_saved_keys.keyType;
+
+    if (IEEE80211_CIPHER_CCKM_KRK != uik->ik_type) {
+        if (NONE_CRYPT == keyType) {
+            goto _reinstall_keys_out;
+        }
+
+        if (uik->ik_keylen) {
+            status = wmi_addKey_cmd(ar->arWmi, uik->ik_keyix,
+                    ar->user_saved_keys.keyType, PAIRWISE_USAGE,
+                    uik->ik_keylen, (A_UINT8 *)&uik->ik_keyrsc,
+                    uik->ik_keydata, key_op_ctrl, SYNC_BEFORE_WMIFLAG);
+        }
+
+    } else {
+        status = wmi_add_krk_cmd(ar->arWmi, uik->ik_keydata);
+    }
+
+    if (IEEE80211_CIPHER_CCKM_KRK != bik->ik_type) {
+        if (NONE_CRYPT == keyType) {
+            goto _reinstall_keys_out;
+        }
+
+        if (bik->ik_keylen) {
+            status = wmi_addKey_cmd(ar->arWmi, bik->ik_keyix,
+                    ar->user_saved_keys.keyType, GROUP_USAGE,
+                    bik->ik_keylen, (A_UINT8 *)&bik->ik_keyrsc,
+                    bik->ik_keydata, key_op_ctrl, NO_SYNC_WMIFLAG);
+        }
+    } else {
+        status = wmi_add_krk_cmd(ar->arWmi, bik->ik_keydata);
+    }
+
+_reinstall_keys_out:
+    ar->user_savedkeys_stat = USER_SAVEDKEYS_STAT_INIT;
+    ar->user_key_ctrl      = 0;
+
+    return status;
+}
+#endif /* USER_KEYS */
+
+
+void
+ar6000_dset_open_req(
+    void *context,
+    A_UINT32 id,
+    A_UINT32 targHandle,
+    A_UINT32 targReplyFn,
+    A_UINT32 targReplyArg)
+{
+}
+
+void
+ar6000_dset_close(
+    void *context,
+    A_UINT32 access_cookie)
+{
+    return;
+}
+
+void
+ar6000_dset_data_req(
+   void *context,
+   A_UINT32 accessCookie,
+   A_UINT32 offset,
+   A_UINT32 length,
+   A_UINT32 targBuf,
+   A_UINT32 targReplyFn,
+   A_UINT32 targReplyArg)
+{
+}
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/ar6000/ar6000_raw_if.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/ar6000/ar6000_raw_if.c
@@ -0,0 +1,439 @@
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "../include/ar6000_drv.h"
+
+#ifdef HTC_RAW_INTERFACE
+
+static void
+ar6000_htc_raw_read_cb(void *Context, HTC_PACKET *pPacket)
+{
+    AR_SOFTC_T        *ar = (AR_SOFTC_T *)Context;
+    raw_htc_buffer    *busy;
+    HTC_RAW_STREAM_ID streamID;
+
+    busy = (raw_htc_buffer *)pPacket->pPktContext;
+    A_ASSERT(busy != NULL);
+
+    if (pPacket->Status == A_ECANCELED) {
+        /*
+         * HTC provides A_ECANCELED status when it doesn't want to be refilled
+         * (probably due to a shutdown)
+         */
+        return;
+    }
+
+    streamID = arEndpoint2RawStreamID(ar,pPacket->Endpoint);
+    A_ASSERT(streamID != HTC_RAW_STREAM_NOT_MAPPED);
+
+#ifdef CF
+   if (down_trylock(&ar->raw_htc_read_sem[streamID])) {
+#else
+    if (down_interruptible(&ar->raw_htc_read_sem[streamID])) {
+#endif /* CF */
+        AR_DEBUG2_PRINTF("Unable to down the semaphore\n");
+    }
+
+    A_ASSERT((pPacket->Status != A_OK) ||
+             (pPacket->pBuffer == (busy->data + HTC_HEADER_LEN)));
+
+    busy->length = pPacket->ActualLength + HTC_HEADER_LEN;
+    busy->currPtr = HTC_HEADER_LEN;
+    ar->read_buffer_available[streamID] = TRUE;
+    //AR_DEBUG_PRINTF("raw read cb:  0x%X 0x%X \n", busy->currPtr,busy->length);
+    up(&ar->raw_htc_read_sem[streamID]);
+
+    /* Signal the waiting process */
+    AR_DEBUG2_PRINTF("Waking up the StreamID(%d) read process\n", streamID);
+    wake_up_interruptible(&ar->raw_htc_read_queue[streamID]);
+}
+
+static void
+ar6000_htc_raw_write_cb(void *Context, HTC_PACKET *pPacket)
+{
+    AR_SOFTC_T          *ar = (AR_SOFTC_T  *)Context;
+    raw_htc_buffer      *free;
+    HTC_RAW_STREAM_ID   streamID;
+
+    free = (raw_htc_buffer *)pPacket->pPktContext;
+    A_ASSERT(free != NULL);
+
+    if (pPacket->Status == A_ECANCELED) {
+        /*
+         * HTC provides A_ECANCELED status when it doesn't want to be refilled
+         * (probably due to a shutdown)
+         */
+        return;
+    }
+
+    streamID = arEndpoint2RawStreamID(ar,pPacket->Endpoint);
+    A_ASSERT(streamID != HTC_RAW_STREAM_NOT_MAPPED);
+
+#ifdef CF
+    if (down_trylock(&ar->raw_htc_write_sem[streamID])) {
+#else
+    if (down_interruptible(&ar->raw_htc_write_sem[streamID])) {
+#endif
+        AR_DEBUG2_PRINTF("Unable to down the semaphore\n");
+    }
+
+    A_ASSERT(pPacket->pBuffer == (free->data + HTC_HEADER_LEN));
+
+    free->length = 0;
+    ar->write_buffer_available[streamID] = TRUE;
+    up(&ar->raw_htc_write_sem[streamID]);
+
+    /* Signal the waiting process */
+    AR_DEBUG2_PRINTF("Waking up the StreamID(%d) write process\n", streamID);
+    wake_up_interruptible(&ar->raw_htc_write_queue[streamID]);
+}
+
+/* connect to a service */
+static A_STATUS ar6000_connect_raw_service(AR_SOFTC_T        *ar,
+                                           HTC_RAW_STREAM_ID StreamID)
+{
+    A_STATUS                 status;
+    HTC_SERVICE_CONNECT_RESP response;
+    A_UINT8                  streamNo;
+    HTC_SERVICE_CONNECT_REQ  connect;
+
+    do {
+
+        A_MEMZERO(&connect,sizeof(connect));
+            /* pass the stream ID as meta data to the RAW streams service */
+        streamNo = (A_UINT8)StreamID;
+        connect.pMetaData = &streamNo;
+        connect.MetaDataLength = sizeof(A_UINT8);
+            /* these fields are the same for all endpoints */
+        connect.EpCallbacks.pContext = ar;
+        connect.EpCallbacks.EpTxComplete = ar6000_htc_raw_write_cb;
+        connect.EpCallbacks.EpRecv = ar6000_htc_raw_read_cb;
+            /* simple interface, we don't need these optional callbacks */
+        connect.EpCallbacks.EpRecvRefill = NULL;
+        connect.EpCallbacks.EpSendFull = NULL;
+        connect.MaxSendQueueDepth = RAW_HTC_WRITE_BUFFERS_NUM;
+
+            /* connect to the raw streams service, we may be able to get 1 or more
+             * connections, depending on WHAT is running on the target */
+        connect.ServiceID = HTC_RAW_STREAMS_SVC;
+
+        A_MEMZERO(&response,sizeof(response));
+
+            /* try to connect to the raw stream, it is okay if this fails with
+             * status HTC_SERVICE_NO_MORE_EP */
+        status = HTCConnectService(ar->arHtcTarget,
+                                   &connect,
+                                   &response);
+
+        if (A_FAILED(status)) {
+            if (response.ConnectRespCode == HTC_SERVICE_NO_MORE_EP) {
+                AR_DEBUG_PRINTF("HTC RAW , No more streams allowed \n");
+                status = A_OK;
+            }
+            break;
+        }
+
+            /* set endpoint mapping for the RAW HTC streams */
+        arSetRawStream2EndpointIDMap(ar,StreamID,response.Endpoint);
+
+        AR_DEBUG_PRINTF("HTC RAW : stream ID: %d, endpoint: %d\n",
+                        StreamID, arRawStream2EndpointID(ar,StreamID));
+
+    } while (FALSE);
+
+    return status;
+}
+
+int ar6000_htc_raw_open(AR_SOFTC_T *ar)
+{
+    A_STATUS status;
+    int streamID, endPt, count2;
+    raw_htc_buffer *buffer;
+    HTC_SERVICE_ID servicepriority;
+
+    A_ASSERT(ar->arHtcTarget != NULL);
+
+        /* wait for target */
+    status = HTCWaitTarget(ar->arHtcTarget);
+
+    if (A_FAILED(status)) {
+        AR_DEBUG_PRINTF("HTCWaitTarget failed (%d)\n", status);
+        return -ENODEV;
+    }
+
+    for (endPt = 0; endPt < ENDPOINT_MAX; endPt++) {
+        ar->arEp2RawMapping[endPt] = HTC_RAW_STREAM_NOT_MAPPED;
+    }
+
+    for (streamID = HTC_RAW_STREAM_0; streamID < HTC_RAW_STREAM_NUM_MAX; streamID++) {
+        /* Initialize the data structures */
+        init_MUTEX(&ar->raw_htc_read_sem[streamID]);
+        init_MUTEX(&ar->raw_htc_write_sem[streamID]);
+        init_waitqueue_head(&ar->raw_htc_read_queue[streamID]);
+        init_waitqueue_head(&ar->raw_htc_write_queue[streamID]);
+
+            /* try to connect to the raw service */
+        status = ar6000_connect_raw_service(ar,streamID);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        if (arRawStream2EndpointID(ar,streamID) == 0) {
+            break;
+        }
+
+        for (count2 = 0; count2 < RAW_HTC_READ_BUFFERS_NUM; count2 ++) {
+            /* Initialize the receive buffers */
+            buffer = &ar->raw_htc_write_buffer[streamID][count2];
+            memset(buffer, 0, sizeof(raw_htc_buffer));
+            buffer = &ar->raw_htc_read_buffer[streamID][count2];
+            memset(buffer, 0, sizeof(raw_htc_buffer));
+
+            SET_HTC_PACKET_INFO_RX_REFILL(&buffer->HTCPacket,
+                                          buffer,
+                                          buffer->data,
+                                          AR6000_BUFFER_SIZE,
+                                          arRawStream2EndpointID(ar,streamID));
+
+            /* Queue buffers to HTC for receive */
+            if ((status = HTCAddReceivePkt(ar->arHtcTarget, &buffer->HTCPacket)) != A_OK)
+            {
+                BMIInit();
+                return -EIO;
+            }
+        }
+
+        for (count2 = 0; count2 < RAW_HTC_WRITE_BUFFERS_NUM; count2 ++) {
+            /* Initialize the receive buffers */
+            buffer = &ar->raw_htc_write_buffer[streamID][count2];
+            memset(buffer, 0, sizeof(raw_htc_buffer));
+        }
+
+        ar->read_buffer_available[streamID] = FALSE;
+        ar->write_buffer_available[streamID] = TRUE;
+    }
+
+    if (A_FAILED(status)) {
+        return -EIO;
+    }
+
+    AR_DEBUG_PRINTF("HTC RAW, number of streams the target supports: %d \n", streamID);
+
+    servicepriority = HTC_RAW_STREAMS_SVC;  /* only 1 */
+
+        /* set callbacks and priority list */
+    HTCSetCreditDistribution(ar->arHtcTarget,
+                             ar,
+                             NULL,  /* use default */
+                             NULL,  /* use default */
+                             &servicepriority,
+                             1);
+
+    /* Start the HTC component */
+    if ((status = HTCStart(ar->arHtcTarget)) != A_OK) {
+        BMIInit();
+        return -EIO;
+    }
+
+    (ar)->arRawIfInit = TRUE;
+
+    return 0;
+}
+
+int ar6000_htc_raw_close(AR_SOFTC_T *ar)
+{
+    A_PRINTF("ar6000_htc_raw_close called \n");
+    HTCStop(ar->arHtcTarget);
+
+        /* reset the device */
+    ar6000_reset_device(ar->arHifDevice, ar->arTargetType, TRUE);
+    /* Initialize the BMI component */
+    BMIInit();
+
+    return 0;
+}
+
+raw_htc_buffer *
+get_filled_buffer(AR_SOFTC_T *ar, HTC_RAW_STREAM_ID StreamID)
+{
+    int count;
+    raw_htc_buffer *busy;
+
+    /* Check for data */
+    for (count = 0; count < RAW_HTC_READ_BUFFERS_NUM; count ++) {
+        busy = &ar->raw_htc_read_buffer[StreamID][count];
+        if (busy->length) {
+            break;
+        }
+    }
+    if (busy->length) {
+        ar->read_buffer_available[StreamID] = TRUE;
+    } else {
+        ar->read_buffer_available[StreamID] = FALSE;
+    }
+
+    return busy;
+}
+
+ssize_t ar6000_htc_raw_read(AR_SOFTC_T *ar, HTC_RAW_STREAM_ID StreamID,
+                            char __user *buffer, size_t length)
+{
+    int readPtr;
+    raw_htc_buffer *busy;
+
+    if (arRawStream2EndpointID(ar,StreamID) == 0) {
+        AR_DEBUG_PRINTF("StreamID(%d) not connected! \n", StreamID);
+        return -EFAULT;
+    }
+
+    if (down_interruptible(&ar->raw_htc_read_sem[StreamID])) {
+        return -ERESTARTSYS;
+    }
+
+    busy = get_filled_buffer(ar,StreamID);
+    while (!ar->read_buffer_available[StreamID]) {
+        up(&ar->raw_htc_read_sem[StreamID]);
+
+        /* Wait for the data */
+        AR_DEBUG2_PRINTF("Sleeping StreamID(%d) read process\n", StreamID);
+        if (wait_event_interruptible(ar->raw_htc_read_queue[StreamID],
+                                     ar->read_buffer_available[StreamID]))
+        {
+            return -EINTR;
+        }
+        if (down_interruptible(&ar->raw_htc_read_sem[StreamID])) {
+            return -ERESTARTSYS;
+        }
+        busy = get_filled_buffer(ar,StreamID);
+    }
+
+    /* Read the data */
+    readPtr = busy->currPtr;
+    if (length > busy->length - HTC_HEADER_LEN) {
+        length = busy->length - HTC_HEADER_LEN;
+    }
+    if (copy_to_user(buffer, &busy->data[readPtr], length)) {
+        up(&ar->raw_htc_read_sem[StreamID]);
+        return -EFAULT;
+    }
+
+    busy->currPtr += length;
+
+    //AR_DEBUG_PRINTF("raw read ioctl:  currPTR : 0x%X 0x%X \n", busy->currPtr,busy->length);
+
+    if (busy->currPtr == busy->length)
+    {
+        busy->currPtr = 0;
+        busy->length = 0;
+        HTC_PACKET_RESET_RX(&busy->HTCPacket);
+        //AR_DEBUG_PRINTF("raw read ioctl:  ep for packet:%d \n", busy->HTCPacket.Endpoint);
+        HTCAddReceivePkt(ar->arHtcTarget, &busy->HTCPacket);
+    }
+    ar->read_buffer_available[StreamID] = FALSE;
+    up(&ar->raw_htc_read_sem[StreamID]);
+
+    return length;
+}
+
+static raw_htc_buffer *
+get_free_buffer(AR_SOFTC_T *ar, HTC_ENDPOINT_ID StreamID)
+{
+    int count;
+    raw_htc_buffer *free;
+
+    free = NULL;
+    for (count = 0; count < RAW_HTC_WRITE_BUFFERS_NUM; count ++) {
+        free = &ar->raw_htc_write_buffer[StreamID][count];
+        if (free->length == 0) {
+            break;
+        }
+    }
+    if (!free->length) {
+        ar->write_buffer_available[StreamID] = TRUE;
+    } else {
+        ar->write_buffer_available[StreamID] = FALSE;
+    }
+
+    return free;
+}
+
+ssize_t ar6000_htc_raw_write(AR_SOFTC_T *ar, HTC_RAW_STREAM_ID StreamID,
+                     char __user *buffer, size_t length)
+{
+    int writePtr;
+    raw_htc_buffer *free;
+
+    if (arRawStream2EndpointID(ar,StreamID) == 0) {
+        AR_DEBUG_PRINTF("StreamID(%d) not connected! \n", StreamID);
+        return -EFAULT;
+    }
+
+    if (down_interruptible(&ar->raw_htc_write_sem[StreamID])) {
+        return -ERESTARTSYS;
+    }
+
+    /* Search for a free buffer */
+    free = get_free_buffer(ar,StreamID);
+
+    /* Check if there is space to write else wait */
+    while (!ar->write_buffer_available[StreamID]) {
+        up(&ar->raw_htc_write_sem[StreamID]);
+
+        /* Wait for buffer to become free */
+        AR_DEBUG2_PRINTF("Sleeping StreamID(%d) write process\n", StreamID);
+        if (wait_event_interruptible(ar->raw_htc_write_queue[StreamID],
+                                     ar->write_buffer_available[StreamID]))
+        {
+            return -EINTR;
+        }
+        if (down_interruptible(&ar->raw_htc_write_sem[StreamID])) {
+            return -ERESTARTSYS;
+        }
+        free = get_free_buffer(ar,StreamID);
+    }
+
+    /* Send the data */
+    writePtr = HTC_HEADER_LEN;
+    if (length > (AR6000_BUFFER_SIZE - HTC_HEADER_LEN)) {
+        length = AR6000_BUFFER_SIZE - HTC_HEADER_LEN;
+    }
+
+    if (copy_from_user(&free->data[writePtr], buffer, length)) {
+        up(&ar->raw_htc_read_sem[StreamID]);
+        return -EFAULT;
+    }
+
+    free->length = length;
+
+    SET_HTC_PACKET_INFO_TX(&free->HTCPacket,
+                           free,
+                           &free->data[writePtr],
+                           length,
+                           arRawStream2EndpointID(ar,StreamID),
+                           AR6K_DATA_PKT_TAG);
+
+    HTCSendPkt(ar->arHtcTarget,&free->HTCPacket);
+
+    ar->write_buffer_available[StreamID] = FALSE;
+    up(&ar->raw_htc_write_sem[StreamID]);
+
+    return length;
+}
+#endif /* HTC_RAW_INTERFACE */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/ar6000/common_drv.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/ar6000/common_drv.c
@@ -0,0 +1,848 @@
+
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "../include/config.h"
+#include "../include/athdefs.h"
+#include "../include/athtypes.h"
+#include "../include/mbox_host_reg.h"
+#if defined(CONFIG_AR6002_REV1_FORCE_HOST)
+#include "../include/vmc_reg.h"
+#endif
+#include "../include/targaddrs.h"
+#include "../include/osapi.h"
+#include "../include/hif.h"
+#include "../include/htc_api.h"
+#include "../include/wmi.h"
+#include "../include/bmi.h"
+#include "../include/bmi_msg.h"
+#include "../include/common_drv.h"
+#include "../include/debug.h"
+
+#define HOST_INTEREST_ITEM_ADDRESS(target, item)    \
+(((target) == TARGET_TYPE_AR6001) ?     \
+   AR6001_HOST_INTEREST_ITEM_ADDRESS(item) :    \
+   AR6002_HOST_INTEREST_ITEM_ADDRESS(item))
+
+
+#define AR6001_LOCAL_COUNT_ADDRESS      0x0c014080
+#define AR6002_LOCAL_COUNT_ADDRESS      0x00018080
+#define AR6001_RESET_CONTROL_ADDRESS    0x0C000000
+#define AR6002_RESET_CONTROL_ADDRESS    0x00004000
+
+#define RESET_CONTROL_COLD_RST_MASK     0x00000100
+#define RESET_CONTROL_WARM_RST_MASK     0x00000080
+#define RESET_CAUSE_LAST_MASK           0x00000007
+
+/* Compile the 4BYTE version of the window register setup routine,
+ * This mitigates host interconnect issues with non-4byte aligned bus requests, some
+ * interconnects use bus adapters that impose strict limitations.
+ * Since diag window access is not intended for performance critical operations, the 4byte mode should
+ * be satisfactory even though it generates 4X the bus activity. */
+
+#ifdef USE_4BYTE_REGISTER_ACCESS
+
+    /* set the window address register (using 4-byte register access ). */
+A_STATUS ar6000_SetAddressWindowRegister(HIF_DEVICE *hifDevice, A_UINT32 RegisterAddr, A_UINT32 Address)
+{
+    A_STATUS status;
+    A_UINT8 addrValue[4];
+    A_INT32 i;
+
+        /* write bytes 1,2,3 of the register to set the upper address bytes, the LSB is written
+         * last to initiate the access cycle */
+
+    for (i = 1; i <= 3; i++) {
+            /* fill the buffer with the address byte value we want to hit 4 times*/
+        addrValue[0] = ((A_UINT8 *)&Address)[i];
+        addrValue[1] = addrValue[0];
+        addrValue[2] = addrValue[0];
+        addrValue[3] = addrValue[0];
+
+            /* hit each byte of the register address with a 4-byte write operation to the same address,
+             * this is a harmless operation */
+        status = HIFReadWrite(hifDevice,
+                              RegisterAddr+i,
+                              addrValue,
+                              4,
+                              HIF_WR_SYNC_BYTE_FIX,
+                              NULL);
+        if (status != A_OK) {
+            break;
+        }
+    }
+
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot write initial bytes of 0x%x to window reg: 0x%X \n",
+             RegisterAddr, Address));
+        return status;
+    }
+
+        /* write the address register again, this time write the whole 4-byte value.
+         * The effect here is that the LSB write causes the cycle to start, the extra
+         * 3 byte write to bytes 1,2,3 has no effect since we are writing the same values again */
+    status = HIFReadWrite(hifDevice,
+                          RegisterAddr,
+                          (A_UCHAR *)(&Address),
+                          4,
+                          HIF_WR_SYNC_BYTE_INC,
+                          NULL);
+
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot write 0x%x to window reg: 0x%X \n",
+            RegisterAddr, Address));
+        return status;
+    }
+
+    return A_OK;
+
+
+
+}
+
+
+#else
+
+    /* set the window address register */
+A_STATUS ar6000_SetAddressWindowRegister(HIF_DEVICE *hifDevice, A_UINT32 RegisterAddr, A_UINT32 Address)
+{
+    A_STATUS status;
+
+        /* write bytes 1,2,3 of the register to set the upper address bytes, the LSB is written
+         * last to initiate the access cycle */
+    status = HIFReadWrite(hifDevice,
+                          RegisterAddr+1,  /* write upper 3 bytes */
+                          ((A_UCHAR *)(&Address))+1,
+                          sizeof(A_UINT32)-1,
+                          HIF_WR_SYNC_BYTE_INC,
+                          NULL);
+
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot write initial bytes of 0x%x to window reg: 0x%X \n",
+             RegisterAddr, Address));
+        return status;
+    }
+
+        /* write the LSB of the register, this initiates the operation */
+    status = HIFReadWrite(hifDevice,
+                          RegisterAddr,
+                          (A_UCHAR *)(&Address),
+                          sizeof(A_UINT8),
+                          HIF_WR_SYNC_BYTE_INC,
+                          NULL);
+
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot write 0x%x to window reg: 0x%X \n",
+            RegisterAddr, Address));
+        return status;
+    }
+
+    return A_OK;
+}
+
+#endif
+
+/*
+ * Read from the AR6000 through its diagnostic window.
+ * No cooperation from the Target is required for this.
+ */
+A_STATUS
+ar6000_ReadRegDiag(HIF_DEVICE *hifDevice, A_UINT32 *address, A_UINT32 *data)
+{
+    A_STATUS status;
+
+        /* set window register to start read cycle */
+    status = ar6000_SetAddressWindowRegister(hifDevice,
+                                             WINDOW_READ_ADDR_ADDRESS,
+                                             *address);
+
+    if (status != A_OK) {
+        return status;
+    }
+
+        /* read the data */
+    status = HIFReadWrite(hifDevice,
+                          WINDOW_DATA_ADDRESS,
+                          (A_UCHAR *)data,
+                          sizeof(A_UINT32),
+                          HIF_RD_SYNC_BYTE_INC,
+                          NULL);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot read from WINDOW_DATA_ADDRESS\n"));
+        return status;
+    }
+
+    return status;
+}
+
+
+/*
+ * Write to the AR6000 through its diagnostic window.
+ * No cooperation from the Target is required for this.
+ */
+A_STATUS
+ar6000_WriteRegDiag(HIF_DEVICE *hifDevice, A_UINT32 *address, A_UINT32 *data)
+{
+    A_STATUS status;
+
+        /* set write data */
+    status = HIFReadWrite(hifDevice,
+                          WINDOW_DATA_ADDRESS,
+                          (A_UCHAR *)data,
+                          sizeof(A_UINT32),
+                          HIF_WR_SYNC_BYTE_INC,
+                          NULL);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot write 0x%x to WINDOW_DATA_ADDRESS\n", *data));
+        return status;
+    }
+
+        /* set window register, which starts the write cycle */
+    return ar6000_SetAddressWindowRegister(hifDevice,
+                                           WINDOW_WRITE_ADDR_ADDRESS,
+                                           *address);
+    }
+
+A_STATUS
+ar6000_ReadDataDiag(HIF_DEVICE *hifDevice, A_UINT32 address,
+                    A_UCHAR *data, A_UINT32 length)
+{
+    A_UINT32 count;
+    A_STATUS status = A_OK;
+
+    for (count = 0; count < length; count += 4, address += 4) {
+        if ((status = ar6000_ReadRegDiag(hifDevice, &address,
+                                         (A_UINT32 *)&data[count])) != A_OK)
+        {
+            break;
+        }
+    }
+
+    return status;
+}
+
+A_STATUS
+ar6000_WriteDataDiag(HIF_DEVICE *hifDevice, A_UINT32 address,
+                     A_UCHAR *data, A_UINT32 length)
+{
+    A_UINT32 count;
+    A_STATUS status = A_OK;
+
+    for (count = 0; count < length; count += 4, address += 4) {
+        if ((status = ar6000_WriteRegDiag(hifDevice, &address,
+                                          (A_UINT32 *)&data[count])) != A_OK)
+        {
+            break;
+        }
+    }
+
+    return status;
+}
+
+static A_STATUS
+_do_write_diag(HIF_DEVICE *hifDevice, A_UINT32 addr, A_UINT32 value)
+{
+    A_STATUS status;
+
+    status = ar6000_WriteRegDiag(hifDevice, &addr, &value);
+    if (status != A_OK)
+    {
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot force Target to execute ROM!\n"));
+    }
+
+    return status;
+}
+
+
+/*
+ * Delay up to wait_msecs millisecs to allow Target to enter BMI phase,
+ * which is a good sign that it's alive and well.  This is used after
+ * explicitly forcing the Target to reset.
+ *
+ * The wait_msecs time should be sufficiently long to cover any reasonable
+ * boot-time delay.  For instance, AR6001 firmware allow one second for a
+ * low frequency crystal to settle before it calibrates the refclk frequency.
+ *
+ * TBD: Might want to add special handling for AR6K_OPTION_BMI_DISABLE.
+ */
+static A_STATUS
+_delay_until_target_alive(HIF_DEVICE *hifDevice, A_INT32 wait_msecs, A_UINT32 TargetType)
+{
+    A_INT32 actual_wait;
+    A_INT32 i;
+    A_UINT32 address;
+
+    actual_wait = 0;
+
+    /* Hardcode the address of LOCAL_COUNT_ADDRESS based on the target type */
+    if (TargetType == TARGET_TYPE_AR6001) {
+        address = AR6001_LOCAL_COUNT_ADDRESS;
+    } else {
+       address = AR6002_LOCAL_COUNT_ADDRESS;
+    }
+    address += 0x10;
+    for (i=0; actual_wait < wait_msecs; i++) {
+        A_UINT32 data;
+
+        A_MSLEEP(100);
+        actual_wait += 100;
+
+        data = 0;
+        if (ar6000_ReadRegDiag(hifDevice, &address, &data) != A_OK) {
+            return A_ERROR;
+        }
+
+        if (data != 0) {
+            /* No need to wait longer -- we have a BMI credit */
+            return A_OK;
+        }
+    }
+    return A_ERROR; /* timed out */
+}
+
+A_STATUS
+ar6000_reset_device_skipflash(HIF_DEVICE *hifDevice)
+{
+    struct forceROM_s {
+        A_UINT32 addr;
+        A_UINT32 data;
+    };
+    struct forceROM_s *ForceROM;
+    A_INT32 szForceROM;
+    A_UINT32 instruction;
+
+    static struct forceROM_s ForceROM_REV2[] = {
+        /* NB: This works for AR6001 REV2 ROM (old). */
+        {0x00001ff0, 0x175b0027}, /* jump instruction at 0xa0001ff0 */
+        {0x00001ff4, 0x00000000}, /* nop instruction at 0xa0001ff4 */
+
+#define MC_REMAP_TARGET_ADDRESS                  0x0c004200
+#define MC_REMAP_COMPARE_ADDRESS                 0x0c004180
+#define MC_REMAP_SIZE_ADDRESS                    0x0c004100
+#define MC_REMAP_VALID_ADDRESS                   0x0c004080
+#define LOCAL_SCRATCH_ADDRESS                    0x0c0140c0
+
+        {MC_REMAP_TARGET_ADDRESS, 0x00001ff0}, /* remap to 0xa0001ff0 */
+        {MC_REMAP_COMPARE_ADDRESS, 0x01000040},/* ...from 0xbfc00040 */
+        {MC_REMAP_SIZE_ADDRESS, 0x00000000},   /* ...1 cache line */
+        {MC_REMAP_VALID_ADDRESS, 0x00000001},  /* ...remap is valid */
+
+        /* Force is_host_present to return TRUE */
+        {0x00001fe0,  0x8c620000},
+        {0x00001fe4,  0x34420002},
+        {0x00001fe8,  0xac620000},
+        {0x00001fec,  0x00000000},
+        {MC_REMAP_TARGET_ADDRESS+4, 0x00001fe0}, /* remap to 0xa0001fe0 */
+        {MC_REMAP_COMPARE_ADDRESS+4, 0x01003de0},/* ...from 0x81003de0 */
+        {MC_REMAP_SIZE_ADDRESS+4, 0x00000000},   /* ...1 cache line */
+        {MC_REMAP_VALID_ADDRESS+4, 0x00000001},  /* ...remap is valid */
+    };
+
+    static struct forceROM_s ForceROM_NEW[] = {
+        /* NB: This works for AR6001 ROM REV3 and beyond.  */
+        {LOCAL_SCRATCH_ADDRESS, AR6K_OPTION_IGNORE_FLASH},
+    };
+
+    /*
+     * Examine a semi-arbitrary instruction that's different
+     * in REV2 and other revisions.
+     * NB: If a Host port does not require simultaneous support
+     * for multiple revisions of Target ROM, this code can be elided.
+     */
+    (void)ar6000_ReadDataDiag(hifDevice, 0x01000040,
+                              (A_UCHAR *)&instruction, 4);
+
+    AR_DEBUG_PRINTF(ATH_LOG_ERR, ("instruction=0x%x\n", instruction));
+
+    if (instruction == 0x3c1aa200) {
+        /* It's an old ROM */
+        ForceROM = ForceROM_REV2;
+        szForceROM = sizeof(ForceROM_REV2)/sizeof(*ForceROM);
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Using OLD method\n"));
+    } else {
+        ForceROM = ForceROM_NEW;
+        szForceROM = sizeof(ForceROM_NEW)/sizeof(*ForceROM);
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Using NEW method\n"));
+    }
+
+    AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Force Target to execute from ROM....\n"));
+    {
+        A_INT32 i;
+
+    for (i = 0; i < szForceROM; i++)
+    {
+            if (_do_write_diag(hifDevice, ForceROM[i].addr, ForceROM[i].data) != A_OK) {
+                return A_ERROR;
+            }
+        }
+    }
+
+
+    {
+        A_INT32 attempt_number;
+        A_INT32 i;
+
+        /*
+         * We may need multiple consecutive warm resets.  Current belief is
+         * that if the first warm reset occurs while there are outstanding
+         * reads (e.g. to flash) then instruction/data loads in startup
+         * code -- which executes just after the reset -- may return
+         * bogus results.  The second warm reset occurs quickly enough
+         * so that we're likely to still be in ROM code (i.e. not
+         * accessing flash) when it occurs, and everything works well.
+         *
+         * The details depend on board and flash part, so this reset algorithm
+         * tries a single warm reset first.  If that doesn't work, we try
+         * multiple warm resets.
+         *
+         * TBDXXX: Hardware Eng to verify that a warm reset with pending
+         * reads to flash may be problematic.
+         */
+        for (attempt_number = 1; attempt_number <= 3; attempt_number++)
+        {
+            /* Clear BMI credit counter */
+            if (_do_write_diag(hifDevice,
+                               AR6001_LOCAL_COUNT_ADDRESS+0x10,
+                               0) != A_OK)
+        {
+            return A_ERROR;
+        }
+
+#if defined(AR6001)
+            /* Clear any memctlr errors, since they're sticky */
+            if (_do_write_diag(hifDevice,
+                               ERROR_VALID_ADDRESS,
+                               ERROR_VALID_ERROR_CAPTURE_ENABLE_MASK) != A_OK)
+            {
+                return A_ERROR;
+    }
+#endif
+
+            /* Issue 1 or more consecutive WARM resets */
+            for (i=0; i<attempt_number; i++) {
+                if (_do_write_diag(hifDevice,
+                                   AR6001_RESET_CONTROL_ADDRESS,
+                                   RESET_CONTROL_WARM_RST_MASK) != A_OK)
+                {
+                    return A_ERROR;
+                }
+            }
+
+            if (_delay_until_target_alive(hifDevice, 2000, TARGET_TYPE_AR6001) == A_OK) {
+                AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Target executing from ROM\n"));
+            } else {
+                AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot force Target to execute ROM!\n"));
+            }
+        }
+    }
+
+    /*
+     * Something has gone wrong -- we're unable to reset the Target.
+     */
+    AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Target failure: Will not execute from ROM\n"));
+    return A_ERROR;
+}
+
+/* reset device */
+A_STATUS ar6000_reset_device(HIF_DEVICE *hifDevice, A_UINT32 TargetType, A_BOOL waitForCompletion)
+{
+
+#if !defined(DWSIM)
+    A_STATUS status = A_OK;
+    A_UINT32 address;
+    A_UINT32 data;
+
+    do {
+
+        /*
+         * Give some time for the mbox and sdio to settle. Doing a
+         * reset in the middle of throughput test, cause the reset
+         * to fail
+         */
+        A_MSLEEP(100);
+
+        data = RESET_CONTROL_COLD_RST_MASK;
+
+          /* Hardcode the address of RESET_CONTROL_ADDRESS based on the target type */
+        if (TargetType == TARGET_TYPE_AR6001) {
+            address = AR6001_RESET_CONTROL_ADDRESS;
+        } else {
+            if (TargetType == TARGET_TYPE_AR6002) {
+                address = AR6002_RESET_CONTROL_ADDRESS;
+            } else {
+                A_ASSERT(0);
+            }
+        }
+
+        status = ar6000_WriteRegDiag(hifDevice, &address, &data);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        if (!waitForCompletion) {
+            break;
+        }
+
+
+        /* Up to 2 second delay to allow things to settle down */
+        (void)_delay_until_target_alive(hifDevice, 2000, TargetType);
+
+        /*
+         * Read back the RESET CAUSE register to ensure that the cold reset
+         * went through.
+         */
+
+        // address = RESET_CAUSE_ADDRESS;
+        /* Hardcode the address of RESET_CAUSE_ADDRESS based on the target type */
+        if (TargetType == TARGET_TYPE_AR6001) {
+            address = 0x0C0000CC;
+        } else {
+            if (TargetType == TARGET_TYPE_AR6002) {
+                address = 0x000040C0;
+            } else {
+                A_ASSERT(0);
+            }
+        }
+
+        data = 0;
+        status = ar6000_ReadRegDiag(hifDevice, &address, &data);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Reset Cause readback: 0x%X \n",data));
+        data &= RESET_CAUSE_LAST_MASK;
+        if (data != 2) {
+            AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Unable to cold reset the target \n"));
+        }
+
+    } while (FALSE);
+
+    if (A_FAILED(status)) {
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Failed to reset target \n"));
+    }
+#endif
+    return A_OK;
+}
+
+#if defined(CONFIG_AR6002_REV1_FORCE_HOST)
+#define AR6002_VERSION_REV1 0x20000086
+/*
+ * Call this function just before the call to BMIInit
+ * in order to force* AR6002 rev 1.x firmware to detect a Host.
+ * THIS IS FOR USE ONLY WITH AR6002 REV 1.x.
+ * TBDXXX: Remove this function when REV 1.x is desupported.
+ */
+A_STATUS
+ar6002_REV1_reset_force_host(HIF_DEVICE *hifDevice)
+{
+    A_INT32 i;
+    struct forceROM_s {
+        A_UINT32 addr;
+        A_UINT32 data;
+    };
+    struct forceROM_s *ForceROM;
+    A_INT32 szForceROM;
+    A_STATUS status = A_OK;
+    A_UINT32 address;
+    A_UINT32 data;
+
+    /* Force AR6002 REV1.x to recognize Host presence.
+     *
+     * Note: Use RAM at 0x52df80..0x52dfa0 with ROM Remap entry 0
+     * so that this workaround functions with AR6002.war1.sh.  We
+     * could fold that entire workaround into this one, but it's not
+     * worth the effort at this point.  This workaround cannot be
+     * merged into the other workaround because this must be done
+     * before BMI.
+     */
+
+    static struct forceROM_s ForceROM_NEW[] = {
+        {0x52df80, 0x20f31c07},
+        {0x52df84, 0x92374420},
+        {0x52df88, 0x1d120c03},
+        {0x52df8c, 0xff8216f0},
+        {0x52df90, 0xf01d120c},
+        {0x52df94, 0x81004136},
+        {0x52df98, 0xbc9100bd},
+        {0x52df9c, 0x00bba100},
+
+        {0x00008000|MC_TCAM_TARGET_ADDRESS, 0x0012dfe0}, /* Use remap entry 0 */
+        {0x00008000|MC_TCAM_COMPARE_ADDRESS, 0x000e2380},
+        {0x00008000|MC_TCAM_MASK_ADDRESS, 0x00000000},
+        {0x00008000|MC_TCAM_VALID_ADDRESS, 0x00000001},
+
+        {0x00018000|(AR6002_LOCAL_COUNT_ADDRESS+0x10), 0}, /* clear BMI credit counter */
+
+        {0x00004000|AR6002_RESET_CONTROL_ADDRESS, RESET_CONTROL_WARM_RST_MASK},
+    };
+
+    address = 0x004ed4b0; /* REV1 target software ID is stored here */
+    status = ar6000_ReadRegDiag(hifDevice, &address, &data);
+    if (A_FAILED(status) || (data != AR6002_VERSION_REV1)) {
+        return A_ERROR; /* Not AR6002 REV1 */
+    }
+
+    ForceROM = ForceROM_NEW;
+    szForceROM = sizeof(ForceROM_NEW)/sizeof(*ForceROM);
+
+    AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Force Target to recognize Host....\n"));
+    for (i = 0; i < szForceROM; i++)
+    {
+        if (ar6000_WriteRegDiag(hifDevice,
+                                &ForceROM[i].addr,
+                                &ForceROM[i].data) != A_OK)
+        {
+            AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot force Target to recognize Host!\n"));
+            return A_ERROR;
+        }
+    }
+
+    A_MSLEEP(1000);
+
+    return A_OK;
+}
+#endif /* CONFIG_AR6002_REV1_FORCE_HOST */
+
+#define REG_DUMP_COUNT_AR6001   38  /* WORDs, derived from AR6001_regdump.h */
+#define REG_DUMP_COUNT_AR6002   32  /* WORDs, derived from AR6002_regdump.h */
+
+
+#if REG_DUMP_COUNT_AR6001 <= REG_DUMP_COUNT_AR6002
+#define REGISTER_DUMP_LEN_MAX  REG_DUMP_COUNT_AR6002
+#else
+#define REGISTER_DUMP_LEN_MAX  REG_DUMP_COUNT_AR6001
+#endif
+
+void ar6000_dump_target_assert_info(HIF_DEVICE *hifDevice, A_UINT32 TargetType)
+{
+    A_UINT32 address;
+    A_UINT32 regDumpArea = 0;
+    A_STATUS status;
+    A_UINT32 regDumpValues[REGISTER_DUMP_LEN_MAX];
+    A_UINT32 regDumpCount = 0;
+    A_UINT32 i;
+
+    do {
+
+            /* the reg dump pointer is copied to the host interest area */
+        address = HOST_INTEREST_ITEM_ADDRESS(TargetType, hi_failure_state);
+
+        if (TargetType == TARGET_TYPE_AR6001) {
+                /* for AR6001, this is a fixed location because the ptr is actually stuck in cache,
+                 * this may be fixed in later firmware versions */
+            address = 0x18a0;
+            regDumpCount = REG_DUMP_COUNT_AR6001;
+
+        } else  if (TargetType == TARGET_TYPE_AR6002) {
+
+            regDumpCount = REG_DUMP_COUNT_AR6002;
+
+        } else {
+            A_ASSERT(0);
+        }
+
+            /* read RAM location through diagnostic window */
+        status = ar6000_ReadRegDiag(hifDevice, &address, &regDumpArea);
+
+        if (A_FAILED(status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR6K: Failed to get ptr to register dump area \n"));
+            break;
+        }
+#ifndef ATHR_DISPLAY_MSG
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR6K: Location of register dump data: 0x%X \n",regDumpArea));
+#else
+        ATHR_DISPLAY_MSG (TRUE, (L"AR6K: Location of register dump data: 0x%X \n",regDumpArea));
+#endif
+        if (regDumpArea == 0) {
+                /* no reg dump */
+            break;
+        }
+
+        if (TargetType == TARGET_TYPE_AR6001) {
+            regDumpArea &= 0x0FFFFFFF;  /* convert to physical address in target memory */
+        }
+
+            /* fetch register dump data */
+        status = ar6000_ReadDataDiag(hifDevice,
+                                     regDumpArea,
+                                     (A_UCHAR *)&regDumpValues[0],
+                                     regDumpCount * (sizeof(A_UINT32)));
+
+        if (A_FAILED(status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR6K: Failed to get register dump \n"));
+            break;
+        }
+#ifndef ATHR_DISPLAY_MSG
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR6K: Register Dump: \n"));
+#else
+        ATHR_DISPLAY_MSG (TRUE, (L"AR6K: Register Dump: \n"));
+#endif
+
+        for (i = 0; i < regDumpCount; i++) {
+#ifndef ATHR_DISPLAY_MSG
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" %d :  0x%8.8X \n",i, regDumpValues[i]));
+#else
+            ATHR_DISPLAY_MSG (TRUE, (L" %d :  0x%8.8X \n",i, regDumpValues[i]));
+#endif
+#ifdef UNDER_CE
+            logPrintf(ATH_DEBUG_ERR," %d:  0x%8.8X \n",i, regDumpValues[i]);
+#endif
+        }
+
+    } while (FALSE);
+
+}
+
+/* set HTC/Mbox operational parameters, this can only be called when the target is in the
+ * BMI phase */
+A_STATUS ar6000_set_htc_params(HIF_DEVICE *hifDevice,
+                               A_UINT32    TargetType,
+                               A_UINT32    MboxIsrYieldValue,
+                               A_UINT8     HtcControlBuffers)
+{
+    A_STATUS status;
+    A_UINT32 blocksizes[HTC_MAILBOX_NUM_MAX];
+
+    do {
+            /* get the block sizes */
+        status = HIFConfigureDevice(hifDevice, HIF_DEVICE_GET_MBOX_BLOCK_SIZE,
+                                    blocksizes, sizeof(blocksizes));
+
+        if (A_FAILED(status)) {
+            AR_DEBUG_PRINTF(ATH_LOG_ERR,("Failed to get block size info from HIF layer...\n"));
+            break;
+        }
+            /* note: we actually get the block size for mailbox 1, for SDIO the block
+             * size on mailbox 0 is artificially set to 1 */
+            /* must be a power of 2 */
+        A_ASSERT((blocksizes[1] & (blocksizes[1] - 1)) == 0);
+
+        if (HtcControlBuffers != 0) {
+                /* set override for number of control buffers to use */
+            blocksizes[1] |=  ((A_UINT32)HtcControlBuffers) << 16;
+        }
+
+            /* set the host interest area for the block size */
+        status = BMIWriteMemory(hifDevice,
+                                HOST_INTEREST_ITEM_ADDRESS(TargetType, hi_mbox_io_block_sz),
+                                (A_UCHAR *)&blocksizes[1],
+                                4);
+
+        if (A_FAILED(status)) {
+            AR_DEBUG_PRINTF(ATH_LOG_ERR,("BMIWriteMemory for IO block size failed \n"));
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_LOG_INF,("Block Size Set: %d (target address:0x%X)\n",
+                blocksizes[1], HOST_INTEREST_ITEM_ADDRESS(TargetType, hi_mbox_io_block_sz)));
+
+        if (MboxIsrYieldValue != 0) {
+                /* set the host interest area for the mbox ISR yield limit */
+            status = BMIWriteMemory(hifDevice,
+                                    HOST_INTEREST_ITEM_ADDRESS(TargetType, hi_mbox_isr_yield_limit),
+                                    (A_UCHAR *)&MboxIsrYieldValue,
+                                    4);
+
+            if (A_FAILED(status)) {
+                AR_DEBUG_PRINTF(ATH_LOG_ERR,("BMIWriteMemory for yield limit failed \n"));
+                break;
+            }
+        }
+
+    } while (FALSE);
+
+    return status;
+}
+
+
+static A_STATUS prepare_ar6002(HIF_DEVICE *hifDevice, A_UINT32 TargetVersion)
+{
+    A_STATUS status = A_OK;
+
+    do {
+
+        if (TargetVersion == AR6002_VERSION_REV1) {
+            /* the following applies to REV1 silicon, we need to disable
+             * sleep as soon as possible as the on-board crystal can be wildly off causing our
+             * sleep activation timer to fire off early */
+            A_UINT32 value;
+
+                /* read host interest area for system sleep setting */
+            status = BMIReadMemory(hifDevice,
+                                   HOST_INTEREST_ITEM_ADDRESS(TARGET_TYPE_AR6002, hi_system_sleep_setting),
+                                   (A_UCHAR *)&value,
+                                   4);
+
+            if (A_FAILED(status)) {
+                break;
+            }
+
+                /* force the setting to disable sleep, this prevents our sleep activation timer
+                 * from having any effect, the host must reset the sleep setting back to zero after it
+                 * has completed all initialization */
+            value |= 0x1;
+
+            status = BMIWriteMemory(hifDevice,
+                                    HOST_INTEREST_ITEM_ADDRESS(TARGET_TYPE_AR6002, hi_system_sleep_setting),
+                                    (A_UCHAR *)&value,
+                                    4);
+
+            if (A_FAILED(status)) {
+                break;
+            }
+
+            /* also disable sleep immediately by programming the sleep register directly */
+
+            status = BMIReadSOCRegister(hifDevice,0x40c4,&value);
+
+            if (A_FAILED(status)) {
+                break;
+            }
+
+            value |= 0x1;
+
+            status = BMIWriteSOCRegister(hifDevice,0x40c4,value);
+
+            if (A_FAILED(status)) {
+                break;
+            }
+
+        }
+
+   } while (FALSE);
+
+   return status;
+}
+
+/* this function assumes the caller has already initialized the BMI APIs */
+A_STATUS ar6000_prepare_target(HIF_DEVICE *hifDevice,
+                               A_UINT32    TargetType,
+                               A_UINT32    TargetVersion)
+{
+    if (TargetType == TARGET_TYPE_AR6002) {
+            /* do any preparations for AR6002 devices */
+        return prepare_ar6002(hifDevice,TargetVersion);
+    }
+
+    return A_OK;
+}
+
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/ar6000/credit_dist.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/ar6000/credit_dist.c
@@ -0,0 +1,355 @@
+
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "../include/config.h"
+#include "../include/athdefs.h"
+#include "../include/athtypes.h"
+#include "../include/osapi.h"
+#include "../include/debug.h"
+#include "../include/htc_api.h"
+#include "../include/common_drv.h"
+
+/********* CREDIT DISTRIBUTION FUNCTIONS ******************************************/
+
+#define NO_VO_SERVICE 1 /* currently WMI only uses 3 data streams, so we leave VO service inactive */
+
+#ifdef NO_VO_SERVICE
+#define DATA_SVCS_USED 3
+#else
+#define DATA_SVCS_USED 4
+#endif
+
+static void RedistributeCredits(COMMON_CREDIT_STATE_INFO *pCredInfo,
+                                HTC_ENDPOINT_CREDIT_DIST *pEPDistList);
+
+static void SeekCredits(COMMON_CREDIT_STATE_INFO *pCredInfo,
+                        HTC_ENDPOINT_CREDIT_DIST *pEPDistList);
+
+/* reduce an ep's credits back to a set limit */
+static INLINE void ReduceCredits(COMMON_CREDIT_STATE_INFO *pCredInfo,
+                                HTC_ENDPOINT_CREDIT_DIST  *pEpDist,
+                                int                       Limit)
+{
+    int credits;
+
+        /* set the new limit */
+    pEpDist->TxCreditsAssigned = Limit;
+
+    if (pEpDist->TxCredits <= Limit) {
+        return;
+    }
+
+        /* figure out how much to take away */
+    credits = pEpDist->TxCredits - Limit;
+        /* take them away */
+    pEpDist->TxCredits -= credits;
+    pCredInfo->CurrentFreeCredits += credits;
+}
+
+/* give an endpoint some credits from the free credit pool */
+#define GiveCredits(pCredInfo,pEpDist,credits)      \
+{                                                   \
+    (pEpDist)->TxCredits += (credits);              \
+    (pEpDist)->TxCreditsAssigned += (credits);      \
+    (pCredInfo)->CurrentFreeCredits -= (credits);   \
+}
+
+
+/* default credit init callback.
+ * This function is called in the context of HTCStart() to setup initial (application-specific)
+ * credit distributions */
+static void ar6000_credit_init(void                     *Context,
+                               HTC_ENDPOINT_CREDIT_DIST *pEPList,
+                               int                      TotalCredits)
+{
+    HTC_ENDPOINT_CREDIT_DIST *pCurEpDist;
+    int                      count;
+    COMMON_CREDIT_STATE_INFO *pCredInfo = (COMMON_CREDIT_STATE_INFO *)Context;
+
+    pCredInfo->CurrentFreeCredits = TotalCredits;
+    pCredInfo->TotalAvailableCredits = TotalCredits;
+
+    pCurEpDist = pEPList;
+
+        /* run through the list and initialize */
+    while (pCurEpDist != NULL) {
+
+            /* set minimums for each endpoint */
+        pCurEpDist->TxCreditsMin = pCurEpDist->TxCreditsPerMaxMsg;
+
+        if (pCurEpDist->ServiceID == WMI_CONTROL_SVC) {
+                /* give control service some credits */
+            GiveCredits(pCredInfo,pCurEpDist,pCurEpDist->TxCreditsMin);
+                /* control service is always marked active, it never goes inactive EVER */
+            SET_EP_ACTIVE(pCurEpDist);
+        } else if (pCurEpDist->ServiceID == WMI_DATA_BK_SVC) {
+                /* this is the lowest priority data endpoint, save this off for easy access */
+            pCredInfo->pLowestPriEpDist = pCurEpDist;
+        }
+
+        /* Streams have to be created (explicit | implicit)for all kinds
+         * of traffic. BE endpoints are also inactive in the beginning.
+         * When BE traffic starts it creates implicit streams that
+         * redistributes credits.
+         */
+
+        /* note, all other endpoints have minimums set but are initially given NO credits.
+         * Credits will be distributed as traffic activity demands */
+        pCurEpDist = pCurEpDist->pNext;
+    }
+
+    if (pCredInfo->CurrentFreeCredits <= 0) {
+        AR_DEBUG_PRINTF(ATH_LOG_INF, ("Not enough credits (%d) to do credit distributions \n", TotalCredits));
+        A_ASSERT(FALSE);
+        return;
+    }
+
+        /* reset list */
+    pCurEpDist = pEPList;
+        /* now run through the list and set max operating credit limits for everyone */
+    while (pCurEpDist != NULL) {
+        if (pCurEpDist->ServiceID == WMI_CONTROL_SVC) {
+                /* control service max is just 1 max message */
+            pCurEpDist->TxCreditsNorm = pCurEpDist->TxCreditsPerMaxMsg;
+        } else {
+                /* for the remaining data endpoints, we assume that each TxCreditsPerMaxMsg are
+                 * the same.
+                 * We use a simple calculation here, we take the remaining credits and
+                 * determine how many max messages this can cover and then set each endpoint's
+                 * normal value equal to 3/4 this amount.
+                 * */
+            count = (pCredInfo->CurrentFreeCredits/pCurEpDist->TxCreditsPerMaxMsg) * pCurEpDist->TxCreditsPerMaxMsg;
+            count = (count * 3) >> 2;
+            count = max(count,pCurEpDist->TxCreditsPerMaxMsg);
+                /* set normal */
+            pCurEpDist->TxCreditsNorm = count;
+
+        }
+        pCurEpDist = pCurEpDist->pNext;
+    }
+
+}
+
+
+/* default credit distribution callback
+ * This callback is invoked whenever endpoints require credit distributions.
+ * A lock is held while this function is invoked, this function shall NOT block.
+ * The pEPDistList is a list of distribution structures in prioritized order as
+ * defined by the call to the HTCSetCreditDistribution() api.
+ *
+ */
+static void ar6000_credit_distribute(void                     *Context,
+                                     HTC_ENDPOINT_CREDIT_DIST *pEPDistList,
+                                     HTC_CREDIT_DIST_REASON   Reason)
+{
+    HTC_ENDPOINT_CREDIT_DIST *pCurEpDist;
+    COMMON_CREDIT_STATE_INFO *pCredInfo = (COMMON_CREDIT_STATE_INFO *)Context;
+
+    switch (Reason) {
+        case HTC_CREDIT_DIST_SEND_COMPLETE :
+            pCurEpDist = pEPDistList;
+                /* we are given the start of the endpoint distribution list.
+                 * There may be one or more endpoints to service.
+                 * Run through the list and distribute credits */
+            while (pCurEpDist != NULL) {
+
+                if (pCurEpDist->TxCreditsToDist > 0) {
+                        /* return the credits back to the endpoint */
+                    pCurEpDist->TxCredits += pCurEpDist->TxCreditsToDist;
+                        /* always zero out when we are done */
+                    pCurEpDist->TxCreditsToDist = 0;
+
+                    if (pCurEpDist->TxCredits > pCurEpDist->TxCreditsAssigned) {
+                            /* reduce to the assigned limit, previous credit reductions
+                             * could have caused the limit to change */
+                        ReduceCredits(pCredInfo, pCurEpDist, pCurEpDist->TxCreditsAssigned);
+                    }
+
+                    if (pCurEpDist->TxCredits > pCurEpDist->TxCreditsNorm) {
+                            /* oversubscribed endpoints need to reduce back to normal */
+                        ReduceCredits(pCredInfo, pCurEpDist, pCurEpDist->TxCreditsNorm);
+                    }
+                }
+
+                pCurEpDist = pCurEpDist->pNext;
+            }
+
+            break;
+
+        case HTC_CREDIT_DIST_ACTIVITY_CHANGE :
+            RedistributeCredits(pCredInfo,pEPDistList);
+            break;
+        case HTC_CREDIT_DIST_SEEK_CREDITS :
+            SeekCredits(pCredInfo,pEPDistList);
+            break;
+        case HTC_DUMP_CREDIT_STATE :
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Credit Distribution, total : %d, free : %d\n",
+            								pCredInfo->TotalAvailableCredits, pCredInfo->CurrentFreeCredits));
+            break;
+        default:
+            break;
+
+    }
+
+        /* sanity checks done after each distribution action */
+    A_ASSERT(pCredInfo->CurrentFreeCredits <= pCredInfo->TotalAvailableCredits);
+    A_ASSERT(pCredInfo->CurrentFreeCredits >= 0);
+
+}
+
+/* redistribute credits based on activity change */
+static void RedistributeCredits(COMMON_CREDIT_STATE_INFO *pCredInfo,
+                                HTC_ENDPOINT_CREDIT_DIST *pEPDistList)
+{
+    HTC_ENDPOINT_CREDIT_DIST *pCurEpDist = pEPDistList;
+
+        /* walk through the list and remove credits from inactive endpoints */
+    while (pCurEpDist != NULL) {
+
+        if (pCurEpDist->ServiceID != WMI_CONTROL_SVC) {
+            if (!IS_EP_ACTIVE(pCurEpDist)) {
+                    /* EP is inactive, reduce credits back to zero */
+                ReduceCredits(pCredInfo, pCurEpDist, 0);
+            }
+        }
+
+        /* NOTE in the active case, we do not need to do anything further,
+         * when an EP goes active and needs credits, HTC will call into
+         * our distribution function using a reason code of HTC_CREDIT_DIST_SEEK_CREDITS  */
+
+        pCurEpDist = pCurEpDist->pNext;
+    }
+
+}
+
+/* HTC has an endpoint that needs credits, pEPDist is the endpoint in question */
+static void SeekCredits(COMMON_CREDIT_STATE_INFO *pCredInfo,
+                        HTC_ENDPOINT_CREDIT_DIST *pEPDist)
+{
+    HTC_ENDPOINT_CREDIT_DIST *pCurEpDist;
+    int                      credits = 0;
+    int                      need;
+
+    do {
+
+        if (pEPDist->ServiceID == WMI_CONTROL_SVC) {
+                /* we never oversubscribe on the control service, this is not
+                 * a high performance path and the target never holds onto control
+                 * credits for too long */
+            break;
+        }
+
+        if (pEPDist->ServiceID == WMI_DATA_VI_SVC) {
+            if (pEPDist->TxCreditsAssigned >= pEPDist->TxCreditsNorm) {
+                 /* limit VI service from oversubscribing */
+                 break;
+            }
+        }
+
+        if (pEPDist->ServiceID == WMI_DATA_VO_SVC) {
+            if (pEPDist->TxCreditsAssigned >= pEPDist->TxCreditsNorm) {
+                 /* limit VO service from oversubscribing */
+                break;
+            }
+        }
+
+        /* for all other services, we follow a simple algorithm of
+         * 1. checking the free pool for credits
+         * 2. checking lower priority endpoints for credits to take */
+
+                /* give what we can */
+            credits = min(pCredInfo->CurrentFreeCredits,pEPDist->TxCreditsSeek);
+
+        if (credits >= pEPDist->TxCreditsSeek) {
+                /* we found some to fullfill the seek request */
+            break;
+        }
+
+        /* we don't have enough in the free pool, try taking away from lower priority services
+         *
+         * The rule for taking away credits:
+         *   1. Only take from lower priority endpoints
+         *   2. Only take what is allocated above the minimum (never starve an endpoint completely)
+         *   3. Only take what you need.
+         *
+         * */
+
+            /* starting at the lowest priority */
+        pCurEpDist = pCredInfo->pLowestPriEpDist;
+
+            /* work backwards until we hit the endpoint again */
+        while (pCurEpDist != pEPDist) {
+                /* calculate how many we need so far */
+            need = pEPDist->TxCreditsSeek - pCredInfo->CurrentFreeCredits;
+
+            if ((pCurEpDist->TxCreditsAssigned - need) >= pCurEpDist->TxCreditsMin) {
+                    /* the current one has been allocated more than it's minimum and it
+                     * has enough credits assigned above it's minimum to fullfill our need
+                     * try to take away just enough to fullfill our need */
+                ReduceCredits(pCredInfo,
+                              pCurEpDist,
+                              pCurEpDist->TxCreditsAssigned - need);
+
+                if (pCredInfo->CurrentFreeCredits >= pEPDist->TxCreditsSeek) {
+                        /* we have enough */
+                    break;
+                }
+            }
+
+            pCurEpDist = pCurEpDist->pPrev;
+        }
+
+            /* return what we can get */
+        credits = min(pCredInfo->CurrentFreeCredits,pEPDist->TxCreditsSeek);
+
+    } while (FALSE);
+
+        /* did we find some credits? */
+    if (credits) {
+            /* give what we can */
+        GiveCredits(pCredInfo, pEPDist, credits);
+    }
+
+}
+
+/* initialize and setup credit distribution */
+A_STATUS ar6000_setup_credit_dist(HTC_HANDLE HTCHandle, COMMON_CREDIT_STATE_INFO *pCredInfo)
+{
+    HTC_SERVICE_ID servicepriority[5];
+
+    A_MEMZERO(pCredInfo,sizeof(COMMON_CREDIT_STATE_INFO));
+
+    servicepriority[0] = WMI_CONTROL_SVC;  /* highest */
+    servicepriority[1] = WMI_DATA_VO_SVC;
+    servicepriority[2] = WMI_DATA_VI_SVC;
+    servicepriority[3] = WMI_DATA_BE_SVC;
+    servicepriority[4] = WMI_DATA_BK_SVC; /* lowest */
+
+        /* set callbacks and priority list */
+    HTCSetCreditDistribution(HTCHandle,
+                             pCredInfo,
+                             ar6000_credit_distribute,
+                             ar6000_credit_init,
+                             servicepriority,
+                             5);
+
+    return A_OK;
+}
+
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/ar6000/eeprom.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/ar6000/eeprom.c
@@ -0,0 +1,453 @@
+/*
+ * Copy the AR6002 eeprom contents into AR6002 memory.
+ *
+ * Andy Lowe (alowe@mvista.com), MontaVista Software
+ *
+ * 2009 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Based on the userspace application eeprom.c from the Atheros SDK.
+ * Copyright (c) 2006 Atheros Communications, Inc.
+*/
+
+#include <linux/kernel.h>
+#include "../include/ar6000_drv.h"
+#include "../include/hif.h"
+#include "../include/bmi.h"
+#include "../include/targaddrs.h"
+#include "../include/addrs.h"
+#include "../include/apb_map.h"
+#include "../include/gpio_reg.h"
+#include "../include/rtc_reg.h"
+#include "../include/si_reg.h"
+
+#define EEPROM_WAIT_LIMIT 16
+#define EEPROM_SZ AR6002_BOARD_DATA_SZ
+
+/*
+ * Enable and configure the Target's Serial Interface
+ * so we can access the EEPROM.
+ */
+static int enable_si(HIF_DEVICE *hifdev, u32 *sys_sleep_reg)
+{
+	u32 regval;
+	int err;
+
+	err = BMIReadSOCRegister(hifdev,
+		RTC_BASE_ADDRESS + SYSTEM_SLEEP_OFFSET,
+		sys_sleep_reg);
+	if (err) goto read_err;
+	/* temporarily disable system sleep */
+	err = BMIWriteSOCRegister(hifdev,
+		RTC_BASE_ADDRESS + SYSTEM_SLEEP_OFFSET,
+		SYSTEM_SLEEP_DISABLE_SET(1));
+	if (err) goto write_err;
+
+	err = BMIReadSOCRegister(hifdev,
+		RTC_BASE_ADDRESS + CLOCK_CONTROL_OFFSET,
+		&regval);
+	if (err) goto read_err;
+	regval &= ~CLOCK_CONTROL_SI0_CLK_MASK;
+	err = BMIWriteSOCRegister(hifdev,
+		RTC_BASE_ADDRESS + CLOCK_CONTROL_OFFSET,
+		regval);
+	if (err) goto write_err;
+
+	err = BMIReadSOCRegister(hifdev,
+		RTC_BASE_ADDRESS + RESET_CONTROL_OFFSET,
+		&regval);
+	if (err) goto read_err;
+	regval &= ~RESET_CONTROL_SI0_RST_MASK;
+	err = BMIWriteSOCRegister(hifdev,
+		RTC_BASE_ADDRESS + RESET_CONTROL_OFFSET,
+		regval);
+	if (err) goto write_err;
+
+	err = BMIReadSOCRegister(hifdev,
+		GPIO_BASE_ADDRESS + GPIO_PIN0_OFFSET,
+		&regval);
+	if (err) goto read_err;
+	regval &= ~GPIO_PIN0_CONFIG_MASK;
+	err = BMIWriteSOCRegister(hifdev,
+		GPIO_BASE_ADDRESS + GPIO_PIN0_OFFSET,
+		regval);
+	if (err) goto write_err;
+
+	err = BMIReadSOCRegister(hifdev,
+		GPIO_BASE_ADDRESS + GPIO_PIN1_OFFSET,
+		&regval);
+	if (err) goto read_err;
+	regval &= ~GPIO_PIN1_CONFIG_MASK;
+	err = BMIWriteSOCRegister(hifdev,
+		GPIO_BASE_ADDRESS + GPIO_PIN1_OFFSET,
+		regval);
+	if (err) goto write_err;
+
+	/* SI_CONFIG = 0x500a6 */
+	regval = SI_CONFIG_BIDIR_OD_DATA_SET(1) |
+		 SI_CONFIG_I2C_SET(1)           |
+		 SI_CONFIG_POS_SAMPLE_SET(1)    |
+		 SI_CONFIG_INACTIVE_CLK_SET(1)  |
+		 SI_CONFIG_INACTIVE_DATA_SET(1) |
+		 SI_CONFIG_DIVIDER_SET(6);
+	err = BMIWriteSOCRegister(hifdev,
+		SI_BASE_ADDRESS + SI_CONFIG_OFFSET,
+		regval);
+	if (err) goto write_err;
+
+	return 0;
+
+      read_err:
+	printk(KERN_ERR "enable_si: BMIReadSOCRegister returned error %d\n",
+		err);
+	return -1;
+
+      write_err:
+	printk(KERN_ERR "enable_si: BMIWriteSOCRegister returned error %d\n",
+		err);
+	return -1;
+}
+
+static int disable_si(HIF_DEVICE *hifdev, u32 sys_sleep_reg)
+{
+	u32 regval;
+	int err;
+
+	err = BMIWriteSOCRegister(hifdev,
+		RTC_BASE_ADDRESS + RESET_CONTROL_OFFSET,
+		RESET_CONTROL_SI0_RST_MASK);
+	if (err) goto write_err;
+	err = BMIReadSOCRegister(hifdev,
+		RTC_BASE_ADDRESS + CLOCK_CONTROL_OFFSET,
+		&regval);
+	if (err) goto read_err;
+	regval |= CLOCK_CONTROL_SI0_CLK_MASK;
+	err = BMIWriteSOCRegister(hifdev,
+		RTC_BASE_ADDRESS + CLOCK_CONTROL_OFFSET,
+		regval);
+	if (err) goto write_err;
+	/* restore system sleep setting */
+	err = BMIWriteSOCRegister(hifdev,
+		RTC_BASE_ADDRESS+SYSTEM_SLEEP_OFFSET,
+		sys_sleep_reg);
+	if (err) goto write_err;
+
+	return 0;
+
+      read_err:
+	printk(KERN_ERR "disable_si: BMIReadSOCRegister returned error %d\n",
+		err);
+	return -1;
+
+      write_err:
+	printk(KERN_ERR "disable_si: BMIWriteSOCRegister returned error %d\n",
+		err);
+	return -1;
+}
+
+/*
+ * Tell the Target to start an 8-byte read from EEPROM,
+ * putting the results in Target RX_DATA registers.
+ */
+static int request_8byte_read(HIF_DEVICE *hifdev, int offset,
+			      int addr_width_16bit)
+{
+	u32 regval;
+	int err;
+
+	if (addr_width_16bit){
+		regval = ((offset & 0xff) << 16) | (offset & 0xff00) | 0xa0;
+		err = BMIWriteSOCRegister(hifdev,
+			SI_BASE_ADDRESS + SI_TX_DATA0_OFFSET,
+			regval);
+		if (err) goto write_err;
+
+		regval = SI_CS_START_SET(1)  |
+			 SI_CS_RX_CNT_SET(0) |
+			 SI_CS_TX_CNT_SET(3);
+		err = BMIWriteSOCRegister(hifdev,
+			SI_BASE_ADDRESS + SI_CS_OFFSET,
+			regval);
+		if (err) goto write_err;
+
+		regval = 0xa1;
+		err = BMIWriteSOCRegister(hifdev,
+			SI_BASE_ADDRESS + SI_TX_DATA0_OFFSET,
+			regval);
+		if (err) goto write_err;
+
+		regval = SI_CS_START_SET(1)  |
+			 SI_CS_RX_CNT_SET(8) |
+			 SI_CS_TX_CNT_SET(1);
+		err = BMIWriteSOCRegister(hifdev,
+			SI_BASE_ADDRESS + SI_CS_OFFSET,
+			regval);
+		if (err) goto write_err;
+	} else {
+		/* SI_TX_DATA0 = read from offset */
+		regval = (0xa1 << 16)           |
+			 ((offset & 0xff) << 8) |
+			 (0xa0 | ((offset & 0xff00) >> 7));
+		err = BMIWriteSOCRegister(hifdev,
+			SI_BASE_ADDRESS + SI_TX_DATA0_OFFSET,
+			regval);
+		if (err) goto write_err;
+
+		regval = SI_CS_START_SET(1)  |
+			 SI_CS_RX_CNT_SET(8) |
+			 SI_CS_TX_CNT_SET(3);
+		err = BMIWriteSOCRegister(hifdev,
+			SI_BASE_ADDRESS + SI_CS_OFFSET,
+			regval);
+		if (err) goto write_err;
+	}
+
+	return 0;
+
+      write_err:
+	printk(KERN_ERR "request_8byte_read: BMIWriteSOCRegister returned "
+		"error %d\n", err);
+	return -1;
+}
+
+/*
+ * Check whether or not an EEPROM request that was started
+ * earlier has completed yet.
+ */
+static int request_in_progress(HIF_DEVICE *hifdev)
+{
+	u32 regval;
+	int err;
+
+ 	/* Wait for DONE_INT in SI_CS */
+	err = BMIReadSOCRegister(hifdev,
+		SI_BASE_ADDRESS + SI_CS_OFFSET,
+		&regval);
+	if (err) goto read_err;
+
+	if (regval & SI_CS_DONE_ERR_MASK)
+		goto eeprom_err;
+
+	return (!(regval & SI_CS_DONE_INT_MASK));
+
+      read_err:
+	printk(KERN_ERR "request_in_progress: BMIReadSOCRegister returned "
+		"error %d\n", err);
+	return -1;
+
+      eeprom_err:
+	printk(KERN_ERR "request_in_progress: eeprom signaled error 0x%x\n",
+		regval);
+	return -1;
+}
+
+/*
+ * try to detect the type of EEPROM:  16bit address or 8bit address
+ */
+static int eeprom_type_detect(HIF_DEVICE *hifdev, int *addr_width_16bit)
+{
+	u32 regval;
+	u8 i = 0;
+	int err;
+
+	err = request_8byte_read(hifdev, 0x100, *addr_width_16bit);
+	if (err)
+		return err;
+
+	/* Wait for DONE_INT in SI_CS */
+	do {
+		err = BMIReadSOCRegister(hifdev,
+			SI_BASE_ADDRESS + SI_CS_OFFSET,
+			&regval);
+		if (err) goto read_err;
+		if (regval & SI_CS_DONE_ERR_MASK) {
+			*addr_width_16bit = !*addr_width_16bit;
+			break;
+		}
+		if (i++ == EEPROM_WAIT_LIMIT)
+			goto eeprom_err;
+	} while(!(regval & SI_CS_DONE_INT_MASK));
+
+	return 0;
+
+      read_err:
+	printk(KERN_ERR "eeprom_type_detect: BMIReadSOCRegister returned "
+		"error %d\n", err);
+	return -1;
+
+      eeprom_err:
+	printk(KERN_ERR "eeprom_type_detect: eeprom read timeout\n");
+	return -1;
+}
+
+/*
+ * Extract the results of a completed EEPROM Read request
+ * and return them to the caller.
+ */
+static int read_8byte_results(HIF_DEVICE *hifdev, u32 data[2])
+{
+	int err;
+
+	/* Read SI_RX_DATA0 and SI_RX_DATA1 */
+	err = BMIReadSOCRegister(hifdev,
+		SI_BASE_ADDRESS + SI_RX_DATA0_OFFSET,
+		&data[0]);
+	if (err) goto read_err;
+	err = BMIReadSOCRegister(hifdev,
+		SI_BASE_ADDRESS + SI_RX_DATA1_OFFSET,
+		&data[1]);
+	if (err) goto read_err;
+
+	return 0;
+
+      read_err:
+	printk(KERN_ERR "read_8byte_results: BMIReadSOCRegister returned "
+		"error %d\n", err);
+	return -1;
+}
+
+/*
+ * Wait for a previously started command to complete.
+ * Timeout if the command is takes "too long".
+ */
+static int wait_for_eeprom_completion(HIF_DEVICE *hifdev)
+{
+	int i = 0;
+	int err;
+
+	while ((err = request_in_progress(hifdev)) > 0) {
+		if (i++ == EEPROM_WAIT_LIMIT)
+			goto eeprom_err;
+	}
+
+	return err;
+
+      eeprom_err:
+	printk(KERN_ERR "wait_for_eeprom_completion: eeprom access timeout\n");
+	return -1;
+}
+
+/*
+ * High-level function which starts an 8-byte read,
+ * waits for it to complete, and returns the result.
+ */
+static int fetch_8bytes(HIF_DEVICE *hifdev, int offset, u32 data[2],
+			int addr_width_16bit)
+{
+	int err;
+
+	err = request_8byte_read(hifdev, offset, addr_width_16bit);
+	if (err)
+		return err;
+	err = wait_for_eeprom_completion(hifdev);
+	if (err)
+		return err;
+	err = read_8byte_results(hifdev, data);
+	if (err)
+		return err;
+
+	/* Clear any pending intr */
+	err = BMIWriteSOCRegister(hifdev,
+		SI_BASE_ADDRESS + SI_CS_OFFSET,
+		SI_CS_DONE_INT_MASK);
+	if (err) goto write_err;
+
+	return 0;
+
+      write_err:
+	printk(KERN_ERR "fetch_8bytes: BMIWriteSOCRegister returned error %d\n",
+		err);
+	return -1;
+}
+
+int ar6002_read_eeprom(AR_SOFTC_T *ar)
+{
+	int i;
+	int err;
+	u8 *eeprom;
+	u32 sys_sleep_reg = 0;
+	int addr_width_16bit = 0;
+	u32 first_word;
+	u32 board_data_addr;
+	u32 one = 1;
+
+	eeprom = kzalloc(EEPROM_SZ, GFP_KERNEL);
+	if (!eeprom) {
+		printk(KERN_ERR "ar6002_read_eeprom: out of memory\n");
+		return -ENOMEM;
+	}
+
+	err = enable_si(ar->arHifDevice, &sys_sleep_reg);
+	if (err) goto err_out;
+	err = eeprom_type_detect(ar->arHifDevice, &addr_width_16bit);
+	if (err) goto err_out;
+
+	/*
+	 * Transfer from EEPROM to Target RAM.
+	 * Fetch EEPROM_SZ Bytes of Board Data, 8 bytes at a time.
+	 */
+	/* Check the first word of EEPROM for validity */
+	err = fetch_8bytes(ar->arHifDevice, 0, (u32 *)(&eeprom[0]),
+		addr_width_16bit);
+	if (err) goto err_out;
+	first_word = *((u32 *)eeprom);
+	if ((first_word == 0) || (first_word == 0xffffffff)) {
+		printk(KERN_ERR "ar6002_read_eeprom: eeprom contents are "
+			"invalid\n");
+		goto err_out;
+	}
+
+	for (i = 8; i < EEPROM_SZ; i += 8) {
+		err = fetch_8bytes(ar->arHifDevice, i, (u32 *)(&eeprom[i]),
+			addr_width_16bit);
+		if (err) goto err_out;
+	}
+
+	/* Determine where in Target RAM to write Board Data */
+	err = BMIReadMemory(ar->arHifDevice,
+		AR6002_HOST_INTEREST_ITEM_ADDRESS(hi_board_data),
+		(u8 *) &board_data_addr,
+		sizeof(board_data_addr));
+	if (err) {
+		printk(KERN_ERR "ar6002_read_eeprom: BMIReadMemory returned "
+			"error %d\n", err);
+		goto err_out;
+	}
+	if (board_data_addr == 0) {
+		printk(KERN_ERR "ar6002_read_eeprom: hi_board_data is zero\n");
+		goto err_out;
+	}
+
+	/* Write EEPROM data to Target RAM */
+	err = BMIWriteMemory(ar->arHifDevice, board_data_addr, eeprom,
+		EEPROM_SZ);
+	if (err) {
+		printk(KERN_ERR "ar6002_read_eeprom: BMIWriteMemory returned "
+			"error %d\n", err);
+		goto err_out;
+	}
+
+	/* Record the fact that Board Data IS initialized */
+	err = BMIWriteMemory(ar->arHifDevice,
+		AR6002_HOST_INTEREST_ITEM_ADDRESS(hi_board_data_initialized),
+		(u8 *) &one, sizeof(one));
+	if (err) {
+		printk(KERN_ERR "ar6002_read_eeprom: BMIWriteMemory returned "
+			"error %d\n", err);
+		goto err_out;
+	}
+
+	err = disable_si(ar->arHifDevice, sys_sleep_reg);
+	if (err) goto err_out;
+
+	kfree(eeprom);
+
+	return 0;
+
+      err_out:
+	kfree(eeprom);
+	return -1;
+}
+EXPORT_SYMBOL(ar6002_read_eeprom);
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/ar6000/engine.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/ar6000/engine.c
@@ -0,0 +1,280 @@
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation;
+//
+// Software distributed under the License is distributed on an "AS
+// IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+// implied. See the License for the specific language governing
+// rights and limitations under the License.
+//
+//
+ *
+ */
+#include "../include/engine.h"
+
+#define ACC (regs[0])
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static unsigned int   regs[16];
+static int            offset;
+static const unsigned char *cp;
+
+int ar6k_reg_preload( int reg, unsigned int value )
+{
+    if( (reg < 0) || (reg > 16) )
+        return(-1);              /* Illegal register */
+
+    regs[ reg ] = value;
+    return(0);
+}
+
+static int getoffset( void )
+{
+    int i = 0;
+
+    cp++;
+    offset++;
+
+    i |=  (*cp & 0xFF);       cp++; offset++;
+    i |=  (*cp & 0xFF) <<  8; cp++; offset++;
+    i |=  (*cp & 0xFF) << 16; cp++; offset++;
+    i |=  (*cp & 0xFF) << 24; cp++; offset++;
+
+    return(i);
+}
+
+static int getarg( void )
+{
+    int i;
+
+    if( *cp & 0x0F )
+    {
+        i = regs[ *cp & 0xF ];
+        cp++; offset++;
+        return(i);
+    }
+    return( getoffset() );
+}
+
+static void dumpregs( void )
+{
+    int i;
+
+    sysprint("Acc: 0x%X\n", ACC);
+
+    for(i=1; i<16; i++)
+        sysprint("r%x : 0x%X\n", i, regs[ i ]);
+
+}
+
+int fwengine(const unsigned char *img, int size, void *ar)
+{
+    unsigned int   crc;
+    u32            img_crc = 0;
+    int            i;
+
+    /* 14 is the minimal size of an empty image */
+    if( ! (*img) || (*img != 0xFF) || (size <14) )
+    {
+        syserr("Wrong image or no image\n");
+        return -1;
+    }
+
+    /* Check crc32 */
+    cp = img + size - 4;
+
+    img_crc |= (~(*cp) & 0xFF) <<  0; cp++;
+    img_crc |= (~(*cp) & 0xFF) <<  8; cp++;
+    img_crc |= (~(*cp) & 0xFF) << 16; cp++;
+    img_crc |= (~(*cp) & 0xFF) << 24;
+    img_crc = __cpu_to_le32(img_crc);
+
+    crc = crc32(~0, img, size - 4);
+    crc = crc32(crc, &img_crc, 4);
+
+    if( crc )
+    {
+        syserr("Image CRC error\n");
+        return -1;
+    }
+
+    if( *(img+1) > VERSION )
+    {
+        syserr("Image version is newer than the driver\n");
+        return -1;
+    }
+
+    /* Basic checks complete, we can print greeting and FW_ID here if desired */
+
+    /* Get to the first opcode */
+
+    cp     = img + 2;                            /* Skip magic and version */
+    offset = 2;
+
+    while( (offset < size) && (*cp) )
+    {
+        cp++;                                    /* Skip build host name */
+        offset++;
+    }
+
+    cp     += 6;                                 /* Skip build date */
+    offset += 6;
+
+    while( (cp > img) && (cp < (img+size-4)) )   /* just an additional bounds check */
+    {
+        /* First, find out opcode class */
+        switch( (*cp & 0xF0) )
+        {
+          case RLoad :
+              ACC = getarg( );
+              break;
+          case Ror   :
+              ACC |= getarg( );
+              break;
+          case Rand  :
+              ACC &= getarg( );
+              break;
+          case Add   :
+              ACC += getarg( );
+              break;
+          case Rstor :
+              regs[ *cp & 0xF ] = ACC;
+              cp++;
+              offset++;
+              break;
+          case Shift :
+              i = getarg( );
+              if(i < 0)
+                  ACC >>= -i;
+              else
+                  ACC <<= i;
+              break;
+          case Nneg  :
+              if( *cp & 0xF )
+                  regs[ *cp & 0xF ] = ~regs[ *cp & 0xF ];
+              else
+                  ACC = -ACC;
+              cp++;
+              offset++;
+              break;
+          case Trr   :
+              if (get_target_reg( getarg(), &ACC, ar ))
+                  return -1;
+              break;
+          case Trw   :
+              if (write_target_reg( getarg(), ACC , ar ))
+                  return -1;
+              break;
+          case Trx   :
+              ACC = execute_on_target( getarg(), ACC, ar );
+              if (ACC)
+                  return -1;
+              break;
+          case Exit  :
+              if( *cp & 0xF ) /* abort with code */
+                  return( regs[ *cp & 0xF ] );
+              else{            /* clean exit */
+                  return(0);
+              }
+              break;
+          case Cmp   :
+              ACC -= getarg();
+              break;
+          case Ldprn :
+              if( ! (*cp & 0xF) ) /* register dump */
+                  dumpregs();
+              else
+              {
+                  int ret;
+
+                  ret = load_binary(ACC, cp, ar);
+                  if( ret < 0 )
+                      return( -1 ); /* Error */
+                  cp += ret;
+                  offset += ret;
+              }
+              break;
+          case Jump  :
+              if( !(*cp & 0xF) ||
+                  ((*cp == 0xE1) && (ACC)) ||
+                  ((*cp == 0xE2) && !(ACC)) )
+              {
+                  offset = getoffset();
+                  cp     = img + offset;
+              } else
+                  getoffset();
+              break;
+          default:
+              syserr("Image format error\n");
+              break;
+
+        }
+    }
+    return(0);
+}
+#ifdef UNIT_TEST
+#include <stdio.h>
+
+unsigned char fwbuf[ 4 * 1024 * 1024 ];
+
+void bmidone( void *ar )
+{
+    printf("BMI done.\n");
+}
+int load_binary(unsigned int addr, const unsigned char *cp, void *ar)
+{
+    int size = 0;
+    int adv  = 5;
+
+    cp++;
+    size |= ( *cp & 0xFF );       cp++;
+    size |= ( *cp & 0xFF ) <<  8; cp++;
+    size |= ( *cp & 0xFF ) << 16; cp++;
+    size |= ( *cp & 0xFF ) << 24; cp++;
+
+    printf("Loading binary to address 0x%X, size %d\n", addr, size);
+    adv += size;
+    return(adv);
+}
+
+int execute_on_target( unsigned address, unsigned arg, void *ar )
+{
+    printf("Start target execution at address 0x%X with argument 0x%X\n", address, arg);
+    return(0);
+}
+
+int write_target_reg( unsigned address, unsigned value, void *ar )
+{
+    printf("Writing target register 0x%X with 0x%X\n", address, value);
+    return(0);
+}
+
+int get_target_reg( unsigned address, unsigned *val, void *ar )
+{
+    *val = 1;
+    printf("Reading target register 0x%X, returning 0x%X\n", address, *val );
+    return 0;
+}
+int main()
+{
+    int ch, ret;
+    unsigned char *bufptr = fwbuf;
+
+    init_crc32();
+
+    printf("Reading firmware image\n");
+    while( (ch = getchar()) != EOF)
+        *bufptr++ = ch;
+
+    printf("Calling firmware engine for image size: %d\n", bufptr - fwbuf + 1);
+    ret = engine( fwbuf, bufptr - fwbuf, NULL );
+    printf("Engine returned with code %d\n", ret);
+}
+#endif /* UNIT_TEST */
+#endif /* KERNEL_VERSION 2.6 only */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/ar6000/ioctl.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/ar6000/ioctl.c
@@ -0,0 +1,2747 @@
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "../include/ar6000_drv.h"
+
+static A_UINT8 bcast_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+static A_UINT8 null_mac[] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
+extern unsigned int wmitimeout;
+extern A_WAITQUEUE_HEAD arEvent;
+extern int tspecCompliance;
+extern int bmienable;
+extern int bypasswmi;
+
+static int
+ar6000_ioctl_get_roam_tbl(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if(wmi_get_roam_tbl_cmd(ar->arWmi) != A_OK) {
+        return -EIO;
+    }
+
+    return 0;
+}
+
+static int
+ar6000_ioctl_get_roam_data(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+
+    /* currently assume only roam times are required */
+    if(wmi_get_roam_data_cmd(ar->arWmi, ROAM_DATA_TIME) != A_OK) {
+        return -EIO;
+    }
+
+
+    return 0;
+}
+
+static int
+ar6000_ioctl_set_roam_ctrl(struct net_device *dev, char *userdata)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_SET_ROAM_CTRL_CMD cmd;
+    A_UINT8 size = sizeof(cmd);
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+
+    if (copy_from_user(&cmd, userdata, size)) {
+        return -EFAULT;
+    }
+
+    if (cmd.roamCtrlType == WMI_SET_HOST_BIAS) {
+        if (cmd.info.bssBiasInfo.numBss > 1) {
+            size += (cmd.info.bssBiasInfo.numBss - 1) * sizeof(WMI_BSS_BIAS);
+        }
+    }
+
+    if (copy_from_user(&cmd, userdata, size)) {
+        return -EFAULT;
+    }
+
+    if(wmi_set_roam_ctrl_cmd(ar->arWmi, &cmd, size) != A_OK) {
+        return -EIO;
+    }
+
+    return 0;
+}
+
+static int
+ar6000_ioctl_set_powersave_timers(struct net_device *dev, char *userdata)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_POWERSAVE_TIMERS_POLICY_CMD cmd;
+    A_UINT8 size = sizeof(cmd);
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, userdata, size)) {
+        return -EFAULT;
+    }
+
+    if (copy_from_user(&cmd, userdata, size)) {
+        return -EFAULT;
+    }
+
+    if(wmi_set_powersave_timers_cmd(ar->arWmi, &cmd, size) != A_OK) {
+        return -EIO;
+    }
+
+    return 0;
+}
+
+static int
+ar6000_ioctl_set_wmm(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_SET_WMM_CMD cmd;
+    A_STATUS ret;
+
+    if ((dev->flags & IFF_UP) != IFF_UP) {
+        return -EIO;
+    }
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, (char *)((unsigned int*)rq->ifr_data + 1),
+                                sizeof(cmd)))
+    {
+        return -EFAULT;
+    }
+
+    if (cmd.status == WMI_WMM_ENABLED) {
+        ar->arWmmEnabled = TRUE;
+    } else {
+        ar->arWmmEnabled = FALSE;
+    }
+
+    ret = wmi_set_wmm_cmd(ar->arWmi, cmd.status);
+
+    switch (ret) {
+        case A_OK:
+            return 0;
+        case A_EBUSY :
+            return -EBUSY;
+        case A_NO_MEMORY:
+            return -ENOMEM;
+        case A_EINVAL:
+        default:
+            return -EFAULT;
+    }
+}
+
+static int
+ar6000_ioctl_set_txop(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_SET_WMM_TXOP_CMD cmd;
+    A_STATUS ret;
+
+    if ((dev->flags & IFF_UP) != IFF_UP) {
+        return -EIO;
+    }
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, (char *)((unsigned int*)rq->ifr_data + 1),
+                                sizeof(cmd)))
+    {
+        return -EFAULT;
+    }
+
+    ret = wmi_set_wmm_txop(ar->arWmi, cmd.txopEnable);
+
+    switch (ret) {
+        case A_OK:
+            return 0;
+        case A_EBUSY :
+            return -EBUSY;
+        case A_NO_MEMORY:
+            return -ENOMEM;
+        case A_EINVAL:
+        default:
+            return -EFAULT;
+    }
+}
+
+static int
+ar6000_ioctl_get_rd(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    A_STATUS ret = 0;
+
+    if ((dev->flags & IFF_UP) != IFF_UP || ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if(copy_to_user((char *)((unsigned int*)rq->ifr_data + 1),
+                            &ar->arRegCode, sizeof(ar->arRegCode)))
+        ret = -EFAULT;
+
+    return ret;
+}
+
+
+/* Get power mode command */
+static int
+ar6000_ioctl_get_power_mode(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_POWER_MODE_CMD power_mode;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    power_mode.powerMode = wmi_get_power_mode_cmd(ar->arWmi);
+    if (copy_to_user(rq->ifr_data, &power_mode, sizeof(WMI_POWER_MODE_CMD))) {
+        ret = -EFAULT;
+    }
+
+    return ret;
+}
+
+
+static int
+ar6000_ioctl_set_channelParams(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_CHANNEL_PARAMS_CMD cmd, *cmdp;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if (cmd.numChannels > 1) {
+        cmdp = A_MALLOC(130);
+        if (copy_from_user(cmdp, rq->ifr_data,
+                           sizeof (*cmdp) +
+                           ((cmd.numChannels - 1) * sizeof(A_UINT16))))
+        {
+            kfree(cmdp);
+            return -EFAULT;
+        }
+    } else {
+        cmdp = &cmd;
+    }
+
+    if ((ar->arPhyCapability == WMI_11G_CAPABILITY) &&
+        ((cmdp->phyMode == WMI_11A_MODE) || (cmdp->phyMode == WMI_11AG_MODE)))
+    {
+        ret = -EINVAL;
+    }
+
+    if (!ret &&
+        (wmi_set_channelParams_cmd(ar->arWmi, cmdp->scanParam, cmdp->phyMode,
+                                   cmdp->numChannels, cmdp->channelList)
+         != A_OK))
+    {
+        ret = -EIO;
+    }
+
+    if (cmd.numChannels > 1) {
+        kfree(cmdp);
+    }
+
+    return ret;
+}
+
+static int
+ar6000_ioctl_set_snr_threshold(struct net_device *dev, struct ifreq *rq)
+{
+
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_SNR_THRESHOLD_PARAMS_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if( wmi_set_snr_threshold_params(ar->arWmi, &cmd) != A_OK ) {
+        ret = -EIO;
+    }
+
+    return ret;
+}
+
+static int
+ar6000_ioctl_set_rssi_threshold(struct net_device *dev, struct ifreq *rq)
+{
+#define SWAP_THOLD(thold1, thold2) do { \
+    USER_RSSI_THOLD tmpThold;           \
+    tmpThold.tag = thold1.tag;          \
+    tmpThold.rssi = thold1.rssi;        \
+    thold1.tag = thold2.tag;            \
+    thold1.rssi = thold2.rssi;          \
+    thold2.tag = tmpThold.tag;          \
+    thold2.rssi = tmpThold.rssi;        \
+} while (0)
+
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_RSSI_THRESHOLD_PARAMS_CMD cmd;
+    USER_RSSI_PARAMS rssiParams;
+    A_INT32 i, j;
+
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user((char *)&rssiParams, (char *)((unsigned int *)rq->ifr_data + 1), sizeof(USER_RSSI_PARAMS))) {
+        return -EFAULT;
+    }
+    cmd.weight = rssiParams.weight;
+    cmd.pollTime = rssiParams.pollTime;
+
+    A_MEMCPY(ar->rssi_map, &rssiParams.tholds, sizeof(ar->rssi_map));
+    /*
+     *  only 6 elements, so use bubble sorting, in ascending order
+     */
+    for (i = 5; i > 0; i--) {
+        for (j = 0; j < i; j++) { /* above tholds */
+            if (ar->rssi_map[j+1].rssi < ar->rssi_map[j].rssi) {
+                SWAP_THOLD(ar->rssi_map[j+1], ar->rssi_map[j]);
+            } else if (ar->rssi_map[j+1].rssi == ar->rssi_map[j].rssi) {
+                return EFAULT;
+            }
+        }
+    }
+    for (i = 11; i > 6; i--) {
+        for (j = 6; j < i; j++) { /* below tholds */
+            if (ar->rssi_map[j+1].rssi < ar->rssi_map[j].rssi) {
+                SWAP_THOLD(ar->rssi_map[j+1], ar->rssi_map[j]);
+            } else if (ar->rssi_map[j+1].rssi == ar->rssi_map[j].rssi) {
+                return EFAULT;
+            }
+        }
+    }
+
+#ifdef DEBUG
+    for (i = 0; i < 12; i++) {
+        AR_DEBUG2_PRINTF("thold[%d].tag: %d, thold[%d].rssi: %d \n",
+                i, ar->rssi_map[i].tag, i, ar->rssi_map[i].rssi);
+    }
+#endif
+    cmd.thresholdAbove1_Val = ar->rssi_map[0].rssi;
+    cmd.thresholdAbove2_Val = ar->rssi_map[1].rssi;
+    cmd.thresholdAbove3_Val = ar->rssi_map[2].rssi;
+    cmd.thresholdAbove4_Val = ar->rssi_map[3].rssi;
+    cmd.thresholdAbove5_Val = ar->rssi_map[4].rssi;
+    cmd.thresholdAbove6_Val = ar->rssi_map[5].rssi;
+    cmd.thresholdBelow1_Val = ar->rssi_map[6].rssi;
+    cmd.thresholdBelow2_Val = ar->rssi_map[7].rssi;
+    cmd.thresholdBelow3_Val = ar->rssi_map[8].rssi;
+    cmd.thresholdBelow4_Val = ar->rssi_map[9].rssi;
+    cmd.thresholdBelow5_Val = ar->rssi_map[10].rssi;
+    cmd.thresholdBelow6_Val = ar->rssi_map[11].rssi;
+
+    if( wmi_set_rssi_threshold_params(ar->arWmi, &cmd) != A_OK ) {
+        ret = -EIO;
+    }
+
+    return ret;
+}
+
+static int
+ar6000_ioctl_set_lq_threshold(struct net_device *dev, struct ifreq *rq)
+{
+
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_LQ_THRESHOLD_PARAMS_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, (char *)((unsigned int *)rq->ifr_data + 1), sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if( wmi_set_lq_threshold_params(ar->arWmi, &cmd) != A_OK ) {
+        ret = -EIO;
+    }
+
+    return ret;
+}
+
+
+static int
+ar6000_ioctl_set_probedSsid(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_PROBED_SSID_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if (wmi_probedSsid_cmd(ar->arWmi, cmd.entryIndex, cmd.flag, cmd.ssidLength,
+                                  cmd.ssid) != A_OK)
+    {
+        ret = -EIO;
+    }
+
+    return ret;
+}
+
+static int
+ar6000_ioctl_set_badAp(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_ADD_BAD_AP_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if (cmd.badApIndex > WMI_MAX_BAD_AP_INDEX) {
+        return -EIO;
+    }
+
+    if (A_MEMCMP(cmd.bssid, null_mac, AR6000_ETH_ADDR_LEN) == 0) {
+        /*
+         * This is a delete badAP.
+         */
+        if (wmi_deleteBadAp_cmd(ar->arWmi, cmd.badApIndex) != A_OK) {
+            ret = -EIO;
+        }
+    } else {
+        if (wmi_addBadAp_cmd(ar->arWmi, cmd.badApIndex, cmd.bssid) != A_OK) {
+            ret = -EIO;
+        }
+    }
+
+    return ret;
+}
+
+static int
+ar6000_ioctl_create_qos(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_CREATE_PSTREAM_CMD cmd;
+    A_STATUS ret;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    ret = wmi_verify_tspec_params(&cmd, tspecCompliance);
+    if (ret == A_OK)
+        ret = wmi_create_pstream_cmd(ar->arWmi, &cmd);
+
+    switch (ret) {
+        case A_OK:
+            return 0;
+        case A_EBUSY :
+            return -EBUSY;
+        case A_NO_MEMORY:
+            return -ENOMEM;
+        case A_EINVAL:
+        default:
+            return -EFAULT;
+    }
+}
+
+static int
+ar6000_ioctl_delete_qos(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_DELETE_PSTREAM_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    ret = wmi_delete_pstream_cmd(ar->arWmi, cmd.trafficClass, cmd.tsid);
+
+    switch (ret) {
+        case A_OK:
+            return 0;
+        case A_EBUSY :
+            return -EBUSY;
+        case A_NO_MEMORY:
+            return -ENOMEM;
+        case A_EINVAL:
+        default:
+            return -EFAULT;
+    }
+}
+
+static int
+ar6000_ioctl_get_qos_queue(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    struct ar6000_queuereq qreq;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if( copy_from_user(&qreq, rq->ifr_data,
+                  sizeof(struct ar6000_queuereq)))
+        return -EFAULT;
+
+    qreq.activeTsids = wmi_get_mapped_qos_queue(ar->arWmi, qreq.trafficClass);
+
+    if (copy_to_user(rq->ifr_data, &qreq,
+                 sizeof(struct ar6000_queuereq)))
+    {
+        ret = -EFAULT;
+    }
+
+    return ret;
+}
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+static A_STATUS
+ar6000_ioctl_tcmd_get_rx_report(struct net_device *dev,
+                                 struct ifreq *rq, A_UINT8 *data, A_UINT32 len)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    A_UINT32    buf[4];
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (down_interruptible(&ar->arSem)) {
+        return -ERESTARTSYS;
+    }
+    ar->tcmdRxReport = 0;
+    if (wmi_test_cmd(ar->arWmi, data, len) != A_OK) {
+        up(&ar->arSem);
+        return -EIO;
+    }
+
+    wait_event_interruptible_timeout(arEvent, ar->tcmdRxReport != 0, wmitimeout * HZ);
+
+    if (signal_pending(current)) {
+        ret = -EINTR;
+    }
+
+    buf[0] = ar->tcmdRxTotalPkt;
+    buf[1] = ar->tcmdRxRssi;
+    buf[2] = ar->tcmdRxcrcErrPkt;
+    buf[3] = ar->tcmdRxsecErrPkt;
+    if (!ret && copy_to_user(rq->ifr_data, buf, sizeof(buf))) {
+        ret = -EFAULT;
+    }
+
+    up(&ar->arSem);
+
+    return ret;
+}
+
+void
+ar6000_tcmd_rx_report_event(void *devt, A_UINT8 * results, int len)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)devt;
+    TCMD_CONT_RX * rx_rep = (TCMD_CONT_RX *)results;
+
+    ar->tcmdRxTotalPkt = rx_rep->u.report.totalPkt;
+    ar->tcmdRxRssi = rx_rep->u.report.rssiInDBm;
+    ar->tcmdRxcrcErrPkt = rx_rep->u.report.crcErrPkt;
+    ar->tcmdRxsecErrPkt = rx_rep->u.report.secErrPkt;
+    ar->tcmdRxReport = 1;
+
+    wake_up(&arEvent);
+}
+#endif /* CONFIG_HOST_TCMD_SUPPORT*/
+
+static int
+ar6000_ioctl_set_error_report_bitmask(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_TARGET_ERROR_REPORT_BITMASK cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    ret = wmi_set_error_report_bitmask(ar->arWmi, cmd.bitmask);
+
+    return  (ret==0 ? ret : -EINVAL);
+}
+
+static int
+ar6000_clear_target_stats(struct net_device *dev)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    TARGET_STATS *pStats = &ar->arTargetStats;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+       return -EIO;
+    }
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+    A_MEMZERO(pStats, sizeof(TARGET_STATS));
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+    return ret;
+}
+
+static int
+ar6000_ioctl_get_target_stats(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    TARGET_STATS_CMD cmd;
+    TARGET_STATS *pStats = &ar->arTargetStats;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+    if (copy_to_user(rq->ifr_data, pStats, sizeof(*pStats))) {
+        ret = -EFAULT;
+    }
+    if (cmd.clearStats == 1) {
+        ar6000_clear_target_stats(dev);
+    }
+
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    if (ar->statsUpdatePending == FALSE) {
+        ar->statsUpdatePending = TRUE;
+        AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+        if (wmi_get_stats_cmd(ar->arWmi) != A_OK)
+            ar->statsUpdatePending = FALSE;
+    } else {
+        AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+    }
+
+    return ret;
+}
+
+static int
+ar6000_ioctl_set_access_params(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_SET_ACCESS_PARAMS_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if (wmi_set_access_params_cmd(ar->arWmi, cmd.txop, cmd.eCWmin, cmd.eCWmax,
+                                  cmd.aifsn) == A_OK)
+    {
+        ret = 0;
+    } else {
+        ret = -EINVAL;
+    }
+
+    return (ret);
+}
+
+static int
+ar6000_ioctl_set_disconnect_timeout(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_DISC_TIMEOUT_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if (wmi_disctimeout_cmd(ar->arWmi, cmd.disconnectTimeout) == A_OK)
+    {
+        ret = 0;
+    } else {
+        ret = -EINVAL;
+    }
+
+    return (ret);
+}
+
+static int
+ar6000_xioctl_set_voice_pkt_size(struct net_device *dev, char * userdata)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_SET_VOICE_PKT_SIZE_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, userdata, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if (wmi_set_voice_pkt_size_cmd(ar->arWmi, cmd.voicePktSize) == A_OK)
+    {
+        ret = 0;
+    } else {
+        ret = -EINVAL;
+    }
+
+
+    return (ret);
+}
+
+static int
+ar6000_xioctl_set_max_sp_len(struct net_device *dev, char * userdata)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_SET_MAX_SP_LEN_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, userdata, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if (wmi_set_max_sp_len_cmd(ar->arWmi, cmd.maxSPLen) == A_OK)
+    {
+        ret = 0;
+    } else {
+        ret = -EINVAL;
+    }
+
+    return (ret);
+}
+
+
+static int
+ar6000_xioctl_set_bt_status_cmd(struct net_device *dev, char * userdata)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_SET_BT_STATUS_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, userdata, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if (wmi_set_bt_status_cmd(ar->arWmi, cmd.streamType, cmd.status) == A_OK)
+    {
+        ret = 0;
+    } else {
+        ret = -EINVAL;
+    }
+
+    return (ret);
+}
+
+static int
+ar6000_xioctl_set_bt_params_cmd(struct net_device *dev, char * userdata)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    WMI_SET_BT_PARAMS_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, userdata, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if (wmi_set_bt_params_cmd(ar->arWmi, &cmd) == A_OK)
+    {
+        ret = 0;
+    } else {
+        ret = -EINVAL;
+    }
+
+    return (ret);
+}
+
+#ifdef CONFIG_HOST_GPIO_SUPPORT
+struct ar6000_gpio_intr_wait_cmd_s  gpio_intr_results;
+/* gpio_reg_results and gpio_data_available are protected by arSem */
+static struct ar6000_gpio_register_cmd_s gpio_reg_results;
+static A_BOOL gpio_data_available; /* Requested GPIO data available */
+static A_BOOL gpio_intr_available; /* GPIO interrupt info available */
+static A_BOOL gpio_ack_received;   /* GPIO ack was received */
+
+/* Host-side initialization for General Purpose I/O support */
+void ar6000_gpio_init(void)
+{
+    gpio_intr_available = FALSE;
+    gpio_data_available = FALSE;
+    gpio_ack_received   = FALSE;
+}
+
+/*
+ * Called when a GPIO interrupt is received from the Target.
+ * intr_values shows which GPIO pins have interrupted.
+ * input_values shows a recent value of GPIO pins.
+ */
+void
+ar6000_gpio_intr_rx(A_UINT32 intr_mask, A_UINT32 input_values)
+{
+    gpio_intr_results.intr_mask = intr_mask;
+    gpio_intr_results.input_values = input_values;
+    *((volatile A_BOOL *)&gpio_intr_available) = TRUE;
+    wake_up(&arEvent);
+}
+
+/*
+ * This is called when a response is received from the Target
+ * for a previous or ar6000_gpio_input_get or ar6000_gpio_register_get
+ * call.
+ */
+void
+ar6000_gpio_data_rx(A_UINT32 reg_id, A_UINT32 value)
+{
+    gpio_reg_results.gpioreg_id = reg_id;
+    gpio_reg_results.value = value;
+    *((volatile A_BOOL *)&gpio_data_available) = TRUE;
+    wake_up(&arEvent);
+}
+
+/*
+ * This is called when an acknowledgement is received from the Target
+ * for a previous or ar6000_gpio_output_set or ar6000_gpio_register_set
+ * call.
+ */
+void
+ar6000_gpio_ack_rx(void)
+{
+    gpio_ack_received = TRUE;
+    wake_up(&arEvent);
+}
+
+A_STATUS
+ar6000_gpio_output_set(struct net_device *dev,
+                       A_UINT32 set_mask,
+                       A_UINT32 clear_mask,
+                       A_UINT32 enable_mask,
+                       A_UINT32 disable_mask)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    gpio_ack_received = FALSE;
+    return wmi_gpio_output_set(ar->arWmi,
+                set_mask, clear_mask, enable_mask, disable_mask);
+}
+
+static A_STATUS
+ar6000_gpio_input_get(struct net_device *dev)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    *((volatile A_BOOL *)&gpio_data_available) = FALSE;
+    return wmi_gpio_input_get(ar->arWmi);
+}
+
+static A_STATUS
+ar6000_gpio_register_set(struct net_device *dev,
+                         A_UINT32 gpioreg_id,
+                         A_UINT32 value)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    gpio_ack_received = FALSE;
+    return wmi_gpio_register_set(ar->arWmi, gpioreg_id, value);
+}
+
+static A_STATUS
+ar6000_gpio_register_get(struct net_device *dev,
+                         A_UINT32 gpioreg_id)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    *((volatile A_BOOL *)&gpio_data_available) = FALSE;
+    return wmi_gpio_register_get(ar->arWmi, gpioreg_id);
+}
+
+static A_STATUS
+ar6000_gpio_intr_ack(struct net_device *dev,
+                     A_UINT32 ack_mask)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    gpio_intr_available = FALSE;
+    return wmi_gpio_intr_ack(ar->arWmi, ack_mask);
+}
+#endif /* CONFIG_HOST_GPIO_SUPPORT */
+
+#if defined(CONFIG_TARGET_PROFILE_SUPPORT)
+static struct prof_count_s prof_count_results;
+static A_BOOL prof_count_available; /* Requested GPIO data available */
+
+static A_STATUS
+prof_count_get(struct net_device *dev)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    *((volatile A_BOOL *)&prof_count_available) = FALSE;
+    return wmi_prof_count_get_cmd(ar->arWmi);
+}
+
+/*
+ * This is called when a response is received from the Target
+ * for a previous prof_count_get call.
+     */
+void
+prof_count_rx(A_UINT32 addr, A_UINT32 count)
+{
+    prof_count_results.addr = addr;
+    prof_count_results.count = count;
+    *((volatile A_BOOL *)&prof_count_available) = TRUE;
+    wake_up(&arEvent);
+}
+#endif /* CONFIG_TARGET_PROFILE_SUPPORT */
+
+int ar6000_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    HIF_DEVICE *hifDevice = ar->arHifDevice;
+    int ret, param;
+    unsigned int address = 0;
+    unsigned int length = 0;
+    unsigned char *buffer;
+    char *userdata;
+    A_UINT32 connectCtrlFlags;
+
+
+    static WMI_SCAN_PARAMS_CMD scParams = {0, 0, 0, 0, 0,
+                                           WMI_SHORTSCANRATIO_DEFAULT,
+                                           DEFAULT_SCAN_CTRL_FLAGS,
+                                           0};
+    WMI_SET_AKMP_PARAMS_CMD  akmpParams;
+    WMI_SET_PMKID_LIST_CMD   pmkidInfo;
+
+    if (cmd == AR6000_IOCTL_EXTENDED)
+    {
+        /*
+         * This allows for many more wireless ioctls than would otherwise
+         * be available.  Applications embed the actual ioctl command in
+         * the first word of the parameter block, and use the command
+         * AR6000_IOCTL_EXTENDED_CMD on the ioctl call.
+         */
+        get_user(cmd, (int *)rq->ifr_data);
+        userdata = (char *)(((unsigned int *)rq->ifr_data)+1);
+    }
+    else
+    {
+        userdata = (char *)rq->ifr_data;
+    }
+
+    if ((ar->arWlanState == WLAN_DISABLED) &&
+        ((cmd != AR6000_XIOCTRL_WMI_SET_WLAN_STATE) &&
+         (cmd != AR6000_XIOCTL_DIAG_READ) &&
+         (cmd != AR6000_XIOCTL_DIAG_WRITE)))
+    {
+        return -EIO;
+    }
+
+    ret = 0;
+    switch(cmd)
+    {
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+        case AR6000_XIOCTL_TCMD_CONT_TX:
+            {
+                TCMD_CONT_TX txCmd;
+
+                if (ar->tcmdPm == TCMD_PM_SLEEP) {
+                    A_PRINTF("Can NOT send tx tcmd when target is asleep! \n");
+                    return -EFAULT;
+                }
+
+                if(copy_from_user(&txCmd, userdata, sizeof(TCMD_CONT_TX)))
+                    return -EFAULT;
+                wmi_test_cmd(ar->arWmi,(A_UINT8 *)&txCmd, sizeof(TCMD_CONT_TX));
+            }
+            break;
+        case AR6000_XIOCTL_TCMD_CONT_RX:
+            {
+                TCMD_CONT_RX rxCmd;
+
+                if (ar->tcmdPm == TCMD_PM_SLEEP) {
+                    A_PRINTF("Can NOT send rx tcmd when target is asleep! \n");
+                    return -EFAULT;
+                }
+                if(copy_from_user(&rxCmd, userdata, sizeof(TCMD_CONT_RX)))
+                    return -EFAULT;
+                switch(rxCmd.act)
+                {
+                    case TCMD_CONT_RX_PROMIS:
+                    case TCMD_CONT_RX_FILTER:
+                    case TCMD_CONT_RX_SETMAC:
+                    case TCMD_CONT_RX_SET_ANT_SWITCH_TABLE:
+                         wmi_test_cmd(ar->arWmi,(A_UINT8 *)&rxCmd,
+                                                sizeof(TCMD_CONT_RX));
+                         break;
+                    case TCMD_CONT_RX_REPORT:
+                         ar6000_ioctl_tcmd_get_rx_report(dev, rq,
+                         (A_UINT8 *)&rxCmd, sizeof(TCMD_CONT_RX));
+                         break;
+                    default:
+                         A_PRINTF("Unknown Cont Rx mode: %d\n",rxCmd.act);
+                         return -EINVAL;
+                }
+            }
+            break;
+        case AR6000_XIOCTL_TCMD_PM:
+            {
+                TCMD_PM pmCmd;
+
+                if(copy_from_user(&pmCmd, userdata, sizeof(TCMD_PM)))
+                    return -EFAULT;
+                ar->tcmdPm = pmCmd.mode;
+                wmi_test_cmd(ar->arWmi, (A_UINT8*)&pmCmd, sizeof(TCMD_PM));
+            }
+            break;
+#endif /* CONFIG_HOST_TCMD_SUPPORT */
+
+        case AR6000_XIOCTL_BMI_DONE:
+            if(bmienable)
+            {
+                ret = ar6000_init(dev);
+            }
+            else
+            {
+                ret = BMIDone(hifDevice);
+            }
+            break;
+
+        case AR6000_XIOCTL_BMI_READ_MEMORY:
+            get_user(address, (unsigned int *)userdata);
+            get_user(length, (unsigned int *)userdata + 1);
+            AR_DEBUG_PRINTF("Read Memory (address: 0x%x, length: %d)\n",
+                             address, length);
+            if ((buffer = (unsigned char *)A_MALLOC(length)) != NULL) {
+                A_MEMZERO(buffer, length);
+                ret = BMIReadMemory(hifDevice, address, buffer, length);
+                if (copy_to_user(rq->ifr_data, buffer, length)) {
+                    ret = -EFAULT;
+                }
+                A_FREE(buffer);
+            } else {
+                ret = -ENOMEM;
+            }
+            break;
+
+        case AR6000_XIOCTL_BMI_WRITE_MEMORY:
+            get_user(address, (unsigned int *)userdata);
+            get_user(length, (unsigned int *)userdata + 1);
+            AR_DEBUG_PRINTF("Write Memory (address: 0x%x, length: %d)\n",
+                             address, length);
+            if ((buffer = (unsigned char *)A_MALLOC(length)) != NULL) {
+                A_MEMZERO(buffer, length);
+                if (copy_from_user(buffer, &userdata[sizeof(address) +
+                                   sizeof(length)], length))
+                {
+                    ret = -EFAULT;
+                } else {
+                    ret = BMIWriteMemory(hifDevice, address, buffer, length);
+                }
+                A_FREE(buffer);
+            } else {
+                ret = -ENOMEM;
+            }
+            break;
+
+        case AR6000_XIOCTL_BMI_TEST:
+           AR_DEBUG_PRINTF("No longer supported\n");
+           ret = -EOPNOTSUPP;
+           break;
+
+        case AR6000_XIOCTL_BMI_EXECUTE:
+            get_user(address, (unsigned int *)userdata);
+            get_user(param, (unsigned int *)userdata + 1);
+            AR_DEBUG_PRINTF("Execute (address: 0x%x, param: %d)\n",
+                             address, param);
+            ret = BMIExecute(hifDevice, address, &param);
+            put_user(param, (unsigned int *)rq->ifr_data); /* return value */
+            break;
+
+        case AR6000_XIOCTL_BMI_SET_APP_START:
+            get_user(address, (unsigned int *)userdata);
+            AR_DEBUG_PRINTF("Set App Start (address: 0x%x)\n", address);
+            ret = BMISetAppStart(hifDevice, address);
+            break;
+
+        case AR6000_XIOCTL_BMI_READ_SOC_REGISTER:
+            get_user(address, (unsigned int *)userdata);
+            ret = BMIReadSOCRegister(hifDevice, address, &param);
+            put_user(param, (unsigned int *)rq->ifr_data); /* return value */
+            break;
+
+        case AR6000_XIOCTL_BMI_WRITE_SOC_REGISTER:
+            get_user(address, (unsigned int *)userdata);
+            get_user(param, (unsigned int *)userdata + 1);
+            ret = BMIWriteSOCRegister(hifDevice, address, param);
+            break;
+
+#ifdef HTC_RAW_INTERFACE
+        case AR6000_XIOCTL_HTC_RAW_OPEN:
+            ret = A_OK;
+            if (!arRawIfEnabled(ar)) {
+                /* make sure block size is set in case the target was reset since last
+                  * BMI phase (i.e. flashup downloads) */
+                ret = ar6000_set_htc_params(ar->arHifDevice,
+                                            ar->arTargetType,
+                                            0,  /* use default yield */
+                                            0   /* use default number of HTC ctrl buffers */
+                                            );
+                if (A_FAILED(ret)) {
+                    break;
+                }
+                /* Terminate the BMI phase */
+                ret = BMIDone(hifDevice);
+                if (ret == A_OK) {
+                    ret = ar6000_htc_raw_open(ar);
+                }
+            }
+            break;
+
+        case AR6000_XIOCTL_HTC_RAW_CLOSE:
+            if (arRawIfEnabled(ar)) {
+                ret = ar6000_htc_raw_close(ar);
+                arRawIfEnabled(ar) = FALSE;
+            } else {
+                ret = A_ERROR;
+            }
+            break;
+
+        case AR6000_XIOCTL_HTC_RAW_READ:
+            if (arRawIfEnabled(ar)) {
+                unsigned int streamID;
+                get_user(streamID, (unsigned int *)userdata);
+                get_user(length, (unsigned int *)userdata + 1);
+                buffer = rq->ifr_data + sizeof(length);
+                ret = ar6000_htc_raw_read(ar, (HTC_RAW_STREAM_ID)streamID,
+                                          buffer, length);
+                put_user(ret, (unsigned int *)rq->ifr_data);
+            } else {
+                ret = A_ERROR;
+            }
+            break;
+
+        case AR6000_XIOCTL_HTC_RAW_WRITE:
+            if (arRawIfEnabled(ar)) {
+                unsigned int streamID;
+                get_user(streamID, (unsigned int *)userdata);
+                get_user(length, (unsigned int *)userdata + 1);
+                buffer = userdata + sizeof(streamID) + sizeof(length);
+                ret = ar6000_htc_raw_write(ar, (HTC_RAW_STREAM_ID)streamID,
+                                           buffer, length);
+                put_user(ret, (unsigned int *)rq->ifr_data);
+            } else {
+                ret = A_ERROR;
+            }
+            break;
+#endif /* HTC_RAW_INTERFACE */
+
+        case AR6000_XIOCTL_BMI_LZ_STREAM_START:
+            get_user(address, (unsigned int *)userdata);
+            AR_DEBUG_PRINTF("Start Compressed Stream (address: 0x%x)\n", address);
+            ret = BMILZStreamStart(hifDevice, address);
+            break;
+
+        case AR6000_XIOCTL_BMI_LZ_DATA:
+            get_user(length, (unsigned int *)userdata);
+            AR_DEBUG_PRINTF("Send Compressed Data (length: %d)\n", length);
+            if ((buffer = (unsigned char *)A_MALLOC(length)) != NULL) {
+                A_MEMZERO(buffer, length);
+                if (copy_from_user(buffer, &userdata[sizeof(length)], length))
+                {
+                    ret = -EFAULT;
+                } else {
+                    ret = BMILZData(hifDevice, buffer, length);
+                }
+                A_FREE(buffer);
+            } else {
+                ret = -ENOMEM;
+            }
+            break;
+
+#if defined(CONFIG_TARGET_PROFILE_SUPPORT)
+        /*
+         * Optional support for Target-side profiling.
+         * Not needed in production.
+         */
+
+        /* Configure Target-side profiling */
+        case AR6000_XIOCTL_PROF_CFG:
+        {
+            A_UINT32 period;
+            A_UINT32 nbins;
+            get_user(period, (unsigned int *)userdata);
+            get_user(nbins, (unsigned int *)userdata + 1);
+
+            if (wmi_prof_cfg_cmd(ar->arWmi, period, nbins) != A_OK) {
+                ret = -EIO;
+            }
+
+            break;
+        }
+
+        /* Start a profiling bucket/bin at the specified address */
+        case AR6000_XIOCTL_PROF_ADDR_SET:
+        {
+            A_UINT32 addr;
+            get_user(addr, (unsigned int *)userdata);
+
+            if (wmi_prof_addr_set_cmd(ar->arWmi, addr) != A_OK) {
+                ret = -EIO;
+            }
+
+            break;
+        }
+
+        /* START Target-side profiling */
+        case AR6000_XIOCTL_PROF_START:
+            wmi_prof_start_cmd(ar->arWmi);
+            break;
+
+        /* STOP Target-side profiling */
+        case AR6000_XIOCTL_PROF_STOP:
+            wmi_prof_stop_cmd(ar->arWmi);
+            break;
+        case AR6000_XIOCTL_PROF_COUNT_GET:
+        {
+            if (ar->arWmiReady == FALSE) {
+                return -EIO;
+            }
+            if (down_interruptible(&ar->arSem)) {
+                return -ERESTARTSYS;
+            }
+
+            prof_count_available = FALSE;
+            ret = prof_count_get(dev);
+            if (ret != A_OK) {
+                up(&ar->arSem);
+                return -EIO;
+            }
+
+            /* Wait for Target to respond. */
+            wait_event_interruptible(arEvent, prof_count_available);
+            if (signal_pending(current)) {
+                ret = -EINTR;
+            } else {
+                if (copy_to_user(userdata, &prof_count_results,
+                                 sizeof(prof_count_results)))
+                {
+                    ret = -EFAULT;
+                }
+            }
+            up(&ar->arSem);
+            break;
+        }
+#endif /* CONFIG_TARGET_PROFILE_SUPPORT */
+
+        case AR6000_IOCTL_WMI_GETREV:
+        {
+            if (copy_to_user(rq->ifr_data, &ar->arVersion,
+                             sizeof(ar->arVersion)))
+            {
+                ret = -EFAULT;
+            }
+            break;
+        }
+        case AR6000_IOCTL_WMI_SETPWR:
+        {
+            WMI_POWER_MODE_CMD pwrModeCmd;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&pwrModeCmd, userdata,
+                                   sizeof(pwrModeCmd)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_powermode_cmd(ar->arWmi, pwrModeCmd.powerMode)
+                       != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_IBSS_PM_CAPS:
+        {
+            WMI_IBSS_PM_CAPS_CMD ibssPmCaps;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&ibssPmCaps, userdata,
+                                   sizeof(ibssPmCaps)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_ibsspmcaps_cmd(ar->arWmi, ibssPmCaps.power_saving, ibssPmCaps.ttl,
+                    ibssPmCaps.atim_windows, ibssPmCaps.timeout_value) != A_OK)
+                {
+                    ret = -EIO;
+                }
+                AR6000_SPIN_LOCK(&ar->arLock, 0);
+                ar->arIbssPsEnable = ibssPmCaps.power_saving;
+                AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+            }
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_PMPARAMS:
+        {
+            WMI_POWER_PARAMS_CMD pmParams;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&pmParams, userdata,
+                                      sizeof(pmParams)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_pmparams_cmd(ar->arWmi, pmParams.idle_period,
+                                     pmParams.pspoll_number,
+                                     pmParams.dtim_policy) != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_IOCTL_WMI_SETSCAN:
+        {
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&scParams, userdata,
+                                      sizeof(scParams)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (CAN_SCAN_IN_CONNECT(scParams.scanCtrlFlags)) {
+                    ar->arSkipScan = FALSE;
+                } else {
+                    ar->arSkipScan = TRUE;
+                }
+
+                if (wmi_scanparams_cmd(ar->arWmi, scParams.fg_start_period,
+                                       scParams.fg_end_period,
+                                       scParams.bg_period,
+                                       scParams.minact_chdwell_time,
+                                       scParams.maxact_chdwell_time,
+                                       scParams.pas_chdwell_time,
+                                       scParams.shortScanRatio,
+                                       scParams.scanCtrlFlags,
+                                       scParams.max_dfsch_act_time,
+                                       scParams.maxact_scan_per_ssid) != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_IOCTL_WMI_SETLISTENINT:
+        {
+            WMI_LISTEN_INT_CMD listenCmd;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&listenCmd, userdata,
+                                      sizeof(listenCmd)))
+            {
+                ret = -EFAULT;
+            } else {
+                    if (wmi_listeninterval_cmd(ar->arWmi, listenCmd.listenInterval, listenCmd.numBeacons) != A_OK) {
+                        ret = -EIO;
+                    } else {
+                        AR6000_SPIN_LOCK(&ar->arLock, 0);
+                        ar->arListenInterval = param;
+                        AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+                    }
+
+                }
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_BMISS_TIME:
+        {
+            WMI_BMISS_TIME_CMD bmissCmd;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&bmissCmd, userdata,
+                                      sizeof(bmissCmd)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_bmisstime_cmd(ar->arWmi, bmissCmd.bmissTime, bmissCmd.numBeacons) != A_OK) {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_IOCTL_WMI_SETBSSFILTER:
+        {
+            WMI_BSS_FILTER_CMD filt;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&filt, userdata,
+                                   sizeof(filt)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_bssfilter_cmd(ar->arWmi, filt.bssFilter, filt.ieMask)
+                        != A_OK) {
+                    ret = -EIO;
+                } else {
+                    ar->arUserBssFilter = filt.bssFilter;
+                }
+            }
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_SNRTHRESHOLD:
+        {
+            ret = ar6000_ioctl_set_snr_threshold(dev, rq);
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_RSSITHRESHOLD:
+        {
+            ret = ar6000_ioctl_set_rssi_threshold(dev, rq);
+            break;
+        }
+        case AR6000_XIOCTL_WMI_CLR_RSSISNR:
+        {
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            }
+            ret = wmi_clr_rssi_snr(ar->arWmi);
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_LQTHRESHOLD:
+        {
+            ret = ar6000_ioctl_set_lq_threshold(dev, rq);
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_LPREAMBLE:
+        {
+            WMI_SET_LPREAMBLE_CMD setLpreambleCmd;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&setLpreambleCmd, userdata,
+                                   sizeof(setLpreambleCmd)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_set_lpreamble_cmd(ar->arWmi, setLpreambleCmd.status)
+                       != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_RTS:
+        {
+            WMI_SET_RTS_CMD rtsCmd;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&rtsCmd, userdata,
+                                   sizeof(rtsCmd)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_set_rts_cmd(ar->arWmi, rtsCmd.threshold)
+                       != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_WMM:
+        {
+            ret = ar6000_ioctl_set_wmm(dev, rq);
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_TXOP:
+        {
+            ret = ar6000_ioctl_set_txop(dev, rq);
+            break;
+        }
+        case AR6000_XIOCTL_WMI_GET_RD:
+        {
+            ret = ar6000_ioctl_get_rd(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_CHANNELPARAMS:
+        {
+            ret = ar6000_ioctl_set_channelParams(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_PROBEDSSID:
+        {
+            ret = ar6000_ioctl_set_probedSsid(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_BADAP:
+        {
+            ret = ar6000_ioctl_set_badAp(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_CREATE_QOS:
+        {
+            ret = ar6000_ioctl_create_qos(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_DELETE_QOS:
+        {
+            ret = ar6000_ioctl_delete_qos(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_GET_QOS_QUEUE:
+        {
+            ret = ar6000_ioctl_get_qos_queue(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_GET_TARGET_STATS:
+        {
+            ret = ar6000_ioctl_get_target_stats(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_ERROR_REPORT_BITMASK:
+        {
+            ret = ar6000_ioctl_set_error_report_bitmask(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_ASSOC_INFO:
+        {
+            WMI_SET_ASSOC_INFO_CMD cmd;
+            A_UINT8 assocInfo[WMI_MAX_ASSOC_INFO_LEN];
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else {
+                get_user(cmd.ieType, userdata);
+                if (cmd.ieType >= WMI_MAX_ASSOC_INFO_TYPE) {
+                    ret = -EIO;
+                } else {
+                    get_user(cmd.bufferSize, userdata + 1);
+                    if (cmd.bufferSize > WMI_MAX_ASSOC_INFO_LEN) {
+                        ret = -EFAULT;
+                        break;
+                    }
+                    if (copy_from_user(assocInfo, userdata + 2,
+                                       cmd.bufferSize))
+                    {
+                        ret = -EFAULT;
+                    } else {
+                        if (wmi_associnfo_cmd(ar->arWmi, cmd.ieType,
+                                                 cmd.bufferSize,
+                                                 assocInfo) != A_OK)
+                        {
+                            ret = -EIO;
+                        }
+                    }
+                }
+            }
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_ACCESS_PARAMS:
+        {
+            ret = ar6000_ioctl_set_access_params(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_DISC_TIMEOUT:
+        {
+            ret = ar6000_ioctl_set_disconnect_timeout(dev, rq);
+            break;
+        }
+        case AR6000_XIOCTL_FORCE_TARGET_RESET:
+        {
+            if (ar->arHtcTarget)
+            {
+//                HTCForceReset(htcTarget);
+            }
+            else
+            {
+                AR_DEBUG_PRINTF("ar6000_ioctl cannot attempt reset.\n");
+            }
+            break;
+        }
+        case AR6000_XIOCTL_TARGET_INFO:
+        case AR6000_XIOCTL_CHECK_TARGET_READY: /* backwards compatibility */
+        {
+            /* If we made it to here, then the Target exists and is ready. */
+
+            if (cmd == AR6000_XIOCTL_TARGET_INFO) {
+                if (copy_to_user((A_UINT32 *)rq->ifr_data, &ar->arVersion.target_ver,
+                                 sizeof(ar->arVersion.target_ver)))
+                {
+                    ret = -EFAULT;
+                }
+                if (copy_to_user(((A_UINT32 *)rq->ifr_data)+1, &ar->arTargetType,
+                                 sizeof(ar->arTargetType)))
+                {
+                    ret = -EFAULT;
+                }
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_HB_CHALLENGE_RESP_PARAMS:
+        {
+            WMI_SET_HB_CHALLENGE_RESP_PARAMS_CMD hbparam;
+
+            if (copy_from_user(&hbparam, userdata, sizeof(hbparam)))
+            {
+                ret = -EFAULT;
+            } else {
+                AR6000_SPIN_LOCK(&ar->arLock, 0);
+                /* Start a cyclic timer with the parameters provided. */
+                if (hbparam.frequency) {
+                    ar->arHBChallengeResp.frequency = hbparam.frequency;
+                }
+                if (hbparam.threshold) {
+                    ar->arHBChallengeResp.missThres = hbparam.threshold;
+                }
+
+                /* Delete the pending timer and start a new one */
+                if (timer_pending(&ar->arHBChallengeResp.timer)) {
+                    A_UNTIMEOUT(&ar->arHBChallengeResp.timer);
+                }
+                A_TIMEOUT_MS(&ar->arHBChallengeResp.timer, ar->arHBChallengeResp.frequency * 1000, 0);
+                AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_GET_HB_CHALLENGE_RESP:
+        {
+            A_UINT32 cookie;
+
+            if (copy_from_user(&cookie, userdata, sizeof(cookie))) {
+                return -EFAULT;
+            }
+
+            /* Send the challenge on the control channel */
+            if (wmi_get_challenge_resp_cmd(ar->arWmi, cookie, APP_HB_CHALLENGE) != A_OK) {
+                return -EIO;
+            }
+            break;
+        }
+#ifdef USER_KEYS
+        case AR6000_XIOCTL_USER_SETKEYS:
+        {
+
+            ar->user_savedkeys_stat = USER_SAVEDKEYS_STAT_RUN;
+
+            if (copy_from_user(&ar->user_key_ctrl, userdata,
+                               sizeof(ar->user_key_ctrl)))
+            {
+                return -EFAULT;
+            }
+
+            A_PRINTF("ar6000 USER set key %x\n", ar->user_key_ctrl);
+            break;
+        }
+#endif /* USER_KEYS */
+
+#ifdef CONFIG_HOST_GPIO_SUPPORT
+        case AR6000_XIOCTL_GPIO_OUTPUT_SET:
+        {
+            struct ar6000_gpio_output_set_cmd_s gpio_output_set_cmd;
+
+            if (ar->arWmiReady == FALSE) {
+                return -EIO;
+            }
+            if (down_interruptible(&ar->arSem)) {
+                return -ERESTARTSYS;
+            }
+
+            if (copy_from_user(&gpio_output_set_cmd, userdata,
+                                sizeof(gpio_output_set_cmd)))
+            {
+                ret = -EFAULT;
+            } else {
+                ret = ar6000_gpio_output_set(dev,
+                                             gpio_output_set_cmd.set_mask,
+                                             gpio_output_set_cmd.clear_mask,
+                                             gpio_output_set_cmd.enable_mask,
+                                             gpio_output_set_cmd.disable_mask);
+                if (ret != A_OK) {
+                    ret = EIO;
+                }
+            }
+            up(&ar->arSem);
+            break;
+        }
+        case AR6000_XIOCTL_GPIO_INPUT_GET:
+        {
+            if (ar->arWmiReady == FALSE) {
+                return -EIO;
+            }
+            if (down_interruptible(&ar->arSem)) {
+                return -ERESTARTSYS;
+            }
+
+            ret = ar6000_gpio_input_get(dev);
+            if (ret != A_OK) {
+                up(&ar->arSem);
+                return -EIO;
+            }
+
+            /* Wait for Target to respond. */
+            wait_event_interruptible(arEvent, gpio_data_available);
+            if (signal_pending(current)) {
+                ret = -EINTR;
+            } else {
+                A_ASSERT(gpio_reg_results.gpioreg_id == GPIO_ID_NONE);
+
+                if (copy_to_user(userdata, &gpio_reg_results.value,
+                                 sizeof(gpio_reg_results.value)))
+                {
+                    ret = -EFAULT;
+                }
+            }
+            up(&ar->arSem);
+            break;
+        }
+        case AR6000_XIOCTL_GPIO_REGISTER_SET:
+        {
+            struct ar6000_gpio_register_cmd_s gpio_register_cmd;
+
+            if (ar->arWmiReady == FALSE) {
+                return -EIO;
+            }
+            if (down_interruptible(&ar->arSem)) {
+                return -ERESTARTSYS;
+            }
+
+            if (copy_from_user(&gpio_register_cmd, userdata,
+                                sizeof(gpio_register_cmd)))
+            {
+                ret = -EFAULT;
+            } else {
+                ret = ar6000_gpio_register_set(dev,
+                                               gpio_register_cmd.gpioreg_id,
+                                               gpio_register_cmd.value);
+                if (ret != A_OK) {
+                    ret = EIO;
+                }
+
+                /* Wait for acknowledgement from Target */
+                wait_event_interruptible(arEvent, gpio_ack_received);
+                if (signal_pending(current)) {
+                    ret = -EINTR;
+                }
+            }
+            up(&ar->arSem);
+            break;
+        }
+        case AR6000_XIOCTL_GPIO_REGISTER_GET:
+        {
+            struct ar6000_gpio_register_cmd_s gpio_register_cmd;
+
+            if (ar->arWmiReady == FALSE) {
+                return -EIO;
+            }
+            if (down_interruptible(&ar->arSem)) {
+                return -ERESTARTSYS;
+            }
+
+            if (copy_from_user(&gpio_register_cmd, userdata,
+                                sizeof(gpio_register_cmd)))
+            {
+                ret = -EFAULT;
+            } else {
+                ret = ar6000_gpio_register_get(dev, gpio_register_cmd.gpioreg_id);
+                if (ret != A_OK) {
+                    up(&ar->arSem);
+                    return -EIO;
+                }
+
+                /* Wait for Target to respond. */
+                wait_event_interruptible(arEvent, gpio_data_available);
+                if (signal_pending(current)) {
+                    ret = -EINTR;
+                } else {
+                    A_ASSERT(gpio_register_cmd.gpioreg_id == gpio_reg_results.gpioreg_id);
+                    if (copy_to_user(userdata, &gpio_reg_results,
+                                     sizeof(gpio_reg_results)))
+                    {
+                        ret = -EFAULT;
+                    }
+                }
+            }
+            up(&ar->arSem);
+            break;
+        }
+        case AR6000_XIOCTL_GPIO_INTR_ACK:
+        {
+            struct ar6000_gpio_intr_ack_cmd_s gpio_intr_ack_cmd;
+
+            if (ar->arWmiReady == FALSE) {
+                return -EIO;
+            }
+            if (down_interruptible(&ar->arSem)) {
+                return -ERESTARTSYS;
+            }
+
+            if (copy_from_user(&gpio_intr_ack_cmd, userdata,
+                                sizeof(gpio_intr_ack_cmd)))
+            {
+                ret = -EFAULT;
+            } else {
+                ret = ar6000_gpio_intr_ack(dev, gpio_intr_ack_cmd.ack_mask);
+                if (ret != A_OK) {
+                    ret = EIO;
+                }
+            }
+            up(&ar->arSem);
+            break;
+        }
+        case AR6000_XIOCTL_GPIO_INTR_WAIT:
+        {
+            /* Wait for Target to report an interrupt. */
+            dev_hold(dev);
+            rtnl_unlock();
+            wait_event_interruptible(arEvent, gpio_intr_available);
+            rtnl_lock();
+            __dev_put(dev);
+
+            if (signal_pending(current)) {
+                ret = -EINTR;
+            } else {
+                if (copy_to_user(userdata, &gpio_intr_results,
+                                 sizeof(gpio_intr_results)))
+                {
+                    ret = -EFAULT;
+                }
+            }
+            break;
+        }
+#endif /* CONFIG_HOST_GPIO_SUPPORT */
+
+        case AR6000_XIOCTL_DBGLOG_CFG_MODULE:
+        {
+            struct ar6000_dbglog_module_config_s config;
+
+            if (copy_from_user(&config, userdata, sizeof(config))) {
+                return -EFAULT;
+            }
+
+            /* Send the challenge on the control channel */
+            if (wmi_config_debug_module_cmd(ar->arWmi, config.mmask,
+                                            config.tsr, config.rep,
+                                            config.size, config.valid) != A_OK)
+            {
+                return -EIO;
+            }
+            break;
+        }
+
+        case AR6000_XIOCTL_DBGLOG_GET_DEBUG_LOGS:
+        {
+            /* Send the challenge on the control channel */
+            if (ar6000_dbglog_get_debug_logs(ar) != A_OK)
+            {
+                return -EIO;
+            }
+            break;
+        }
+
+        case AR6000_XIOCTL_SET_ADHOC_BSSID:
+        {
+            WMI_SET_ADHOC_BSSID_CMD adhocBssid;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&adhocBssid, userdata,
+                                      sizeof(adhocBssid)))
+            {
+                ret = -EFAULT;
+            } else if (A_MEMCMP(adhocBssid.bssid, bcast_mac,
+                                AR6000_ETH_ADDR_LEN) == 0)
+            {
+                ret = -EFAULT;
+            } else {
+
+                A_MEMCPY(ar->arReqBssid, adhocBssid.bssid, sizeof(ar->arReqBssid));
+        }
+            break;
+        }
+
+        case AR6000_XIOCTL_SET_OPT_MODE:
+        {
+        WMI_SET_OPT_MODE_CMD optModeCmd;
+            AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&optModeCmd, userdata,
+                                      sizeof(optModeCmd)))
+            {
+                ret = -EFAULT;
+            } else if (ar->arConnected && optModeCmd.optMode == SPECIAL_ON) {
+                ret = -EFAULT;
+
+            } else if (wmi_set_opt_mode_cmd(ar->arWmi, optModeCmd.optMode)
+                       != A_OK)
+            {
+                ret = -EIO;
+            }
+            break;
+        }
+
+        case AR6000_XIOCTL_OPT_SEND_FRAME:
+        {
+        WMI_OPT_TX_FRAME_CMD optTxFrmCmd;
+            A_UINT8 data[MAX_OPT_DATA_LEN];
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&optTxFrmCmd, userdata,
+                                      sizeof(optTxFrmCmd)))
+            {
+                ret = -EFAULT;
+            } else if (copy_from_user(data,
+                                      userdata+sizeof(WMI_OPT_TX_FRAME_CMD)-1,
+                                      optTxFrmCmd.optIEDataLen))
+            {
+                ret = -EFAULT;
+            } else {
+                ret = wmi_opt_tx_frame_cmd(ar->arWmi,
+                                           optTxFrmCmd.frmType,
+                                           optTxFrmCmd.dstAddr,
+                                           optTxFrmCmd.bssid,
+                                           optTxFrmCmd.optIEDataLen,
+                                           data);
+            }
+
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SETRETRYLIMITS:
+        {
+            WMI_SET_RETRY_LIMITS_CMD setRetryParams;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&setRetryParams, userdata,
+                                      sizeof(setRetryParams)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_set_retry_limits_cmd(ar->arWmi, setRetryParams.frameType,
+                                          setRetryParams.trafficClass,
+                                          setRetryParams.maxRetries,
+                                          setRetryParams.enableNotify) != A_OK)
+                {
+                    ret = -EIO;
+                }
+                AR6000_SPIN_LOCK(&ar->arLock, 0);
+                ar->arMaxRetries = setRetryParams.maxRetries;
+                AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+            }
+            break;
+        }
+
+        case AR6000_XIOCTL_SET_ADHOC_BEACON_INTVAL:
+        {
+            WMI_BEACON_INT_CMD bIntvlCmd;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&bIntvlCmd, userdata,
+                       sizeof(bIntvlCmd)))
+            {
+                ret = -EFAULT;
+            } else if (wmi_set_adhoc_bconIntvl_cmd(ar->arWmi, bIntvlCmd.beaconInterval)
+                        != A_OK)
+            {
+                ret = -EIO;
+            }
+            break;
+        }
+        case IEEE80211_IOCTL_SETAUTHALG:
+        {
+            AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+            struct ieee80211req_authalg req;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&req, userdata,
+                       sizeof(struct ieee80211req_authalg)))
+            {
+                ret = -EFAULT;
+            } else if (req.auth_alg == AUTH_ALG_OPEN_SYSTEM) {
+                ar->arDot11AuthMode  = OPEN_AUTH;
+                ar->arPairwiseCrypto  = NONE_CRYPT;
+                ar->arGroupCrypto     = NONE_CRYPT;
+            } else if (req.auth_alg == AUTH_ALG_LEAP) {
+                ar->arDot11AuthMode   = LEAP_AUTH;
+            } else {
+                ret = -EIO;
+            }
+            break;
+        }
+
+        case AR6000_XIOCTL_SET_VOICE_PKT_SIZE:
+            ret = ar6000_xioctl_set_voice_pkt_size(dev, userdata);
+            break;
+
+        case AR6000_XIOCTL_SET_MAX_SP:
+            ret = ar6000_xioctl_set_max_sp_len(dev, userdata);
+            break;
+
+        case AR6000_XIOCTL_WMI_GET_ROAM_TBL:
+            ret = ar6000_ioctl_get_roam_tbl(dev, rq);
+            break;
+        case AR6000_XIOCTL_WMI_SET_ROAM_CTRL:
+            ret = ar6000_ioctl_set_roam_ctrl(dev, userdata);
+            break;
+        case AR6000_XIOCTRL_WMI_SET_POWERSAVE_TIMERS:
+            ret = ar6000_ioctl_set_powersave_timers(dev, userdata);
+            break;
+        case AR6000_XIOCTRL_WMI_GET_POWER_MODE:
+            ret = ar6000_ioctl_get_power_mode(dev, rq);
+            break;
+        case AR6000_XIOCTRL_WMI_SET_WLAN_STATE:
+            get_user(ar->arWlanState, (unsigned int *)userdata);
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+                break;
+            }
+
+            if (ar->arWlanState == WLAN_ENABLED) {
+                /* Enable foreground scanning */
+                if (wmi_scanparams_cmd(ar->arWmi, scParams.fg_start_period,
+                                       scParams.fg_end_period,
+                                       scParams.bg_period,
+                                       scParams.minact_chdwell_time,
+                                       scParams.maxact_chdwell_time,
+                                       scParams.pas_chdwell_time,
+                                       scParams.shortScanRatio,
+                                       scParams.scanCtrlFlags,
+                                       scParams.max_dfsch_act_time,
+                                       scParams.maxact_scan_per_ssid) != A_OK)
+                {
+                    ret = -EIO;
+                }
+                if (ar->arSsidLen) {
+                    ar->arConnectPending = TRUE;
+                    if (wmi_connect_cmd(ar->arWmi, ar->arNetworkType,
+                                        ar->arDot11AuthMode, ar->arAuthMode,
+                                        ar->arPairwiseCrypto,
+                                        ar->arPairwiseCryptoLen,
+                                        ar->arGroupCrypto, ar->arGroupCryptoLen,
+                                        ar->arSsidLen, ar->arSsid,
+                                        ar->arReqBssid, ar->arChannelHint,
+                                        ar->arConnectCtrlFlags) != A_OK)
+                    {
+                        ret = -EIO;
+                        ar->arConnectPending = FALSE;
+                    }
+                }
+            } else {
+                /* Disconnect from the AP and disable foreground scanning */
+                AR6000_SPIN_LOCK(&ar->arLock, 0);
+                if (ar->arConnected == TRUE || ar->arConnectPending == TRUE) {
+                    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+                    wmi_disconnect_cmd(ar->arWmi);
+                } else {
+                    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+                }
+
+                if (wmi_scanparams_cmd(ar->arWmi, 0xFFFF, 0, 0, 0, 0, 0, 0, 0xFF, 0, 0) != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        case AR6000_XIOCTL_WMI_GET_ROAM_DATA:
+            ret = ar6000_ioctl_get_roam_data(dev, rq);
+            break;
+        case AR6000_XIOCTL_WMI_SET_BT_STATUS:
+            ret = ar6000_xioctl_set_bt_status_cmd(dev, userdata);
+            break;
+        case AR6000_XIOCTL_WMI_SET_BT_PARAMS:
+            ret = ar6000_xioctl_set_bt_params_cmd(dev, userdata);
+            break;
+        case AR6000_XIOCTL_WMI_STARTSCAN:
+        {
+            WMI_START_SCAN_CMD setStartScanCmd, *cmdp;
+
+            if (ar->arWmiReady == FALSE) {
+                    ret = -EIO;
+                } else if (copy_from_user(&setStartScanCmd, userdata,
+                                          sizeof(setStartScanCmd)))
+                {
+                    ret = -EFAULT;
+                } else {
+                    if (setStartScanCmd.numChannels > 1) {
+                        cmdp = A_MALLOC(130);
+                        if (copy_from_user(cmdp, userdata,
+                                           sizeof (*cmdp) +
+                                           ((setStartScanCmd.numChannels - 1) *
+                                           sizeof(A_UINT16))))
+                        {
+                            kfree(cmdp);
+                            return -EFAULT;
+                        }
+                    } else {
+                        cmdp = &setStartScanCmd;
+                    }
+
+                    if (wmi_startscan_cmd(ar->arWmi, cmdp->scanType,
+                                          cmdp->forceFgScan,
+                                          cmdp->isLegacy,
+                                          cmdp->homeDwellTime,
+                                          cmdp->forceScanInterval,
+                                          cmdp->numChannels,
+                                          cmdp->channelList) != A_OK)
+                    {
+                        ret = -EIO;
+                    }
+                }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SETFIXRATES:
+        {
+            WMI_FIX_RATES_CMD setFixRatesCmd;
+            A_STATUS returnStatus;
+
+            if (ar->arWmiReady == FALSE) {
+                    ret = -EIO;
+                } else if (copy_from_user(&setFixRatesCmd, userdata,
+                                          sizeof(setFixRatesCmd)))
+                {
+                    ret = -EFAULT;
+                } else {
+                    returnStatus = wmi_set_fixrates_cmd(ar->arWmi, setFixRatesCmd.fixRateMask);
+                    if (returnStatus == A_EINVAL)
+                    {
+                        ret = -EINVAL;
+                    }
+                    else if(returnStatus != A_OK) {
+                        ret = -EIO;
+                    }
+                }
+            break;
+        }
+
+        case AR6000_XIOCTL_WMI_GETFIXRATES:
+        {
+            WMI_FIX_RATES_CMD getFixRatesCmd;
+            AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+            int ret = 0;
+
+            if (ar->arWmiReady == FALSE) {
+                return -EIO;
+            }
+
+            if (down_interruptible(&ar->arSem)) {
+                return -ERESTARTSYS;
+            }
+            /* Used copy_from_user/copy_to_user to access user space data */
+            if (copy_from_user(&getFixRatesCmd, userdata, sizeof(getFixRatesCmd))) {
+                ret = -EFAULT;
+            } else {
+                ar->arRateMask = 0xFFFF;
+
+                if (wmi_get_ratemask_cmd(ar->arWmi) != A_OK) {
+                    up(&ar->arSem);
+                    return -EIO;
+                }
+
+                wait_event_interruptible_timeout(arEvent, ar->arRateMask != 0xFFFF, wmitimeout * HZ);
+
+                if (signal_pending(current)) {
+                    ret = -EINTR;
+                }
+
+                if (!ret) {
+                    getFixRatesCmd.fixRateMask = ar->arRateMask;
+                }
+
+                if(copy_to_user(userdata, &getFixRatesCmd, sizeof(getFixRatesCmd))) {
+                   ret = -EFAULT;
+                }
+
+                up(&ar->arSem);
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_AUTHMODE:
+        {
+            WMI_SET_AUTH_MODE_CMD setAuthMode;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&setAuthMode, userdata,
+                                      sizeof(setAuthMode)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_set_authmode_cmd(ar->arWmi, setAuthMode.mode) != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_REASSOCMODE:
+        {
+            WMI_SET_REASSOC_MODE_CMD setReassocMode;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&setReassocMode, userdata,
+                                      sizeof(setReassocMode)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_set_reassocmode_cmd(ar->arWmi, setReassocMode.mode) != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_XIOCTL_DIAG_READ:
+        {
+            A_UINT32 addr, data;
+            get_user(addr, (unsigned int *)userdata);
+            if (ar6000_ReadRegDiag(ar->arHifDevice, &addr, &data) != A_OK) {
+                ret = -EIO;
+            }
+            put_user(data, (unsigned int *)userdata + 1);
+            break;
+        }
+        case AR6000_XIOCTL_DIAG_WRITE:
+        {
+            A_UINT32 addr, data;
+            get_user(addr, (unsigned int *)userdata);
+            get_user(data, (unsigned int *)userdata + 1);
+            if (ar6000_WriteRegDiag(ar->arHifDevice, &addr, &data) != A_OK) {
+                ret = -EIO;
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_KEEPALIVE:
+        {
+             WMI_SET_KEEPALIVE_CMD setKeepAlive;
+             if (ar->arWmiReady == FALSE) {
+                 return -EIO;
+             } else if (copy_from_user(&setKeepAlive, userdata,
+                        sizeof(setKeepAlive))){
+                 ret = -EFAULT;
+             } else {
+                 if (wmi_set_keepalive_cmd(ar->arWmi, setKeepAlive.keepaliveInterval) != A_OK) {
+                     ret = -EIO;
+               }
+             }
+             break;
+        }
+        case AR6000_XIOCTL_WMI_GET_KEEPALIVE:
+        {
+            AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+            WMI_GET_KEEPALIVE_CMD getKeepAlive;
+            int ret = 0;
+            if (ar->arWmiReady == FALSE) {
+               return -EIO;
+            }
+            if (down_interruptible(&ar->arSem)) {
+                return -ERESTARTSYS;
+            }
+            if (copy_from_user(&getKeepAlive, userdata,sizeof(getKeepAlive))) {
+               ret = -EFAULT;
+            } else {
+            getKeepAlive.keepaliveInterval = wmi_get_keepalive_cmd(ar->arWmi);
+            ar->arKeepaliveConfigured = 0xFF;
+            if (wmi_get_keepalive_configured(ar->arWmi) != A_OK){
+                up(&ar->arSem);
+                return -EIO;
+            }
+            wait_event_interruptible_timeout(arEvent, ar->arKeepaliveConfigured != 0xFF, wmitimeout * HZ);
+            if (signal_pending(current)) {
+                ret = -EINTR;
+            }
+
+            if (!ret) {
+                getKeepAlive.configured = ar->arKeepaliveConfigured;
+            }
+            if (copy_to_user(userdata, &getKeepAlive, sizeof(getKeepAlive))) {
+               ret = -EFAULT;
+            }
+            up(&ar->arSem);
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_APPIE:
+        {
+            WMI_SET_APPIE_CMD appIEcmd;
+            A_UINT8           appIeInfo[IEEE80211_APPIE_FRAME_MAX_LEN];
+            A_UINT32            fType,ieLen;
+
+			if (ar->arWmiReady == FALSE) {
+				return -EIO;
+			}
+			get_user(fType, (A_UINT32 *)userdata);
+			appIEcmd.mgmtFrmType = fType;
+			if (appIEcmd.mgmtFrmType >= IEEE80211_APPIE_NUM_OF_FRAME) {
+				ret = -EIO;
+			} else {
+				get_user(ieLen, (A_UINT32 *)(userdata + 4));
+				appIEcmd.ieLen = ieLen;
+				if (appIEcmd.ieLen > IEEE80211_APPIE_FRAME_MAX_LEN) {
+					ret = -EIO;
+					break;
+				}
+				if (copy_from_user(appIeInfo, userdata + 8, appIEcmd.ieLen)) {
+					ret = -EFAULT;
+				} else {
+					if (wmi_set_appie_cmd(ar->arWmi, appIEcmd.mgmtFrmType,
+										  appIEcmd.ieLen,  appIeInfo) != A_OK)
+					{
+						ret = -EIO;
+					}
+				}
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_MGMT_FRM_RX_FILTER:
+        {
+            WMI_BSS_FILTER_CMD cmd;
+            A_UINT32    filterType;
+
+            if (copy_from_user(&filterType, userdata, sizeof(A_UINT32)))
+            {
+                return -EFAULT;
+            }
+            if (filterType & (IEEE80211_FILTER_TYPE_BEACON |
+                                    IEEE80211_FILTER_TYPE_PROBE_RESP))
+            {
+                cmd.bssFilter = ALL_BSS_FILTER;
+            } else {
+                cmd.bssFilter = NONE_BSS_FILTER;
+            }
+            if (wmi_bssfilter_cmd(ar->arWmi, cmd.bssFilter, 0) != A_OK) {
+                ret = -EIO;
+            } else {
+                ar->arUserBssFilter = cmd.bssFilter;
+            }
+
+            AR6000_SPIN_LOCK(&ar->arLock, 0);
+            ar->arMgmtFilter = filterType;
+            AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_WSC_STATUS:
+        {
+            A_UINT32    wsc_status;
+
+            if (ar->arWmiReady == FALSE) {
+                return -EIO;
+            } else if (copy_from_user(&wsc_status, userdata, sizeof(A_UINT32)))
+            {
+                return -EFAULT;
+            }
+            if (wmi_set_wsc_status_cmd(ar->arWmi, wsc_status) != A_OK) {
+                ret = -EIO;
+            }
+            break;
+        }
+        case AR6000_XIOCTL_BMI_ROMPATCH_INSTALL:
+        {
+            A_UINT32 ROM_addr;
+            A_UINT32 RAM_addr;
+            A_UINT32 nbytes;
+            A_UINT32 do_activate;
+            A_UINT32 rompatch_id;
+
+            get_user(ROM_addr, (A_UINT32 *)userdata);
+            get_user(RAM_addr, (A_UINT32 *)userdata + 1);
+            get_user(nbytes, (A_UINT32 *)userdata + 2);
+            get_user(do_activate, (A_UINT32 *)userdata + 3);
+            AR_DEBUG_PRINTF("Install rompatch from ROM: 0x%x to RAM: 0x%x  length: %d\n",
+                             ROM_addr, RAM_addr, nbytes);
+            ret = BMIrompatchInstall(hifDevice, ROM_addr, RAM_addr,
+                                        nbytes, do_activate, &rompatch_id);
+            if (ret == A_OK) {
+                put_user(rompatch_id, (unsigned int *)rq->ifr_data); /* return value */
+            }
+            break;
+        }
+
+        case AR6000_XIOCTL_BMI_ROMPATCH_UNINSTALL:
+        {
+            A_UINT32 rompatch_id;
+
+            get_user(rompatch_id, (A_UINT32 *)userdata);
+            AR_DEBUG_PRINTF("UNinstall rompatch_id %d\n", rompatch_id);
+            ret = BMIrompatchUninstall(hifDevice, rompatch_id);
+            break;
+        }
+
+        case AR6000_XIOCTL_BMI_ROMPATCH_ACTIVATE:
+        case AR6000_XIOCTL_BMI_ROMPATCH_DEACTIVATE:
+        {
+            A_UINT32 rompatch_count;
+
+            get_user(rompatch_count, (A_UINT32 *)userdata);
+            AR_DEBUG_PRINTF("Change rompatch activation count=%d\n", rompatch_count);
+            length = sizeof(A_UINT32) * rompatch_count;
+            if ((buffer = (unsigned char *)A_MALLOC(length)) != NULL) {
+                A_MEMZERO(buffer, length);
+                if (copy_from_user(buffer, &userdata[sizeof(rompatch_count)], length))
+                {
+                    ret = -EFAULT;
+                } else {
+                    if (cmd == AR6000_XIOCTL_BMI_ROMPATCH_ACTIVATE) {
+                        ret = BMIrompatchActivate(hifDevice, rompatch_count, (A_UINT32 *)buffer);
+                    } else {
+                        ret = BMIrompatchDeactivate(hifDevice, rompatch_count, (A_UINT32 *)buffer);
+                    }
+                }
+                A_FREE(buffer);
+            } else {
+                ret = -ENOMEM;
+            }
+
+            break;
+        }
+
+        case AR6000_XIOCTL_WMI_SET_HOST_SLEEP_MODE:
+        {
+            WMI_SET_HOST_SLEEP_MODE_CMD setHostSleepMode;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&setHostSleepMode, userdata,
+                                      sizeof(setHostSleepMode)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_set_host_sleep_mode_cmd(ar->arWmi,
+                                &setHostSleepMode) != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_WOW_MODE:
+        {
+            WMI_SET_WOW_MODE_CMD setWowMode;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&setWowMode, userdata,
+                                      sizeof(setWowMode)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_set_wow_mode_cmd(ar->arWmi,
+                                &setWowMode) != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_GET_WOW_LIST:
+        {
+            WMI_GET_WOW_LIST_CMD getWowList;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&getWowList, userdata,
+                                      sizeof(getWowList)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_get_wow_list_cmd(ar->arWmi,
+                                &getWowList) != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_ADD_WOW_PATTERN:
+        {
+#define WOW_PATTERN_SIZE 64
+#define WOW_MASK_SIZE 64
+
+            WMI_ADD_WOW_PATTERN_CMD cmd;
+            A_UINT8 mask_data[WOW_PATTERN_SIZE]={0};
+            A_UINT8 pattern_data[WOW_PATTERN_SIZE]={0};
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else {
+
+                if(copy_from_user(&cmd, userdata,
+                            sizeof(WMI_ADD_WOW_PATTERN_CMD)))
+                      return -EFAULT;
+                if (copy_from_user(pattern_data,
+                                      userdata + 3,
+                                      cmd.filter_size)){
+                        ret = -EFAULT;
+                        break;
+                }
+                if (copy_from_user(mask_data,
+                                      (userdata + 3 + cmd.filter_size),
+                                      cmd.filter_size)){
+                        ret = -EFAULT;
+                        break;
+                } else {
+                    if (wmi_add_wow_pattern_cmd(ar->arWmi,
+                                &cmd, pattern_data, mask_data, cmd.filter_size) != A_OK){
+                        ret = -EIO;
+                    }
+                }
+            }
+#undef WOW_PATTERN_SIZE
+#undef WOW_MASK_SIZE
+            break;
+        }
+        case AR6000_XIOCTL_WMI_DEL_WOW_PATTERN:
+        {
+            WMI_DEL_WOW_PATTERN_CMD delWowPattern;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&delWowPattern, userdata,
+                                      sizeof(delWowPattern)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_del_wow_pattern_cmd(ar->arWmi,
+                                &delWowPattern) != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_XIOCTL_DUMP_HTC_CREDIT_STATE:
+            if (ar->arHtcTarget != NULL) {
+                HTCDumpCreditStates(ar->arHtcTarget);
+            }
+            break;
+        case AR6000_XIOCTL_TRAFFIC_ACTIVITY_CHANGE:
+            if (ar->arHtcTarget != NULL) {
+                struct ar6000_traffic_activity_change data;
+
+                if (copy_from_user(&data, userdata, sizeof(data)))
+                {
+                    return -EFAULT;
+                }
+                    /* note, this is used for testing (mbox ping testing), indicate activity
+                     * change using the stream ID as the traffic class */
+                ar6000_indicate_tx_activity(ar,
+                                            (A_UINT8)data.StreamID,
+                                            data.Active ? TRUE : FALSE);
+            }
+            break;
+        case AR6000_XIOCTL_WMI_SET_CONNECT_CTRL_FLAGS:
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&connectCtrlFlags, userdata,
+                                      sizeof(connectCtrlFlags)))
+            {
+                ret = -EFAULT;
+            } else {
+                ar->arConnectCtrlFlags = connectCtrlFlags;
+            }
+            break;
+        case AR6000_XIOCTL_WMI_SET_AKMP_PARAMS:
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&akmpParams, userdata,
+                                      sizeof(WMI_SET_AKMP_PARAMS_CMD)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_set_akmp_params_cmd(ar->arWmi, &akmpParams) != A_OK) {
+                    ret = -EIO;
+                }
+            }
+            break;
+        case AR6000_XIOCTL_WMI_SET_PMKID_LIST:
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else {
+                if (copy_from_user(&pmkidInfo.numPMKID, userdata,
+                                      sizeof(pmkidInfo.numPMKID)))
+                {
+                    ret = -EFAULT;
+                    break;
+                }
+                if (copy_from_user(&pmkidInfo.pmkidList,
+                                   userdata + sizeof(pmkidInfo.numPMKID),
+                                   pmkidInfo.numPMKID * sizeof(WMI_PMKID)))
+                {
+                    ret = -EFAULT;
+                    break;
+                }
+                if (wmi_set_pmkid_list_cmd(ar->arWmi, &pmkidInfo) != A_OK) {
+                    ret = -EIO;
+                }
+            }
+            break;
+        case AR6000_XIOCTL_WMI_GET_PMKID_LIST:
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else  {
+                if (wmi_get_pmkid_list_cmd(ar->arWmi) != A_OK) {
+                    ret = -EIO;
+                }
+            }
+            break;
+        case AR6000_XIOCTL_WMI_ABORT_SCAN:
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            }
+            ret = wmi_abort_scan_cmd(ar->arWmi);
+            break;
+        case AR6000_XIOCTL_WMI_TARGET_EVENT_REPORT:
+        {
+            WMI_SET_TARGET_EVENT_REPORT_CMD evtCfgCmd;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            }
+            if (copy_from_user(&evtCfgCmd, userdata,
+                               sizeof(evtCfgCmd))) {
+                ret = -EFAULT;
+                break;
+            }
+            ret = wmi_set_target_event_report_cmd(ar->arWmi, &evtCfgCmd);
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_MCAST_FILTER:
+        {
+             WMI_SET_MCAST_FILTER_CMD cmd;
+             if (ar->arWmiReady == FALSE) {
+                 return -EIO;
+             } else if (copy_from_user(&cmd, userdata,
+                        sizeof(cmd))){
+                 ret = -EFAULT;
+             } else {
+                 if (wmi_set_mcast_filter_cmd(ar->arWmi, cmd.multicast_mac[0],
+                                              cmd.multicast_mac[1],
+                                              cmd.multicast_mac[2],
+                                              cmd.multicast_mac[3]) != A_OK) {
+                     ret = -EIO;
+               }
+             }
+             break;
+        }
+        case AR6000_XIOCTL_WMI_DEL_MCAST_FILTER:
+        {
+             WMI_SET_MCAST_FILTER_CMD cmd;
+             if (ar->arWmiReady == FALSE) {
+                 return -EIO;
+             } else if (copy_from_user(&cmd, userdata, sizeof(cmd))){
+                 ret = -EFAULT;
+             } else {
+                 if (wmi_del_mcast_filter_cmd(ar->arWmi, cmd.multicast_mac[0],
+                                              cmd.multicast_mac[1],
+                                              cmd.multicast_mac[2],
+                                              cmd.multicast_mac[3]) != A_OK) {
+                     ret = -EIO;
+               }
+             }
+             break;
+        }
+        default:
+            ret = -EOPNOTSUPP;
+    }
+    return ret;
+}
+
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/ar6000/netbuf.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/ar6000/netbuf.c
@@ -0,0 +1,240 @@
+
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/skbuff.h>
+#include "../include/config.h"
+#include "../include/athdefs.h"
+#include "../include/athtypes.h"
+#include "../include/osapi.h"
+#include "../include/htc_packet.h"
+
+#define AR6000_DATA_OFFSET    64
+
+void a_netbuf_enqueue(A_NETBUF_QUEUE_T *q, void *pkt)
+{
+    skb_queue_tail((struct sk_buff_head *) q, (struct sk_buff *) pkt);
+}
+
+void a_netbuf_prequeue(A_NETBUF_QUEUE_T *q, void *pkt)
+{
+    skb_queue_head((struct sk_buff_head *) q, (struct sk_buff *) pkt);
+}
+
+void *a_netbuf_dequeue(A_NETBUF_QUEUE_T *q)
+{
+    return((void *) skb_dequeue((struct sk_buff_head *) q));
+}
+
+int a_netbuf_queue_size(A_NETBUF_QUEUE_T *q)
+{
+    return(skb_queue_len((struct sk_buff_head *) q));
+}
+
+int a_netbuf_queue_empty(A_NETBUF_QUEUE_T *q)
+{
+    return(skb_queue_empty((struct sk_buff_head *) q));
+}
+
+void a_netbuf_queue_init(A_NETBUF_QUEUE_T *q)
+{
+    skb_queue_head_init((struct sk_buff_head *) q);
+}
+
+void *
+a_netbuf_alloc(int size)
+{
+    struct sk_buff *skb;
+    int our_headroom, total_headroom;
+
+    /*
+    * dev_alloc_skb() allocates a cache-line aligned buffer and then reserves
+    * NET_SKB_PAD bytes of headroom.  NET_SKB_PAD is not necessarily cache-line
+    * aligned.  We want the total amount of headroom reserved to be a multiple
+    * of the cache line size so that the start of the data in the buffer is
+    * cache-line aligned.  Aligning the buffer will improve efficiency on some
+    * platforms by eliminating the need to use a bounce buffer for DMA
+    * transfers.
+    */
+    total_headroom =
+        SKB_DATA_ALIGN(NET_SKB_PAD + AR6000_DATA_OFFSET + sizeof(HTC_PACKET));
+    our_headroom = total_headroom - NET_SKB_PAD;
+    skb = dev_alloc_skb(our_headroom + size);
+    if (skb)
+        skb_reserve(skb, our_headroom);
+    return ((void *)skb);
+}
+
+/*
+ * Allocate an SKB w.o. any encapsulation requirement.
+ */
+void *
+a_netbuf_alloc_raw(int size)
+{
+    struct sk_buff *skb;
+
+    skb = dev_alloc_skb(size);
+
+    return ((void *)skb);
+}
+
+void
+a_netbuf_free(void *bufPtr)
+{
+    struct sk_buff *skb = (struct sk_buff *)bufPtr;
+
+    dev_kfree_skb(skb);
+}
+
+A_UINT32
+a_netbuf_to_len(void *bufPtr)
+{
+    return (((struct sk_buff *)bufPtr)->len);
+}
+
+void *
+a_netbuf_to_data(void *bufPtr)
+{
+    return (((struct sk_buff *)bufPtr)->data);
+}
+
+/*
+ * Add len # of bytes to the beginning of the network buffer
+ * pointed to by bufPtr
+ */
+A_STATUS
+a_netbuf_push(void *bufPtr, A_INT32 len)
+{
+    skb_push((struct sk_buff *)bufPtr, len);
+
+    return A_OK;
+}
+
+/*
+ * Add len # of bytes to the beginning of the network buffer
+ * pointed to by bufPtr and also fill with data
+ */
+A_STATUS
+a_netbuf_push_data(void *bufPtr, char *srcPtr, A_INT32 len)
+{
+    skb_push((struct sk_buff *) bufPtr, len);
+    A_MEMCPY(((struct sk_buff *)bufPtr)->data, srcPtr, len);
+
+    return A_OK;
+}
+
+/*
+ * Add len # of bytes to the end of the network buffer
+ * pointed to by bufPtr
+ */
+A_STATUS
+a_netbuf_put(void *bufPtr, A_INT32 len)
+{
+    skb_put((struct sk_buff *)bufPtr, len);
+
+    return A_OK;
+}
+
+/*
+ * Add len # of bytes to the end of the network buffer
+ * pointed to by bufPtr and also fill with data
+ */
+A_STATUS
+a_netbuf_put_data(void *bufPtr, char *srcPtr, A_INT32 len)
+{
+    char *start = ((struct sk_buff *)bufPtr)->data +
+        ((struct sk_buff *)bufPtr)->len;
+    skb_put((struct sk_buff *)bufPtr, len);
+    A_MEMCPY(start, srcPtr, len);
+
+    return A_OK;
+}
+
+
+/*
+ * Trim the network buffer pointed to by bufPtr to len # of bytes
+ */
+A_STATUS
+a_netbuf_setlen(void *bufPtr, A_INT32 len)
+{
+    skb_trim((struct sk_buff *)bufPtr, len);
+
+    return A_OK;
+}
+
+/*
+ * Chop of len # of bytes from the end of the buffer.
+ */
+A_STATUS
+a_netbuf_trim(void *bufPtr, A_INT32 len)
+{
+    skb_trim((struct sk_buff *)bufPtr, ((struct sk_buff *)bufPtr)->len - len);
+
+    return A_OK;
+}
+
+/*
+ * Chop of len # of bytes from the end of the buffer and return the data.
+ */
+A_STATUS
+a_netbuf_trim_data(void *bufPtr, char *dstPtr, A_INT32 len)
+{
+    char *start = ((struct sk_buff *)bufPtr)->data +
+        (((struct sk_buff *)bufPtr)->len - len);
+
+    A_MEMCPY(dstPtr, start, len);
+    skb_trim((struct sk_buff *)bufPtr, ((struct sk_buff *)bufPtr)->len - len);
+
+    return A_OK;
+}
+
+
+/*
+ * Returns the number of bytes available to a a_netbuf_push()
+ */
+A_INT32
+a_netbuf_headroom(void *bufPtr)
+{
+    return (skb_headroom((struct sk_buff *)bufPtr));
+}
+
+/*
+ * Removes specified number of bytes from the beginning of the buffer
+ */
+A_STATUS
+a_netbuf_pull(void *bufPtr, A_INT32 len)
+{
+    skb_pull((struct sk_buff *)bufPtr, len);
+
+    return A_OK;
+}
+
+/*
+ * Removes specified number of bytes from the beginning of the buffer
+ * and return the data
+ */
+A_STATUS
+a_netbuf_pull_data(void *bufPtr, char *dstPtr, A_INT32 len)
+{
+    A_MEMCPY(dstPtr, ((struct sk_buff *)bufPtr)->data, len);
+    skb_pull((struct sk_buff *)bufPtr, len);
+
+    return A_OK;
+}
+
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/ar6000/wireless_ext.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/ar6000/wireless_ext.c
@@ -0,0 +1,2532 @@
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "../include/ar6000_drv.h"
+
+static A_UINT8 bcast_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+static void ar6000_set_quality(struct iw_quality *iq, A_INT8 rssi);
+extern unsigned int wmitimeout;
+extern A_WAITQUEUE_HEAD arEvent;
+
+#if WIRELESS_EXT > 14
+/*
+ * Encode a WPA or RSN information element as a custom
+ * element using the hostap format.
+ */
+static u_int
+encode_ie(void *buf, size_t bufsize,
+    const u_int8_t *ie, size_t ielen,
+    const char *leader, size_t leader_len)
+{
+    u_int8_t *p;
+    int i;
+
+    if (bufsize < leader_len)
+        return 0;
+    p = buf;
+    memcpy(p, leader, leader_len);
+    bufsize -= leader_len;
+    p += leader_len;
+    for (i = 0; i < ielen && bufsize > 2; i++)
+    {
+        p += sprintf(p, "%02x", ie[i]);
+        bufsize -= 2;
+    }
+    return (i == ielen ? p - (u_int8_t *)buf : 0);
+}
+#endif /* WIRELESS_EXT > 14 */
+
+void
+ar6000_scan_node(void *arg, bss_t *ni)
+{
+    struct iw_event iwe;
+#if WIRELESS_EXT > 14
+    char buf[256];
+#endif
+    struct ar_giwscan_param *param;
+    A_CHAR *current_ev;
+    A_CHAR *end_buf;
+    struct ieee80211_common_ie  *cie;
+    A_CHAR *current_val;
+    A_INT32 j;
+    A_UINT32 rate_len, data_len = 0;
+
+    param = (struct ar_giwscan_param *)arg;
+
+    current_ev = param->current_ev;
+    end_buf = param->end_buf;
+
+    cie = &ni->ni_cie;
+
+    if ((end_buf - current_ev) > IW_EV_ADDR_LEN)
+    {
+        A_MEMZERO(&iwe, sizeof(iwe));
+        iwe.cmd = SIOCGIWAP;
+        iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+        A_MEMCPY(iwe.u.ap_addr.sa_data, ni->ni_macaddr, 6);
+        current_ev = iwe_stream_add_event(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                          param->info,
+#endif
+                          current_ev, end_buf, &iwe,
+                          IW_EV_ADDR_LEN);
+    }
+    param->bytes_needed += IW_EV_ADDR_LEN;
+
+    data_len = cie->ie_ssid[1] + IW_EV_POINT_LEN;
+    if ((end_buf - current_ev) > data_len)
+    {
+        A_MEMZERO(&iwe, sizeof(iwe));
+        iwe.cmd = SIOCGIWESSID;
+        iwe.u.data.flags = 1;
+        iwe.u.data.length = cie->ie_ssid[1];
+        current_ev = iwe_stream_add_point(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                          param->info,
+#endif
+                          current_ev, end_buf, &iwe,
+                          &cie->ie_ssid[2]);
+    }
+    param->bytes_needed += data_len;
+
+    if (cie->ie_capInfo & (IEEE80211_CAPINFO_ESS|IEEE80211_CAPINFO_IBSS)) {
+        if ((end_buf - current_ev) > IW_EV_UINT_LEN)
+        {
+            A_MEMZERO(&iwe, sizeof(iwe));
+            iwe.cmd = SIOCGIWMODE;
+            iwe.u.mode = cie->ie_capInfo & IEEE80211_CAPINFO_ESS ?
+                         IW_MODE_MASTER : IW_MODE_ADHOC;
+            current_ev = iwe_stream_add_event(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                          param->info,
+#endif
+                          current_ev, end_buf, &iwe,
+                          IW_EV_UINT_LEN);
+        }
+        param->bytes_needed += IW_EV_UINT_LEN;
+    }
+
+    if ((end_buf - current_ev) > IW_EV_FREQ_LEN)
+    {
+        A_MEMZERO(&iwe, sizeof(iwe));
+        iwe.cmd = SIOCGIWFREQ;
+        iwe.u.freq.m = cie->ie_chan * 100000;
+        iwe.u.freq.e = 1;
+        current_ev = iwe_stream_add_event(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                          param->info,
+#endif
+                          current_ev, end_buf, &iwe,
+                          IW_EV_FREQ_LEN);
+    }
+    param->bytes_needed += IW_EV_FREQ_LEN;
+
+    if ((end_buf - current_ev) > IW_EV_QUAL_LEN)
+    {
+        A_MEMZERO(&iwe, sizeof(iwe));
+        iwe.cmd = IWEVQUAL;
+        ar6000_set_quality(&iwe.u.qual, ni->ni_snr);
+        current_ev = iwe_stream_add_event(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                          param->info,
+#endif
+                          current_ev, end_buf, &iwe,
+                          IW_EV_QUAL_LEN);
+    }
+    param->bytes_needed += IW_EV_QUAL_LEN;
+
+    if ((end_buf - current_ev) > IW_EV_POINT_LEN)
+    {
+        A_MEMZERO(&iwe, sizeof(iwe));
+        iwe.cmd = SIOCGIWENCODE;
+        if (cie->ie_capInfo & IEEE80211_CAPINFO_PRIVACY) {
+            iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+        } else {
+            iwe.u.data.flags = IW_ENCODE_DISABLED;
+        }
+        iwe.u.data.length = 0;
+        current_ev = iwe_stream_add_point(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                          param->info,
+#endif
+                          current_ev, end_buf, &iwe, "");
+    }
+    param->bytes_needed += IW_EV_POINT_LEN;
+
+    /* supported bit rate */
+    A_MEMZERO(&iwe, sizeof(iwe));
+    iwe.cmd = SIOCGIWRATE;
+    iwe.u.bitrate.fixed = 0;
+    iwe.u.bitrate.disabled = 0;
+    iwe.u.bitrate.value = 0;
+    current_val = current_ev + IW_EV_LCP_LEN;
+    param->bytes_needed += IW_EV_LCP_LEN;
+
+    if (cie->ie_rates != NULL) {
+        rate_len = cie->ie_rates[1];
+        data_len = (rate_len * (IW_EV_PARAM_LEN - IW_EV_LCP_LEN));
+        if ((end_buf - current_ev) > data_len)
+        {
+            for (j = 0; j < rate_len; j++) {
+                    unsigned char val;
+                    val = cie->ie_rates[2 + j];
+                    iwe.u.bitrate.value =
+                        (val >= 0x80)? ((val - 0x80) * 500000): (val * 500000);
+                    current_val = iwe_stream_add_value(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                                      param->info,
+#endif
+                                      current_ev,
+                                      current_val,
+                                      end_buf,
+                                      &iwe,
+                                      IW_EV_PARAM_LEN);
+            }
+        }
+        param->bytes_needed += data_len;
+    }
+
+    if (cie->ie_xrates != NULL) {
+        rate_len = cie->ie_xrates[1];
+        data_len = (rate_len * (IW_EV_PARAM_LEN - IW_EV_LCP_LEN));
+        if ((end_buf - current_ev) > data_len)
+        {
+            for (j = 0; j < rate_len; j++) {
+                    unsigned char val;
+                    val = cie->ie_xrates[2 + j];
+                    iwe.u.bitrate.value =
+                        (val >= 0x80)? ((val - 0x80) * 500000): (val * 500000);
+                    current_val = iwe_stream_add_value(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                                      param->info,
+#endif
+                                      current_ev,
+                                      current_val,
+                                      end_buf,
+                                      &iwe,
+                                      IW_EV_PARAM_LEN);
+            }
+        }
+        param->bytes_needed += data_len;
+    }
+    /* remove fixed header if no rates were added */
+    if ((current_val - current_ev) > IW_EV_LCP_LEN)
+        current_ev = current_val;
+
+#if WIRELESS_EXT >= 18
+    /* IE */
+    if (cie->ie_wpa != NULL) {
+        data_len = cie->ie_wpa[1] + 2 + IW_EV_POINT_LEN;
+        if ((end_buf - current_ev) > data_len)
+        {
+            A_MEMZERO(&iwe, sizeof(iwe));
+            iwe.cmd = IWEVGENIE;
+            iwe.u.data.length = cie->ie_wpa[1] + 2;
+            current_ev = iwe_stream_add_point(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                          param->info,
+#endif
+                          current_ev, end_buf, &iwe, cie->ie_wpa);
+        }
+        param->bytes_needed += data_len;
+    }
+
+    if (cie->ie_rsn != NULL && cie->ie_rsn[0] == IEEE80211_ELEMID_RSN) {
+        data_len = cie->ie_rsn[1] + 2 + IW_EV_POINT_LEN;
+    	if ((end_buf - current_ev) > data_len)
+        {
+            A_MEMZERO(&iwe, sizeof(iwe));
+            iwe.cmd = IWEVGENIE;
+            iwe.u.data.length = cie->ie_rsn[1] + 2;
+            current_ev = iwe_stream_add_point(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                          param->info,
+#endif
+                          current_ev, end_buf, &iwe, cie->ie_rsn);
+        }
+        param->bytes_needed += data_len;
+    }
+
+#endif /* WIRELESS_EXT >= 18 */
+
+    if ((end_buf - current_ev) > IW_EV_CHAR_LEN)
+    {
+        /* protocol */
+        A_MEMZERO(&iwe, sizeof(iwe));
+        iwe.cmd = SIOCGIWNAME;
+#define CHAN_IS_11A(x)              (!((x >= 2412) && (x <= 2484)))
+        if (CHAN_IS_11A(cie->ie_chan)) {
+            /* 11a */
+            snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11a");
+        } else if ((cie->ie_erp) || (cie->ie_xrates)) {
+            /* 11g */
+            snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11g");
+        } else {
+            /* 11b */
+            snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11b");
+        }
+        current_ev = iwe_stream_add_event(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                          param->info,
+#endif
+                          current_ev, end_buf, &iwe, IW_EV_CHAR_LEN);
+    }
+    param->bytes_needed += IW_EV_CHAR_LEN;
+
+#if WIRELESS_EXT > 14
+    A_MEMZERO(&iwe, sizeof(iwe));
+    iwe.cmd = IWEVCUSTOM;
+    iwe.u.data.length = snprintf(buf, sizeof(buf), "bcn_int=%d", cie->ie_beaconInt);
+    data_len = iwe.u.data.length + IW_EV_POINT_LEN;
+    if ((end_buf - current_ev) > data_len)
+    {
+        current_ev = iwe_stream_add_point(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                          param->info,
+#endif
+                          current_ev, end_buf, &iwe, buf);
+    }
+    param->bytes_needed += data_len;
+
+#if WIRELESS_EXT < 18
+    if (cie->ie_wpa != NULL) {
+        static const char wpa_leader[] = "wpa_ie=";
+        data_len = (sizeof(wpa_leader) - 1) + ((cie->ie_wpa[1]+2) * 2) + IW_EV_POINT_LEN;
+        if ((end_buf - current_ev) > data_len)
+        {
+            A_MEMZERO(&iwe, sizeof(iwe));
+            iwe.cmd = IWEVCUSTOM;
+            iwe.u.data.length = encode_ie(buf, sizeof(buf), cie->ie_wpa,
+                                          cie->ie_wpa[1]+2,
+                                          wpa_leader, sizeof(wpa_leader)-1);
+
+            if (iwe.u.data.length != 0) {
+                current_ev = iwe_stream_add_point(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                              param->info,
+#endif
+                              current_ev, end_buf, &iwe, buf);
+            }
+        }
+        param->bytes_needed += data_len;
+    }
+
+    if (cie->ie_rsn != NULL && cie->ie_rsn[0] == IEEE80211_ELEMID_RSN) {
+        static const char rsn_leader[] = "rsn_ie=";
+        data_len = (sizeof(rsn_leader) - 1) + ((cie->ie_rsn[1]+2) * 2) + IW_EV_POINT_LEN;
+        if ((end_buf - current_ev) > data_len)
+        {
+            A_MEMZERO(&iwe, sizeof(iwe));
+            iwe.cmd = IWEVCUSTOM;
+            iwe.u.data.length = encode_ie(buf, sizeof(buf), cie->ie_rsn,
+                                          cie->ie_rsn[1]+2,
+                                          rsn_leader, sizeof(rsn_leader)-1);
+
+            if (iwe.u.data.length != 0) {
+                current_ev = iwe_stream_add_point(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                              param->info,
+#endif
+                              current_ev, end_buf, &iwe, buf);
+            }
+        }
+        param->bytes_needed += data_len;
+    }
+#endif /* WIRELESS_EXT < 18 */
+
+    if (cie->ie_wmm != NULL) {
+        static const char wmm_leader[] = "wmm_ie=";
+        data_len = (sizeof(wmm_leader) - 1) + ((cie->ie_wmm[1]+2) * 2) + IW_EV_POINT_LEN;
+        if ((end_buf - current_ev) > data_len)
+        {
+            A_MEMZERO(&iwe, sizeof(iwe));
+            iwe.cmd = IWEVCUSTOM;
+            iwe.u.data.length = encode_ie(buf, sizeof(buf), cie->ie_wmm,
+                                          cie->ie_wmm[1]+2,
+                                          wmm_leader, sizeof(wmm_leader)-1);
+            if (iwe.u.data.length != 0) {
+                current_ev = iwe_stream_add_point(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                              param->info,
+#endif
+                              current_ev, end_buf, &iwe, buf);
+            }
+        }
+        param->bytes_needed += data_len;
+    }
+
+    if (cie->ie_ath != NULL) {
+        static const char ath_leader[] = "ath_ie=";
+        data_len = (sizeof(ath_leader) - 1) + ((cie->ie_ath[1]+2) * 2) + IW_EV_POINT_LEN;
+        if ((end_buf - current_ev) > data_len)
+        {
+            A_MEMZERO(&iwe, sizeof(iwe));
+            iwe.cmd = IWEVCUSTOM;
+            iwe.u.data.length = encode_ie(buf, sizeof(buf), cie->ie_ath,
+                                          cie->ie_ath[1]+2,
+                                          ath_leader, sizeof(ath_leader)-1);
+            if (iwe.u.data.length != 0) {
+                current_ev = iwe_stream_add_point(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                              param->info,
+#endif
+                              current_ev, end_buf, &iwe, buf);
+            }
+        }
+        param->bytes_needed += data_len;
+    }
+
+#endif /* WIRELESS_EXT > 14 */
+
+#if WIRELESS_EXT >= 18
+    if (cie->ie_wsc != NULL) {
+	    data_len = (cie->ie_wsc[1] + 2) + IW_EV_POINT_LEN;
+        if ((end_buf - current_ev) > data_len)
+        {
+            A_MEMZERO(&iwe, sizeof(iwe));
+            iwe.cmd = IWEVGENIE;
+            iwe.u.data.length = cie->ie_wsc[1] + 2;
+            current_ev = iwe_stream_add_point(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+                          param->info,
+#endif
+                          current_ev, end_buf, &iwe, cie->ie_wsc);
+        }
+        param->bytes_needed += data_len;
+    }
+#endif /* WIRELESS_EXT >= 18 */
+
+    param->current_ev = current_ev;
+}
+
+int
+ar6000_ioctl_giwscan(struct net_device *dev,
+            struct iw_request_info *info,
+            struct iw_point *data, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    struct ar_giwscan_param param;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    param.current_ev = extra;
+    param.end_buf = extra + data->length;
+    param.bytes_needed = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+    param.info = info;
+#endif
+
+    /* Translate data to WE format */
+    wmi_iterate_nodes(ar->arWmi, ar6000_scan_node, &param);
+
+    /* check if bytes needed is greater than bytes consumed */
+    if (param.bytes_needed > (param.current_ev - extra))
+    {
+        /* Request one byte more than needed, because when "data->length" equals bytes_needed,
+        it is not possible to add the last event data as all iwe_stream_add_xxxxx() functions
+        checks whether (cur_ptr + ev_len) < end_ptr, due to this one more retry would happen*/
+        data->length = param.bytes_needed + 1;
+
+        return -E2BIG;
+    }
+
+    return 0;
+}
+
+extern int reconnect_flag;
+/* SIOCSIWESSID */
+static int
+ar6000_ioctl_siwessid(struct net_device *dev,
+                     struct iw_request_info *info,
+                     struct iw_point *data, char *ssid)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    A_STATUS status;
+    A_UINT8     arNetworkType;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+#if defined(WIRELESS_EXT)
+    if (WIRELESS_EXT >= 20) {
+        data->length += 1;
+    }
+#endif
+
+    /*
+     * iwconfig passes a null terminated string with length including this
+     * so we need to account for this
+     */
+    if (data->flags && (!data->length || (data->length == 1) ||
+        ((data->length - 1) > sizeof(ar->arSsid))))
+    {
+        /*
+         * ssid is invalid
+         */
+        return -EINVAL;
+    }
+    /* Added for bug 25178, return an IOCTL error instead of target returning
+       Illegal parameter error when either the BSSID or channel is missing
+       and we cannot scan during connect.
+     */
+    if (data->flags) {
+        if (ar->arSkipScan == TRUE &&
+            (ar->arChannelHint == 0 ||
+             (!ar->arReqBssid[0] && !ar->arReqBssid[1] && !ar->arReqBssid[2] &&
+              !ar->arReqBssid[3] && !ar->arReqBssid[4] && !ar->arReqBssid[5])))
+        {
+            return -EINVAL;
+        }
+    }
+
+    if (down_interruptible(&ar->arSem)) {
+        return -ERESTARTSYS;
+    }
+
+    if (ar->arTxPending[wmi_get_control_ep(ar->arWmi)]) {
+        /*
+         * sleep until the command queue drains
+         */
+        wait_event_interruptible_timeout(arEvent,
+            ar->arTxPending[wmi_get_control_ep(ar->arWmi)] == 0, wmitimeout * HZ);
+        if (signal_pending(current)) {
+            up(&ar->arSem);
+            return -EINTR;
+        }
+    }
+
+    if (!data->flags) {
+        arNetworkType = ar->arNetworkType;
+        ar6000_init_profile_info(ar);
+        ar->arNetworkType = arNetworkType;
+    }
+
+    if ((ar->arSsidLen) || (!data->flags))
+    {
+        if ((!data->flags) ||
+            (A_MEMCMP(ar->arSsid, ssid, ar->arSsidLen) != 0) ||
+            (ar->arSsidLen != (data->length - 1)))
+        {
+            /*
+             * SSID set previously or essid off has been issued.
+             *
+             * Disconnect Command is issued in two cases after wmi is ready
+             * (1) ssid is different from the previous setting
+             * (2) essid off has been issued
+             *
+             */
+            if (ar->arWmiReady == TRUE) {
+                reconnect_flag = 0;
+                status = wmi_disconnect_cmd(ar->arWmi);
+                A_MEMZERO(ar->arSsid, sizeof(ar->arSsid));
+                ar->arSsidLen = 0;
+                if (ar->arSkipScan == FALSE) {
+                    A_MEMZERO(ar->arReqBssid, sizeof(ar->arReqBssid));
+                }
+                if (!data->flags) {
+                    up(&ar->arSem);
+                    return 0;
+                }
+            } else {
+                 up(&ar->arSem);
+                 return -EIO;
+            }
+        }
+        else
+        {
+            /*
+             * SSID is same, so we assume profile hasn't changed.
+             * If the interface is up and wmi is ready, we issue
+             * a reconnect cmd. Issue a reconnect only we are already
+             * connected.
+             */
+            if((ar->arConnected == TRUE) && (ar->arWmiReady == TRUE))
+            {
+                reconnect_flag = TRUE;
+                status = wmi_reconnect_cmd(ar->arWmi,ar->arReqBssid,
+                                           ar->arChannelHint);
+                up(&ar->arSem);
+                if (status != A_OK) {
+                    return -EIO;
+                }
+                return 0;
+            }
+            else{
+                /*
+                 * Dont return if connect is pending.
+                 */
+                if(!(ar->arConnectPending)) {
+                    up(&ar->arSem);
+                    return 0;
+                }
+            }
+        }
+    }
+
+    ar->arSsidLen = data->length - 1;
+    A_MEMCPY(ar->arSsid, ssid, ar->arSsidLen);
+
+    /* The ssid length check prevents second "essid off" from the user,
+       to be treated as a connect cmd. The second "essid off" is ignored.
+    */
+    if((ar->arWmiReady == TRUE) && (ar->arSsidLen > 0) )
+    {
+        if (SHARED_AUTH == ar->arDot11AuthMode) {
+            ar6000_install_static_wep_keys(ar);
+        }
+
+        if (!ar->arUserBssFilter) {
+            if (wmi_bssfilter_cmd(ar->arWmi, ALL_BSS_FILTER, 0) != A_OK) {
+                up(&ar->arSem);
+                return -EIO;
+            }
+        }
+
+        AR_DEBUG_PRINTF("Connect called with authmode %d dot11 auth %d"\
+                        " PW crypto %d PW crypto Len %d GRP crypto %d"\
+                        " GRP crypto Len %d\n",
+                        ar->arAuthMode, ar->arDot11AuthMode,
+                        ar->arPairwiseCrypto, ar->arPairwiseCryptoLen,
+                        ar->arGroupCrypto, ar->arGroupCryptoLen);
+        reconnect_flag = 0;
+        status = wmi_connect_cmd(ar->arWmi, ar->arNetworkType,
+                                 ar->arDot11AuthMode, ar->arAuthMode,
+                                 ar->arPairwiseCrypto, ar->arPairwiseCryptoLen,
+                                 ar->arGroupCrypto,ar->arGroupCryptoLen,
+                                 ar->arSsidLen, ar->arSsid,
+                                 ar->arReqBssid, ar->arChannelHint,
+                                 ar->arConnectCtrlFlags);
+
+
+        up(&ar->arSem);
+
+        if (status != A_OK) {
+            return -EIO;
+        }
+        ar->arConnectPending = TRUE;
+    }else{
+      up(&ar->arSem);
+    }
+    return 0;
+}
+
+/* SIOCGIWESSID */
+static int
+ar6000_ioctl_giwessid(struct net_device *dev,
+                     struct iw_request_info *info,
+                     struct iw_point *data, char *essid)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (!ar->arSsidLen) {
+        return -EINVAL;
+    }
+
+    data->flags = 1;
+    data->length = ar->arSsidLen;
+    A_MEMCPY(essid, ar->arSsid, ar->arSsidLen);
+
+    return 0;
+}
+
+
+void ar6000_install_static_wep_keys(AR_SOFTC_T *ar)
+{
+    A_UINT8 index;
+    A_UINT8 keyUsage;
+
+    for (index = WMI_MIN_KEY_INDEX; index <= WMI_MAX_KEY_INDEX; index++) {
+        if (ar->arWepKeyList[index].arKeyLen) {
+            keyUsage = GROUP_USAGE;
+            if (index == ar->arDefTxKeyIndex) {
+                keyUsage |= TX_USAGE;
+            }
+            wmi_addKey_cmd(ar->arWmi,
+                           index,
+                           WEP_CRYPT,
+                           keyUsage,
+                           ar->arWepKeyList[index].arKeyLen,
+                           NULL,
+                           ar->arWepKeyList[index].arKey, KEY_OP_INIT_VAL,
+                           NO_SYNC_WMIFLAG);
+        }
+    }
+}
+
+int
+ar6000_ioctl_delkey(struct net_device *dev, struct iw_request_info *info,
+             void *w, char *extra)
+{
+    return 0;
+}
+
+int
+ar6000_ioctl_setmlme(struct net_device *dev, struct iw_request_info *info,
+             void *w, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    struct ieee80211req_mlme *mlme = (struct ieee80211req_mlme *)extra;
+
+    if ((ar->arWmiReady == FALSE) || (ar->arConnected != TRUE)) {
+        return -EIO;
+    }
+
+    switch (mlme->im_op) {
+        case IEEE80211_MLME_DISASSOC:
+        case IEEE80211_MLME_DEAUTH:
+            /* Not Supported */
+            break;
+        default:
+            break;
+    }
+    return 0;
+}
+
+
+int
+ar6000_ioctl_setwmmparams(struct net_device *dev, struct iw_request_info *info,
+             void *w, char *extra)
+{
+    return -EIO;            /* for now */
+}
+
+int
+ar6000_ioctl_getwmmparams(struct net_device *dev, struct iw_request_info *info,
+             void *w, char *extra)
+{
+    return -EIO;            /* for now */
+}
+
+int ar6000_ioctl_setoptie(struct net_device *dev, struct iw_request_info *info,
+			  struct iw_point *data, char *extra)
+{
+	/* The target generates the WPA/RSN IE */
+	return 0;
+}
+
+int
+ar6000_ioctl_setauthalg(struct net_device *dev, struct iw_request_info *info,
+             void *w, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    struct ieee80211req_authalg *req = (struct ieee80211req_authalg *)extra;
+    int ret = 0;
+
+
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    if (req->auth_alg == AUTH_ALG_OPEN_SYSTEM) {
+        ar->arDot11AuthMode  = OPEN_AUTH;
+    } else if (req->auth_alg == AUTH_ALG_LEAP) {
+        ar->arDot11AuthMode   = LEAP_AUTH;
+        ar->arPairwiseCrypto  = WEP_CRYPT;
+        ar->arGroupCrypto     = WEP_CRYPT;
+    } else {
+        ret = -EIO;
+    }
+
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+
+    return ret;
+}
+static int
+ar6000_ioctl_addpmkid(struct net_device *dev, struct iw_request_info *info,
+             void *w, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    struct ieee80211req_addpmkid  *req = (struct ieee80211req_addpmkid *)extra;
+    A_STATUS status;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    AR_DEBUG_PRINTF("Add pmkid for %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x en=%d\n",
+                    req->pi_bssid[0], req->pi_bssid[1], req->pi_bssid[2],
+                    req->pi_bssid[3], req->pi_bssid[4], req->pi_bssid[5],
+                    req->pi_enable);
+
+    status = wmi_setPmkid_cmd(ar->arWmi, req->pi_bssid, req->pi_pmkid,
+                              req->pi_enable);
+
+    if (status != A_OK) {
+        return -EIO;
+    }
+
+    return 0;
+}
+
+/*
+ * SIOCSIWRATE
+ */
+int
+ar6000_ioctl_siwrate(struct net_device *dev,
+            struct iw_request_info *info,
+            struct iw_param *rrq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    A_UINT32  kbps;
+
+    if (rrq->fixed) {
+        kbps = rrq->value / 1000;           /* rrq->value is in bps */
+    } else {
+        kbps = -1;                          /* -1 indicates auto rate */
+    }
+    if(kbps != -1 && wmi_validate_bitrate(ar->arWmi, kbps) == A_EINVAL)
+    {
+        AR_DEBUG_PRINTF("BitRate is not Valid %d\n", kbps);
+        return -EINVAL;
+    }
+    ar->arBitRate = kbps;
+    if(ar->arWmiReady == TRUE)
+    {
+        if (wmi_set_bitrate_cmd(ar->arWmi, kbps) != A_OK) {
+            return -EINVAL;
+        }
+    }
+    return 0;
+}
+
+/*
+ * SIOCGIWRATE
+ */
+int
+ar6000_ioctl_giwrate(struct net_device *dev,
+            struct iw_request_info *info,
+            struct iw_param *rrq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    int ret = 0;
+
+    if (down_interruptible(&ar->arSem)) {
+        return -ERESTARTSYS;
+    }
+    if(ar->arWmiReady == TRUE)
+    {
+        ar->arBitRate = 0xFFFF;
+        if (wmi_get_bitrate_cmd(ar->arWmi) != A_OK) {
+            up(&ar->arSem);
+            return -EIO;
+        }
+        wait_event_interruptible_timeout(arEvent, ar->arBitRate != 0xFFFF, wmitimeout * HZ);
+        if (signal_pending(current)) {
+            ret = -EINTR;
+        }
+    }
+    /* If the interface is down or wmi is not ready or the target is not
+       connected - return the value stored in the device structure */
+    if (!ret) {
+        if (ar->arBitRate == -1) {
+            rrq->fixed = TRUE;
+            rrq->value = 0;
+        } else {
+            rrq->value = ar->arBitRate * 1000;
+        }
+    }
+
+    up(&ar->arSem);
+
+    return ret;
+}
+
+/*
+ * SIOCSIWTXPOW
+ */
+static int
+ar6000_ioctl_siwtxpow(struct net_device *dev,
+             struct iw_request_info *info,
+             struct iw_param *rrq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    A_UINT8 dbM;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (rrq->disabled) {
+        return -EOPNOTSUPP;
+    }
+
+    if (rrq->fixed) {
+        if (rrq->flags != IW_TXPOW_DBM) {
+            return -EOPNOTSUPP;
+        }
+        ar->arTxPwr= dbM = rrq->value;
+        ar->arTxPwrSet = TRUE;
+    } else {
+        ar->arTxPwr = dbM = 0;
+        ar->arTxPwrSet = FALSE;
+    }
+    if(ar->arWmiReady == TRUE)
+    {
+        AR_DEBUG_PRINTF("Set tx pwr cmd %d dbM\n", dbM);
+        wmi_set_txPwr_cmd(ar->arWmi, dbM);
+    }
+    return 0;
+}
+
+/*
+ * SIOCGIWTXPOW
+ */
+int
+ar6000_ioctl_giwtxpow(struct net_device *dev,
+            struct iw_request_info *info,
+            struct iw_param *rrq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    int ret = 0;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (down_interruptible(&ar->arSem)) {
+        return -ERESTARTSYS;
+    }
+    if((ar->arWmiReady == TRUE) && (ar->arConnected == TRUE))
+    {
+        ar->arTxPwr = 0;
+
+        if (wmi_get_txPwr_cmd(ar->arWmi) != A_OK) {
+            up(&ar->arSem);
+            return -EIO;
+        }
+
+        wait_event_interruptible_timeout(arEvent, ar->arTxPwr != 0, wmitimeout * HZ);
+
+        if (signal_pending(current)) {
+            ret = -EINTR;
+         }
+    }
+   /* If the interace is down or wmi is not ready or target is not connected
+      then return value stored in the device structure */
+
+    if (!ret) {
+         if (ar->arTxPwrSet == TRUE) {
+            rrq->fixed = TRUE;
+        }
+        rrq->value = ar->arTxPwr;
+        rrq->flags = IW_TXPOW_DBM;
+    }
+
+    up(&ar->arSem);
+
+    return ret;
+}
+
+/*
+ * SIOCSIWRETRY
+ * since iwconfig only provides us with one max retry value, we use it
+ * to apply to data frames of the BE traffic class.
+ */
+static int
+ar6000_ioctl_siwretry(struct net_device *dev,
+             struct iw_request_info *info,
+             struct iw_param *rrq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (rrq->disabled) {
+        return -EOPNOTSUPP;
+    }
+
+    if ((rrq->flags & IW_RETRY_TYPE) != IW_RETRY_LIMIT) {
+        return -EOPNOTSUPP;
+    }
+
+    if ( !(rrq->value >= WMI_MIN_RETRIES) || !(rrq->value <= WMI_MAX_RETRIES)) {
+            return - EINVAL;
+    }
+    if(ar->arWmiReady == TRUE)
+    {
+        if (wmi_set_retry_limits_cmd(ar->arWmi, DATA_FRAMETYPE, WMM_AC_BE,
+                                     rrq->value, 0) != A_OK){
+            return -EINVAL;
+        }
+    }
+    ar->arMaxRetries = rrq->value;
+    return 0;
+}
+
+/*
+ * SIOCGIWRETRY
+ */
+static int
+ar6000_ioctl_giwretry(struct net_device *dev,
+             struct iw_request_info *info,
+             struct iw_param *rrq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    rrq->disabled = 0;
+    switch (rrq->flags & IW_RETRY_TYPE) {
+    case IW_RETRY_LIFETIME:
+        return -EOPNOTSUPP;
+        break;
+    case IW_RETRY_LIMIT:
+        rrq->flags = IW_RETRY_LIMIT;
+        switch (rrq->flags & IW_RETRY_MODIFIER) {
+        case IW_RETRY_MIN:
+            rrq->flags |= IW_RETRY_MIN;
+            rrq->value = WMI_MIN_RETRIES;
+            break;
+        case IW_RETRY_MAX:
+            rrq->flags |= IW_RETRY_MAX;
+            rrq->value = ar->arMaxRetries;
+            break;
+        }
+        break;
+    }
+    return 0;
+}
+
+/*
+ * SIOCSIWENCODE
+ */
+static int
+ar6000_ioctl_siwencode(struct net_device *dev,
+              struct iw_request_info *info,
+              struct iw_point *erq, char *keybuf)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    int index;
+    A_INT32 auth = ar->arDot11AuthMode;
+    /*
+     *  Static WEP Keys should be configured before setting the SSID
+     */
+    if (ar->arSsidLen) {
+        return -EIO;
+    }
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    index = erq->flags & IW_ENCODE_INDEX;
+
+    if (index && (((index - 1) < WMI_MIN_KEY_INDEX) ||
+                  ((index - 1) > WMI_MAX_KEY_INDEX)))
+    {
+        return -EIO;
+    }
+
+    if (erq->flags & IW_ENCODE_DISABLED) {
+        /*
+         * Encryption disabled
+         */
+        if (index) {
+            /*
+             * If key index was specified then clear the specified key
+             */
+            index--;
+            A_MEMZERO(ar->arWepKeyList[index].arKey,
+                      sizeof(ar->arWepKeyList[index].arKey));
+            ar->arWepKeyList[index].arKeyLen = 0;
+        }
+        ar->arDot11AuthMode       = OPEN_AUTH;
+        ar->arPairwiseCrypto      = NONE_CRYPT;
+        ar->arGroupCrypto         = NONE_CRYPT;
+        ar->arAuthMode            = NONE_AUTH;
+    } else {
+        /*
+         * Enabling WEP encryption
+         */
+        if (index) {
+            index--;                /* keyindex is off base 1 in iwconfig */
+        }
+
+        if (erq->flags & IW_ENCODE_OPEN) {
+            auth = OPEN_AUTH;
+        } else if (erq->flags & IW_ENCODE_RESTRICTED) {
+            auth = SHARED_AUTH;
+        }
+
+        if (erq->length) {
+            if (!IEEE80211_IS_VALID_WEP_CIPHER_LEN(erq->length)) {
+                return -EIO;
+            }
+
+            A_MEMZERO(ar->arWepKeyList[index].arKey,
+                      sizeof(ar->arWepKeyList[index].arKey));
+            A_MEMCPY(ar->arWepKeyList[index].arKey, keybuf, erq->length);
+            ar->arWepKeyList[index].arKeyLen = erq->length;
+        } else {
+            if (ar->arWepKeyList[index].arKeyLen == 0) {
+                return -EIO;
+            }
+            ar->arDefTxKeyIndex = index;
+        }
+
+        ar->arPairwiseCrypto      = WEP_CRYPT;
+        ar->arGroupCrypto         = WEP_CRYPT;
+        ar->arDot11AuthMode       = auth;
+        ar->arAuthMode            = NONE_AUTH;
+    }
+
+    /*
+     * profile has changed.  Erase ssid to signal change
+     */
+    A_MEMZERO(ar->arSsid, sizeof(ar->arSsid));
+
+    return 0;
+}
+
+static int
+ar6000_ioctl_giwencode(struct net_device *dev,
+              struct iw_request_info *info,
+              struct iw_point *erq, char *key)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    A_UINT8 keyIndex;
+    struct ar_wep_key *wk;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (ar->arPairwiseCrypto == NONE_CRYPT) {
+        erq->length = 0;
+        erq->flags = IW_ENCODE_DISABLED;
+    } else {
+        /* get the keyIndex */
+        keyIndex = erq->flags & IW_ENCODE_INDEX;
+        if (0 == keyIndex) {
+            keyIndex = ar->arDefTxKeyIndex;
+        } else if ((keyIndex - 1 < WMI_MIN_KEY_INDEX) ||
+                   (keyIndex - 1 > WMI_MAX_KEY_INDEX))
+        {
+            keyIndex = WMI_MIN_KEY_INDEX;
+        } else {
+            keyIndex--;
+        }
+        erq->flags = keyIndex + 1;
+        erq->flags |= IW_ENCODE_ENABLED;
+        wk = &ar->arWepKeyList[keyIndex];
+        if (erq->length > wk->arKeyLen) {
+            erq->length = wk->arKeyLen;
+        }
+        if (wk->arKeyLen) {
+            A_MEMCPY(key, wk->arKey, erq->length);
+        }
+        if (ar->arDot11AuthMode == OPEN_AUTH) {
+            erq->flags |= IW_ENCODE_OPEN;
+        } else if (ar->arDot11AuthMode == SHARED_AUTH) {
+            erq->flags |= IW_ENCODE_RESTRICTED;
+        }
+    }
+
+    return 0;
+}
+
+static int ar6000_ioctl_siwpower(struct net_device *dev,
+				 struct iw_request_info *info,
+				 union iwreq_data *wrqu, char *extra)
+{
+	AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+	WMI_POWER_MODE power_mode;
+
+	if (ar->arWlanState == WLAN_DISABLED || ar->arWmiReady == FALSE)
+		return -EIO;
+
+	if (wrqu->power.disabled)
+		power_mode = MAX_PERF_POWER;
+	else
+		power_mode = REC_POWER;
+
+	if (wmi_powermode_cmd(ar->arWmi, power_mode) < 0)
+		return -EIO;
+
+	return 0;
+}
+
+static int ar6000_ioctl_giwpower(struct net_device *dev,
+				 struct iw_request_info *info,
+				 union iwreq_data *wrqu, char *extra)
+{
+	AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+	if (ar->arWlanState == WLAN_DISABLED || ar->arWmiReady == FALSE)
+		return -EIO;
+
+	return wmi_get_power_mode_cmd(ar->arWmi);
+}
+
+#if WIRELESS_EXT >= 18
+/*
+ * SIOCSIWGENIE
+ */
+static int
+ar6000_ioctl_siwgenie(struct net_device *dev,
+              struct iw_request_info *info,
+              struct iw_point *erq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    return 0;
+}
+
+
+/*
+ * SIOCGIWGENIE
+ */
+static int
+ar6000_ioctl_giwgenie(struct net_device *dev,
+              struct iw_request_info *info,
+              struct iw_point *erq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+    erq->length = 0;
+    erq->flags = 0;
+
+    return 0;
+}
+
+/*
+ * SIOCSIWAUTH
+ */
+static int
+ar6000_ioctl_siwauth(struct net_device *dev,
+              struct iw_request_info *info,
+              struct iw_param *data, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    A_BOOL profChanged;
+    A_UINT16 param;
+    A_INT32 ret;
+    A_INT32 value;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    param = data->flags & IW_AUTH_INDEX;
+    value = data->value;
+    profChanged = TRUE;
+    ret = 0;
+
+    switch (param) {
+        case IW_AUTH_WPA_VERSION:
+            if (value & IW_AUTH_WPA_VERSION_DISABLED) {
+                ar->arAuthMode = NONE_AUTH;
+            } else if (value & IW_AUTH_WPA_VERSION_WPA) {
+                    ar->arAuthMode = WPA_AUTH;
+            } else if (value & IW_AUTH_WPA_VERSION_WPA2) {
+                    ar->arAuthMode = WPA2_AUTH;
+            } else {
+                ret = -1;
+                profChanged    = FALSE;
+            }
+            break;
+        case IW_AUTH_CIPHER_PAIRWISE:
+            if (value & IW_AUTH_CIPHER_NONE) {
+                ar->arPairwiseCrypto = NONE_CRYPT;
+                ar->arPairwiseCryptoLen = 0;
+            } else if (value & IW_AUTH_CIPHER_WEP40) {
+                ar->arPairwiseCrypto = WEP_CRYPT;
+                ar->arPairwiseCryptoLen = 5;
+            } else if (value & IW_AUTH_CIPHER_TKIP) {
+                ar->arPairwiseCrypto = TKIP_CRYPT;
+                ar->arPairwiseCryptoLen = 0;
+            } else if (value & IW_AUTH_CIPHER_CCMP) {
+                ar->arPairwiseCrypto = AES_CRYPT;
+                ar->arPairwiseCryptoLen = 0;
+            } else if (value & IW_AUTH_CIPHER_WEP104) {
+                ar->arPairwiseCrypto = WEP_CRYPT;
+                ar->arPairwiseCryptoLen = 13;
+            } else {
+                ret = -1;
+                profChanged    = FALSE;
+            }
+            break;
+        case IW_AUTH_CIPHER_GROUP:
+            if (value & IW_AUTH_CIPHER_NONE) {
+                ar->arGroupCrypto = NONE_CRYPT;
+                ar->arGroupCryptoLen = 0;
+            } else if (value & IW_AUTH_CIPHER_WEP40) {
+                ar->arGroupCrypto = WEP_CRYPT;
+                ar->arGroupCryptoLen = 5;
+            } else if (value & IW_AUTH_CIPHER_TKIP) {
+                ar->arGroupCrypto = TKIP_CRYPT;
+                ar->arGroupCryptoLen = 0;
+            } else if (value & IW_AUTH_CIPHER_CCMP) {
+                ar->arGroupCrypto = AES_CRYPT;
+                ar->arGroupCryptoLen = 0;
+            } else if (value & IW_AUTH_CIPHER_WEP104) {
+                ar->arGroupCrypto = WEP_CRYPT;
+                ar->arGroupCryptoLen = 13;
+            } else {
+                ret = -1;
+                profChanged    = FALSE;
+            }
+            break;
+        case IW_AUTH_KEY_MGMT:
+            if (value & IW_AUTH_KEY_MGMT_PSK) {
+                if (WPA_AUTH == ar->arAuthMode) {
+                    ar->arAuthMode = WPA_PSK_AUTH;
+                } else if (WPA2_AUTH == ar->arAuthMode) {
+                    ar->arAuthMode = WPA2_PSK_AUTH;
+                } else {
+                    ret = -1;
+                }
+            } else if (!(value & IW_AUTH_KEY_MGMT_802_1X)) {
+                ar->arAuthMode = NONE_AUTH;
+            }
+            break;
+        case IW_AUTH_TKIP_COUNTERMEASURES:
+            wmi_set_tkip_countermeasures_cmd(ar->arWmi, value);
+            profChanged    = FALSE;
+            break;
+        case IW_AUTH_DROP_UNENCRYPTED:
+            profChanged    = FALSE;
+            break;
+        case IW_AUTH_80211_AUTH_ALG:
+            if (value & IW_AUTH_ALG_OPEN_SYSTEM) {
+                ar->arDot11AuthMode = OPEN_AUTH;
+            } else if (value & IW_AUTH_ALG_SHARED_KEY) {
+                ar->arDot11AuthMode = SHARED_AUTH;
+            } else if (value & IW_AUTH_ALG_LEAP) {
+                ar->arDot11AuthMode = LEAP_AUTH;
+            } else {
+                ret = -1;
+                profChanged    = FALSE;
+            }
+            break;
+        case IW_AUTH_WPA_ENABLED:
+            if (!value) {
+                ar->arAuthMode = NONE_AUTH;
+            }
+            break;
+        case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+            profChanged    = FALSE;
+            break;
+        case IW_AUTH_ROAMING_CONTROL:
+            profChanged    = FALSE;
+            break;
+        case IW_AUTH_PRIVACY_INVOKED:
+            if (!value) {
+                ar->arPairwiseCrypto = NONE_CRYPT;
+                ar->arPairwiseCryptoLen = 0;
+                ar->arGroupCrypto = NONE_CRYPT;
+                ar->arGroupCryptoLen = 0;
+            }
+            break;
+        default:
+           ret = -1;
+           profChanged    = FALSE;
+           break;
+    }
+
+    if (profChanged == TRUE) {
+        /*
+         * profile has changed.  Erase ssid to signal change
+         */
+        A_MEMZERO(ar->arSsid, sizeof(ar->arSsid));
+    }
+
+    return ret;
+}
+
+
+/*
+ * SIOCGIWAUTH
+ */
+static int
+ar6000_ioctl_giwauth(struct net_device *dev,
+              struct iw_request_info *info,
+              struct iw_param *data, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    A_UINT16 param;
+    A_INT32 ret;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    param = data->flags & IW_AUTH_INDEX;
+    ret = 0;
+    data->value = 0;
+
+
+    switch (param) {
+        case IW_AUTH_WPA_VERSION:
+            if (ar->arAuthMode == NONE_AUTH) {
+                data->value |= IW_AUTH_WPA_VERSION_DISABLED;
+            } else if (ar->arAuthMode == WPA_AUTH) {
+                data->value |= IW_AUTH_WPA_VERSION_WPA;
+            } else if (ar->arAuthMode == WPA2_AUTH) {
+                data->value |= IW_AUTH_WPA_VERSION_WPA2;
+            } else {
+                ret = -1;
+            }
+            break;
+        case IW_AUTH_CIPHER_PAIRWISE:
+            if (ar->arPairwiseCrypto == NONE_CRYPT) {
+                data->value |= IW_AUTH_CIPHER_NONE;
+            } else if (ar->arPairwiseCrypto == WEP_CRYPT) {
+                if (ar->arPairwiseCryptoLen == 13) {
+                    data->value |= IW_AUTH_CIPHER_WEP104;
+                } else {
+                    data->value |= IW_AUTH_CIPHER_WEP104;
+                }
+            } else if (ar->arPairwiseCrypto == TKIP_CRYPT) {
+                data->value |= IW_AUTH_CIPHER_TKIP;
+            } else if (ar->arPairwiseCrypto == AES_CRYPT) {
+                data->value |= IW_AUTH_CIPHER_CCMP;
+            } else {
+                ret = -1;
+            }
+            break;
+        case IW_AUTH_CIPHER_GROUP:
+            if (ar->arGroupCrypto == NONE_CRYPT) {
+                    data->value |= IW_AUTH_CIPHER_NONE;
+            } else if (ar->arGroupCrypto == WEP_CRYPT) {
+                if (ar->arGroupCryptoLen == 13) {
+                    data->value |= IW_AUTH_CIPHER_WEP104;
+                } else {
+                    data->value |= IW_AUTH_CIPHER_WEP104;
+                }
+            } else if (ar->arGroupCrypto == TKIP_CRYPT) {
+                data->value |= IW_AUTH_CIPHER_TKIP;
+            } else if (ar->arGroupCrypto == AES_CRYPT) {
+                data->value |= IW_AUTH_CIPHER_CCMP;
+            } else {
+                ret = -1;
+            }
+            break;
+        case IW_AUTH_KEY_MGMT:
+            if ((ar->arAuthMode == WPA_PSK_AUTH) ||
+                (ar->arAuthMode == WPA2_PSK_AUTH)) {
+                data->value |= IW_AUTH_KEY_MGMT_PSK;
+            } else if ((ar->arAuthMode == WPA_AUTH) ||
+                       (ar->arAuthMode == WPA2_AUTH)) {
+                data->value |= IW_AUTH_KEY_MGMT_802_1X;
+            }
+            break;
+        case IW_AUTH_TKIP_COUNTERMEASURES:
+            // TODO. Save countermeassure enable/disable
+            data->value = 0;
+            break;
+        case IW_AUTH_DROP_UNENCRYPTED:
+            break;
+        case IW_AUTH_80211_AUTH_ALG:
+            if (ar->arDot11AuthMode == OPEN_AUTH) {
+                data->value |= IW_AUTH_ALG_OPEN_SYSTEM;
+            } else if (ar->arDot11AuthMode == SHARED_AUTH) {
+                data->value |= IW_AUTH_ALG_SHARED_KEY;
+            } else if (ar->arDot11AuthMode == LEAP_AUTH) {
+                data->value |= IW_AUTH_ALG_LEAP;
+            } else {
+                ret = -1;
+            }
+            break;
+        case IW_AUTH_WPA_ENABLED:
+            if (ar->arAuthMode == NONE_AUTH) {
+                data->value = 0;
+            } else {
+                data->value = 1;
+            }
+            break;
+        case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+            break;
+        case IW_AUTH_ROAMING_CONTROL:
+            break;
+        case IW_AUTH_PRIVACY_INVOKED:
+            if (ar->arPairwiseCrypto == NONE_CRYPT) {
+                data->value = 0;
+            } else {
+                data->value = 1;
+            }
+            break;
+        default:
+           ret = -1;
+           break;
+    }
+
+    return 0;
+}
+
+/*
+ * SIOCSIWPMKSA
+ */
+static int
+ar6000_ioctl_siwpmksa(struct net_device *dev,
+              struct iw_request_info *info,
+              struct iw_point *data, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    A_INT32 ret;
+    A_STATUS status;
+    struct iw_pmksa *pmksa;
+
+    pmksa = (struct iw_pmksa *)extra;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    ret = 0;
+    status = A_OK;
+
+    switch (pmksa->cmd) {
+        case IW_PMKSA_ADD:
+            status = wmi_setPmkid_cmd(ar->arWmi, pmksa->bssid.sa_data, pmksa->pmkid, TRUE);
+            break;
+        case IW_PMKSA_REMOVE:
+            status = wmi_setPmkid_cmd(ar->arWmi, pmksa->bssid.sa_data, pmksa->pmkid, FALSE);
+            break;
+        case IW_PMKSA_FLUSH:
+            break;
+        default:
+            ret=-1;
+            break;
+    }
+    if (status != A_OK) {
+        ret = -1;
+    }
+
+    return ret;
+}
+
+/*
+ * SIOCSIWENCODEEXT
+ */
+static int
+ar6000_ioctl_siwencodeext(struct net_device *dev,
+              struct iw_request_info *info,
+              struct iw_point *erq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    A_INT32 index;
+    struct iw_encode_ext *ext;
+    KEY_USAGE keyUsage;
+    A_INT32 keyLen;
+    A_UINT8 *keyData;
+    A_UINT8 keyRsc[8];
+    A_STATUS status;
+    CRYPTO_TYPE keyType;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    index = erq->flags & IW_ENCODE_INDEX;
+
+    if (index && (((index - 1) < WMI_MIN_KEY_INDEX) ||
+                  ((index - 1) > WMI_MAX_KEY_INDEX)))
+    {
+        return -EIO;
+    }
+
+    ext = (struct iw_encode_ext *)extra;
+    if (erq->flags & IW_ENCODE_DISABLED) {
+        /*
+         * Encryption disabled
+         */
+        if (index) {
+            /*
+             * If key index was specified then clear the specified key
+             */
+            index--;
+            A_MEMZERO(ar->arWepKeyList[index].arKey,
+                      sizeof(ar->arWepKeyList[index].arKey));
+            ar->arWepKeyList[index].arKeyLen = 0;
+        }
+    } else {
+        /*
+         * Enabling WEP encryption
+         */
+        if (index) {
+            index--;                /* keyindex is off base 1 in iwconfig */
+        }
+
+        keyUsage = 0;
+        keyLen = erq->length - sizeof(struct iw_encode_ext);
+
+        if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+            keyUsage = TX_USAGE;
+            ar->arDefTxKeyIndex = index;
+            // Just setting the key index
+            if (keyLen == 0) {
+                return 0;
+            }
+        }
+
+        if (keyLen <= 0) {
+            return -EIO;
+        }
+
+        /* key follows iw_encode_ext */
+        keyData = (A_UINT8 *)(ext + 1);
+
+        switch (ext->alg) {
+            case IW_ENCODE_ALG_WEP:
+                keyType = WEP_CRYPT;
+                if (!IEEE80211_IS_VALID_WEP_CIPHER_LEN(keyLen)) {
+                    return -EIO;
+                }
+
+                // Check whether it is static wep
+                if (!ar->arConnected) {
+                    A_MEMZERO(ar->arWepKeyList[index].arKey,
+                          sizeof(ar->arWepKeyList[index].arKey));
+                    A_MEMCPY(ar->arWepKeyList[index].arKey, keyData, keyLen);
+                    ar->arWepKeyList[index].arKeyLen = keyLen;
+
+                    return 0;
+                }
+                break;
+            case IW_ENCODE_ALG_TKIP:
+                keyType = TKIP_CRYPT;
+                break;
+            case IW_ENCODE_ALG_CCMP:
+                keyType = AES_CRYPT;
+                break;
+            default:
+                return -EIO;
+        }
+
+        if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
+            keyUsage |= GROUP_USAGE;
+        } else {
+            keyUsage |= PAIRWISE_USAGE;
+        }
+
+        if (ext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) {
+            A_MEMCPY(keyRsc, ext->rx_seq, sizeof(keyRsc));
+        } else {
+            A_MEMZERO(keyRsc, sizeof(keyRsc));
+        }
+
+         status = wmi_addKey_cmd(ar->arWmi, index, keyType, keyUsage,
+                            keyLen, keyRsc,
+                            keyData, KEY_OP_INIT_VAL,
+                            SYNC_BOTH_WMIFLAG);
+         if (status != A_OK) {
+            return -EIO;
+         }
+    }
+
+    return 0;
+}
+
+/*
+ * SIOCGIWENCODEEXT
+ */
+static int
+ar6000_ioctl_giwencodeext(struct net_device *dev,
+              struct iw_request_info *info,
+              struct iw_point *erq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (ar->arPairwiseCrypto == NONE_CRYPT) {
+        erq->length = 0;
+        erq->flags = IW_ENCODE_DISABLED;
+    } else {
+        erq->length = 0;
+    }
+
+    return 0;
+}
+#endif // WIRELESS_EXT >= 18
+
+static int
+ar6000_ioctl_setparam(struct net_device *dev,
+                      struct iw_request_info *info,
+                      void *erq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    int *i = (int *)extra;
+    int param = i[0];
+    int value = i[1];
+    int ret = 0;
+    A_BOOL profChanged = FALSE;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    switch (param) {
+        case IEEE80211_PARAM_WPA:
+            switch (value) {
+                case WPA_MODE_WPA1:
+                    ar->arAuthMode = WPA_AUTH;
+                    profChanged    = TRUE;
+                    break;
+                case WPA_MODE_WPA2:
+                    ar->arAuthMode = WPA2_AUTH;
+                    profChanged    = TRUE;
+                    break;
+                case WPA_MODE_NONE:
+                    ar->arAuthMode = NONE_AUTH;
+                    profChanged    = TRUE;
+                    break;
+                default:
+                    printk("IEEE80211_PARAM_WPA: Unknown value %d\n", value);
+                    break;
+            }
+            break;
+        case IEEE80211_PARAM_AUTHMODE:
+            switch(value) {
+                case IEEE80211_AUTH_WPA_PSK:
+                    if (WPA_AUTH == ar->arAuthMode) {
+                        ar->arAuthMode = WPA_PSK_AUTH;
+                        profChanged    = TRUE;
+                    } else if (WPA2_AUTH == ar->arAuthMode) {
+                        ar->arAuthMode = WPA2_PSK_AUTH;
+                        profChanged    = TRUE;
+                    } else {
+                        AR_DEBUG_PRINTF("Error -  Setting PSK mode when WPA "\
+                                        "param was set to %d\n",
+                                        ar->arAuthMode);
+                        ret = -1;
+                    }
+                    break;
+                case IEEE80211_AUTH_WPA_CCKM:
+                    if (WPA2_AUTH == ar->arAuthMode) {
+                        ar->arAuthMode = WPA2_AUTH_CCKM;
+                    } else {
+                        ar->arAuthMode = WPA_AUTH_CCKM;
+                    }
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case IEEE80211_PARAM_UCASTCIPHER:
+            switch (value) {
+                case IEEE80211_CIPHER_AES_CCM:
+                    ar->arPairwiseCrypto = AES_CRYPT;
+                    profChanged          = TRUE;
+                    break;
+                case IEEE80211_CIPHER_TKIP:
+                    ar->arPairwiseCrypto = TKIP_CRYPT;
+                    profChanged          = TRUE;
+                    break;
+                case IEEE80211_CIPHER_WEP:
+                    ar->arPairwiseCrypto = WEP_CRYPT;
+                    profChanged          = TRUE;
+                    break;
+                case IEEE80211_CIPHER_NONE:
+                    ar->arPairwiseCrypto = NONE_CRYPT;
+                    profChanged          = TRUE;
+                    break;
+            }
+            break;
+        case IEEE80211_PARAM_UCASTKEYLEN:
+            if (!IEEE80211_IS_VALID_WEP_CIPHER_LEN(value)) {
+                ret = -EIO;
+            } else {
+                ar->arPairwiseCryptoLen = value;
+            }
+            break;
+        case IEEE80211_PARAM_MCASTCIPHER:
+            switch (value) {
+                case IEEE80211_CIPHER_AES_CCM:
+                    ar->arGroupCrypto = AES_CRYPT;
+                    profChanged       = TRUE;
+                    break;
+                case IEEE80211_CIPHER_TKIP:
+                    ar->arGroupCrypto = TKIP_CRYPT;
+                    profChanged       = TRUE;
+                    break;
+                case IEEE80211_CIPHER_WEP:
+                    ar->arGroupCrypto = WEP_CRYPT;
+                    profChanged       = TRUE;
+                    break;
+                case IEEE80211_CIPHER_NONE:
+                    ar->arGroupCrypto = NONE_CRYPT;
+                    profChanged       = TRUE;
+                    break;
+            }
+            break;
+        case IEEE80211_PARAM_MCASTKEYLEN:
+            if (!IEEE80211_IS_VALID_WEP_CIPHER_LEN(value)) {
+                ret = -EIO;
+            } else {
+                ar->arGroupCryptoLen = value;
+            }
+            break;
+        case IEEE80211_PARAM_COUNTERMEASURES:
+            if (ar->arWmiReady == FALSE) {
+                return -EIO;
+            }
+            wmi_set_tkip_countermeasures_cmd(ar->arWmi, value);
+            break;
+        default:
+            break;
+    }
+
+    if (profChanged == TRUE) {
+        /*
+         * profile has changed.  Erase ssid to signal change
+         */
+        A_MEMZERO(ar->arSsid, sizeof(ar->arSsid));
+    }
+
+    return ret;
+}
+
+int
+ar6000_ioctl_getparam(struct net_device *dev, struct iw_request_info *info,
+            void *w, char *extra)
+{
+    return -EIO;            /* for now */
+}
+
+int
+ar6000_ioctl_setkey(struct net_device *dev, struct iw_request_info *info,
+             void *w, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    struct ieee80211req_key *ik = (struct ieee80211req_key *)extra;
+    KEY_USAGE keyUsage;
+    A_STATUS status;
+    CRYPTO_TYPE keyType = NONE_CRYPT;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+#ifdef USER_KEYS
+    ar->user_saved_keys.keyOk = FALSE;
+#endif
+
+    if ( 0 == memcmp(ik->ik_macaddr, "\x00\x00\x00\x00\x00\x00",
+                     IEEE80211_ADDR_LEN)) {
+        keyUsage = GROUP_USAGE;
+#ifdef USER_KEYS
+        A_MEMCPY(&ar->user_saved_keys.bcast_ik, ik,
+                 sizeof(struct ieee80211req_key));
+#endif
+    } else {
+        keyUsage = PAIRWISE_USAGE;
+#ifdef USER_KEYS
+        A_MEMCPY(&ar->user_saved_keys.ucast_ik, ik,
+                 sizeof(struct ieee80211req_key));
+#endif
+    }
+
+    switch (ik->ik_type) {
+        case IEEE80211_CIPHER_WEP:
+            keyType = WEP_CRYPT;
+            break;
+        case IEEE80211_CIPHER_TKIP:
+            keyType = TKIP_CRYPT;
+            break;
+        case IEEE80211_CIPHER_AES_CCM:
+            keyType = AES_CRYPT;
+            break;
+        default:
+            break;
+    }
+#ifdef USER_KEYS
+    ar->user_saved_keys.keyType = keyType;
+#endif
+    if (IEEE80211_CIPHER_CCKM_KRK != ik->ik_type) {
+        if (NONE_CRYPT == keyType) {
+            return -EIO;
+        }
+
+        status = wmi_addKey_cmd(ar->arWmi, ik->ik_keyix, keyType, keyUsage,
+                                ik->ik_keylen, (A_UINT8 *)&ik->ik_keyrsc,
+                                ik->ik_keydata, KEY_OP_INIT_VAL,
+                                SYNC_BOTH_WMIFLAG);
+
+        if (status != A_OK) {
+            return -EIO;
+        }
+    } else {
+        status = wmi_add_krk_cmd(ar->arWmi, ik->ik_keydata);
+    }
+
+#ifdef USER_KEYS
+    ar->user_saved_keys.keyOk = TRUE;
+#endif
+
+    return 0;
+}
+
+
+/*
+ * SIOCGIWNAME
+ */
+int
+ar6000_ioctl_giwname(struct net_device *dev,
+           struct iw_request_info *info,
+           char *name, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    switch (ar->arPhyCapability) {
+    case (WMI_11A_CAPABILITY):
+        strncpy(name, "AR6000 802.11a", IFNAMSIZ);
+        break;
+    case (WMI_11G_CAPABILITY):
+        strncpy(name, "AR6000 802.11g", IFNAMSIZ);
+        break;
+    case (WMI_11AG_CAPABILITY):
+        strncpy(name, "AR6000 802.11ag", IFNAMSIZ);
+        break;
+    default:
+        strncpy(name, "AR6000 802.11", IFNAMSIZ);
+        break;
+    }
+
+    return 0;
+}
+
+/*
+ * SIOCSIWFREQ
+ */
+int
+ar6000_ioctl_siwfreq(struct net_device *dev,
+            struct iw_request_info *info,
+            struct iw_freq *freq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    /*
+     * We support limiting the channels via wmiconfig.
+     *
+     * We use this command to configure the channel hint for the connect cmd
+     * so it is possible the target will end up connecting to a different
+     * channel.
+     */
+    if (freq->e > 1) {
+        return -EINVAL;
+    } else if (freq->e == 1) {
+        ar->arChannelHint = freq->m / 100000;
+    } else {
+        ar->arChannelHint = wlan_ieee2freq(freq->m);
+    }
+
+    A_PRINTF("channel hint set to %d\n", ar->arChannelHint);
+    return 0;
+}
+
+/*
+ * SIOCGIWFREQ
+ */
+int
+ar6000_ioctl_giwfreq(struct net_device *dev,
+                struct iw_request_info *info,
+                struct iw_freq *freq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (ar->arConnected != TRUE) {
+        return -EINVAL;
+    }
+
+    freq->m = ar->arBssChannel * 100000;
+    freq->e = 1;
+
+    return 0;
+}
+
+/*
+ * SIOCSIWMODE
+ */
+int
+ar6000_ioctl_siwmode(struct net_device *dev,
+            struct iw_request_info *info,
+            __u32 *mode, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    /*
+     * clear SSID during mode switch in connected state
+     */
+    if(!(ar->arNetworkType == (((*mode) == IW_MODE_INFRA) ? INFRA_NETWORK : ADHOC_NETWORK)) && (ar->arConnected == TRUE) ){
+        A_MEMZERO(ar->arSsid, sizeof(ar->arSsid));
+    }
+
+    switch (*mode) {
+    case IW_MODE_INFRA:
+        ar->arNetworkType = INFRA_NETWORK;
+        break;
+    case IW_MODE_ADHOC:
+        ar->arNetworkType = ADHOC_NETWORK;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+/*
+ * SIOCGIWMODE
+ */
+int
+ar6000_ioctl_giwmode(struct net_device *dev,
+            struct iw_request_info *info,
+            __u32 *mode, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    switch (ar->arNetworkType) {
+    case INFRA_NETWORK:
+        *mode = IW_MODE_INFRA;
+        break;
+    case ADHOC_NETWORK:
+        *mode = IW_MODE_ADHOC;
+        break;
+    default:
+        return -EIO;
+    }
+    return 0;
+}
+
+/*
+ * SIOCSIWSENS
+ */
+int
+ar6000_ioctl_siwsens(struct net_device *dev,
+            struct iw_request_info *info,
+            struct iw_param *sens, char *extra)
+{
+    return 0;
+}
+
+/*
+ * SIOCGIWSENS
+ */
+int
+ar6000_ioctl_giwsens(struct net_device *dev,
+            struct iw_request_info *info,
+            struct iw_param *sens, char *extra)
+{
+    sens->value = 0;
+    sens->fixed = 1;
+
+    return 0;
+}
+
+/*
+ * SIOCGIWRANGE
+ */
+int
+ar6000_ioctl_giwrange(struct net_device *dev,
+             struct iw_request_info *info,
+             struct iw_point *data, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    struct iw_range *range = (struct iw_range *) extra;
+    int i, ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (down_interruptible(&ar->arSem)) {
+        return -ERESTARTSYS;
+    }
+    ar->arNumChannels = -1;
+    A_MEMZERO(ar->arChannelList, sizeof (ar->arChannelList));
+
+    if (wmi_get_channelList_cmd(ar->arWmi) != A_OK) {
+        up(&ar->arSem);
+        return -EIO;
+    }
+
+    wait_event_interruptible_timeout(arEvent, ar->arNumChannels != -1, wmitimeout * HZ);
+
+    if (signal_pending(current)) {
+        up(&ar->arSem);
+        return -EINTR;
+    }
+
+    data->length = sizeof(struct iw_range);
+    A_MEMZERO(range, sizeof(struct iw_range));
+
+    range->txpower_capa = 0;
+
+    range->min_pmp = 1 * 1024;
+    range->max_pmp = 65535 * 1024;
+    range->min_pmt = 1 * 1024;
+    range->max_pmt = 1000 * 1024;
+    range->pmp_flags = IW_POWER_PERIOD;
+    range->pmt_flags = IW_POWER_TIMEOUT;
+    range->pm_capa = 0;
+
+    range->we_version_compiled = WIRELESS_EXT;
+    range->we_version_source = 13;
+
+    range->retry_capa = IW_RETRY_LIMIT;
+    range->retry_flags = IW_RETRY_LIMIT;
+    range->min_retry = 0;
+    range->max_retry = 255;
+
+    range->num_frequency = range->num_channels = ar->arNumChannels;
+    for (i = 0; i < ar->arNumChannels; i++) {
+        range->freq[i].i = wlan_freq2ieee(ar->arChannelList[i]);
+        range->freq[i].m = ar->arChannelList[i] * 100000;
+        range->freq[i].e = 1;
+         /*
+         * Linux supports max of 32 channels, bail out once you
+         * reach the max.
+         */
+        if (i == IW_MAX_FREQUENCIES) {
+            break;
+        }
+    }
+
+    /*
+    * Our quality value is the signal-to-noise ratio in dB.  The maximum
+    * quality is not well-defined, but empirically a value of 63 dB seems
+    * to be about right.
+    */
+    range->max_qual.qual  = 63;
+
+    /*
+     * In order to use dBm measurements, 'level' must be lower
+     * than any possible measurement (see iw_print_stats() in
+     * wireless tools).  It's unclear how this is meant to be
+     * done, but setting zero in these values forces dBm and
+     * the actual numbers are not used.
+     */
+    range->max_qual.level = 0;
+    range->max_qual.noise = 0;
+
+    range->sensitivity = 3;
+
+    range->max_encoding_tokens = 4;
+    /* XXX query driver to find out supported key sizes */
+    range->num_encoding_sizes = 3;
+    range->encoding_size[0] = 5;        /* 40-bit */
+    range->encoding_size[1] = 13;       /* 104-bit */
+    range->encoding_size[2] = 16;       /* 128-bit */
+
+    range->num_bitrates = 0;
+
+    /* estimated maximum TCP throughput values (bps) */
+    range->throughput = 22000000;
+
+    range->min_rts = 0;
+    range->max_rts = 2347;
+    range->min_frag = 256;
+    range->max_frag = 2346;
+
+    range->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |
+        IW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;
+
+    range->scan_capa = IW_SCAN_CAPA_NONE;
+
+    up(&ar->arSem);
+
+    return ret;
+}
+
+
+/*
+ * SIOCSIWAP
+ * This ioctl is used to set the desired bssid for the connect command.
+ */
+int
+ar6000_ioctl_siwap(struct net_device *dev,
+              struct iw_request_info *info,
+              struct sockaddr *ap_addr, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (ap_addr->sa_family != ARPHRD_ETHER) {
+        return -EIO;
+    }
+
+    if (A_MEMCMP(&ap_addr->sa_data, bcast_mac, AR6000_ETH_ADDR_LEN) == 0) {
+        A_MEMZERO(ar->arReqBssid, sizeof(ar->arReqBssid));
+    } else {
+        A_MEMCPY(ar->arReqBssid, &ap_addr->sa_data,  sizeof(ar->arReqBssid));
+    }
+
+    return 0;
+}
+
+/*
+ * SIOCGIWAP
+ */
+int
+ar6000_ioctl_giwap(struct net_device *dev,
+              struct iw_request_info *info,
+              struct sockaddr *ap_addr, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (ar->arConnected != TRUE) {
+        return -EINVAL;
+    }
+
+    A_MEMCPY(&ap_addr->sa_data, ar->arBssid, sizeof(ar->arBssid));
+    ap_addr->sa_family = ARPHRD_ETHER;
+
+    return 0;
+}
+
+/*
+ * SIOCSIWMLME
+ */
+static int ar6000_ioctl_siwmlme(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu,
+				char *extra)
+{
+	AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+	struct iw_mlme *mlme = (struct iw_mlme *)extra;
+	u16 reason;
+	int ret = 0;
+
+	if ((ar->arWmiReady == FALSE) || (ar->arConnected != TRUE))
+		return -EIO;
+
+	reason = cpu_to_le16(mlme->reason_code);
+
+	switch (mlme->cmd) {
+	case IW_MLME_DEAUTH:
+		/* silently ignore */
+		break;
+
+	case IW_MLME_DISASSOC:
+		/* handle this just like 'essid off' */
+		{
+			struct iw_point data;
+			char ssid[1];
+
+			memset(&data, 0, sizeof(data));
+			ssid[0] = '\0';
+
+			ret = ar6000_ioctl_siwessid(dev, info, &data, ssid);
+		}
+		break;
+
+	case IW_MLME_AUTH:
+	case IW_MLME_ASSOC:
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+	return ret;
+}
+
+/*
+ * SIOCGIWAPLIST
+ */
+int
+ar6000_ioctl_iwaplist(struct net_device *dev,
+            struct iw_request_info *info,
+            struct iw_point *data, char *extra)
+{
+    return -EIO;            /* for now */
+}
+
+/*
+ * SIOCSIWSCAN
+ */
+int
+ar6000_ioctl_siwscan(struct net_device *dev,
+                     struct iw_request_info *info,
+                     struct iw_point *data, char *extra)
+{
+#define SIOCSIWSCAN_TIMEOUT     (30*HZ)
+#define ACT_DWELLTIME_DEFAULT   105
+#define HOME_TXDRAIN_TIME       100
+#define SCAN_INT                HOME_TXDRAIN_TIME + ACT_DWELLTIME_DEFAULT
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)dev->priv;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    /*
+     * The AR6001 firmware doesn't seem to deal well with a second scan command
+     * before the first has completed.  The scan still completes, but it takes
+     * perhaps 5 times longer than normal.  To avoid this, save a timestamp when
+     * a start scan command is issued, and avoid issuing a second start scan
+     * command until the first has completed or a timeout period has elapsed.
+     */
+    if (ar->siocsiwscan_timestamp) {
+        if (time_before(jiffies,
+            ar->siocsiwscan_timestamp + SIOCSIWSCAN_TIMEOUT))
+        {
+            return ret;
+        }
+    }
+    ar->siocsiwscan_timestamp = 0;
+
+    if (!ar->arUserBssFilter) {
+        if (wmi_bssfilter_cmd(ar->arWmi, (ar->arConnected ? ALL_BUT_BSS_FILTER : ALL_BSS_FILTER), 0) != A_OK) {
+            return -EIO;
+        }
+    }
+
+    if (ar->arConnected) {
+        if  (wmi_get_stats_cmd(ar->arWmi) != A_OK) {
+            return -EIO;
+        }
+    }
+
+    if (wmi_startscan_cmd(ar->arWmi, WMI_LONG_SCAN, FALSE, FALSE, \
+                          HOME_TXDRAIN_TIME, SCAN_INT, 0, NULL) != A_OK) {
+        ret = -EIO;
+    }
+    ar->siocsiwscan_timestamp = jiffies;
+
+    return ret;
+#undef  ACT_DWELLTIME_DEFAULT
+#undef HOME_TXDRAIN_TIME
+#undef SCAN_INT
+}
+
+
+/*
+ * Units are in db above the noise floor. That means the
+ * rssi values reported in the tx/rx descriptors in the
+ * driver are the SNR expressed in db.
+ *
+ * If you assume that the noise floor is -95, which is an
+ * excellent assumption 99.5 % of the time, then you can
+ * derive the absolute signal level (i.e. -95 + rssi).
+ * There are some other slight factors to take into account
+ * depending on whether the rssi measurement is from 11b,
+ * 11g, or 11a.   These differences are at most 2db and
+ * can be documented.
+ *
+ * NB: various calculations are based on the orinoco/wavelan
+ *     drivers for compatibility
+ */
+static void
+ar6000_set_quality(struct iw_quality *iq, A_INT8 rssi)
+{
+    if (rssi < 0) {
+        iq->qual = 0;
+    } else {
+        iq->qual = rssi;
+    }
+
+    /* NB: max is 94 because noise is hardcoded to 161 */
+    if (iq->qual > 94)
+        iq->qual = 94;
+
+    iq->noise = 161;        /* -95dBm */
+    iq->level = iq->noise + iq->qual;
+    iq->updated = 7;
+}
+
+
+/* Structures to export the Wireless Handlers */
+static const iw_handler ath_handlers[] = {
+    (iw_handler) NULL,                          /* SIOCSIWCOMMIT */
+    (iw_handler) ar6000_ioctl_giwname,          /* SIOCGIWNAME */
+    (iw_handler) NULL,                          /* SIOCSIWNWID */
+    (iw_handler) NULL,                          /* SIOCGIWNWID */
+    (iw_handler) ar6000_ioctl_siwfreq,          /* SIOCSIWFREQ */
+    (iw_handler) ar6000_ioctl_giwfreq,          /* SIOCGIWFREQ */
+    (iw_handler) ar6000_ioctl_siwmode,          /* SIOCSIWMODE */
+    (iw_handler) ar6000_ioctl_giwmode,          /* SIOCGIWMODE */
+    (iw_handler) ar6000_ioctl_siwsens,          /* SIOCSIWSENS */
+    (iw_handler) ar6000_ioctl_giwsens,          /* SIOCGIWSENS */
+    (iw_handler) NULL /* not _used */,          /* SIOCSIWRANGE */
+    (iw_handler) ar6000_ioctl_giwrange,         /* SIOCGIWRANGE */
+    (iw_handler) NULL /* not used */,           /* SIOCSIWPRIV */
+    (iw_handler) NULL /* kernel code */,        /* SIOCGIWPRIV */
+    (iw_handler) NULL /* not used */,           /* SIOCSIWSTATS */
+    (iw_handler) NULL /* kernel code */,        /* SIOCGIWSTATS */
+    (iw_handler) NULL,                          /* SIOCSIWSPY */
+    (iw_handler) NULL,                          /* SIOCGIWSPY */
+    (iw_handler) NULL,                          /* SIOCSIWTHRSPY */
+    (iw_handler) NULL,                          /* SIOCGIWTHRSPY */
+    (iw_handler) ar6000_ioctl_siwap,            /* SIOCSIWAP */
+    (iw_handler) ar6000_ioctl_giwap,            /* SIOCGIWAP */
+    (iw_handler) ar6000_ioctl_siwmlme,          /* SIOCSIWMLME */
+    (iw_handler) ar6000_ioctl_iwaplist,         /* SIOCGIWAPLIST */
+    (iw_handler) ar6000_ioctl_siwscan,          /* SIOCSIWSCAN */
+    (iw_handler) ar6000_ioctl_giwscan,          /* SIOCGIWSCAN */
+    (iw_handler) ar6000_ioctl_siwessid,         /* SIOCSIWESSID */
+    (iw_handler) ar6000_ioctl_giwessid,         /* SIOCGIWESSID */
+    (iw_handler) NULL,                          /* SIOCSIWNICKN */
+    (iw_handler) NULL,                          /* SIOCGIWNICKN */
+    (iw_handler) NULL,                          /* -- hole -- */
+    (iw_handler) NULL,                          /* -- hole -- */
+    (iw_handler) ar6000_ioctl_siwrate,          /* SIOCSIWRATE */
+    (iw_handler) ar6000_ioctl_giwrate,          /* SIOCGIWRATE */
+    (iw_handler) NULL,           /* SIOCSIWRTS */
+    (iw_handler) NULL,           /* SIOCGIWRTS */
+    (iw_handler) NULL,          /* SIOCSIWFRAG */
+    (iw_handler) NULL,          /* SIOCGIWFRAG */
+    (iw_handler) ar6000_ioctl_siwtxpow,         /* SIOCSIWTXPOW */
+    (iw_handler) ar6000_ioctl_giwtxpow,         /* SIOCGIWTXPOW */
+    (iw_handler) ar6000_ioctl_siwretry,         /* SIOCSIWRETRY */
+    (iw_handler) ar6000_ioctl_giwretry,         /* SIOCGIWRETRY */
+    (iw_handler) ar6000_ioctl_siwencode,        /* SIOCSIWENCODE */
+    (iw_handler) ar6000_ioctl_giwencode,        /* SIOCGIWENCODE */
+    (iw_handler) ar6000_ioctl_siwpower,         /* SIOCSIWPOWER */
+    (iw_handler) ar6000_ioctl_giwpower,         /* SIOCGIWPOWER */
+#if WIRELESS_EXT >= 18
+    (iw_handler) NULL,                          /* -- hole -- */
+    (iw_handler) NULL,                          /* -- hole -- */
+    (iw_handler) ar6000_ioctl_siwgenie,         /* SIOCSIWGENIE */
+    (iw_handler) ar6000_ioctl_giwgenie,         /* SIOCGIWGENIE */
+    (iw_handler) ar6000_ioctl_siwauth,          /* SIOCSIWAUTH */
+    (iw_handler) ar6000_ioctl_giwauth,          /* SIOCGIWAUTH */
+    (iw_handler) ar6000_ioctl_siwencodeext,     /* SIOCSIWENCODEEXT */
+    (iw_handler) ar6000_ioctl_giwencodeext,     /* SIOCGIWENCODEEXT */
+    (iw_handler) ar6000_ioctl_siwpmksa,         /* SIOCSIWPMKSA */
+#endif // WIRELESS_EXT >= 18
+};
+
+static const iw_handler ath_priv_handlers[] = {
+    (iw_handler) ar6000_ioctl_setparam,         /* SIOCWFIRSTPRIV+0 */
+    (iw_handler) ar6000_ioctl_getparam,         /* SIOCWFIRSTPRIV+1 */
+    (iw_handler) ar6000_ioctl_setkey,           /* SIOCWFIRSTPRIV+2 */
+    (iw_handler) ar6000_ioctl_setwmmparams,     /* SIOCWFIRSTPRIV+3 */
+    (iw_handler) ar6000_ioctl_delkey,           /* SIOCWFIRSTPRIV+4 */
+    (iw_handler) ar6000_ioctl_getwmmparams,     /* SIOCWFIRSTPRIV+5 */
+    (iw_handler) ar6000_ioctl_setoptie,         /* SIOCWFIRSTPRIV+6 */
+    (iw_handler) ar6000_ioctl_setmlme,          /* SIOCWFIRSTPRIV+7 */
+    (iw_handler) ar6000_ioctl_addpmkid,         /* SIOCWFIRSTPRIV+8 */
+};
+
+#define IW_PRIV_TYPE_KEY \
+    (IW_PRIV_TYPE_BYTE | sizeof(struct ieee80211req_key))
+#define IW_PRIV_TYPE_DELKEY \
+    (IW_PRIV_TYPE_BYTE | sizeof(struct ieee80211req_del_key))
+#define IW_PRIV_TYPE_MLME \
+    (IW_PRIV_TYPE_BYTE | sizeof(struct ieee80211req_mlme))
+#define IW_PRIV_TYPE_ADDPMKID \
+    (IW_PRIV_TYPE_BYTE | sizeof(struct ieee80211req_addpmkid))
+
+static const struct iw_priv_args ar6000_priv_args[] = {
+    { IEEE80211_IOCTL_SETKEY,
+      IW_PRIV_TYPE_KEY | IW_PRIV_SIZE_FIXED, 0,       "setkey"},
+    { IEEE80211_IOCTL_DELKEY,
+      IW_PRIV_TYPE_DELKEY | IW_PRIV_SIZE_FIXED, 0,    "delkey"},
+    { IEEE80211_IOCTL_SETPARAM,
+      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0,   "setparam"},
+    { IEEE80211_IOCTL_GETPARAM,
+      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,      "getparam"},
+    { IEEE80211_IOCTL_SETWMMPARAMS,
+      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 4, 0,   "setwmmparams"},
+    { IEEE80211_IOCTL_GETWMMPARAMS,
+      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 3,
+      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,      "getwmmparams"},
+    { IEEE80211_IOCTL_SETOPTIE,
+      IW_PRIV_TYPE_BYTE, 0,       "setie"},
+    { IEEE80211_IOCTL_SETMLME,
+      IW_PRIV_TYPE_MLME, 0,       "setmlme"},
+    { IEEE80211_IOCTL_ADDPMKID,
+      IW_PRIV_TYPE_ADDPMKID | IW_PRIV_SIZE_FIXED, 0,  "addpmkid"},
+};
+
+void ar6000_ioctl_iwsetup(struct iw_handler_def *def)
+{
+    def->private_args = (struct iw_priv_args *)ar6000_priv_args;
+    def->num_private_args = ARRAY_SIZE(ar6000_priv_args);
+}
+
+struct iw_handler_def ath_iw_handler_def = {
+#define N(a) (sizeof (a) / sizeof (a[0]))
+    .standard         = (iw_handler *)ath_handlers,
+    .num_standard     = N(ath_handlers),
+    .private          = (iw_handler *)ath_priv_handlers,
+    .num_private      = N(ath_priv_handlers),
+#undef N
+};
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/bmi/Makefile
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/bmi/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_SDIO_AR6000_WLAN)                  += bmi.o
+
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/bmi/bmi.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/bmi/bmi.c
@@ -0,0 +1,772 @@
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "../include/hif.h"
+#include "../include/bmi.h"
+#include "../include/htc_api.h"
+#include "bmi_internal.h"
+
+/*
+Although we had envisioned BMI to run on top of HTC, this is not what the
+final implementation boiled down to on chip. Its a part of BSP and does
+not use the HTC protocol either. On the host side, however, we were still
+living with the original idea. I think the time has come to accept the truth
+and separate it from HTC which has been carrying BMI's burden all this while.
+It shall make HTC state machine relatively simpler
+*/
+
+/* APIs visible to the driver */
+void
+BMIInit(void)
+{
+    bmiDone = FALSE;
+}
+
+A_STATUS
+BMIDone(HIF_DEVICE *device)
+{
+    A_STATUS status;
+    A_UINT32 cid;
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF (ATH_DEBUG_BMI, ("BMIDone skipped\n"));
+        return A_OK;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Done: Enter (device: 0x%p)\n", device));
+    bmiDone = TRUE;
+    cid = BMI_DONE;
+
+    status = bmiBufferSend(device, (A_UCHAR *)&cid, sizeof(cid));
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+        return A_ERROR;
+    }
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Done: Exit\n"));
+
+    return A_OK;
+}
+
+A_STATUS
+BMIGetTargetInfo(HIF_DEVICE *device, struct bmi_target_info *targ_info)
+{
+    A_STATUS status;
+    A_UINT32 cid;
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Get Target Info: Enter (device: 0x%p)\n", device));
+    cid = BMI_GET_TARGET_INFO;
+
+    status = bmiBufferSend(device, (A_UCHAR *)&cid, sizeof(cid));
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+        return A_ERROR;
+    }
+
+    status = bmiBufferReceive(device, (A_UCHAR *)&targ_info->target_ver,
+                                                sizeof(targ_info->target_ver));
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read Target Version from the device\n"));
+        return A_ERROR;
+    }
+
+    if (targ_info->target_ver == TARGET_VERSION_SENTINAL) {
+        /* Determine how many bytes are in the Target's targ_info */
+        status = bmiBufferReceive(device, (A_UCHAR *)&targ_info->target_info_byte_count,
+                                            sizeof(targ_info->target_info_byte_count));
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read Target Info Byte Count from the device\n"));
+            return A_ERROR;
+        }
+
+        /*
+         * The Target's targ_info doesn't match the Host's targ_info.
+         * We need to do some backwards compatibility work to make this OK.
+         */
+        A_ASSERT(targ_info->target_info_byte_count == sizeof(*targ_info));
+
+        /* Read the remainder of the targ_info */
+        status = bmiBufferReceive(device,
+                        ((A_UCHAR *)targ_info)+sizeof(targ_info->target_info_byte_count),
+                        sizeof(*targ_info)-sizeof(targ_info->target_info_byte_count));
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read Target Info (%d bytes) from the device\n",
+                        					targ_info->target_info_byte_count));
+            return A_ERROR;
+        }
+    } else {
+        /*
+         * Target must be an AR6001 whose firmware does not
+         * support BMI_GET_TARGET_INFO.  Construct the data
+         * that it would have sent.
+         */
+        targ_info->target_info_byte_count=sizeof(*targ_info);
+        targ_info->target_type=TARGET_TYPE_AR6001;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Get Target Info: Exit (ver: 0x%x type: 0x%x)\n",
+        							targ_info->target_ver, targ_info->target_type));
+
+    return A_OK;
+}
+
+A_STATUS
+BMIReadMemory(HIF_DEVICE *device,
+              A_UINT32 address,
+              A_UCHAR *buffer,
+              A_UINT32 length)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    A_UINT32 remaining, rxlen;
+    static A_UCHAR data[BMI_DATASZ_MAX + sizeof(cid) + sizeof(address) + sizeof(length)];
+    memset (&data, 0, BMI_DATASZ_MAX + sizeof(cid) + sizeof(address) + sizeof(length));
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+       			("BMI Read Memory: Enter (device: 0x%p, address: 0x%x, length: %d)\n",
+        			device, address, length));
+
+    cid = BMI_READ_MEMORY;
+
+    remaining = length;
+
+    while (remaining)
+    {
+        rxlen = (remaining < BMI_DATASZ_MAX) ? remaining : BMI_DATASZ_MAX;
+        offset = 0;
+        A_MEMCPY(&data[offset], &cid, sizeof(cid));
+        offset += sizeof(cid);
+        A_MEMCPY(&data[offset], &address, sizeof(address));
+        offset += sizeof(address);
+        A_MEMCPY(&data[offset], &rxlen, sizeof(rxlen));
+        offset += sizeof(length);
+
+        status = bmiBufferSend(device, data, offset);
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+            return A_ERROR;
+        }
+        status = bmiBufferReceive(device, data, rxlen);
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read from the device\n"));
+            return A_ERROR;
+        }
+        A_MEMCPY(&buffer[length - remaining], data, rxlen);
+        remaining -= rxlen; address += rxlen;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Read Memory: Exit\n"));
+    return A_OK;
+}
+
+A_STATUS
+BMIWriteMemory(HIF_DEVICE *device,
+               A_UINT32 address,
+               const A_UCHAR *buffer,
+               A_UINT32 length)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    A_UINT32 remaining, txlen;
+    const A_UINT32 header = sizeof(cid) + sizeof(address) + sizeof(length);
+    static A_UCHAR data[BMI_DATASZ_MAX + sizeof(cid) + sizeof(address) + sizeof(length)];
+	memset (&data, 0, BMI_DATASZ_MAX+header);
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+         ("BMI Write Memory: Enter (device: 0x%p, address: 0x%x, length: %d)\n",
+         device, address, length));
+
+    cid = BMI_WRITE_MEMORY;
+
+    remaining = length;
+    while (remaining)
+    {
+        txlen = (remaining < (BMI_DATASZ_MAX - header)) ?
+                                       remaining : (BMI_DATASZ_MAX - header);
+        offset = 0;
+        A_MEMCPY(&data[offset], &cid, sizeof(cid));
+        offset += sizeof(cid);
+        A_MEMCPY(&data[offset], &address, sizeof(address));
+        offset += sizeof(address);
+        A_MEMCPY(&data[offset], &txlen, sizeof(txlen));
+        offset += sizeof(txlen);
+        A_MEMCPY(&data[offset], &buffer[length - remaining], txlen);
+        offset += txlen;
+        status = bmiBufferSend(device, data, offset);
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+            return A_ERROR;
+        }
+        remaining -= txlen; address += txlen;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Write Memory: Exit\n"));
+
+    return A_OK;
+}
+
+A_STATUS
+BMIExecute(HIF_DEVICE *device,
+           A_UINT32 address,
+           A_UINT32 *param)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    static A_UCHAR data[sizeof(cid) + sizeof(address) + sizeof(*param)];
+    memset (&data, 0, sizeof(cid) + sizeof(address) + sizeof(*param));
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+       ("BMI Execute: Enter (device: 0x%p, address: 0x%x, param: %d)\n",
+        device, address, *param));
+
+    cid = BMI_EXECUTE;
+
+    offset = 0;
+    A_MEMCPY(&data[offset], &cid, sizeof(cid));
+    offset += sizeof(cid);
+    A_MEMCPY(&data[offset], &address, sizeof(address));
+    offset += sizeof(address);
+    A_MEMCPY(&data[offset], param, sizeof(*param));
+    offset += sizeof(*param);
+    status = bmiBufferSend(device, data, offset);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+        return A_ERROR;
+    }
+
+    status = bmiBufferReceive(device, data, sizeof(*param));
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read from the device\n"));
+        return A_ERROR;
+    }
+
+    A_MEMCPY(param, data, sizeof(*param));
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Execute: Exit (param: %d)\n", *param));
+    return A_OK;
+}
+
+A_STATUS
+BMISetAppStart(HIF_DEVICE *device,
+               A_UINT32 address)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    static A_UCHAR data[sizeof(cid) + sizeof(address)];
+    memset (&data, 0, sizeof(cid) + sizeof(address));
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+       ("BMI Set App Start: Enter (device: 0x%p, address: 0x%x)\n",
+        device, address));
+
+    cid = BMI_SET_APP_START;
+
+    offset = 0;
+    A_MEMCPY(&data[offset], &cid, sizeof(cid));
+    offset += sizeof(cid);
+    A_MEMCPY(&data[offset], &address, sizeof(address));
+    offset += sizeof(address);
+    status = bmiBufferSend(device, data, offset);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Set App Start: Exit\n"));
+    return A_OK;
+}
+
+A_STATUS
+BMIReadSOCRegister(HIF_DEVICE *device,
+                   A_UINT32 address,
+                   A_UINT32 *param)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    static A_UCHAR data[sizeof(cid) + sizeof(address)];
+    memset (&data, 0, sizeof(cid) + sizeof(address));
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+       ("BMI Read SOC Register: Enter (device: 0x%p, address: 0x%x)\n",
+       device, address));
+
+    cid = BMI_READ_SOC_REGISTER;
+
+    offset = 0;
+    A_MEMCPY(&data[offset], &cid, sizeof(cid));
+    offset += sizeof(cid);
+    A_MEMCPY(&data[offset], &address, sizeof(address));
+    offset += sizeof(address);
+
+    status = bmiBufferSend(device, data, offset);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+        return A_ERROR;
+    }
+
+    status = bmiBufferReceive(device, data, sizeof(*param));
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read from the device\n"));
+        return A_ERROR;
+    }
+    A_MEMCPY(param, data, sizeof(*param));
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Read SOC Register: Exit (value: %d)\n", *param));
+    return A_OK;
+}
+
+A_STATUS
+BMIWriteSOCRegister(HIF_DEVICE *device,
+                    A_UINT32 address,
+                    A_UINT32 param)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    static A_UCHAR data[sizeof(cid) + sizeof(address) + sizeof(param)];
+
+    memset (&data, 0, sizeof(cid) + sizeof(address) + sizeof(param));
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+     ("BMI Write SOC Register: Enter (device: 0x%p, address: 0x%x, param: %d)\n",
+     device, address, param));
+
+    cid = BMI_WRITE_SOC_REGISTER;
+
+    offset = 0;
+    A_MEMCPY(&data[offset], &cid, sizeof(cid));
+    offset += sizeof(cid);
+    A_MEMCPY(&data[offset], &address, sizeof(address));
+    offset += sizeof(address);
+    A_MEMCPY(&data[offset], &param, sizeof(param));
+    offset += sizeof(param);
+    status = bmiBufferSend(device, data, offset);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Read SOC Register: Exit\n"));
+    return A_OK;
+}
+
+A_STATUS
+BMIrompatchInstall(HIF_DEVICE *device,
+                   A_UINT32 ROM_addr,
+                   A_UINT32 RAM_addr,
+                   A_UINT32 nbytes,
+                   A_UINT32 do_activate,
+                   A_UINT32 *rompatch_id)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    static A_UCHAR data[sizeof(cid) + sizeof(ROM_addr) + sizeof(RAM_addr) +
+                                sizeof(nbytes) + sizeof(do_activate)];
+
+	memset (&data, 0, sizeof(cid) + sizeof(ROM_addr) + sizeof(RAM_addr) +
+                      sizeof(nbytes) + sizeof(do_activate));
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+         ("BMI rompatch Install: Enter (device: 0x%p, ROMaddr: 0x%x, RAMaddr: 0x%x length: %d activate: %d)\n",
+         device, ROM_addr, RAM_addr, nbytes, do_activate));
+
+    cid = BMI_ROMPATCH_INSTALL;
+
+    offset = 0;
+    A_MEMCPY(&data[offset], &cid, sizeof(cid));
+    offset += sizeof(cid);
+    A_MEMCPY(&data[offset], &ROM_addr, sizeof(ROM_addr));
+    offset += sizeof(ROM_addr);
+    A_MEMCPY(&data[offset], &RAM_addr, sizeof(RAM_addr));
+    offset += sizeof(RAM_addr);
+    A_MEMCPY(&data[offset], &nbytes, sizeof(nbytes));
+    offset += sizeof(nbytes);
+    A_MEMCPY(&data[offset], &do_activate, sizeof(do_activate));
+    offset += sizeof(do_activate);
+    status = bmiBufferSend(device, data, offset);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+        return A_ERROR;
+    }
+
+    status = bmiBufferReceive(device, (A_UCHAR *)rompatch_id, sizeof(*rompatch_id));
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read from the device\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI rompatch Install: (rompatch_id=%d)\n", *rompatch_id));
+    return A_OK;
+}
+
+A_STATUS
+BMIrompatchUninstall(HIF_DEVICE *device,
+                     A_UINT32 rompatch_id)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    static A_UCHAR data[sizeof(cid) + sizeof(rompatch_id)];
+    memset (&data, 0, sizeof(cid) + sizeof(rompatch_id));
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+         ("BMI rompatch Uninstall: Enter (device: 0x%p, rompatch_id: %d)\n",
+         								 device, rompatch_id));
+
+    cid = BMI_ROMPATCH_UNINSTALL;
+
+    offset = 0;
+    A_MEMCPY(&data[offset], &cid, sizeof(cid));
+    offset += sizeof(cid);
+    A_MEMCPY(&data[offset], &rompatch_id, sizeof(rompatch_id));
+    offset += sizeof(rompatch_id);
+    status = bmiBufferSend(device, data, offset);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI rompatch UNinstall: (rompatch_id=0x%x)\n", rompatch_id));
+    return A_OK;
+}
+
+static A_STATUS
+_BMIrompatchChangeActivation(HIF_DEVICE *device,
+                             A_UINT32 rompatch_count,
+                             A_UINT32 *rompatch_list,
+                             A_UINT32 do_activate)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    static A_UCHAR data[BMI_DATASZ_MAX + sizeof(cid) + sizeof(rompatch_count)];
+    A_UINT32 length;
+
+	memset (&data, 0, BMI_DATASZ_MAX + sizeof(cid) + sizeof(rompatch_count));
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+         ("BMI Change rompatch Activation: Enter (device: 0x%p, count: %d)\n",
+           device, rompatch_count));
+
+    cid = do_activate ? BMI_ROMPATCH_ACTIVATE : BMI_ROMPATCH_DEACTIVATE;
+
+    offset = 0;
+    A_MEMCPY(&data[offset], &cid, sizeof(cid));
+    offset += sizeof(cid);
+    A_MEMCPY(&data[offset], &rompatch_count, sizeof(rompatch_count));
+    offset += sizeof(rompatch_count);
+    length = rompatch_count * sizeof(*rompatch_list);
+    A_MEMCPY(&data[offset], rompatch_list, length);
+    offset += length;
+    status = bmiBufferSend(device, data, offset);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Change rompatch Activation: Exit\n"));
+
+    return A_OK;
+}
+
+A_STATUS
+BMIrompatchActivate(HIF_DEVICE *device,
+                    A_UINT32 rompatch_count,
+                    A_UINT32 *rompatch_list)
+{
+    return _BMIrompatchChangeActivation(device, rompatch_count, rompatch_list, 1);
+}
+
+A_STATUS
+BMIrompatchDeactivate(HIF_DEVICE *device,
+                      A_UINT32 rompatch_count,
+                      A_UINT32 *rompatch_list)
+{
+    return _BMIrompatchChangeActivation(device, rompatch_count, rompatch_list, 0);
+}
+
+A_STATUS
+BMILZData(HIF_DEVICE *device,
+          A_UCHAR *buffer,
+          A_UINT32 length)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    A_UINT32 remaining, txlen;
+    const A_UINT32 header = sizeof(cid) + sizeof(length);
+    static A_UCHAR data[BMI_DATASZ_MAX + sizeof(cid) + sizeof(length)];
+
+    memset (&data, 0, BMI_DATASZ_MAX+header);
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+         ("BMI Send LZ Data: Enter (device: 0x%p, length: %d)\n",
+         device, length));
+
+    cid = BMI_LZ_DATA;
+
+    remaining = length;
+    while (remaining)
+    {
+        txlen = (remaining < (BMI_DATASZ_MAX - header)) ?
+                                       remaining : (BMI_DATASZ_MAX - header);
+        offset = 0;
+        A_MEMCPY(&data[offset], &cid, sizeof(cid));
+        offset += sizeof(cid);
+        A_MEMCPY(&data[offset], &txlen, sizeof(txlen));
+        offset += sizeof(txlen);
+        A_MEMCPY(&data[offset], &buffer[length - remaining], txlen);
+        offset += txlen;
+        status = bmiBufferSend(device, data, offset);
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+            return A_ERROR;
+        }
+        remaining -= txlen;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI LZ Data: Exit\n"));
+
+    return A_OK;
+}
+
+A_STATUS
+BMILZStreamStart(HIF_DEVICE *device,
+                 A_UINT32 address)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    static A_UCHAR data[sizeof(cid) + sizeof(address)];
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+         ("BMI LZ Stream Start: Enter (device: 0x%p, address: 0x%x)\n",
+         device, address));
+
+    cid = BMI_LZ_STREAM_START;
+    offset = 0;
+    A_MEMCPY(&data[offset], &cid, sizeof(cid));
+    offset += sizeof(cid);
+    A_MEMCPY(&data[offset], &address, sizeof(address));
+    offset += sizeof(address);
+    status = bmiBufferSend(device, data, offset);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to Start LZ Stream to the device\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI LZ Stream Start: Exit\n"));
+
+    return A_OK;
+}
+
+/* BMI Access routines */
+A_STATUS
+bmiBufferSend(HIF_DEVICE *device,
+              A_UCHAR *buffer,
+              A_UINT32 length)
+{
+    A_STATUS status;
+    A_UINT32 timeout;
+    A_UINT32 address;
+    static A_UINT32 cmdCredits;
+    A_UINT32 mboxAddress[HTC_MAILBOX_NUM_MAX];
+
+    HIFConfigureDevice(device, HIF_DEVICE_GET_MBOX_ADDR,
+                       &mboxAddress[0], sizeof(mboxAddress));
+
+    cmdCredits = 0;
+    timeout = BMI_COMMUNICATION_TIMEOUT;
+
+    while(timeout-- && !cmdCredits) {
+        /* Read the counter register to get the command credits */
+        address = COUNT_DEC_ADDRESS + (HTC_MAILBOX_NUM_MAX + ENDPOINT1) * 4;
+        /* hit the credit counter with a 4-byte access, the first byte read will hit the counter and cause
+         * a decrement, while the remaining 3 bytes has no effect.  The rationale behind this is to
+         * make all HIF accesses 4-byte aligned */
+        status = HIFReadWrite(device, address, (A_UINT8 *)&cmdCredits, 4,
+            HIF_RD_SYNC_BYTE_INC, NULL);
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to decrement the command credit count register\n"));
+            return A_ERROR;
+        }
+        /* the counter is only 8=bits, ignore anything in the upper 3 bytes */
+        cmdCredits &= 0xFF;
+    }
+
+    if (cmdCredits) {
+        address = mboxAddress[ENDPOINT1];
+        status = HIFReadWrite(device, address, buffer, length,
+            HIF_WR_SYNC_BYTE_INC, NULL);
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to send the BMI data to the device\n"));
+            return A_ERROR;
+        }
+    } else {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("BMI Communication timeout\n"));
+        return A_ERROR;
+    }
+
+    return status;
+}
+
+A_STATUS
+bmiBufferReceive(HIF_DEVICE *device,
+                 A_UCHAR *buffer,
+                 A_UINT32 length)
+{
+    A_STATUS status;
+    A_UINT32 address;
+    A_UINT32 mboxAddress[HTC_MAILBOX_NUM_MAX];
+
+    HIFConfigureDevice(device, HIF_DEVICE_GET_MBOX_ADDR,
+                       &mboxAddress[0], sizeof(mboxAddress));
+
+#define AVOID_BMI_READ_TIMEOUTS 0
+#if AVOID_BMI_READ_TIMEOUTS
+    /*
+     * During normal bootups, small reads may be required.
+     * Rather than issue an HIF Read and then wait as the Target adds
+     * successive bytes to the FIFO, we wait here until the Target
+     * has finished the entire response and has issued the next
+     * BMI Command Credit.  At that point we read the full response
+     * and continue.  This allows us to cleanly timeout on an unexpected
+     * Target failure rather than risk problems at the HIF level.  In
+     * particular, this avoids SDIO timeouts.  And on an interconnect
+     * such as Compact Flash that does not provide any indication on
+     * data timeout, it avoids a potential hang.
+     *
+     * This synchronization doesn't work for reads larger than the
+     * size of the MBOX FIFO (128B), because the Target is unable
+     * to push the 129th byte of data until AFTER an HIF Read is
+     * posted. So for large reads we proceed to post the HIF Read
+     * without this safety net.  Fortunately, large BMI reads do not
+     * occur in practice -- they're supported for debug/development.
+     *
+     * This credit check is also useless when firmware chooses to
+     * allow multiple outstanding BMI Command Credits.  To restrict
+     * the Target to one BMI Command Credit, see HI_OPTION_BMI_CRED_LIMIT.
+     *
+     * For a more conservative Host implementation (which would be
+     * safer for a Compact Flash interconnect):
+     *   Set AVOID_BMI_READ_TIMEOUTS (above) to 1 and
+     *   Set HI_OPTION_BMI_CRED_LIMIT and
+     *   reduce BMI_DATASZ_MAX to 32 or 64
+     */
+    if (length < 128) { /* check against MBOX FIFO size */
+        A_UINT32 timeout;
+        static A_UINT32 cmdCredits;
+    cmdCredits = 0;
+    timeout = BMI_COMMUNICATION_TIMEOUT;
+    while(timeout-- && !cmdCredits) {
+        /* Read the counter register to get the command credits */
+        address = COUNT_ADDRESS + (HTC_MAILBOX_NUM_MAX + ENDPOINT1) * 1;
+        /* read the counter using a 4-byte read.  Since the counter is NOT auto-decrementing,
+         * we can read this counter multiple times using a non-incrementing address mode.
+         * The rationale here is to make all HIF accesses a multiple of 4 bytes */
+        status = HIFReadWrite(device, address, (A_UINT8 *)&cmdCredits, sizeof(cmdCredits),
+            HIF_RD_SYNC_BYTE_FIX, NULL);
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read the command credit count register\n"));
+            return A_ERROR;
+        }
+            /* we did a 4-byte read to the same count register so mask off upper bytes */
+        cmdCredits &= 0xFF;
+    }
+
+        if (!cmdCredits) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Communication timeout\n"));
+            return A_ERROR;
+        }
+    }
+#endif
+
+        address = mboxAddress[ENDPOINT1];
+    status = HIFReadWrite(device, address, buffer, length, HIF_RD_SYNC_BYTE_INC, NULL);
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read the BMI data from the device\n"));
+            return A_ERROR;
+        }
+
+    return A_OK;
+}
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/bmi/bmi_internal.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/bmi/bmi_internal.h
@@ -0,0 +1,45 @@
+#ifndef BMI_INTERNAL_H
+#define BMI_INTERNAL_H
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "../include/config.h"
+#include "../include/athdefs.h"
+#include "../include/athtypes.h"
+#include "../include/osapi.h"
+#include "../include/debug.h"
+#include "../include/mbox_host_reg.h"
+#include "../include/bmi_msg.h"
+
+#define BMI_COMMUNICATION_TIMEOUT       100000
+
+/* ------ Global Variable Declarations ------- */
+A_BOOL bmiDone;
+
+A_STATUS
+bmiBufferSend(HIF_DEVICE *device,
+              A_UCHAR *buffer,
+              A_UINT32 length);
+
+A_STATUS
+bmiBufferReceive(HIF_DEVICE *device,
+                 A_UCHAR *buffer,
+                 A_UINT32 length);
+
+#endif
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/hif/Makefile
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/hif/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_SDIO_AR6000_WLAN)  += hif.o
+
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/hif/hif.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/hif/hif.c
@@ -0,0 +1,809 @@
+/*
+ * @file: hif.c
+ *
+ * @abstract: HIF layer reference implementation for Atheros SDIO stack
+ *
+ * @notice: Copyright (c) 2004-2006 Atheros Communications Inc.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "hif_internal.h"
+
+/* ------ Static Variables ------ */
+
+/* ------ Global Variable Declarations ------- */
+SD_PNP_INFO Ids[] = {
+    {
+        .SDIO_ManufacturerID = MANUFACTURER_ID_AR6001_BASE | 0xB,
+        .SDIO_ManufacturerCode = MANUFACTURER_CODE,
+        .SDIO_FunctionClass = FUNCTION_CLASS,
+        .SDIO_FunctionNo = 1
+    },
+    {
+        .SDIO_ManufacturerID = MANUFACTURER_ID_AR6001_BASE | 0xA,
+        .SDIO_ManufacturerCode = MANUFACTURER_CODE,
+        .SDIO_FunctionClass = FUNCTION_CLASS,
+        .SDIO_FunctionNo = 1
+    },
+    {
+        .SDIO_ManufacturerID = MANUFACTURER_ID_AR6001_BASE | 0x9,
+        .SDIO_ManufacturerCode = MANUFACTURER_CODE,
+        .SDIO_FunctionClass = FUNCTION_CLASS,
+        .SDIO_FunctionNo = 1
+    },
+    {
+        .SDIO_ManufacturerID = MANUFACTURER_ID_AR6001_BASE | 0x8,
+        .SDIO_ManufacturerCode = MANUFACTURER_CODE,
+        .SDIO_FunctionClass = FUNCTION_CLASS,
+        .SDIO_FunctionNo = 1
+    },
+    {
+        .SDIO_ManufacturerID = MANUFACTURER_ID_AR6002_BASE | 0x0,
+        .SDIO_ManufacturerCode = MANUFACTURER_CODE,
+        .SDIO_FunctionClass = FUNCTION_CLASS,
+        .SDIO_FunctionNo = 1
+    },
+    {
+        .SDIO_ManufacturerID = MANUFACTURER_ID_AR6002_BASE | 0x1,
+        .SDIO_ManufacturerCode = MANUFACTURER_CODE,
+        .SDIO_FunctionClass = FUNCTION_CLASS,
+        .SDIO_FunctionNo = 1
+    },
+    {
+    }                      //list is null termintaed
+};
+
+TARGET_FUNCTION_CONTEXT FunctionContext = {
+    .function.Version    = CT_SDIO_STACK_VERSION_CODE,
+    .function.pName      = "sdio_wlan",
+    .function.MaxDevices = 1,
+    .function.NumDevices = 0,
+    .function.pIds       = Ids,
+    .function.pProbe     = hifDeviceInserted,
+    .function.pRemove    = hifDeviceRemoved,
+    .function.pSuspend   = NULL,
+    .function.pResume    = NULL,
+    .function.pWake      = NULL,
+    .function.pContext   = &FunctionContext,
+};
+
+HIF_DEVICE hifDevice[HIF_MAX_DEVICES];
+HTC_CALLBACKS htcCallbacks;
+BUS_REQUEST busRequest[BUS_REQUEST_MAX_NUM];
+static BUS_REQUEST *s_busRequestFreeQueue = NULL;
+OS_CRITICALSECTION lock;
+extern A_UINT32 onebitmode;
+extern A_UINT32 busspeedlow;
+extern A_UINT32 debughif;
+
+#ifdef DEBUG
+#define ATH_DEBUG_ERROR 1
+#define ATH_DEBUG_WARN  2
+#define ATH_DEBUG_TRACE 3
+#define _AR_DEBUG_PRINTX_ARG(arg...) arg
+#define AR_DEBUG_PRINTF(lvl, args)\
+    {if (lvl <= debughif)\
+        A_PRINTF(KERN_ALERT _AR_DEBUG_PRINTX_ARG args);\
+    }
+#else
+#define AR_DEBUG_PRINTF(lvl, args)
+#endif
+
+static BUS_REQUEST *hifAllocateBusRequest(void);
+static void hifFreeBusRequest(BUS_REQUEST *busrequest);
+static THREAD_RETURN insert_helper_func(POSKERNEL_HELPER pHelper);
+static void ResetAllCards(void);
+
+/* ------ Functions ------ */
+int HIFInit(HTC_CALLBACKS *callbacks)
+{
+    SDIO_STATUS status;
+    DBG_ASSERT(callbacks != NULL);
+
+    /* Store the callback and event handlers */
+    htcCallbacks.deviceInsertedHandler = callbacks->deviceInsertedHandler;
+    htcCallbacks.deviceRemovedHandler = callbacks->deviceRemovedHandler;
+    htcCallbacks.deviceSuspendHandler = callbacks->deviceSuspendHandler;
+    htcCallbacks.deviceResumeHandler = callbacks->deviceResumeHandler;
+    htcCallbacks.deviceWakeupHandler = callbacks->deviceWakeupHandler;
+    htcCallbacks.rwCompletionHandler = callbacks->rwCompletionHandler;
+    htcCallbacks.dsrHandler = callbacks->dsrHandler;
+
+    CriticalSectionInit(&lock);
+
+    /* Register with bus driver core */
+    status = SDIO_RegisterFunction(&FunctionContext.function);
+    DBG_ASSERT(SDIO_SUCCESS(status));
+
+    return(0);
+}
+
+A_STATUS
+HIFReadWrite(HIF_DEVICE *device,
+             A_UINT32 address,
+             A_UCHAR *buffer,
+             A_UINT32 length,
+             A_UINT32 request,
+             void *context)
+{
+    A_UINT8 rw;
+    A_UINT8 mode;
+    A_UINT8 funcNo;
+    A_UINT8 opcode;
+    A_UINT16 count;
+    SDREQUEST *sdrequest;
+    SDIO_STATUS sdiostatus;
+    BUS_REQUEST *busrequest;
+    A_STATUS    status = A_OK;
+
+    DBG_ASSERT(device != NULL);
+    DBG_ASSERT(device->handle != NULL);
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Device: %p\n", device));
+
+    do {
+        busrequest = hifAllocateBusRequest();
+        if (busrequest == NULL) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERROR, ("HIF Unable to allocate bus request\n"));
+            status = A_NO_RESOURCE;
+            break;
+        }
+
+        sdrequest = busrequest->request;
+        busrequest->context = context;
+
+        sdrequest->pDataBuffer = buffer;
+        if (request & HIF_SYNCHRONOUS) {
+            sdrequest->Flags = SDREQ_FLAGS_RESP_SDIO_R5 | SDREQ_FLAGS_DATA_TRANS;
+            sdrequest->pCompleteContext = NULL;
+            sdrequest->pCompletion = NULL;
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Execution mode: Synchronous\n"));
+        } else if (request & HIF_ASYNCHRONOUS) {
+            sdrequest->Flags = SDREQ_FLAGS_RESP_SDIO_R5 | SDREQ_FLAGS_DATA_TRANS |
+                               SDREQ_FLAGS_TRANS_ASYNC;
+            sdrequest->pCompleteContext = busrequest;
+            sdrequest->pCompletion = hifRWCompletionHandler;
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Execution mode: Asynchronous\n"));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                            ("Invalid execution mode: 0x%08x\n", request));
+            status = A_EINVAL;
+            break;
+        }
+
+        if (request & HIF_EXTENDED_IO) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Command type: CMD53\n"));
+            sdrequest->Command = CMD53;
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                            ("Invalid command type: 0x%08x\n", request));
+            status = A_EINVAL;
+            break;
+        }
+
+        if (request & HIF_BLOCK_BASIS) {
+            mode = CMD53_BLOCK_BASIS;
+            sdrequest->BlockLen = HIF_MBOX_BLOCK_SIZE;
+            sdrequest->BlockCount = length / HIF_MBOX_BLOCK_SIZE;
+            count = sdrequest->BlockCount;
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE,
+                            ("Block mode (BlockLen: %d, BlockCount: %d)\n",
+                            sdrequest->BlockLen, sdrequest->BlockCount));
+        } else if (request & HIF_BYTE_BASIS) {
+            mode = CMD53_BYTE_BASIS;
+            sdrequest->BlockLen = length;
+            sdrequest->BlockCount = 1;
+            count = sdrequest->BlockLen;
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE,
+                            ("Byte mode (BlockLen: %d, BlockCount: %d)\n",
+                            sdrequest->BlockLen, sdrequest->BlockCount));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                            ("Invalid data mode: 0x%08x\n", request));
+            status = A_EINVAL;
+            break;
+        }
+
+#if 0
+        /* useful for checking register accesses */
+        if (length & 0x3) {
+            A_PRINTF(KERN_ALERT"HIF (%s) is not a multiple of 4 bytes, addr:0x%X, len:%d\n",
+                                request & HIF_WRITE ? "write":"read", address, length);
+        }
+#endif
+
+        if ((address >= HIF_MBOX_START_ADDR(0)) &&
+            (address <= HIF_MBOX_END_ADDR(3)))
+        {
+
+            DBG_ASSERT(length <= HIF_MBOX_WIDTH);
+
+            /*
+             * Mailbox write. Adjust the address so that the last byte
+             * falls on the EOM address.
+             */
+            address += (HIF_MBOX_WIDTH - length);
+        }
+
+
+
+        if (request & HIF_WRITE) {
+            rw = CMD53_WRITE;
+            sdrequest->Flags |= SDREQ_FLAGS_DATA_WRITE;
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Direction: Write\n"));
+        } else if (request & HIF_READ) {
+            rw = CMD53_READ;
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Direction: Read\n"));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                            ("Invalid direction: 0x%08x\n", request));
+            status = A_EINVAL;
+            break;
+        }
+
+        if (request & HIF_FIXED_ADDRESS) {
+            opcode = CMD53_FIXED_ADDRESS;
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Address mode: Fixed\n"));
+        } else if (request & HIF_INCREMENTAL_ADDRESS) {
+            opcode = CMD53_INCR_ADDRESS;
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Address mode: Incremental\n"));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                            ("Invalid address mode: 0x%08x\n", request));
+            status = A_EINVAL;
+            break;
+        }
+
+        funcNo = SDDEVICE_GET_SDIO_FUNCNO(device->handle);
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Function number: %d\n", funcNo));
+        SDIO_SET_CMD53_ARG(sdrequest->Argument, rw, funcNo,
+                           mode, opcode, address, count);
+
+        /* Send the command out */
+        sdiostatus = SDDEVICE_CALL_REQUEST_FUNC(device->handle, sdrequest);
+
+        if (!SDIO_SUCCESS(sdiostatus)) {
+            status = A_ERROR;
+        }
+
+    } while (FALSE);
+
+    if (A_FAILED(status) || (request & HIF_SYNCHRONOUS)) {
+        if (busrequest != NULL) {
+            hifFreeBusRequest(busrequest);
+        }
+    }
+
+    if (A_FAILED(status) && (request & HIF_ASYNCHRONOUS)) {
+            /* call back async handler on failure */
+        htcCallbacks.rwCompletionHandler(context, status);
+    }
+
+    return status;
+}
+
+A_STATUS
+HIFConfigureDevice(HIF_DEVICE *device, HIF_DEVICE_CONFIG_OPCODE opcode,
+                   void *config, A_UINT32 configLen)
+{
+    A_UINT32 count;
+
+    switch(opcode) {
+        case HIF_DEVICE_GET_MBOX_BLOCK_SIZE:
+            ((A_UINT32 *)config)[0] = HIF_MBOX0_BLOCK_SIZE;
+            ((A_UINT32 *)config)[1] = HIF_MBOX1_BLOCK_SIZE;
+            ((A_UINT32 *)config)[2] = HIF_MBOX2_BLOCK_SIZE;
+            ((A_UINT32 *)config)[3] = HIF_MBOX3_BLOCK_SIZE;
+            break;
+
+        case HIF_DEVICE_GET_MBOX_ADDR:
+            for (count = 0; count < 4; count ++) {
+                ((A_UINT32 *)config)[count] = HIF_MBOX_START_ADDR(count);
+            }
+            break;
+        case HIF_DEVICE_GET_IRQ_PROC_MODE:
+                /* the SDIO stack allows the interrupts to be processed either way, ASYNC or SYNC */
+            *((HIF_DEVICE_IRQ_PROCESSING_MODE *)config) = HIF_DEVICE_IRQ_ASYNC_SYNC;
+            break;
+        default:
+            AR_DEBUG_PRINTF(ATH_DEBUG_WARN,
+                            ("Unsupported configuration opcode: %d\n", opcode));
+            return A_ERROR;
+    }
+
+    return A_OK;
+}
+
+void
+HIFShutDownDevice(HIF_DEVICE *device)
+{
+    A_UINT8 data;
+    A_UINT32 count;
+    SDIO_STATUS status;
+    SDCONFIG_BUS_MODE_DATA busSettings;
+    SDCONFIG_FUNC_ENABLE_DISABLE_DATA fData;
+
+    if (device != NULL) {
+        DBG_ASSERT(device->handle != NULL);
+
+        /* Remove the allocated current if any */
+        status = SDLIB_IssueConfig(device->handle,
+                                   SDCONFIG_FUNC_FREE_SLOT_CURRENT, NULL, 0);
+        DBG_ASSERT(SDIO_SUCCESS(status));
+
+        /* Disable the card */
+        fData.EnableFlags = SDCONFIG_DISABLE_FUNC;
+        fData.TimeOut = 1;
+        status = SDLIB_IssueConfig(device->handle, SDCONFIG_FUNC_ENABLE_DISABLE,
+                                   &fData, sizeof(fData));
+        DBG_ASSERT(SDIO_SUCCESS(status));
+
+        /* Perform a soft I/O reset */
+        data = SDIO_IO_RESET;
+        status = SDLIB_IssueCMD52(device->handle, 0, SDIO_IO_ABORT_REG,
+                                  &data, 1, 1);
+        DBG_ASSERT(SDIO_SUCCESS(status));
+
+        /*
+         * WAR - Codetelligence driver does not seem to shutdown correctly in 1
+         * bit mode. By default it configures the HC in the 4 bit. Its later in
+         * our driver that we switch to 1 bit mode. If we try to shutdown, the
+         * driver hangs so we revert to 4 bit mode, to be transparent to the
+         * underlying bus driver.
+         */
+        if (onebitmode) {
+            ZERO_OBJECT(busSettings);
+            busSettings.BusModeFlags = SDDEVICE_GET_BUSMODE_FLAGS(device->handle);
+            SDCONFIG_SET_BUS_WIDTH(busSettings.BusModeFlags,
+                                   SDCONFIG_BUS_WIDTH_4_BIT);
+
+            /* Issue config request to change the bus width to 4 bit */
+            status = SDLIB_IssueConfig(device->handle, SDCONFIG_BUS_MODE_CTRL,
+                                       &busSettings,
+                                       sizeof(SDCONFIG_BUS_MODE_DATA));
+            DBG_ASSERT(SDIO_SUCCESS(status));
+        }
+
+        /* Free the bus requests */
+        for (count = 0; count < BUS_REQUEST_MAX_NUM; count ++) {
+            SDDeviceFreeRequest(device->handle, busRequest[count].request);
+        }
+        /* Clean up the queue */
+        s_busRequestFreeQueue = NULL;
+    } else {
+            /* since we are unloading the driver anyways, reset all cards in case the SDIO card
+             * is externally powered and we are unloading the SDIO stack.  This avoids the problem when
+             * the SDIO stack is reloaded and attempts are made to re-enumerate a card that is already
+             * enumerated */
+        ResetAllCards();
+        /* Unregister with bus driver core */
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRACE,
+                        ("Unregistering with the bus driver\n"));
+        status = SDIO_UnregisterFunction(&FunctionContext.function);
+        DBG_ASSERT(SDIO_SUCCESS(status));
+    }
+}
+
+void
+hifRWCompletionHandler(SDREQUEST *request)
+{
+    A_STATUS status;
+    void *context;
+    BUS_REQUEST *busrequest;
+
+    if (SDIO_SUCCESS(request->Status)) {
+        status = A_OK;
+    } else {
+        status = A_ERROR;
+    }
+
+    DBG_ASSERT(status == A_OK);
+    busrequest = (BUS_REQUEST *) request->pCompleteContext;
+    context = (void *) busrequest->context;
+        /* free the request before calling the callback, in case the
+         * callback submits another request, this guarantees that
+         * there is at least 1 free request available everytime the callback
+         * is invoked */
+    hifFreeBusRequest(busrequest);
+    htcCallbacks.rwCompletionHandler(context, status);
+}
+
+void
+hifIRQHandler(void *context)
+{
+    A_STATUS status;
+    HIF_DEVICE *device;
+
+    device = (HIF_DEVICE *)context;
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Device: %p\n", device));
+    status = htcCallbacks.dsrHandler(device->htc_handle);
+    DBG_ASSERT(status == A_OK);
+}
+
+BOOL
+hifDeviceInserted(SDFUNCTION *function, SDDEVICE *handle)
+{
+    BOOL enabled;
+    A_UINT8 data;
+    A_UINT32 count;
+    HIF_DEVICE *device;
+    SDIO_STATUS status;
+    A_UINT16 maxBlocks;
+    A_UINT16 maxBlockSize;
+    SDCONFIG_BUS_MODE_DATA busSettings;
+    SDCONFIG_FUNC_ENABLE_DISABLE_DATA fData;
+    TARGET_FUNCTION_CONTEXT *functionContext;
+    SDCONFIG_FUNC_SLOT_CURRENT_DATA slotCurrent;
+    SD_BUSCLOCK_RATE                currentBusClock;
+
+    DBG_ASSERT(function != NULL);
+    DBG_ASSERT(handle != NULL);
+
+    device = addHifDevice(handle);
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Device: %p\n", device));
+    functionContext =  (TARGET_FUNCTION_CONTEXT *)function->pContext;
+
+    /*
+     * Issue commands to get the manufacturer ID and stuff and compare it
+     * against the rev Id derived from the ID registered during the
+     * initialization process. Report the device only in the case there
+     * is a match. In the case od SDIO, the bus driver has already queried
+     * these details so we just need to use their data structures to get the
+     * relevant values. Infact, the driver has already matched it against
+     * the Ids that we registered with it so we dont need to the step here.
+     */
+
+    /* Configure the SDIO Bus Width */
+    if (onebitmode) {
+        data = SDIO_BUS_WIDTH_1_BIT;
+        status = SDLIB_IssueCMD52(handle, 0, SDIO_BUS_IF_REG, &data, 1, 1);
+        if (!SDIO_SUCCESS(status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                            ("Unable to set the bus width to 1 bit\n"));
+            return FALSE;
+        }
+    }
+
+    /* Get current bus flags */
+    ZERO_OBJECT(busSettings);
+
+    busSettings.BusModeFlags = SDDEVICE_GET_BUSMODE_FLAGS(handle);
+    if (onebitmode) {
+        SDCONFIG_SET_BUS_WIDTH(busSettings.BusModeFlags,
+                               SDCONFIG_BUS_WIDTH_1_BIT);
+    }
+
+        /* get the current operating clock, the bus driver sets us up based
+         * on what our CIS reports and what the host controller can handle
+         * we can use this to determine whether we want to drop our clock rate
+         * down */
+    currentBusClock = SDDEVICE_GET_OPER_CLOCK(handle);
+    busSettings.ClockRate = currentBusClock;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRACE,
+                        ("HIF currently running at: %d \n",currentBusClock));
+
+        /* see if HIF wants to run at a lower clock speed, we may already be
+         * at that lower clock speed */
+    if (currentBusClock > (SDIO_CLOCK_FREQUENCY_DEFAULT >> busspeedlow)) {
+        busSettings.ClockRate = SDIO_CLOCK_FREQUENCY_DEFAULT >> busspeedlow;
+        AR_DEBUG_PRINTF(ATH_DEBUG_WARN,
+                        ("HIF overriding clock to %d \n",busSettings.ClockRate));
+    }
+
+    /* Issue config request to override clock rate */
+    status = SDLIB_IssueConfig(handle, SDCONFIG_FUNC_CHANGE_BUS_MODE, &busSettings,
+                               sizeof(SDCONFIG_BUS_MODE_DATA));
+    if (!SDIO_SUCCESS(status)) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                        ("Unable to configure the host clock\n"));
+        return FALSE;
+    } else {
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRACE,
+                        ("Configured clock: %d, Maximum clock: %d\n",
+                        busSettings.ActualClockRate,
+                        SDDEVICE_GET_MAX_CLOCK(handle)));
+    }
+
+    /*
+     * Check if the target supports block mode. This result of this check
+     * can be used to implement the HIFReadWrite API.
+     */
+    if (SDDEVICE_GET_SDIO_FUNC_MAXBLKSIZE(handle)) {
+        /* Limit block size to operational block limit or card function
+           capability */
+        maxBlockSize = min(SDDEVICE_GET_OPER_BLOCK_LEN(handle),
+                           SDDEVICE_GET_SDIO_FUNC_MAXBLKSIZE(handle));
+
+        /* check if the card support multi-block transfers */
+        if (!(SDDEVICE_GET_SDIOCARD_CAPS(handle) & SDIO_CAPS_MULTI_BLOCK)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Byte basis only\n"));
+
+            /* Limit block size to max byte basis */
+            maxBlockSize =  min(maxBlockSize,
+                                (A_UINT16)SDIO_MAX_LENGTH_BYTE_BASIS);
+            maxBlocks = 1;
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Multi-block capable\n"));
+            maxBlocks = SDDEVICE_GET_OPER_BLOCKS(handle);
+            status = SDLIB_SetFunctionBlockSize(handle, HIF_MBOX_BLOCK_SIZE);
+            if (!SDIO_SUCCESS(status)) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                                ("Failed to set block size. Err:%d\n", status));
+                return FALSE;
+            }
+        }
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRACE,
+                        ("Bytes Per Block: %d bytes, Block Count:%d \n",
+                        maxBlockSize, maxBlocks));
+    } else {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                        ("Function does not support Block Mode!\n"));
+        return FALSE;
+    }
+
+    /* Allocate the slot current */
+    status = SDLIB_GetDefaultOpCurrent(handle, &slotCurrent.SlotCurrent);
+    if (SDIO_SUCCESS(status)) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Allocating Slot current: %d mA\n",
+                                slotCurrent.SlotCurrent));
+        status = SDLIB_IssueConfig(handle, SDCONFIG_FUNC_ALLOC_SLOT_CURRENT,
+                                   &slotCurrent, sizeof(slotCurrent));
+        if (!SDIO_SUCCESS(status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                            ("Failed to allocate slot current %d\n", status));
+            return FALSE;
+        }
+    }
+
+    /* Enable the AR6000 function */
+    count = 0;
+    enabled = FALSE;
+    fData.TimeOut = 1;
+    fData.EnableFlags = SDCONFIG_ENABLE_FUNC;
+    while ((count++ < SDWLAN_ENABLE_DISABLE_TIMEOUT) && !enabled)
+    {
+        /* Enable AR6000 */
+        status = SDLIB_IssueConfig(handle, SDCONFIG_FUNC_ENABLE_DISABLE,
+                                   &fData, sizeof(fData));
+        if (!SDIO_SUCCESS(status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE,
+                            ("Attempting to enable the card again\n"));
+            continue;
+        }
+
+        /* Mark the status as enabled */
+        enabled = TRUE;
+    }
+
+    /* Check if we were succesful in enabling the target */
+    if (!enabled) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                        ("Failed to communicate with the target\n"));
+        return FALSE;
+    }
+
+    /* Allocate the bus requests to be used later */
+    A_MEMZERO(busRequest, sizeof(busRequest));
+    for (count = 0; count < BUS_REQUEST_MAX_NUM; count ++) {
+        if ((busRequest[count].request = SDDeviceAllocRequest(handle)) == NULL){
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERROR, ("Unable to allocate memory\n"));
+            /* TODO: Free the memory that has already been allocated */
+            return FALSE;
+        }
+        hifFreeBusRequest(&busRequest[count]);
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRACE,
+                ("0x%08x = busRequest[%d].request = 0x%08x\n",
+				(unsigned int) &busRequest[count], count,
+				(unsigned int) busRequest[count].request));
+    }
+
+        /* Schedule a worker to handle device inserted, this is a temporary workaround
+         * to fix a deadlock if the device fails to intialize in the insertion handler
+         * The failure causes the instance to shutdown the HIF layer and unregister the
+         * function driver within the busdriver probe context which can deadlock
+         *
+         * NOTE: we cannot use the default work queue because that would block
+         * SD bus request processing for all synchronous I/O. We must use a kernel
+         * thread that is creating using the helper library.
+         * */
+
+    if (SDIO_SUCCESS(SDLIB_OSCreateHelper(&device->insert_helper,
+                         insert_helper_func,
+                         device))) {
+        device->helper_started = TRUE;
+    }
+
+    return TRUE;
+}
+
+static THREAD_RETURN insert_helper_func(POSKERNEL_HELPER pHelper)
+{
+        /* Inform HTC */
+    if ((htcCallbacks.deviceInsertedHandler(SD_GET_OS_HELPER_CONTEXT(pHelper))) != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Device rejected\n"));
+    }
+
+    return 0;
+}
+
+void
+HIFAckInterrupt(HIF_DEVICE *device)
+{
+    SDIO_STATUS status;
+    DBG_ASSERT(device != NULL);
+    DBG_ASSERT(device->handle != NULL);
+
+    /* Acknowledge our function IRQ */
+    status = SDLIB_IssueConfig(device->handle, SDCONFIG_FUNC_ACK_IRQ,
+                               NULL, 0);
+    DBG_ASSERT(SDIO_SUCCESS(status));
+}
+
+void
+HIFUnMaskInterrupt(HIF_DEVICE *device)
+{
+    SDIO_STATUS status;
+
+    DBG_ASSERT(device != NULL);
+    DBG_ASSERT(device->handle != NULL);
+
+    /* Register the IRQ Handler */
+    SDDEVICE_SET_IRQ_HANDLER(device->handle, hifIRQHandler, device);
+
+    /* Unmask our function IRQ */
+    status = SDLIB_IssueConfig(device->handle, SDCONFIG_FUNC_UNMASK_IRQ,
+                               NULL, 0);
+    DBG_ASSERT(SDIO_SUCCESS(status));
+}
+
+void HIFMaskInterrupt(HIF_DEVICE *device)
+{
+    SDIO_STATUS status;
+    DBG_ASSERT(device != NULL);
+    DBG_ASSERT(device->handle != NULL);
+
+    /* Mask our function IRQ */
+    status = SDLIB_IssueConfig(device->handle, SDCONFIG_FUNC_MASK_IRQ,
+                               NULL, 0);
+    DBG_ASSERT(SDIO_SUCCESS(status));
+
+    /* Unregister the IRQ Handler */
+    SDDEVICE_SET_IRQ_HANDLER(device->handle, NULL, NULL);
+}
+
+static BUS_REQUEST *hifAllocateBusRequest(void)
+{
+    BUS_REQUEST *busrequest;
+
+    /* Acquire lock */
+    CriticalSectionAcquire(&lock);
+
+    /* Remove first in list */
+    if((busrequest = s_busRequestFreeQueue) != NULL)
+    {
+        s_busRequestFreeQueue = busrequest->next;
+    }
+
+    /* Release lock */
+    CriticalSectionRelease(&lock);
+
+    return busrequest;
+}
+
+static void
+hifFreeBusRequest(BUS_REQUEST *busrequest)
+{
+    DBG_ASSERT(busrequest != NULL);
+
+    /* Acquire lock */
+    CriticalSectionAcquire(&lock);
+
+    /* Insert first in list */
+    busrequest->next = s_busRequestFreeQueue;
+    s_busRequestFreeQueue = busrequest;
+
+    /* Release lock */
+    CriticalSectionRelease(&lock);
+}
+
+void
+hifDeviceRemoved(SDFUNCTION *function, SDDEVICE *handle)
+{
+    A_STATUS status;
+    HIF_DEVICE *device;
+    DBG_ASSERT(function != NULL);
+    DBG_ASSERT(handle != NULL);
+
+    device = getHifDevice(handle);
+
+        /* cleanup the helper thread */
+    if (device->helper_started) {
+        SDLIB_OSDeleteHelper(&device->insert_helper);
+        device->helper_started = FALSE;
+    }
+
+    status = htcCallbacks.deviceRemovedHandler(device->htc_handle, A_OK);
+    delHifDevice(handle);
+    DBG_ASSERT(status == A_OK);
+}
+
+HIF_DEVICE *
+addHifDevice(SDDEVICE *handle)
+{
+    DBG_ASSERT(handle != NULL);
+    hifDevice[0].handle = handle;
+    return &hifDevice[0];
+}
+
+HIF_DEVICE *
+getHifDevice(SDDEVICE *handle)
+{
+    DBG_ASSERT(handle != NULL);
+    return &hifDevice[0];
+}
+
+void
+delHifDevice(SDDEVICE *handle)
+{
+    DBG_ASSERT(handle != NULL);
+    hifDevice[0].handle = NULL;
+}
+
+struct device*
+HIFGetOSDevice(HIF_DEVICE *device)
+{
+    return &device->handle->Device.dev;
+}
+
+static void ResetAllCards(void)
+{
+    UINT8       data;
+    SDIO_STATUS status;
+    int         i;
+
+    data = SDIO_IO_RESET;
+
+    /* set the I/O CARD reset bit:
+     * NOTE: we are exploiting a "feature" of the SDIO core that resets the core when you
+     * set the RES bit in the SDIO_IO_ABORT register.  This bit however "normally" resets the
+     * I/O functions leaving the SDIO core in the same state (as per SDIO spec).
+     * In this design, this reset can be used to reset the SDIO core itself */
+    for (i = 0; i < HIF_MAX_DEVICES; i++) {
+        if (hifDevice[i].handle != NULL) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE,
+                        ("Issuing I/O Card reset for instance: %d \n",i));
+                /* set the I/O Card reset bit */
+            status = SDLIB_IssueCMD52(hifDevice[i].handle,
+                                      0,                    /* function 0 space */
+                                      SDIO_IO_ABORT_REG,
+                                      &data,
+                                      1,                    /* 1 byte */
+                                      TRUE);                /* write */
+        }
+    }
+
+}
+
+void HIFSetHandle(void *hif_handle, void *handle)
+{
+    HIF_DEVICE *device = (HIF_DEVICE *) hif_handle;
+
+    device->htc_handle = handle;
+
+    return;
+}
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/hif/hif_internal.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/hif/hif_internal.h
@@ -0,0 +1,102 @@
+/*
+ * @file: hif_internal.h
+ *
+ * @abstract: internal header file for hif layer
+ *
+ * @notice: Copyright (c) 2004-2006 Atheros Communications Inc.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "../include/config.h"
+#include <linux/sdio/ctsystem.h>
+#include <linux/sdio/sdio_busdriver.h>
+#include <linux/sdio/_sdio_defs.h>
+#include <linux/sdio/sdio_lib.h>
+#include "../include/athdefs.h"
+#include "../include/athtypes.h"
+#include "../include/osapi.h"
+#include "../include/hif.h"
+
+#define MANUFACTURER_ID_AR6001_BASE        0x100
+#define MANUFACTURER_ID_AR6002_BASE        0x200
+#define FUNCTION_CLASS                     0x0
+#define MANUFACTURER_CODE                  0x271
+
+#define BUS_REQUEST_MAX_NUM                64
+
+#define SDIO_CLOCK_FREQUENCY_DEFAULT       25000000
+#define SDWLAN_ENABLE_DISABLE_TIMEOUT      20
+#define FLAGS_CARD_ENAB                    0x02
+#define FLAGS_CARD_IRQ_UNMSK               0x04
+
+#define HIF_MBOX_BLOCK_SIZE                128
+#define HIF_MBOX_BASE_ADDR                 0x800
+#define HIF_MBOX_WIDTH                     0x800
+#define HIF_MBOX0_BLOCK_SIZE               1
+#define HIF_MBOX1_BLOCK_SIZE               HIF_MBOX_BLOCK_SIZE
+#define HIF_MBOX2_BLOCK_SIZE               HIF_MBOX_BLOCK_SIZE
+#define HIF_MBOX3_BLOCK_SIZE               HIF_MBOX_BLOCK_SIZE
+
+#define HIF_MBOX_START_ADDR(mbox)                        \
+    HIF_MBOX_BASE_ADDR + mbox * HIF_MBOX_WIDTH
+
+#define HIF_MBOX_END_ADDR(mbox)	                         \
+    HIF_MBOX_START_ADDR(mbox) + HIF_MBOX_WIDTH - 1
+
+struct hif_device {
+    SDDEVICE *handle;
+    void *htc_handle;
+    OSKERNEL_HELPER insert_helper;
+    BOOL  helper_started;
+};
+
+typedef struct target_function_context {
+    SDFUNCTION           function; /* function description of the bus driver */
+    OS_SEMAPHORE         instanceSem; /* instance lock. Unused */
+    SDLIST               instanceList; /* list of instances. Unused */
+} TARGET_FUNCTION_CONTEXT;
+
+typedef struct bus_request {
+    struct bus_request *next;
+    SDREQUEST *request;
+    void *context;
+} BUS_REQUEST;
+
+BOOL
+hifDeviceInserted(SDFUNCTION *function, SDDEVICE *device);
+
+void
+hifDeviceRemoved(SDFUNCTION *function, SDDEVICE *device);
+
+SDREQUEST *
+hifAllocateDeviceRequest(SDDEVICE *device);
+
+void
+hifFreeDeviceRequest(SDREQUEST *request);
+
+void
+hifRWCompletionHandler(SDREQUEST *request);
+
+void
+hifIRQHandler(void *context);
+
+HIF_DEVICE *
+addHifDevice(SDDEVICE *handle);
+
+HIF_DEVICE *
+getHifDevice(SDDEVICE *handle);
+
+void
+delHifDevice(SDDEVICE *handle);
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/htc/Makefile
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/htc/Makefile
@@ -0,0 +1,5 @@
+#
+# SDIO ar6000 wlan htc function driver
+#
+obj-$(CONFIG_SDIO_AR6000_WLAN)  += htc.o htc_events.o htc_recv.o htc_send.o htc_utils.o ar6k.o ar6k_events.o
+
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/htc/ar6k.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/htc/ar6k.c
@@ -0,0 +1,1001 @@
+/*
+ * AR6K device layer that handles register level I/O
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+#include "../include/config.h"
+#include "../include/athdefs.h"
+#include "../include/athtypes.h"
+#include "../include/mbox_host_reg.h"
+#include "../include/osapi.h"
+#include "../include/debug.h"
+#include "../include/hif.h"
+#include "../include/htc_packet.h"
+#include "../include/ar6k.h"
+
+#define MAILBOX_FOR_BLOCK_SIZE 1
+
+extern A_UINT32 resetok;
+
+A_STATUS DevEnableInterrupts(AR6K_DEVICE *pDev);
+A_STATUS DevDisableInterrupts(AR6K_DEVICE *pDev);
+
+#define LOCK_AR6K(p)      A_MUTEX_LOCK(&(p)->Lock);
+#define UNLOCK_AR6K(p)    A_MUTEX_UNLOCK(&(p)->Lock);
+
+void AR6KFreeIOPacket(AR6K_DEVICE *pDev, HTC_PACKET *pPacket)
+{
+    LOCK_AR6K(pDev);
+    HTC_PACKET_ENQUEUE(&pDev->RegisterIOList,pPacket);
+    UNLOCK_AR6K(pDev);
+}
+
+HTC_PACKET *AR6KAllocIOPacket(AR6K_DEVICE *pDev)
+{
+    HTC_PACKET *pPacket;
+
+    LOCK_AR6K(pDev);
+    pPacket = HTC_PACKET_DEQUEUE(&pDev->RegisterIOList);
+    UNLOCK_AR6K(pDev);
+
+    return pPacket;
+}
+
+void DevCleanup(AR6K_DEVICE *pDev)
+{
+    if (A_IS_MUTEX_VALID(&pDev->Lock)) {
+        A_MUTEX_DELETE(&pDev->Lock);
+    }
+}
+
+A_STATUS DevSetup(AR6K_DEVICE *pDev)
+{
+    A_UINT32 mailboxaddrs[AR6K_MAILBOXES];
+    A_UINT32 blocksizes[AR6K_MAILBOXES];
+    A_STATUS status = A_OK;
+    int      i;
+
+    AR_DEBUG_ASSERT(AR6K_IRQ_PROC_REGS_SIZE == 16);
+    AR_DEBUG_ASSERT(AR6K_IRQ_ENABLE_REGS_SIZE == 4);
+
+    do {
+            /* give a handle to HIF for this target */
+        HIFSetHandle(pDev->HIFDevice, (void *)pDev);
+            /* initialize our free list of IO packets */
+        INIT_HTC_PACKET_QUEUE(&pDev->RegisterIOList);
+        A_MUTEX_INIT(&pDev->Lock);
+
+            /* get the addresses for all 4 mailboxes */
+        status = HIFConfigureDevice(pDev->HIFDevice, HIF_DEVICE_GET_MBOX_ADDR,
+                                    mailboxaddrs, sizeof(mailboxaddrs));
+
+        if (status != A_OK) {
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+
+            /* carve up register I/O packets (these are for ASYNC register I/O ) */
+        for (i = 0; i < AR6K_MAX_REG_IO_BUFFERS; i++) {
+            HTC_PACKET *pIOPacket;
+            pIOPacket = &pDev->RegIOBuffers[i].HtcPacket;
+            SET_HTC_PACKET_INFO_RX_REFILL(pIOPacket,
+                                          pDev,
+                                          pDev->RegIOBuffers[i].Buffer,
+                                          AR6K_REG_IO_BUFFER_SIZE,
+                                          0); /* don't care */
+            AR6KFreeIOPacket(pDev,pIOPacket);
+        }
+
+            /* get the address of the mailbox we are using */
+        pDev->MailboxAddress = mailboxaddrs[HTC_MAILBOX];
+
+            /* get the block sizes */
+        status = HIFConfigureDevice(pDev->HIFDevice, HIF_DEVICE_GET_MBOX_BLOCK_SIZE,
+                                    blocksizes, sizeof(blocksizes));
+
+        if (status != A_OK) {
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+
+            /* note: we actually get the block size of a mailbox other than 0, for SDIO the block
+             * size on mailbox 0 is artificially set to 1.  So we use the block size that is set
+             * for the other 3 mailboxes */
+        pDev->BlockSize = blocksizes[MAILBOX_FOR_BLOCK_SIZE];
+            /* must be a power of 2 */
+        AR_DEBUG_ASSERT((pDev->BlockSize & (pDev->BlockSize - 1)) == 0);
+
+            /* assemble mask, used for padding to a block */
+        pDev->BlockMask = pDev->BlockSize - 1;
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRC,("BlockSize: %d, MailboxAddress:0x%X \n",
+                    pDev->BlockSize, pDev->MailboxAddress));
+
+        pDev->GetPendingEventsFunc = NULL;
+            /* see if the HIF layer implements the get pending events function  */
+        HIFConfigureDevice(pDev->HIFDevice,
+                           HIF_DEVICE_GET_PENDING_EVENTS_FUNC,
+                           &pDev->GetPendingEventsFunc,
+                           sizeof(pDev->GetPendingEventsFunc));
+
+            /* assume we can process HIF interrupt events asynchronously */
+        pDev->HifIRQProcessingMode = HIF_DEVICE_IRQ_ASYNC_SYNC;
+
+            /* see if the HIF layer overrides this assumption */
+        HIFConfigureDevice(pDev->HIFDevice,
+                           HIF_DEVICE_GET_IRQ_PROC_MODE,
+                           &pDev->HifIRQProcessingMode,
+                           sizeof(pDev->HifIRQProcessingMode));
+
+        switch (pDev->HifIRQProcessingMode) {
+            case HIF_DEVICE_IRQ_SYNC_ONLY:
+                AR_DEBUG_PRINTF(ATH_DEBUG_TRC,("HIF Interrupt processing is SYNC ONLY\n"));
+                break;
+            case HIF_DEVICE_IRQ_ASYNC_SYNC:
+                AR_DEBUG_PRINTF(ATH_DEBUG_TRC,("HIF Interrupt processing is ASYNC and SYNC\n"));
+                break;
+            default:
+                AR_DEBUG_ASSERT(FALSE);
+        }
+
+        pDev->HifMaskUmaskRecvEvent = NULL;
+
+            /* see if the HIF layer implements the mask/unmask recv events function  */
+        HIFConfigureDevice(pDev->HIFDevice,
+                           HIF_DEVICE_GET_RECV_EVENT_MASK_UNMASK_FUNC,
+                           &pDev->HifMaskUmaskRecvEvent,
+                           sizeof(pDev->HifMaskUmaskRecvEvent));
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRC,("HIF special overrides : 0x%X , 0x%X\n",
+                 (A_UINT32)pDev->GetPendingEventsFunc, (A_UINT32)pDev->HifMaskUmaskRecvEvent));
+
+        status = DevDisableInterrupts(pDev);
+
+    } while (FALSE);
+
+    if (A_FAILED(status)) {
+            /* make sure handle is cleared */
+        HIFSetHandle(pDev->HIFDevice, NULL);
+    }
+
+    return status;
+
+}
+
+A_STATUS DevEnableInterrupts(AR6K_DEVICE *pDev)
+{
+    A_STATUS                  status;
+    AR6K_IRQ_ENABLE_REGISTERS regs;
+
+    LOCK_AR6K(pDev);
+
+        /* Enable all the interrupts except for the internal AR6000 CPU interrupt */
+    pDev->IrqEnableRegisters.int_status_enable = INT_STATUS_ENABLE_ERROR_SET(0x01) |
+                                      INT_STATUS_ENABLE_CPU_SET(0x01) |
+                                      INT_STATUS_ENABLE_COUNTER_SET(0x01);
+
+    if (NULL == pDev->GetPendingEventsFunc) {
+        pDev->IrqEnableRegisters.int_status_enable |= INT_STATUS_ENABLE_MBOX_DATA_SET(0x01);
+    } else {
+        /* The HIF layer provided us with a pending events function which means that
+         * the detection of pending mbox messages is handled in the HIF layer.
+         * This is the case for the SPI2 interface.
+         * In the normal case we enable MBOX interrupts, for the case
+         * with HIFs that offer this mechanism, we keep these interrupts
+         * masked */
+        pDev->IrqEnableRegisters.int_status_enable &= ~INT_STATUS_ENABLE_MBOX_DATA_SET(0x01);
+    }
+
+
+    /* Set up the CPU Interrupt Status Register */
+    pDev->IrqEnableRegisters.cpu_int_status_enable = CPU_INT_STATUS_ENABLE_BIT_SET(0x00);
+
+    /* Set up the Error Interrupt Status Register */
+    pDev->IrqEnableRegisters.error_status_enable =
+                                  ERROR_STATUS_ENABLE_RX_UNDERFLOW_SET(0x01) |
+                                  ERROR_STATUS_ENABLE_TX_OVERFLOW_SET(0x01);
+
+    /* Set up the Counter Interrupt Status Register (only for debug interrupt to catch fatal errors) */
+    pDev->IrqEnableRegisters.counter_int_status_enable =
+        COUNTER_INT_STATUS_ENABLE_BIT_SET(AR6K_TARGET_DEBUG_INTR_MASK);
+
+        /* copy into our temp area */
+    A_MEMCPY(&regs,&pDev->IrqEnableRegisters,AR6K_IRQ_ENABLE_REGS_SIZE);
+
+    UNLOCK_AR6K(pDev);
+
+        /* always synchronous */
+    status = HIFReadWrite(pDev->HIFDevice,
+                          INT_STATUS_ENABLE_ADDRESS,
+                          &regs.int_status_enable,
+                          AR6K_IRQ_ENABLE_REGS_SIZE,
+                          HIF_WR_SYNC_BYTE_INC,
+                          NULL);
+
+    if (status != A_OK) {
+        /* Can't write it for some reason */
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                        ("Failed to update interrupt control registers err: %d\n", status));
+
+    }
+
+    return status;
+}
+
+A_STATUS DevDisableInterrupts(AR6K_DEVICE *pDev)
+{
+    AR6K_IRQ_ENABLE_REGISTERS regs;
+
+    LOCK_AR6K(pDev);
+        /* Disable all interrupts */
+    pDev->IrqEnableRegisters.int_status_enable = 0;
+    pDev->IrqEnableRegisters.cpu_int_status_enable = 0;
+    pDev->IrqEnableRegisters.error_status_enable = 0;
+    pDev->IrqEnableRegisters.counter_int_status_enable = 0;
+        /* copy into our temp area */
+    A_MEMCPY(&regs,&pDev->IrqEnableRegisters,AR6K_IRQ_ENABLE_REGS_SIZE);
+
+    UNLOCK_AR6K(pDev);
+
+        /* always synchronous */
+    return HIFReadWrite(pDev->HIFDevice,
+                        INT_STATUS_ENABLE_ADDRESS,
+                        &regs.int_status_enable,
+                        AR6K_IRQ_ENABLE_REGS_SIZE,
+                        HIF_WR_SYNC_BYTE_INC,
+                        NULL);
+}
+
+/* enable device interrupts */
+A_STATUS DevUnmaskInterrupts(AR6K_DEVICE *pDev)
+{
+        /* for good measure, make sure interrupt are disabled before unmasking at the HIF
+         * layer.
+         * The rationale here is that between device insertion (where we clear the interrupts the first time)
+         * and when HTC is finally ready to handle interrupts, other software can perform target "soft" resets.
+         * The AR6K interrupt enables reset back to an "enabled" state when this happens.
+         *  */
+    DevDisableInterrupts(pDev);
+
+        /* Unmask the host controller interrupts */
+    HIFUnMaskInterrupt(pDev->HIFDevice);
+
+    return DevEnableInterrupts(pDev);
+}
+
+/* disable all device interrupts */
+A_STATUS DevMaskInterrupts(AR6K_DEVICE *pDev)
+{
+        /* mask the interrupt at the HIF layer, we don't want a stray interrupt taken while
+         * we zero out our shadow registers in DevDisableInterrupts()*/
+        HIFMaskInterrupt(pDev->HIFDevice);
+
+    return DevDisableInterrupts(pDev);
+}
+
+/* callback when our fetch to enable/disable completes */
+static void DevDoEnableDisableRecvAsyncHandler(void *Context, HTC_PACKET *pPacket)
+{
+    AR6K_DEVICE *pDev = (AR6K_DEVICE *)Context;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("+DevDoEnableDisableRecvAsyncHandler: (dev: 0x%X)\n", (A_UINT32)pDev));
+
+    if (A_FAILED(pPacket->Status)) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                (" Failed to disable receiver, status:%d \n", pPacket->Status));
+    }
+        /* free this IO packet */
+    AR6KFreeIOPacket(pDev,pPacket);
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("-DevDoEnableDisableRecvAsyncHandler \n"));
+}
+
+/* disable packet reception (used in case the host runs out of buffers)
+ * this is the "override" method when the HIF reports another methods to
+ * disable recv events */
+static A_STATUS DevDoEnableDisableRecvOverride(AR6K_DEVICE *pDev, A_BOOL EnableRecv, A_BOOL AsyncMode)
+{
+    A_STATUS                  status = A_OK;
+    HTC_PACKET                *pIOPacket = NULL;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC,("DevDoEnableDisableRecvOverride: Enable:%d Mode:%d\n",
+            EnableRecv,AsyncMode));
+
+    do {
+
+        if (AsyncMode) {
+
+            pIOPacket = AR6KAllocIOPacket(pDev);
+
+            if (NULL == pIOPacket) {
+                status = A_NO_MEMORY;
+                AR_DEBUG_ASSERT(FALSE);
+                break;
+            }
+
+                /* stick in our completion routine when the I/O operation completes */
+            pIOPacket->Completion = DevDoEnableDisableRecvAsyncHandler;
+            pIOPacket->pContext = pDev;
+
+                /* call the HIF layer override and do this asynchronously */
+            status = pDev->HifMaskUmaskRecvEvent(pDev->HIFDevice,
+                                                 EnableRecv ? HIF_UNMASK_RECV : HIF_MASK_RECV,
+                                                 pIOPacket);
+            break;
+        }
+
+            /* if we get here we are doing it synchronously */
+        status = pDev->HifMaskUmaskRecvEvent(pDev->HIFDevice,
+                                             EnableRecv ? HIF_UNMASK_RECV : HIF_MASK_RECV,
+                                             NULL);
+
+    } while (FALSE);
+
+    if (A_FAILED(status) && (pIOPacket != NULL)) {
+        AR6KFreeIOPacket(pDev,pIOPacket);
+    }
+
+    return status;
+}
+
+/* disable packet reception (used in case the host runs out of buffers)
+ * this is the "normal" method using the interrupt enable registers through
+ * the host I/F */
+static A_STATUS DevDoEnableDisableRecvNormal(AR6K_DEVICE *pDev, A_BOOL EnableRecv, A_BOOL AsyncMode)
+{
+    A_STATUS                  status = A_OK;
+    HTC_PACKET                *pIOPacket = NULL;
+    AR6K_IRQ_ENABLE_REGISTERS regs;
+
+        /* take the lock to protect interrupt enable shadows */
+    LOCK_AR6K(pDev);
+
+    if (EnableRecv) {
+        pDev->IrqEnableRegisters.int_status_enable |= INT_STATUS_ENABLE_MBOX_DATA_SET(0x01);
+    } else {
+        pDev->IrqEnableRegisters.int_status_enable &= ~INT_STATUS_ENABLE_MBOX_DATA_SET(0x01);
+    }
+
+        /* copy into our temp area */
+    A_MEMCPY(&regs,&pDev->IrqEnableRegisters,AR6K_IRQ_ENABLE_REGS_SIZE);
+    UNLOCK_AR6K(pDev);
+
+    do {
+
+        if (AsyncMode) {
+
+            pIOPacket = AR6KAllocIOPacket(pDev);
+
+            if (NULL == pIOPacket) {
+                status = A_NO_MEMORY;
+                AR_DEBUG_ASSERT(FALSE);
+                break;
+            }
+
+                /* copy values to write to our async I/O buffer */
+            A_MEMCPY(pIOPacket->pBuffer,&regs,AR6K_IRQ_ENABLE_REGS_SIZE);
+
+                /* stick in our completion routine when the I/O operation completes */
+            pIOPacket->Completion = DevDoEnableDisableRecvAsyncHandler;
+            pIOPacket->pContext = pDev;
+
+                /* write it out asynchronously */
+            HIFReadWrite(pDev->HIFDevice,
+                         INT_STATUS_ENABLE_ADDRESS,
+                         pIOPacket->pBuffer,
+                         AR6K_IRQ_ENABLE_REGS_SIZE,
+                         HIF_WR_ASYNC_BYTE_INC,
+                         pIOPacket);
+            break;
+        }
+
+        /* if we get here we are doing it synchronously */
+
+        status = HIFReadWrite(pDev->HIFDevice,
+                              INT_STATUS_ENABLE_ADDRESS,
+                              &regs.int_status_enable,
+                              AR6K_IRQ_ENABLE_REGS_SIZE,
+                              HIF_WR_SYNC_BYTE_INC,
+                              NULL);
+
+    } while (FALSE);
+
+    if (A_FAILED(status) && (pIOPacket != NULL)) {
+        AR6KFreeIOPacket(pDev,pIOPacket);
+    }
+
+    return status;
+}
+
+
+A_STATUS DevStopRecv(AR6K_DEVICE *pDev, A_BOOL AsyncMode)
+{
+    if (NULL == pDev->HifMaskUmaskRecvEvent) {
+        return DevDoEnableDisableRecvNormal(pDev,FALSE,AsyncMode);
+    } else {
+        return DevDoEnableDisableRecvOverride(pDev,FALSE,AsyncMode);
+    }
+}
+
+A_STATUS DevEnableRecv(AR6K_DEVICE *pDev, A_BOOL AsyncMode)
+{
+    if (NULL == pDev->HifMaskUmaskRecvEvent) {
+        return DevDoEnableDisableRecvNormal(pDev,TRUE,AsyncMode);
+    } else {
+        return DevDoEnableDisableRecvOverride(pDev,TRUE,AsyncMode);
+    }
+}
+
+void DevDumpRegisters(AR6K_IRQ_PROC_REGISTERS   *pIrqProcRegs,
+                      AR6K_IRQ_ENABLE_REGISTERS *pIrqEnableRegs)
+{
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_DUMP, ("\n<------- Register Table -------->\n"));
+
+    if (pIrqProcRegs != NULL) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("Int Status:               0x%x\n",pIrqProcRegs->host_int_status));
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("CPU Int Status:            0x%x\n",pIrqProcRegs->cpu_int_status));
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("Error Int Status:          0x%x\n",pIrqProcRegs->error_int_status));
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("Counter Int Status:        0x%x\n",pIrqProcRegs->counter_int_status));
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("Mbox Frame:                0x%x\n",pIrqProcRegs->mbox_frame));
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("Rx Lookahead Valid:        0x%x\n",pIrqProcRegs->rx_lookahead_valid));
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("Rx Lookahead 0:            0x%x\n",pIrqProcRegs->rx_lookahead[0]));
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("Rx Lookahead 1:            0x%x\n",pIrqProcRegs->rx_lookahead[1]));
+    }
+
+    if (pIrqEnableRegs != NULL) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("Int Status Enable:         0x%x\n",pIrqEnableRegs->int_status_enable));
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("Counter Int Status Enable: 0x%x\n",pIrqEnableRegs->counter_int_status_enable));
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP, ("<------------------------------->\n"));
+    }
+}
+
+
+#ifdef MBOXHW_UNIT_TEST
+
+
+/* This is a mailbox hardware unit test that must be called in a schedulable context
+ * This test is very simple, it will send a list of buffers with a counting pattern
+ * and the target will invert the data and send the message back
+ *
+ * the unit test has the following constraints:
+ *
+ * The target has at least 8 buffers of 256 bytes each. The host will send
+ * the following pattern of buffers in rapid succession :
+ *
+ * 1 buffer - 128 bytes
+ * 1 buffer - 256 bytes
+ * 1 buffer - 512 bytes
+ * 1 buffer - 1024 bytes
+ *
+ * The host will send the buffers to one mailbox and wait for buffers to be reflected
+ * back from the same mailbox. The target sends the buffers FIFO order.
+ * Once the final buffer has been received for a mailbox, the next mailbox is tested.
+ *
+ *
+ * Note:  To simplifythe test , we assume that the chosen buffer sizes
+ *        will fall on a nice block pad
+ *
+ * It is expected that higher-order tests will be written to stress the mailboxes using
+ * a message-based protocol (with some performance timming) that can create more
+ * randomness in the packets sent over mailboxes.
+ *
+ * */
+
+#define A_ROUND_UP_PWR2(x, align)    (((int) (x) + ((align)-1)) & ~((align)-1))
+
+#define BUFFER_BLOCK_PAD 128
+
+#if 0
+#define BUFFER1 128
+#define BUFFER2 256
+#define BUFFER3 512
+#define BUFFER4 1024
+#endif
+
+#if 1
+#define BUFFER1 80
+#define BUFFER2 200
+#define BUFFER3 444
+#define BUFFER4 800
+#endif
+
+#define TOTAL_BYTES (A_ROUND_UP_PWR2(BUFFER1,BUFFER_BLOCK_PAD) + \
+                     A_ROUND_UP_PWR2(BUFFER2,BUFFER_BLOCK_PAD) + \
+                     A_ROUND_UP_PWR2(BUFFER3,BUFFER_BLOCK_PAD) + \
+                     A_ROUND_UP_PWR2(BUFFER4,BUFFER_BLOCK_PAD) )
+
+#define TEST_BYTES (BUFFER1 +  BUFFER2 + BUFFER3 + BUFFER4)
+
+#define TEST_CREDITS_RECV_TIMEOUT 100
+
+static A_UINT8  g_Buffer[TOTAL_BYTES];
+static A_UINT32 g_MailboxAddrs[AR6K_MAILBOXES];
+static A_UINT32 g_BlockSizes[AR6K_MAILBOXES];
+
+#define BUFFER_PROC_LIST_DEPTH 4
+
+typedef struct _BUFFER_PROC_LIST{
+    A_UINT8  *pBuffer;
+    A_UINT32 length;
+}BUFFER_PROC_LIST;
+
+
+#define PUSH_BUFF_PROC_ENTRY(pList,len,pCurrpos) \
+{                                                   \
+    (pList)->pBuffer = (pCurrpos);                  \
+    (pList)->length = (len);                        \
+    (pCurrpos) += (len);                            \
+    (pList)++;                                      \
+}
+
+/* a simple and crude way to send different "message" sizes */
+static void AssembleBufferList(BUFFER_PROC_LIST *pList)
+{
+    A_UINT8 *pBuffer = g_Buffer;
+
+#if BUFFER_PROC_LIST_DEPTH < 4
+#error "Buffer processing list depth is not deep enough!!"
+#endif
+
+    PUSH_BUFF_PROC_ENTRY(pList,BUFFER1,pBuffer);
+    PUSH_BUFF_PROC_ENTRY(pList,BUFFER2,pBuffer);
+    PUSH_BUFF_PROC_ENTRY(pList,BUFFER3,pBuffer);
+    PUSH_BUFF_PROC_ENTRY(pList,BUFFER4,pBuffer);
+
+}
+
+#define FILL_ZERO     TRUE
+#define FILL_COUNTING FALSE
+static void InitBuffers(A_BOOL Zero)
+{
+    A_UINT16 *pBuffer16 = (A_UINT16 *)g_Buffer;
+    int      i;
+
+        /* fill buffer with 16 bit counting pattern or zeros */
+    for (i = 0; i <  (TOTAL_BYTES / 2) ; i++) {
+        if (!Zero) {
+            pBuffer16[i] = (A_UINT16)i;
+        } else {
+            pBuffer16[i] = 0;
+        }
+    }
+}
+
+
+static A_BOOL CheckOneBuffer(A_UINT16 *pBuffer16, int Length)
+{
+    int      i;
+    A_UINT16 startCount;
+    A_BOOL   success = TRUE;
+
+        /* get the starting count */
+    startCount = pBuffer16[0];
+        /* invert it, this is the expected value */
+    startCount = ~startCount;
+        /* scan the buffer and verify */
+    for (i = 0; i < (Length / 2) ; i++,startCount++) {
+            /* target will invert all the data */
+        if ((A_UINT16)pBuffer16[i] != (A_UINT16)~startCount) {
+            success = FALSE;
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Invalid Data Got:0x%X, Expecting:0x%X (offset:%d, total:%d) \n",
+                        pBuffer16[i], ((A_UINT16)~startCount), i, Length));
+             AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("0x%X 0x%X 0x%X 0x%X \n",
+                        pBuffer16[i], pBuffer16[i + 1], pBuffer16[i + 2],pBuffer16[i+3]));
+            break;
+        }
+    }
+
+    return success;
+}
+
+static A_BOOL CheckBuffers(void)
+{
+    int      i;
+    A_BOOL   success = TRUE;
+    BUFFER_PROC_LIST checkList[BUFFER_PROC_LIST_DEPTH];
+
+        /* assemble the list */
+    AssembleBufferList(checkList);
+
+        /* scan the buffers and verify */
+    for (i = 0; i < BUFFER_PROC_LIST_DEPTH ; i++) {
+        success = CheckOneBuffer((A_UINT16 *)checkList[i].pBuffer, checkList[i].length);
+        if (!success) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Buffer : 0x%X, Length:%d failed verify \n",
+                        (A_UINT32)checkList[i].pBuffer, checkList[i].length));
+            break;
+        }
+    }
+
+    return success;
+}
+
+    /* find the end marker for the last buffer we will be sending */
+static A_UINT16 GetEndMarker(void)
+{
+    A_UINT8  *pBuffer;
+    BUFFER_PROC_LIST checkList[BUFFER_PROC_LIST_DEPTH];
+
+        /* fill up buffers with the normal counting pattern */
+    InitBuffers(FILL_COUNTING);
+
+        /* assemble the list we will be sending down */
+    AssembleBufferList(checkList);
+        /* point to the last 2 bytes of the last buffer */
+    pBuffer = &(checkList[BUFFER_PROC_LIST_DEPTH - 1].pBuffer[(checkList[BUFFER_PROC_LIST_DEPTH - 1].length) - 2]);
+
+        /* the last count in the last buffer is the marker */
+    return (A_UINT16)pBuffer[0] | ((A_UINT16)pBuffer[1] << 8);
+}
+
+#define ATH_PRINT_OUT_ZONE ATH_DEBUG_ERR
+
+/* send the ordered buffers to the target */
+static A_STATUS SendBuffers(AR6K_DEVICE *pDev, int mbox)
+{
+    A_STATUS         status = A_OK;
+    A_UINT32         request = HIF_WR_SYNC_BLOCK_INC;
+    BUFFER_PROC_LIST sendList[BUFFER_PROC_LIST_DEPTH];
+    int              i;
+    int              totalBytes = 0;
+    int              paddedLength;
+    int              totalwPadding = 0;
+
+    AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Sending buffers on mailbox : %d \n",mbox));
+
+        /* fill buffer with counting pattern */
+    InitBuffers(FILL_COUNTING);
+
+        /* assemble the order in which we send */
+    AssembleBufferList(sendList);
+
+    for (i = 0; i < BUFFER_PROC_LIST_DEPTH; i++) {
+
+            /* we are doing block transfers, so we need to pad everything to a block size */
+        paddedLength = (sendList[i].length + (g_BlockSizes[mbox] - 1)) &
+                       (~(g_BlockSizes[mbox] - 1));
+
+            /* send each buffer synchronously */
+        status = HIFReadWrite(pDev->HIFDevice,
+                              g_MailboxAddrs[mbox],
+                              sendList[i].pBuffer,
+                              paddedLength,
+                              request,
+                              NULL);
+        if (status != A_OK) {
+            break;
+        }
+        totalBytes += sendList[i].length;
+        totalwPadding += paddedLength;
+    }
+
+    AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Sent %d bytes (%d padded bytes) to mailbox : %d \n",totalBytes,totalwPadding,mbox));
+
+    return status;
+}
+
+/* poll the mailbox credit counter until we get a credit or timeout */
+static A_STATUS GetCredits(AR6K_DEVICE *pDev, int mbox, int *pCredits)
+{
+    A_STATUS status = A_OK;
+    int      timeout = TEST_CREDITS_RECV_TIMEOUT;
+    A_UINT8  credits = 0;
+    A_UINT32 address;
+
+    while (TRUE) {
+
+            /* Read the counter register to get credits, this auto-decrements  */
+        address = COUNT_DEC_ADDRESS + (AR6K_MAILBOXES + mbox) * 4;
+        status = HIFReadWrite(pDev->HIFDevice, address, &credits, sizeof(credits),
+                              HIF_RD_SYNC_BYTE_FIX, NULL);
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                ("Unable to decrement the command credit count register (mbox=%d)\n",mbox));
+            status = A_ERROR;
+            break;
+        }
+
+        if (credits) {
+            break;
+        }
+
+        timeout--;
+
+        if (timeout <= 0) {
+              AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                (" Timeout reading credit registers (mbox=%d, address:0x%X) \n",mbox,address));
+            status = A_ERROR;
+            break;
+        }
+
+         /* delay a little, target may not be ready */
+         A_MDELAY(1000);
+
+    }
+
+    if (status == A_OK) {
+        *pCredits = credits;
+    }
+
+    return status;
+}
+
+
+/* wait for the buffers to come back */
+static A_STATUS RecvBuffers(AR6K_DEVICE *pDev, int mbox)
+{
+    A_STATUS         status = A_OK;
+    A_UINT32         request = HIF_RD_SYNC_BLOCK_INC;
+    BUFFER_PROC_LIST recvList[BUFFER_PROC_LIST_DEPTH];
+    int              curBuffer;
+    int              credits;
+    int              i;
+    int              totalBytes = 0;
+    int              paddedLength;
+    int              totalwPadding = 0;
+
+    AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Waiting for buffers on mailbox : %d \n",mbox));
+
+        /* zero the buffers */
+    InitBuffers(FILL_ZERO);
+
+        /* assemble the order in which we should receive */
+    AssembleBufferList(recvList);
+
+    curBuffer = 0;
+
+    while (curBuffer < BUFFER_PROC_LIST_DEPTH) {
+
+            /* get number of buffers that have been completed, this blocks
+             * until we get at least 1 credit or it times out */
+        status = GetCredits(pDev, mbox, &credits);
+
+        if (status != A_OK) {
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Got %d messages on mailbox : %d \n",credits, mbox));
+
+            /* get all the buffers that are sitting on the queue */
+        for (i = 0; i < credits; i++) {
+            AR_DEBUG_ASSERT(curBuffer < BUFFER_PROC_LIST_DEPTH);
+                /* recv the current buffer synchronously, the buffers should come back in
+                 * order... with padding applied by the target */
+            paddedLength = (recvList[curBuffer].length + (g_BlockSizes[mbox] - 1)) &
+                       (~(g_BlockSizes[mbox] - 1));
+
+            status = HIFReadWrite(pDev->HIFDevice,
+                                  g_MailboxAddrs[mbox],
+                                  recvList[curBuffer].pBuffer,
+                                  paddedLength,
+                                  request,
+                                  NULL);
+            if (status != A_OK) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Failed to read %d bytes on mailbox:%d : address:0x%X \n",
+                        recvList[curBuffer].length, mbox, g_MailboxAddrs[mbox]));
+                break;
+            }
+
+            totalwPadding += paddedLength;
+            totalBytes += recvList[curBuffer].length;
+            curBuffer++;
+        }
+
+        if (status != A_OK) {
+            break;
+        }
+            /* go back and get some more */
+        credits = 0;
+    }
+
+    if (totalBytes != TEST_BYTES) {
+        AR_DEBUG_ASSERT(FALSE);
+    }  else {
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Got all buffers on mbox:%d total recv :%d (w/Padding : %d) \n",
+            mbox, totalBytes, totalwPadding));
+    }
+
+    return status;
+
+
+}
+
+static A_STATUS DoOneMboxHWTest(AR6K_DEVICE *pDev, int mbox)
+{
+    A_STATUS status;
+
+    do {
+            /* send out buffers */
+        status = SendBuffers(pDev,mbox);
+
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Sending buffers Failed : %d mbox:%d\n",status,mbox));
+            break;
+        }
+
+            /* go get them, this will block */
+        status =  RecvBuffers(pDev, mbox);
+
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Recv buffers Failed : %d mbox:%d\n",status,mbox));
+            break;
+        }
+
+            /* check the returned data patterns */
+        if (!CheckBuffers()) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Buffer Verify Failed : mbox:%d\n",mbox));
+            status = A_ERROR;
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, (" Send/Recv success! mailbox : %d \n",mbox));
+
+    }  while (FALSE);
+
+    return status;
+}
+
+/* here is where the test starts */
+A_STATUS DoMboxHWTest(AR6K_DEVICE *pDev)
+{
+    int      i;
+    A_STATUS status;
+    int      credits = 0;
+    A_UINT8  params[4];
+    int      numBufs;
+    int      bufferSize;
+    A_UINT16 temp;
+
+
+    AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, (" DoMboxHWTest START -  \n"));
+
+    do {
+            /* get the addresses for all 4 mailboxes */
+        status = HIFConfigureDevice(pDev->HIFDevice, HIF_DEVICE_GET_MBOX_ADDR,
+                                    g_MailboxAddrs, sizeof(g_MailboxAddrs));
+
+        if (status != A_OK) {
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+
+            /* get the block sizes */
+        status = HIFConfigureDevice(pDev->HIFDevice, HIF_DEVICE_GET_MBOX_BLOCK_SIZE,
+                                    g_BlockSizes, sizeof(g_BlockSizes));
+
+        if (status != A_OK) {
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+
+            /* note, the HIF layer usually reports mbox 0 to have a block size of
+             * 1, but our test wants to run in block-mode for all mailboxes, so we treat all mailboxes
+             * the same. */
+        g_BlockSizes[0] = g_BlockSizes[1];
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Block Size to use: %d \n",g_BlockSizes[0]));
+
+        if (g_BlockSizes[1] > BUFFER_BLOCK_PAD) {
+            AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("%d Block size is too large for buffer pad %d\n",
+                g_BlockSizes[1], BUFFER_BLOCK_PAD));
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Waiting for target.... \n"));
+
+            /* the target lets us know it is ready by giving us 1 credit on
+             * mailbox 0 */
+        status = GetCredits(pDev, 0, &credits);
+
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Failed to wait for target ready \n"));
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Target is ready ...\n"));
+
+            /* read the first 4 scratch registers */
+        status = HIFReadWrite(pDev->HIFDevice,
+                              SCRATCH_ADDRESS,
+                              params,
+                              4,
+                              HIF_RD_SYNC_BYTE_INC,
+                              NULL);
+
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Failed to wait get parameters \n"));
+            break;
+        }
+
+        numBufs = params[0];
+        bufferSize = (int)(((A_UINT16)params[2] << 8) | (A_UINT16)params[1]);
+
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE,
+            ("Target parameters: bufs per mailbox:%d, buffer size:%d bytes (total space: %d, minimum required space (w/padding): %d) \n",
+            numBufs, bufferSize, (numBufs * bufferSize), TOTAL_BYTES));
+
+        if ((numBufs * bufferSize) < TOTAL_BYTES) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Not Enough buffer space to run test! need:%d, got:%d \n",
+                TOTAL_BYTES, (numBufs*bufferSize)));
+            status = A_ERROR;
+            break;
+        }
+
+        temp = GetEndMarker();
+
+        status = HIFReadWrite(pDev->HIFDevice,
+                              SCRATCH_ADDRESS + 4,
+                              (A_UINT8 *)&temp,
+                              2,
+                              HIF_WR_SYNC_BYTE_INC,
+                              NULL);
+
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Failed to write end marker \n"));
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("End Marker: 0x%X \n",temp));
+
+        temp = (A_UINT16)g_BlockSizes[1];
+            /* convert to a mask */
+        temp = temp - 1;
+        status = HIFReadWrite(pDev->HIFDevice,
+                              SCRATCH_ADDRESS + 6,
+                              (A_UINT8 *)&temp,
+                              2,
+                              HIF_WR_SYNC_BYTE_INC,
+                              NULL);
+
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Failed to write block mask \n"));
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Set Block Mask: 0x%X \n",temp));
+
+            /* execute the test on each mailbox */
+        for (i = 0; i < AR6K_MAILBOXES; i++) {
+            status = DoOneMboxHWTest(pDev, i);
+            if (status != A_OK) {
+                break;
+            }
+        }
+
+    } while (FALSE);
+
+    if (status == A_OK) {
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, (" DoMboxHWTest DONE - SUCCESS! -  \n"));
+    } else {
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, (" DoMboxHWTest DONE - FAILED! -  \n"));
+    }
+        /* don't let HTC_Start continue, the target is actually not running any HTC code */
+    return A_ERROR;
+}
+#endif
+
+
+
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/htc/ar6k_events.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/htc/ar6k_events.c
@@ -0,0 +1,650 @@
+/*
+ * AR6K Driver layer event handling (i.e. interrupts, message polling)
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+#include "../include/config.h"
+#include "../include/athdefs.h"
+#include "../include/athtypes.h"
+#include "../include/mbox_host_reg.h"
+#include "../include/osapi.h"
+#include "../include/debug.h"
+#include "../include/hif.h"
+#include "../include/htc_packet.h"
+#include "../include/ar6k.h"
+
+extern void AR6KFreeIOPacket(AR6K_DEVICE *pDev, HTC_PACKET *pPacket);
+extern HTC_PACKET *AR6KAllocIOPacket(AR6K_DEVICE *pDev);
+
+static A_STATUS DevServiceDebugInterrupt(AR6K_DEVICE *pDev);
+
+#define DELAY_PER_INTERVAL_MS 10  /* 10 MS delay per polling interval */
+
+/* completion routine for ALL HIF layer async I/O */
+A_STATUS DevRWCompletionHandler(void *context, A_STATUS status)
+{
+    HTC_PACKET *pPacket = (HTC_PACKET *)context;
+
+    COMPLETE_HTC_PACKET(pPacket,status);
+
+    return A_OK;
+}
+
+/* mailbox recv message polling */
+A_STATUS DevPollMboxMsgRecv(AR6K_DEVICE *pDev,
+                            A_UINT32    *pLookAhead,
+                            int          TimeoutMS)
+{
+    A_STATUS status = A_OK;
+    int      timeout = TimeoutMS/DELAY_PER_INTERVAL_MS;
+
+    AR_DEBUG_ASSERT(timeout > 0);
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV,("+DevPollMboxMsgRecv \n"));
+
+    while (TRUE) {
+
+        if (pDev->GetPendingEventsFunc != NULL)
+		{
+
+            HIF_PENDING_EVENTS_INFO events;
+
+            /* the HIF layer uses a special mechanism to get events, do this
+             * synchronously */
+            status = pDev->GetPendingEventsFunc(pDev->HIFDevice,
+                                            &events,
+                                            NULL);
+            if (A_FAILED(status))
+			{
+                AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Failed to get pending events \n"));
+				break;
+            }
+
+            if (events.Events & HIF_RECV_MSG_AVAIL)
+			{
+                    /*  there is a message available, the lookahead should be valid now */
+                *pLookAhead = events.LookAhead;
+
+                break;
+            }
+        }
+		else
+		{
+
+                /* this is the standard HIF way.... */
+                /* load the register table */
+            status = HIFReadWrite(pDev->HIFDevice,
+                                  HOST_INT_STATUS_ADDRESS,
+                                  (A_UINT8 *)&pDev->IrqProcRegisters,
+                                  AR6K_IRQ_PROC_REGS_SIZE,
+                                  HIF_RD_SYNC_BYTE_INC,
+                                  NULL);
+
+            if (A_FAILED(status))
+			{
+                AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Failed to read register table \n"));
+                break;
+            }
+
+                /* check for MBOX data and valid lookahead */
+            if (pDev->IrqProcRegisters.host_int_status & (1 << HTC_MAILBOX))
+			{
+                if (pDev->IrqProcRegisters.rx_lookahead_valid & (1 << HTC_MAILBOX))
+				{
+                    /* mailbox has a message and the look ahead is valid */
+                    *pLookAhead = pDev->IrqProcRegisters.rx_lookahead[HTC_MAILBOX];
+                    break;
+                }
+            }
+
+        }
+
+        timeout--;
+
+        if (timeout <= 0)
+		{
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (" Timeout waiting for recv message \n"));
+            status = A_ERROR;
+
+                /* check if the target asserted */
+            if ( pDev->IrqProcRegisters.counter_int_status & AR6K_TARGET_DEBUG_INTR_MASK) {
+                    /* target signaled an assert, process this pending interrupt
+                     * this will call the target failure handler */
+                DevServiceDebugInterrupt(pDev);
+            }
+
+            break;
+        }
+
+            /* delay a little  */
+         A_MSLEEP(DELAY_PER_INTERVAL_MS);
+         AR_DEBUG_PRINTF(ATH_DEBUG_RECV,("  Retry Mbox Poll : %d \n",timeout));
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV,("-DevPollMboxMsgRecv \n"));
+
+    return status;
+}
+
+static A_STATUS DevServiceCPUInterrupt(AR6K_DEVICE *pDev)
+{
+    A_STATUS status;
+    A_UINT8  cpu_int_status;
+    A_UINT8  regBuffer[4];
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ, ("CPU Interrupt\n"));
+    cpu_int_status = pDev->IrqProcRegisters.cpu_int_status &
+                     pDev->IrqEnableRegisters.cpu_int_status_enable;
+    AR_DEBUG_ASSERT(cpu_int_status);
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,
+                    ("Valid interrupt source(s) in CPU_INT_STATUS: 0x%x\n",
+                    cpu_int_status));
+
+        /* Clear the interrupt */
+    pDev->IrqProcRegisters.cpu_int_status &= ~cpu_int_status; /* W1C */
+
+        /* set up the register transfer buffer to hit the register 4 times , this is done
+         * to make the access 4-byte aligned to mitigate issues with host bus interconnects that
+         * restrict bus transfer lengths to be a multiple of 4-bytes */
+
+        /* set W1C value to clear the interrupt, this hits the register first */
+    regBuffer[0] = cpu_int_status;
+        /* the remaining 4 values are set to zero which have no-effect  */
+    regBuffer[1] = 0;
+    regBuffer[2] = 0;
+    regBuffer[3] = 0;
+
+    status = HIFReadWrite(pDev->HIFDevice,
+                          CPU_INT_STATUS_ADDRESS,
+                          regBuffer,
+                          4,
+                          HIF_WR_SYNC_BYTE_FIX,
+                          NULL);
+
+    AR_DEBUG_ASSERT(status == A_OK);
+    return status;
+}
+
+
+static A_STATUS DevServiceErrorInterrupt(AR6K_DEVICE *pDev)
+{
+    A_STATUS status;
+    A_UINT8  error_int_status;
+    A_UINT8  regBuffer[4];
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ, ("Error Interrupt\n"));
+    error_int_status = pDev->IrqProcRegisters.error_int_status & 0x0F;
+    AR_DEBUG_ASSERT(error_int_status);
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,
+                    ("Valid interrupt source(s) in ERROR_INT_STATUS: 0x%x\n",
+                    error_int_status));
+
+    if (ERROR_INT_STATUS_WAKEUP_GET(error_int_status)) {
+        /* Wakeup */
+        AR_DEBUG_PRINTF(ATH_DEBUG_IRQ, ("Error : Wakeup\n"));
+    }
+
+    if (ERROR_INT_STATUS_RX_UNDERFLOW_GET(error_int_status)) {
+        /* Rx Underflow */
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Error : Rx Underflow\n"));
+    }
+
+    if (ERROR_INT_STATUS_TX_OVERFLOW_GET(error_int_status)) {
+        /* Tx Overflow */
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Error : Tx Overflow\n"));
+    }
+
+        /* Clear the interrupt */
+    pDev->IrqProcRegisters.error_int_status &= ~error_int_status; /* W1C */
+
+        /* set up the register transfer buffer to hit the register 4 times , this is done
+         * to make the access 4-byte aligned to mitigate issues with host bus interconnects that
+         * restrict bus transfer lengths to be a multiple of 4-bytes */
+
+        /* set W1C value to clear the interrupt, this hits the register first */
+    regBuffer[0] = error_int_status;
+        /* the remaining 4 values are set to zero which have no-effect  */
+    regBuffer[1] = 0;
+    regBuffer[2] = 0;
+    regBuffer[3] = 0;
+
+    status = HIFReadWrite(pDev->HIFDevice,
+                          ERROR_INT_STATUS_ADDRESS,
+                          regBuffer,
+                          4,
+                          HIF_WR_SYNC_BYTE_FIX,
+                          NULL);
+
+    AR_DEBUG_ASSERT(status == A_OK);
+    return status;
+}
+
+static A_STATUS DevServiceDebugInterrupt(AR6K_DEVICE *pDev)
+{
+    A_UINT32 dummy;
+    A_STATUS status;
+
+    /* Send a target failure event to the application */
+    AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Target debug interrupt\n"));
+
+    if (pDev->TargetFailureCallback != NULL) {
+        pDev->TargetFailureCallback(pDev->HTCContext);
+    }
+
+    /* clear the interrupt , the debug error interrupt is
+     * counter 0 */
+        /* read counter to clear interrupt */
+    status = HIFReadWrite(pDev->HIFDevice,
+                          COUNT_DEC_ADDRESS,
+                          (A_UINT8 *)&dummy,
+                          4,
+                          HIF_RD_SYNC_BYTE_INC,
+                          NULL);
+
+    AR_DEBUG_ASSERT(status == A_OK);
+    return status;
+}
+
+static A_STATUS DevServiceCounterInterrupt(AR6K_DEVICE *pDev)
+{
+    A_UINT8 counter_int_status;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ, ("Counter Interrupt\n"));
+
+    counter_int_status = pDev->IrqProcRegisters.counter_int_status &
+                         pDev->IrqEnableRegisters.counter_int_status_enable;
+
+    AR_DEBUG_ASSERT(counter_int_status);
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,
+                    ("Valid interrupt source(s) in COUNTER_INT_STATUS: 0x%x\n",
+                    counter_int_status));
+
+    /* Check if the debug interrupt is pending */
+    if (counter_int_status & AR6K_TARGET_DEBUG_INTR_MASK) {
+        return DevServiceDebugInterrupt(pDev);
+    }
+
+    return A_OK;
+}
+
+/* callback when our fetch to get interrupt status registers completes */
+static void DevGetEventAsyncHandler(void *Context, HTC_PACKET *pPacket)
+{
+    AR6K_DEVICE *pDev = (AR6K_DEVICE *)Context;
+    A_UINT32    lookAhead = 0;
+    A_BOOL      otherInts = FALSE;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("+DevGetEventAsyncHandler: (dev: 0x%X)\n", (A_UINT32)pDev));
+
+    do {
+
+        if (A_FAILED(pPacket->Status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                    (" GetEvents I/O request failed, status:%d \n", pPacket->Status));
+            /* bail out, don't unmask HIF interrupt */
+            break;
+        }
+
+        if (pDev->GetPendingEventsFunc != NULL) {
+                /* the HIF layer collected the information for us */
+            HIF_PENDING_EVENTS_INFO *pEvents = (HIF_PENDING_EVENTS_INFO *)pPacket->pBuffer;
+            if (pEvents->Events & HIF_RECV_MSG_AVAIL) {
+                lookAhead = pEvents->LookAhead;
+                if (0 == lookAhead) {
+                    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" DevGetEventAsyncHandler1, lookAhead is zero! \n"));
+                }
+            }
+            if (pEvents->Events & HIF_OTHER_EVENTS) {
+                otherInts = TRUE;
+            }
+        } else {
+                /* standard interrupt table handling.... */
+            AR6K_IRQ_PROC_REGISTERS *pReg = (AR6K_IRQ_PROC_REGISTERS *)pPacket->pBuffer;
+            A_UINT8                 host_int_status;
+
+            host_int_status = pReg->host_int_status & pDev->IrqEnableRegisters.int_status_enable;
+
+            if (host_int_status & (1 << HTC_MAILBOX)) {
+                host_int_status &= ~(1 << HTC_MAILBOX);
+                if (pReg->rx_lookahead_valid & (1 << HTC_MAILBOX)) {
+                        /* mailbox has a message and the look ahead is valid */
+                    lookAhead = pReg->rx_lookahead[HTC_MAILBOX];
+                    if (0 == lookAhead) {
+                        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" DevGetEventAsyncHandler2, lookAhead is zero! \n"));
+                    }
+                }
+            }
+
+            if (host_int_status) {
+                    /* there are other interrupts to handle */
+                otherInts = TRUE;
+            }
+        }
+
+        if (otherInts || (lookAhead == 0)) {
+            /* if there are other interrupts to process, we cannot do this in the async handler so
+             * ack the interrupt which will cause our sync handler to run again
+             * if however there are no more messages, we can now ack the interrupt  */
+            AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,
+                (" Acking interrupt from DevGetEventAsyncHandler (otherints:%d, lookahead:0x%X)\n",
+                otherInts, lookAhead));
+            HIFAckInterrupt(pDev->HIFDevice);
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,
+                    (" DevGetEventAsyncHandler : detected another message, lookahead :0x%X \n",
+                    lookAhead));
+                /* lookahead is non-zero and there are no other interrupts to service,
+                 * go get the next message */
+            pDev->MessagePendingCallback(pDev->HTCContext, &lookAhead, NULL);
+        }
+
+    } while (FALSE);
+
+        /* free this IO packet */
+    AR6KFreeIOPacket(pDev,pPacket);
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("-DevGetEventAsyncHandler \n"));
+}
+
+/* called by the HTC layer when it wants us to check if the device has any more pending
+ * recv messages, this starts off a series of async requests to read interrupt registers  */
+A_STATUS DevCheckPendingRecvMsgsAsync(void *context)
+{
+    AR6K_DEVICE  *pDev = (AR6K_DEVICE *)context;
+    A_STATUS      status = A_OK;
+    HTC_PACKET   *pIOPacket;
+
+    /* this is called in an ASYNC only context, we may NOT block, sleep or call any apis that can
+     * cause us to switch contexts */
+
+   AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("+DevCheckPendingRecvMsgsAsync: (dev: 0x%X)\n", (A_UINT32)pDev));
+
+   do {
+
+        if (HIF_DEVICE_IRQ_SYNC_ONLY == pDev->HifIRQProcessingMode) {
+                /* break the async processing chain right here, no need to continue.
+                 * The DevDsrHandler() will handle things in a loop when things are driven
+                 * synchronously  */
+            break;
+        }
+            /* first allocate one of our HTC packets we created for async I/O
+             * we reuse HTC packet definitions so that we can use the completion mechanism
+             * in DevRWCompletionHandler() */
+        pIOPacket = AR6KAllocIOPacket(pDev);
+
+        if (NULL == pIOPacket) {
+                /* there should be only 1 asynchronous request out at a time to read these registers
+                 * so this should actually never happen */
+            status = A_NO_MEMORY;
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+
+            /* stick in our completion routine when the I/O operation completes */
+        pIOPacket->Completion = DevGetEventAsyncHandler;
+        pIOPacket->pContext = pDev;
+
+        if (pDev->GetPendingEventsFunc) {
+                /* HIF layer has it's own mechanism, pass the IO to it.. */
+            status = pDev->GetPendingEventsFunc(pDev->HIFDevice,
+                                                (HIF_PENDING_EVENTS_INFO *)pIOPacket->pBuffer,
+                                                pIOPacket);
+
+        } else {
+                /* standard way, read the interrupt register table asynchronously again */
+            status = HIFReadWrite(pDev->HIFDevice,
+                                  HOST_INT_STATUS_ADDRESS,
+                                  pIOPacket->pBuffer,
+                                  AR6K_IRQ_PROC_REGS_SIZE,
+                                  HIF_RD_ASYNC_BYTE_INC,
+                                  pIOPacket);
+        }
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,(" Async IO issued to get interrupt status...\n"));
+   } while (FALSE);
+
+   AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("-DevCheckPendingRecvMsgsAsync \n"));
+
+   return status;
+}
+
+/* process pending interrupts synchronously */
+static A_STATUS ProcessPendingIRQs(AR6K_DEVICE *pDev, A_BOOL *pDone, A_BOOL *pASyncProcessing)
+{
+    A_STATUS    status = A_OK;
+    A_UINT8     host_int_status = 0;
+    A_UINT32    lookAhead = 0;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("+ProcessPendingIRQs: (dev: 0x%X)\n", (A_UINT32)pDev));
+
+    /*** NOTE: the HIF implementation guarantees that the context of this call allows
+     *         us to perform SYNCHRONOUS I/O, that is we can block, sleep or call any API that
+     *         can block or switch thread/task ontexts.
+     *         This is a fully schedulable context.
+     * */
+    do {
+
+        if (pDev->IrqEnableRegisters.int_status_enable == 0) {
+            /* interrupt enables have been cleared, do not try to process any pending interrupts that
+             * may result in more bus transactions.  The target may be unresponsive at this
+             * point. */
+             break;
+        }
+
+        if (pDev->GetPendingEventsFunc != NULL) {
+            HIF_PENDING_EVENTS_INFO events;
+
+                /* the HIF layer uses a special mechanism to get events
+                 * get this synchronously  */
+            status = pDev->GetPendingEventsFunc(pDev->HIFDevice,
+                                                &events,
+                                                NULL);
+
+            if (A_FAILED(status)) {
+                break;
+            }
+
+            if (events.Events & HIF_RECV_MSG_AVAIL) {
+                lookAhead = events.LookAhead;
+                if (0 == lookAhead) {
+                    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" ProcessPendingIRQs1 lookAhead is zero! \n"));
+                }
+            }
+
+            if (!(events.Events & HIF_OTHER_EVENTS) ||
+                !(pDev->IrqEnableRegisters.int_status_enable & OTHER_INTS_ENABLED)) {
+                    /* no need to read the register table, no other interesting interrupts.
+                     * Some interfaces (like SPI) can shadow interrupt sources without
+                     * requiring the host to do a full table read */
+                break;
+            }
+
+            /* otherwise fall through and read the register table */
+        }
+
+        /*
+         * Read the first 28 bytes of the HTC register table. This will yield us
+         * the value of different int status registers and the lookahead
+         * registers.
+         *    length = sizeof(int_status) + sizeof(cpu_int_status) +
+         *             sizeof(error_int_status) + sizeof(counter_int_status) +
+         *             sizeof(mbox_frame) + sizeof(rx_lookahead_valid) +
+         *             sizeof(hole) +  sizeof(rx_lookahead) +
+         *             sizeof(int_status_enable) + sizeof(cpu_int_status_enable) +
+         *             sizeof(error_status_enable) +
+         *             sizeof(counter_int_status_enable);
+         *
+        */
+        status = HIFReadWrite(pDev->HIFDevice,
+                              HOST_INT_STATUS_ADDRESS,
+                              (A_UINT8 *)&pDev->IrqProcRegisters,
+                              AR6K_IRQ_PROC_REGS_SIZE,
+                              HIF_RD_SYNC_BYTE_INC,
+                              NULL);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        if (AR_DEBUG_LVL_CHECK(ATH_DEBUG_IRQ)) {
+            DevDumpRegisters(&pDev->IrqProcRegisters,
+                             &pDev->IrqEnableRegisters);
+        }
+
+            /* Update only those registers that are enabled */
+        host_int_status = pDev->IrqProcRegisters.host_int_status &
+                          pDev->IrqEnableRegisters.int_status_enable;
+
+        if (NULL == pDev->GetPendingEventsFunc) {
+                /* only look at mailbox status if the HIF layer did not provide this function,
+                 * on some HIF interfaces reading the RX lookahead is not valid to do */
+            if (host_int_status & (1 << HTC_MAILBOX)) {
+                    /* mask out pending mailbox value, we use "lookAhead" as the real flag for
+                     * mailbox processing below */
+                host_int_status &= ~(1 << HTC_MAILBOX);
+                if (pDev->IrqProcRegisters.rx_lookahead_valid & (1 << HTC_MAILBOX)) {
+                        /* mailbox has a message and the look ahead is valid */
+                    lookAhead = pDev->IrqProcRegisters.rx_lookahead[HTC_MAILBOX];
+                    if (0 == lookAhead) {
+                        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" ProcessPendingIRQs2, lookAhead is zero! \n"));
+                    }
+                }
+            }
+        } else {
+                /* not valid to check if the HIF has another mechanism for reading mailbox pending status*/
+            host_int_status &= ~(1 << HTC_MAILBOX);
+        }
+
+    } while (FALSE);
+
+
+    do {
+
+            /* did the interrupt status fetches succeed? */
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        if ((0 == host_int_status) && (0 == lookAhead)) {
+                /* nothing to process, the caller can use this to break out of a loop */
+            *pDone = TRUE;
+            break;
+        }
+
+        if (lookAhead != 0) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("Pending mailbox message, LookAhead: 0x%X\n",lookAhead));
+                /* Mailbox Interrupt, the HTC layer may issue async requests to empty the
+                 * mailbox...
+                 * When emptying the recv mailbox we use the async handler above called from the
+                 * completion routine of the callers read request. This can improve performance
+                 * by reducing context switching when we rapidly pull packets */
+            status = pDev->MessagePendingCallback(pDev->HTCContext, &lookAhead, pASyncProcessing);
+            if (A_FAILED(status)) {
+                break;
+            }
+            /* if sync processing of Rx packets is enabled and lookahead of last packet is 0, then
+             * we can avoid extra CMD53 16-byte read above by setting pDone = TRUE */
+            if ((lookAhead == 0) && (*pASyncProcessing == FALSE)) {
+                *pDone = TRUE;
+            }
+        }
+
+            /* now handle the rest of them */
+        AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,
+                            (" Valid interrupt source(s) for OTHER interrupts: 0x%x\n",
+                            host_int_status));
+
+        if (HOST_INT_STATUS_CPU_GET(host_int_status)) {
+                /* CPU Interrupt */
+            status = DevServiceCPUInterrupt(pDev);
+            if (A_FAILED(status)){
+                break;
+            }
+        }
+
+        if (HOST_INT_STATUS_ERROR_GET(host_int_status)) {
+                /* Error Interrupt */
+            status = DevServiceErrorInterrupt(pDev);
+            if (A_FAILED(status)){
+                break;
+            }
+        }
+
+        if (HOST_INT_STATUS_COUNTER_GET(host_int_status)) {
+                /* Counter Interrupt */
+            status = DevServiceCounterInterrupt(pDev);
+            if (A_FAILED(status)){
+                break;
+            }
+        }
+
+    } while (FALSE);
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("-ProcessPendingIRQs: (done:%d, async:%d) status=%d \n",
+                *pDone, *pASyncProcessing, status));
+
+    return status;
+}
+
+
+/* Synchronousinterrupt handler, this handler kicks off all interrupt processing.*/
+A_STATUS DevDsrHandler(void *context)
+{
+    AR6K_DEVICE *pDev = (AR6K_DEVICE *)context;
+    A_STATUS    status = A_OK;
+    A_BOOL      done = FALSE;
+    A_BOOL      asyncProc = FALSE;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("+DevDsrHandler: (dev: 0x%X)\n", (A_UINT32)pDev));
+
+
+    while (!done) {
+        status = ProcessPendingIRQs(pDev, &done, &asyncProc);
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        if (HIF_DEVICE_IRQ_SYNC_ONLY == pDev->HifIRQProcessingMode) {
+            /* the HIF layer does not allow async IRQ processing, override the asyncProc flag */
+            asyncProc = FALSE;
+            /* this will cause us to re-enter ProcessPendingIRQ() and re-read interrupt status registers.
+             * this has a nice side effect of blocking us until all async read requests are completed.
+             * This behavior is required on some HIF implementations that do not allow ASYNC
+             * processing in interrupt handlers (like Windows CE) */
+        }
+
+        if (asyncProc) {
+                /* the function performed some async I/O for performance, we
+                   need to exit the ISR immediately, the check below will prevent the interrupt from being
+                   Ack'd while we handle it asynchronously */
+            break;
+        }
+
+    }
+
+    if (A_SUCCESS(status) && !asyncProc) {
+            /* Ack the interrupt only if :
+             *  1. we did not get any errors in processing interrupts
+             *  2. there are no outstanding async processing requests */
+        AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,(" Acking interrupt from DevDsrHandler \n"));
+        HIFAckInterrupt(pDev->HIFDevice);
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("-DevDsrHandler \n"));
+    return status;
+}
+
+
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/htc/htc.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/htc/htc.c
@@ -0,0 +1,577 @@
+/*
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "htc_internal.h"
+
+
+static HTC_INIT_INFO  HTCInitInfo = {NULL,NULL,NULL};
+static A_BOOL         HTCInitialized = FALSE;
+
+static A_STATUS HTCTargetInsertedHandler(void *hif_handle);
+static A_STATUS HTCTargetRemovedHandler(void *handle, A_STATUS status);
+static void HTCReportFailure(void *Context);
+
+/* Initializes the HTC layer */
+A_STATUS HTCInit(HTC_INIT_INFO *pInitInfo)
+{
+    HTC_CALLBACKS htcCallbacks;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCInit: Enter\n"));
+    if (HTCInitialized) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCInit: Exit\n"));
+        return A_OK;
+    }
+
+    A_MEMCPY(&HTCInitInfo,pInitInfo,sizeof(HTC_INIT_INFO));
+
+    A_MEMZERO(&htcCallbacks, sizeof(HTC_CALLBACKS));
+
+        /* setup HIF layer callbacks */
+    htcCallbacks.deviceInsertedHandler = HTCTargetInsertedHandler;
+    htcCallbacks.deviceRemovedHandler = HTCTargetRemovedHandler;
+        /* the device layer handles these */
+    htcCallbacks.rwCompletionHandler = DevRWCompletionHandler;
+    htcCallbacks.dsrHandler = DevDsrHandler;
+    HIFInit(&htcCallbacks);
+    HTCInitialized = TRUE;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCInit: Exit\n"));
+    return A_OK;
+}
+
+void HTCFreeControlBuffer(HTC_TARGET *target, HTC_PACKET *pPacket, HTC_PACKET_QUEUE *pList)
+{
+    LOCK_HTC(target);
+    HTC_PACKET_ENQUEUE(pList,pPacket);
+    UNLOCK_HTC(target);
+}
+
+HTC_PACKET *HTCAllocControlBuffer(HTC_TARGET *target,  HTC_PACKET_QUEUE *pList)
+{
+    HTC_PACKET *pPacket;
+
+    LOCK_HTC(target);
+    pPacket = HTC_PACKET_DEQUEUE(pList);
+    UNLOCK_HTC(target);
+
+    return pPacket;
+}
+
+/* cleanup the HTC instance */
+static void HTCCleanup(HTC_TARGET *target)
+{
+    A_INT32 i;
+
+    DevCleanup(&target->Device);
+
+    for (i = 0;i < NUM_CONTROL_BUFFERS;i++) {
+        if (target->HTCControlBuffers[i].Buffer) {
+            A_FREE(target->HTCControlBuffers[i].Buffer);
+        }
+    }
+
+    if (A_IS_MUTEX_VALID(&target->HTCLock)) {
+        A_MUTEX_DELETE(&target->HTCLock);
+    }
+
+    if (A_IS_MUTEX_VALID(&target->HTCRxLock)) {
+        A_MUTEX_DELETE(&target->HTCRxLock);
+    }
+
+    if (A_IS_MUTEX_VALID(&target->HTCTxLock)) {
+        A_MUTEX_DELETE(&target->HTCTxLock);
+    }
+        /* free our instance */
+    A_FREE(target);
+}
+
+/* registered target arrival callback from the HIF layer */
+static A_STATUS HTCTargetInsertedHandler(void *hif_handle)
+{
+    HTC_TARGET              *target = NULL;
+    A_STATUS                 status;
+    int                      i;
+    A_UINT32                 ctrl_bufsz;
+    A_UINT32                 blocksizes[HTC_MAILBOX_NUM_MAX];
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("htcTargetInserted - Enter\n"));
+
+    do {
+
+            /* allocate target memory */
+        if ((target = (HTC_TARGET *)A_MALLOC(sizeof(HTC_TARGET))) == NULL) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to allocate memory\n"));
+            status = A_ERROR;
+            break;
+        }
+
+        A_MEMZERO(target, sizeof(HTC_TARGET));
+        A_MUTEX_INIT(&target->HTCLock);
+        A_MUTEX_INIT(&target->HTCRxLock);
+        A_MUTEX_INIT(&target->HTCTxLock);
+        INIT_HTC_PACKET_QUEUE(&target->ControlBufferTXFreeList);
+        INIT_HTC_PACKET_QUEUE(&target->ControlBufferRXFreeList);
+
+            /* give device layer the hif device handle */
+        target->Device.HIFDevice = hif_handle;
+            /* give the device layer our context (for event processing)
+             * the device layer will register it's own context with HIF
+             * so we need to set this so we can fetch it in the target remove handler */
+        target->Device.HTCContext = target;
+            /* set device layer target failure callback */
+        target->Device.TargetFailureCallback = HTCReportFailure;
+            /* set device layer recv message pending callback */
+        target->Device.MessagePendingCallback = HTCRecvMessagePendingHandler;
+        target->EpWaitingForBuffers = ENDPOINT_MAX;
+
+            /* setup device layer */
+        status = DevSetup(&target->Device);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+
+        /* get the block sizes */
+        status = HIFConfigureDevice(hif_handle, HIF_DEVICE_GET_MBOX_BLOCK_SIZE,
+                                    blocksizes, sizeof(blocksizes));
+        if (A_FAILED(status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Failed to get block size info from HIF layer...\n"));
+            break;
+        }
+
+        /* Set the control buffer size based on the block size */
+        if (blocksizes[1] > HTC_MAX_CONTROL_MESSAGE_LENGTH) {
+            ctrl_bufsz = blocksizes[1] + HTC_HDR_LENGTH;
+        } else {
+            ctrl_bufsz = HTC_MAX_CONTROL_MESSAGE_LENGTH + HTC_HDR_LENGTH;
+        }
+        for (i = 0;i < NUM_CONTROL_BUFFERS;i++) {
+            target->HTCControlBuffers[i].Buffer = A_MALLOC(ctrl_bufsz);
+            if (target->HTCControlBuffers[i].Buffer == NULL) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to allocate memory\n"));
+                status = A_ERROR;
+                break;
+            }
+        }
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+            /* carve up buffers/packets for control messages */
+        for (i = 0; i < NUM_CONTROL_RX_BUFFERS; i++) {
+            HTC_PACKET *pControlPacket;
+            pControlPacket = &target->HTCControlBuffers[i].HtcPacket;
+            SET_HTC_PACKET_INFO_RX_REFILL(pControlPacket,
+                                          target,
+                                          target->HTCControlBuffers[i].Buffer,
+                                          ctrl_bufsz,
+                                          ENDPOINT_0);
+            HTC_FREE_CONTROL_RX(target,pControlPacket);
+        }
+
+        for (;i < NUM_CONTROL_BUFFERS;i++) {
+             HTC_PACKET *pControlPacket;
+             pControlPacket = &target->HTCControlBuffers[i].HtcPacket;
+             INIT_HTC_PACKET_INFO(pControlPacket,
+                                  target->HTCControlBuffers[i].Buffer,
+                                  ctrl_bufsz);
+             HTC_FREE_CONTROL_TX(target,pControlPacket);
+        }
+
+    } while (FALSE);
+
+    if (A_SUCCESS(status)) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRC, (" calling AddInstance callback \n"));
+            /* announce ourselves */
+        HTCInitInfo.AddInstance((HTC_HANDLE)target);
+    } else {
+        if (target != NULL) {
+            HTCCleanup(target);
+        }
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("htcTargetInserted - Exit\n"));
+
+    return status;
+}
+
+/* registered removal callback from the HIF layer */
+static A_STATUS HTCTargetRemovedHandler(void *handle, A_STATUS status)
+{
+    HTC_TARGET *target;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("+HTCTargetRemovedHandler handle:0x%X \n",(A_UINT32)handle));
+
+    if (NULL == handle) {
+            /* this could be NULL in the event that target initialization failed */
+        return A_OK;
+    }
+
+    target = ((AR6K_DEVICE *)handle)->HTCContext;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("   removing target:0x%X instance:0x%X ... \n",
+            (A_UINT32)target, (A_UINT32)target->pInstanceContext));
+
+    if (target->pInstanceContext != NULL) {
+            /* let upper layer know, it needs to call HTCStop() */
+        HTCInitInfo.DeleteInstance(target->pInstanceContext);
+    }
+
+    HIFShutDownDevice(target->Device.HIFDevice);
+
+    HTCCleanup(target);
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("-HTCTargetRemovedHandler \n"));
+    return A_OK;
+}
+
+/* get the low level HIF device for the caller , the caller may wish to do low level
+ * HIF requests */
+void *HTCGetHifDevice(HTC_HANDLE HTCHandle)
+{
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    return target->Device.HIFDevice;
+}
+
+/* set the instance block for this HTC handle, so that on removal, the blob can be
+ * returned to the caller */
+void HTCSetInstance(HTC_HANDLE HTCHandle, void *Instance)
+{
+    HTC_TARGET  *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+
+    target->pInstanceContext = Instance;
+}
+
+/* wait for the target to arrive (sends HTC Ready message)
+ * this operation is fully synchronous and the message is polled for */
+A_STATUS HTCWaitTarget(HTC_HANDLE HTCHandle)
+{
+    HTC_TARGET              *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    A_STATUS                 status;
+    HTC_PACKET              *pPacket = NULL;
+    HTC_READY_MSG           *pRdyMsg;
+    HTC_SERVICE_CONNECT_REQ  connect;
+    HTC_SERVICE_CONNECT_RESP resp;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCWaitTarget - Enter (target:0x%X) \n", (A_UINT32)target));
+
+    do {
+
+#ifdef MBOXHW_UNIT_TEST
+
+        status = DoMboxHWTest(&target->Device);
+
+        if (status != A_OK) {
+            break;
+        }
+
+#endif
+
+            /* we should be getting 1 control message that the target is ready */
+        status = HTCWaitforControlMessage(target, &pPacket);
+
+        if (A_FAILED(status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (" Target Not Available!!\n"));
+            break;
+        }
+
+            /* we controlled the buffer creation so it has to be properly aligned */
+        pRdyMsg = (HTC_READY_MSG *)pPacket->pBuffer;
+
+        if ((pRdyMsg->MessageID != HTC_MSG_READY_ID) ||
+            (pPacket->ActualLength < sizeof(HTC_READY_MSG))) {
+                /* this message is not valid */
+            AR_DEBUG_ASSERT(FALSE);
+            status = A_EPROTO;
+            break;
+        }
+
+        if (pRdyMsg->CreditCount == 0 || pRdyMsg->CreditSize == 0) {
+              /* this message is not valid */
+            AR_DEBUG_ASSERT(FALSE);
+            status = A_EPROTO;
+            break;
+        }
+
+        target->TargetCredits = pRdyMsg->CreditCount;
+        target->TargetCreditSize = pRdyMsg->CreditSize;
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRC, (" Target Ready: credits: %d credit size: %d\n",
+                target->TargetCredits, target->TargetCreditSize));
+
+            /* setup our pseudo HTC control endpoint connection */
+        A_MEMZERO(&connect,sizeof(connect));
+        A_MEMZERO(&resp,sizeof(resp));
+        connect.EpCallbacks.pContext = target;
+        connect.EpCallbacks.EpTxComplete = HTCControlTxComplete;
+        connect.EpCallbacks.EpRecv = HTCControlRecv;
+        connect.EpCallbacks.EpRecvRefill = NULL;  /* not needed */
+        connect.EpCallbacks.EpSendFull = NULL;    /* not nedded */
+        connect.MaxSendQueueDepth = NUM_CONTROL_BUFFERS;
+        connect.ServiceID = HTC_CTRL_RSVD_SVC;
+
+            /* connect fake service */
+        status = HTCConnectService((HTC_HANDLE)target,
+                                   &connect,
+                                   &resp);
+
+        if (!A_FAILED(status)) {
+            break;
+        }
+
+    } while (FALSE);
+
+    if (pPacket != NULL) {
+        HTC_FREE_CONTROL_RX(target,pPacket);
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCWaitTarget - Exit\n"));
+
+    return status;
+}
+
+
+
+/* Start HTC, enable interrupts and let the target know host has finished setup */
+A_STATUS HTCStart(HTC_HANDLE HTCHandle)
+{
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    HTC_PACKET *pPacket;
+    A_STATUS   status;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCStart Enter\n"));
+
+        /* make sure interrupts are disabled at the chip level,
+         * this function can be called again from a reboot of the target without shutting down HTC */
+    DevDisableInterrupts(&target->Device);
+        /* make sure state is cleared again */
+    target->HTCStateFlags = 0;
+
+        /* now that we are starting, push control receive buffers into the
+         * HTC control endpoint */
+
+    while (1) {
+        pPacket = HTC_ALLOC_CONTROL_RX(target);
+        if (NULL == pPacket) {
+            break;
+        }
+        HTCAddReceivePkt((HTC_HANDLE)target,pPacket);
+    }
+
+    do {
+
+        AR_DEBUG_ASSERT(target->InitCredits != NULL);
+        AR_DEBUG_ASSERT(target->EpCreditDistributionListHead != NULL);
+        AR_DEBUG_ASSERT(target->EpCreditDistributionListHead->pNext != NULL);
+
+            /* call init credits callback to do the distribution ,
+             * NOTE: the first entry in the distribution list is ENDPOINT_0, so
+             * we pass the start of the list after this one. */
+        target->InitCredits(target->pCredDistContext,
+                            target->EpCreditDistributionListHead->pNext,
+                            target->TargetCredits);
+
+        if (AR_DEBUG_LVL_CHECK(ATH_DEBUG_TRC)) {
+            DumpCreditDistStates(target);
+        }
+
+            /* the caller is done connecting to services, so we can indicate to the
+            * target that the setup phase is complete */
+        status = HTCSendSetupComplete(target);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+            /* unmask interrupts */
+        status = DevUnmaskInterrupts(&target->Device);
+
+        if (A_FAILED(status)) {
+            HTCStop(target);
+        }
+
+    } while (FALSE);
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCStart Exit\n"));
+    return status;
+}
+
+static void ResetEndpointStates(HTC_TARGET *target)
+{
+    HTC_ENDPOINT        *pEndpoint;
+    int                  i;
+
+    for (i = ENDPOINT_0; i < ENDPOINT_MAX; i++) {
+        pEndpoint = &target->EndPoint[i];
+
+        A_MEMZERO(&pEndpoint->CreditDist, sizeof(pEndpoint->CreditDist));
+        pEndpoint->ServiceID = 0;
+        pEndpoint->CurrentTxQueueDepth = 0;
+        pEndpoint->MaxMsgLength = 0;
+        pEndpoint->MaxTxQueueDepth = 0;
+#ifdef HTC_EP_STAT_PROFILING
+        A_MEMZERO(&pEndpoint->EndPointStats,sizeof(pEndpoint->EndPointStats));
+#endif
+        INIT_HTC_PACKET_QUEUE(&pEndpoint->RxBuffers);
+        INIT_HTC_PACKET_QUEUE(&pEndpoint->TxQueue);
+    }
+        /* reset distribution list */
+    target->EpCreditDistributionListHead = NULL;
+}
+
+/* stop HTC communications, i.e. stop interrupt reception, and flush all queued buffers */
+void HTCStop(HTC_HANDLE HTCHandle)
+{
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("+HTCStop \n"));
+
+        /* mark that we are shutting down .. */
+    target->HTCStateFlags |= HTC_STATE_STOPPING;
+
+        /* Masking interrupts is a synchronous operation, when this function returns
+         * all pending HIF I/O has completed, we can safely flush the queues */
+    DevMaskInterrupts(&target->Device);
+
+        /* flush all send packets */
+    HTCFlushSendPkts(target);
+        /* flush all recv buffers */
+    HTCFlushRecvBuffers(target);
+
+    ResetEndpointStates(target);
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("-HTCStop \n"));
+}
+
+/* undo what was done in HTCInit() */
+void HTCShutDown(void)
+{
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("+HTCShutDown: \n"));
+    HTCInitialized = FALSE;
+        /* undo HTCInit */
+    HIFShutDownDevice(NULL);
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("-HTCShutDown: \n"));
+}
+
+void HTCDumpCreditStates(HTC_HANDLE HTCHandle)
+{
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+
+    LOCK_HTC_TX(target);
+
+    DumpCreditDistStates(target);
+
+    UNLOCK_HTC_TX(target);
+}
+
+/* report a target failure from the device, this is a callback from the device layer
+ * which uses a mechanism to report errors from the target (i.e. special interrupts) */
+static void HTCReportFailure(void *Context)
+{
+    HTC_TARGET *target = (HTC_TARGET *)Context;
+
+    target->TargetFailure = TRUE;
+
+    if ((target->pInstanceContext != NULL) && (HTCInitInfo.TargetFailure != NULL)) {
+            /* let upper layer know, it needs to call HTCStop() */
+        HTCInitInfo.TargetFailure(target->pInstanceContext, A_ERROR);
+    }
+}
+
+void DebugDumpBytes(A_UCHAR *buffer, A_UINT16 length, char *pDescription)
+{
+    A_CHAR stream[60];
+    A_UINT32 i;
+    A_UINT16 offset, count;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, ("<---------Dumping %d Bytes : %s ------>\n", length, pDescription));
+
+    count = 0;
+    offset = 0;
+    for(i = 0; i < length; i++) {
+        A_SPRINTF(stream + offset, "%2.2X ", buffer[i]);
+        count ++;
+        offset += 3;
+
+        if(count == 16) {
+            count = 0;
+            offset = 0;
+            AR_DEBUG_PRINTF(ATH_DEBUG_ANY, ("[H]: %s\n", stream));
+            A_MEMZERO(stream, 60);
+        }
+    }
+
+    if(offset != 0) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ANY, ("[H]: %s\n", stream));
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, ("<------------------------------------------------->\n"));
+}
+
+A_BOOL HTCGetEndpointStatistics(HTC_HANDLE               HTCHandle,
+                                HTC_ENDPOINT_ID          Endpoint,
+                                HTC_ENDPOINT_STAT_ACTION Action,
+                                HTC_ENDPOINT_STATS       *pStats)
+{
+
+#ifdef HTC_EP_STAT_PROFILING
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    A_BOOL     clearStats = FALSE;
+    A_BOOL     sample = FALSE;
+
+    switch (Action) {
+        case HTC_EP_STAT_SAMPLE :
+            sample = TRUE;
+            break;
+        case HTC_EP_STAT_SAMPLE_AND_CLEAR :
+            sample = TRUE;
+            clearStats = TRUE;
+            break;
+        case HTC_EP_STAT_CLEAR :
+            clearStats = TRUE;
+            break;
+        default:
+            break;
+    }
+
+    A_ASSERT(Endpoint < ENDPOINT_MAX);
+
+        /* lock out TX and RX while we sample and/or clear */
+    LOCK_HTC_TX(target);
+    LOCK_HTC_RX(target);
+
+    if (sample) {
+        A_ASSERT(pStats != NULL);
+            /* return the stats to the caller */
+        A_MEMCPY(pStats, &target->EndPoint[Endpoint].EndPointStats, sizeof(HTC_ENDPOINT_STATS));
+    }
+
+    if (clearStats) {
+            /* reset stats */
+        A_MEMZERO(&target->EndPoint[Endpoint].EndPointStats, sizeof(HTC_ENDPOINT_STATS));
+    }
+
+    UNLOCK_HTC_RX(target);
+    UNLOCK_HTC_TX(target);
+
+    return TRUE;
+#else
+    return FALSE;
+#endif
+}
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/htc/htc_internal.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/htc/htc_internal.h
@@ -0,0 +1,173 @@
+/*
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef _HTC_INTERNAL_H_
+#define _HTC_INTERNAL_H_
+
+/* for debugging, uncomment this to capture the last frame header, on frame header
+ * processing errors, the last frame header is dump for comparison */
+//#define HTC_CAPTURE_LAST_FRAME
+
+//#define HTC_EP_STAT_PROFILING
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Header files */
+#include "../include/config.h"
+#include "../include/athdefs.h"
+#include "../include/athtypes.h"
+#include "../include/osapi.h"
+#include "../include/debug.h"
+#include "../include/htc.h"
+#include "../include/htc_api.h"
+#include "../include/bmi_msg.h"
+#include "../include/hif.h"
+#include "../include/ar6k.h"
+
+/* HTC operational parameters */
+#define HTC_TARGET_RESPONSE_TIMEOUT        2000 /* in ms */
+#define HTC_TARGET_DEBUG_INTR_MASK         0x01
+#define HTC_TARGET_CREDIT_INTR_MASK        0xF0
+
+typedef struct _HTC_ENDPOINT {
+    HTC_SERVICE_ID              ServiceID;      /* service ID this endpoint is bound to
+                                                   non-zero value means this endpoint is in use */
+    HTC_PACKET_QUEUE            TxQueue;        /* HTC frame buffer TX queue */
+    HTC_PACKET_QUEUE            RxBuffers;      /* HTC frame buffer RX list */
+    HTC_ENDPOINT_CREDIT_DIST    CreditDist;     /* credit distribution structure (exposed to driver layer) */
+    HTC_EP_CALLBACKS            EpCallBacks;    /* callbacks associated with this endpoint */
+    int                         MaxTxQueueDepth;   /* max depth of the TX queue before we need to
+                                                      call driver's full handler */
+    int                         CurrentTxQueueDepth; /* current TX queue depth */
+    int                         MaxMsgLength;        /* max length of endpoint message */
+#ifdef HTC_EP_STAT_PROFILING
+    HTC_ENDPOINT_STATS          EndPointStats;  /* endpoint statistics */
+#endif
+} HTC_ENDPOINT;
+
+#ifdef HTC_EP_STAT_PROFILING
+#define INC_HTC_EP_STAT(p,stat,count) (p)->EndPointStats.stat += (count);
+#else
+#define INC_HTC_EP_STAT(p,stat,count)
+#endif
+
+#define HTC_SERVICE_TX_PACKET_TAG  HTC_TX_PACKET_TAG_INTERNAL
+
+#define NUM_CONTROL_BUFFERS     8
+#define NUM_CONTROL_TX_BUFFERS  2
+#define NUM_CONTROL_RX_BUFFERS  (NUM_CONTROL_BUFFERS - NUM_CONTROL_TX_BUFFERS)
+
+typedef struct HTC_CONTROL_BUFFER {
+    HTC_PACKET    HtcPacket;
+    A_UINT8       *Buffer;
+} HTC_CONTROL_BUFFER;
+
+/* our HTC target state */
+typedef struct _HTC_TARGET {
+    HTC_ENDPOINT                EndPoint[ENDPOINT_MAX];
+    HTC_CONTROL_BUFFER          HTCControlBuffers[NUM_CONTROL_BUFFERS];
+    HTC_ENDPOINT_CREDIT_DIST   *EpCreditDistributionListHead;
+    HTC_PACKET_QUEUE            ControlBufferTXFreeList;
+    HTC_PACKET_QUEUE            ControlBufferRXFreeList;
+    HTC_CREDIT_DIST_CALLBACK    DistributeCredits;
+    HTC_CREDIT_INIT_CALLBACK    InitCredits;
+    void                       *pCredDistContext;
+    int                         TargetCredits;
+    int                         TargetCreditSize;
+    A_MUTEX_T                   HTCLock;
+    A_MUTEX_T                   HTCRxLock;
+    A_MUTEX_T                   HTCTxLock;
+    AR6K_DEVICE                 Device;         /* AR6K - specific state */
+    A_UINT32                    HTCStateFlags;
+    HTC_ENDPOINT_ID             EpWaitingForBuffers;
+    A_BOOL                      TargetFailure;
+    void                       *pInstanceContext;
+#define HTC_STATE_WAIT_BUFFERS  (1 << 0)
+#define HTC_STATE_STOPPING      (1 << 1)
+#ifdef HTC_CAPTURE_LAST_FRAME
+    HTC_FRAME_HDR               LastFrameHdr;  /* useful for debugging */
+    A_UINT8                     LastTrailer[256];
+    A_UINT8                     LastTrailerLength;
+#endif
+} HTC_TARGET;
+
+#define HTC_STOPPING(t) ((t)->HTCStateFlags & HTC_STATE_STOPPING)
+#define LOCK_HTC(t)      A_MUTEX_LOCK(&(t)->HTCLock);
+#define UNLOCK_HTC(t)    A_MUTEX_UNLOCK(&(t)->HTCLock);
+#define LOCK_HTC_RX(t)   A_MUTEX_LOCK(&(t)->HTCRxLock);
+#define UNLOCK_HTC_RX(t) A_MUTEX_UNLOCK(&(t)->HTCRxLock);
+#define LOCK_HTC_TX(t)   A_MUTEX_LOCK(&(t)->HTCTxLock);
+#define UNLOCK_HTC_TX(t) A_MUTEX_UNLOCK(&(t)->HTCTxLock);
+
+#define GET_HTC_TARGET_FROM_HANDLE(hnd) ((HTC_TARGET *)(hnd))
+#define HTC_RECYCLE_RX_PKT(target,p,e)                           \
+{                                                   \
+    if ((e)->EpCallBacks.EpRecvAlloc != NULL) {                   \
+         HTC_PACKET_RESET_RX(pPacket);                           \
+         pPacket->Status = A_ECANCELED;                          \
+         (e)->EpCallBacks.EpRecv((e)->EpCallBacks.pContext,      \
+                                 (p));                           \
+    } else {                                                     \
+    HTC_PACKET_RESET_RX(pPacket);                   \
+    HTCAddReceivePkt((HTC_HANDLE)(target),(p));     \
+    }                                                            \
+}
+
+/* internal HTC functions */
+void        HTCControlTxComplete(void *Context, HTC_PACKET *pPacket);
+void        HTCControlRecv(void *Context, HTC_PACKET *pPacket);
+A_STATUS    HTCWaitforControlMessage(HTC_TARGET *target, HTC_PACKET **ppControlPacket);
+HTC_PACKET *HTCAllocControlBuffer(HTC_TARGET *target, HTC_PACKET_QUEUE *pList);
+void        HTCFreeControlBuffer(HTC_TARGET *target, HTC_PACKET *pPacket, HTC_PACKET_QUEUE *pList);
+A_STATUS    HTCIssueSend(HTC_TARGET *target, HTC_PACKET *pPacket, A_UINT8 Flags);
+A_STATUS    HTCIssueRecv(HTC_TARGET *target, HTC_PACKET *pPacket);
+void        HTCRecvCompleteHandler(void *Context, HTC_PACKET *pPacket);
+A_STATUS    HTCRecvMessagePendingHandler(void *Context, A_UINT32* LookAhead, A_BOOL *pAsyncProc);
+void        HTCProcessCreditRpt(HTC_TARGET *target, HTC_CREDIT_REPORT *pRpt, int NumEntries, HTC_ENDPOINT_ID FromEndpoint);
+A_STATUS    HTCSendSetupComplete(HTC_TARGET *target);
+void        HTCFlushRecvBuffers(HTC_TARGET *target);
+void        HTCFlushSendPkts(HTC_TARGET *target);
+void        DumpCreditDist(HTC_ENDPOINT_CREDIT_DIST *pEPDist);
+void        DumpCreditDistStates(HTC_TARGET *target);
+void 		DebugDumpBytes(A_UCHAR *buffer, A_UINT16 length, char *pDescription);
+
+static INLINE HTC_PACKET *HTC_ALLOC_CONTROL_TX(HTC_TARGET *target) {
+    HTC_PACKET *pPacket = HTCAllocControlBuffer(target,&target->ControlBufferTXFreeList);
+    if (pPacket != NULL) {
+            /* set payload pointer area with some headroom */
+        pPacket->pBuffer = pPacket->pBufferStart + HTC_HDR_LENGTH;
+    }
+    return pPacket;
+}
+
+#define HTC_FREE_CONTROL_TX(t,p) HTCFreeControlBuffer((t),(p),&(t)->ControlBufferTXFreeList)
+#define HTC_ALLOC_CONTROL_RX(t)  HTCAllocControlBuffer((t),&(t)->ControlBufferRXFreeList)
+#define HTC_FREE_CONTROL_RX(t,p) \
+{                                                                \
+    HTC_PACKET_RESET_RX(p);                                      \
+    HTCFreeControlBuffer((t),(p),&(t)->ControlBufferRXFreeList); \
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _HTC_INTERNAL_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/htc/htc_recv.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/htc/htc_recv.c
@@ -0,0 +1,763 @@
+/*
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "htc_internal.h"
+
+#define HTCIssueRecv(t, p) \
+    DevRecvPacket(&(t)->Device,  \
+                  (p),          \
+                  (p)->ActualLength)
+
+#define DO_RCV_COMPLETION(t,p,e)            \
+{                                           \
+    if ((p)->ActualLength > 0) {            \
+        AR_DEBUG_PRINTF(ATH_DEBUG_RECV, (" completing packet 0x%X (%d bytes) on ep : %d \n", \
+            (A_UINT32)(p), (p)->ActualLength, (p)->Endpoint));  \
+        (e)->EpCallBacks.EpRecv((e)->EpCallBacks.pContext,      \
+                                (p));                           \
+    } else {                                                    \
+        AR_DEBUG_PRINTF(ATH_DEBUG_RECV, (" recycling empty packet \n"));  \
+        HTC_RECYCLE_RX_PKT((t), (p), (e));                      \
+    }                                                           \
+}
+
+#ifdef HTC_EP_STAT_PROFILING
+#define HTC_RX_STAT_PROFILE(t,ep,lookAhead)            \
+{                                                      \
+    LOCK_HTC_RX((t));                                  \
+    INC_HTC_EP_STAT((ep), RxReceived, 1);              \
+    if ((lookAhead) != 0) {                            \
+        INC_HTC_EP_STAT((ep), RxLookAheads, 1);        \
+    }                                                  \
+    UNLOCK_HTC_RX((t));                                \
+}
+#else
+#define HTC_RX_STAT_PROFILE(t,ep,lookAhead)
+#endif
+
+static INLINE A_STATUS HTCProcessTrailer(HTC_TARGET *target,
+                                         A_UINT8    *pBuffer,
+                                         int         Length,
+                                         A_UINT32   *pNextLookAhead,
+                                         HTC_ENDPOINT_ID FromEndpoint)
+{
+    HTC_RECORD_HDR          *pRecord;
+    A_UINT8                 *pRecordBuf;
+    HTC_LOOKAHEAD_REPORT    *pLookAhead;
+    A_UINT8                 *pOrigBuffer;
+    int                     origLength;
+    A_STATUS                status;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("+HTCProcessTrailer (length:%d) \n", Length));
+
+    if (AR_DEBUG_LVL_CHECK(ATH_DEBUG_RECV)) {
+        AR_DEBUG_PRINTBUF(pBuffer,Length,"Recv Trailer");
+    }
+
+    pOrigBuffer = pBuffer;
+    origLength = Length;
+    status = A_OK;
+
+    while (Length > 0) {
+
+        if (Length < sizeof(HTC_RECORD_HDR)) {
+            status = A_EPROTO;
+            break;
+        }
+            /* these are byte aligned structs */
+        pRecord = (HTC_RECORD_HDR *)pBuffer;
+        Length -= sizeof(HTC_RECORD_HDR);
+        pBuffer += sizeof(HTC_RECORD_HDR);
+
+        if (pRecord->Length > Length) {
+                /* no room left in buffer for record */
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                (" invalid record length: %d (id:%d) buffer has: %d bytes left \n",
+                        pRecord->Length, pRecord->RecordID, Length));
+            status = A_EPROTO;
+            break;
+        }
+            /* start of record follows the header */
+        pRecordBuf = pBuffer;
+
+        switch (pRecord->RecordID) {
+            case HTC_RECORD_CREDITS:
+                AR_DEBUG_ASSERT(pRecord->Length >= sizeof(HTC_CREDIT_REPORT));
+                HTCProcessCreditRpt(target,
+                                    (HTC_CREDIT_REPORT *)pRecordBuf,
+                                    pRecord->Length / (sizeof(HTC_CREDIT_REPORT)),
+                                    FromEndpoint);
+                break;
+            case HTC_RECORD_LOOKAHEAD:
+                AR_DEBUG_ASSERT(pRecord->Length >= sizeof(HTC_LOOKAHEAD_REPORT));
+                pLookAhead = (HTC_LOOKAHEAD_REPORT *)pRecordBuf;
+                if ((pLookAhead->PreValid == ((~pLookAhead->PostValid) & 0xFF)) &&
+                    (pNextLookAhead != NULL)) {
+
+                    AR_DEBUG_PRINTF(ATH_DEBUG_RECV,
+                                (" LookAhead Report Found (pre valid:0x%X, post valid:0x%X) \n",
+                                pLookAhead->PreValid,
+                                pLookAhead->PostValid));
+
+                        /* look ahead bytes are valid, copy them over */
+                    ((A_UINT8 *)pNextLookAhead)[0] = pLookAhead->LookAhead[0];
+                    ((A_UINT8 *)pNextLookAhead)[1] = pLookAhead->LookAhead[1];
+                    ((A_UINT8 *)pNextLookAhead)[2] = pLookAhead->LookAhead[2];
+                    ((A_UINT8 *)pNextLookAhead)[3] = pLookAhead->LookAhead[3];
+
+                    if (AR_DEBUG_LVL_CHECK(ATH_DEBUG_RECV)) {
+                        DebugDumpBytes((A_UINT8 *)pNextLookAhead,4,"Next Look Ahead");
+                    }
+                }
+                break;
+            default:
+                AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (" unhandled record: id:%d length:%d \n",
+                        pRecord->RecordID, pRecord->Length));
+                break;
+        }
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+            /* advance buffer past this record for next time around */
+        pBuffer += pRecord->Length;
+        Length -= pRecord->Length;
+    }
+
+    if (A_FAILED(status)) {
+        DebugDumpBytes(pOrigBuffer,origLength,"BAD Recv Trailer");
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("-HTCProcessTrailer \n"));
+    return status;
+
+}
+
+/* process a received message (i.e. strip off header, process any trailer data)
+ * note : locks must be released when this function is called */
+static A_STATUS HTCProcessRecvHeader(HTC_TARGET *target, HTC_PACKET *pPacket, A_UINT32 *pNextLookAhead)
+{
+    A_UINT8   temp;
+    A_UINT8   *pBuf;
+    A_STATUS  status = A_OK;
+    A_UINT16  payloadLen;
+    A_UINT32  lookAhead;
+
+    pBuf = pPacket->pBuffer;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("+HTCProcessRecvHeader \n"));
+
+    if (AR_DEBUG_LVL_CHECK(ATH_DEBUG_RECV)) {
+        AR_DEBUG_PRINTBUF(pBuf,pPacket->ActualLength,"HTC Recv PKT");
+    }
+
+    do {
+        /* note, we cannot assume the alignment of pBuffer, so we use the safe macros to
+         * retrieve 16 bit fields */
+        payloadLen = A_GET_UINT16_FIELD(pBuf, HTC_FRAME_HDR, PayloadLen);
+
+        ((A_UINT8 *)&lookAhead)[0] = pBuf[0];
+        ((A_UINT8 *)&lookAhead)[1] = pBuf[1];
+        ((A_UINT8 *)&lookAhead)[2] = pBuf[2];
+        ((A_UINT8 *)&lookAhead)[3] = pBuf[3];
+
+        if (lookAhead != pPacket->HTCReserved) {
+            /* somehow the lookahead that gave us the full read length did not
+             * reflect the actual header in the pending message */
+             AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                    ("HTCProcessRecvHeader, lookahead mismatch! \n"));
+             DebugDumpBytes((A_UINT8 *)&pPacket->HTCReserved,4,"Expected Message LookAhead");
+             DebugDumpBytes(pBuf,sizeof(HTC_FRAME_HDR),"Current Frame Header");
+#ifdef HTC_CAPTURE_LAST_FRAME
+            DebugDumpBytes((A_UINT8 *)&target->LastFrameHdr,sizeof(HTC_FRAME_HDR),"Last Frame Header");
+            if (target->LastTrailerLength != 0) {
+                DebugDumpBytes(target->LastTrailer,
+                               target->LastTrailerLength,
+                               "Last trailer");
+            }
+#endif
+            status = A_EPROTO;
+            break;
+        }
+
+            /* get flags */
+        temp = A_GET_UINT8_FIELD(pBuf, HTC_FRAME_HDR, Flags);
+
+        if (temp & HTC_FLAGS_RECV_TRAILER) {
+            /* this packet has a trailer */
+
+                /* extract the trailer length in control byte 0 */
+            temp = A_GET_UINT8_FIELD(pBuf, HTC_FRAME_HDR, ControlBytes[0]);
+
+            if ((temp < sizeof(HTC_RECORD_HDR)) || (temp > payloadLen)) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                    ("HTCProcessRecvHeader, invalid header (payloadlength should be :%d, CB[0] is:%d) \n",
+                        payloadLen, temp));
+                status = A_EPROTO;
+                break;
+            }
+
+                /* process trailer data that follows HDR + application payload */
+            status = HTCProcessTrailer(target,
+                                       (pBuf + HTC_HDR_LENGTH + payloadLen - temp),
+                                       temp,
+                                       pNextLookAhead,
+                                       pPacket->Endpoint);
+
+            if (A_FAILED(status)) {
+                break;
+            }
+
+#ifdef HTC_CAPTURE_LAST_FRAME
+            A_MEMCPY(target->LastTrailer, (pBuf + HTC_HDR_LENGTH + payloadLen - temp), temp);
+            target->LastTrailerLength = temp;
+#endif
+                /* trim length by trailer bytes */
+            pPacket->ActualLength -= temp;
+        }
+#ifdef HTC_CAPTURE_LAST_FRAME
+         else {
+            target->LastTrailerLength = 0;
+        }
+#endif
+
+            /* if we get to this point, the packet is good */
+            /* remove header and adjust length */
+        pPacket->pBuffer += HTC_HDR_LENGTH;
+        pPacket->ActualLength -= HTC_HDR_LENGTH;
+
+    } while (FALSE);
+
+    if (A_FAILED(status)) {
+            /* dump the whole packet */
+        DebugDumpBytes(pBuf,pPacket->ActualLength,"BAD HTC Recv PKT");
+    } else {
+#ifdef HTC_CAPTURE_LAST_FRAME
+        A_MEMCPY(&target->LastFrameHdr,pBuf,sizeof(HTC_FRAME_HDR));
+#endif
+        if (AR_DEBUG_LVL_CHECK(ATH_DEBUG_RECV)) {
+            if (pPacket->ActualLength > 0) {
+                AR_DEBUG_PRINTBUF(pPacket->pBuffer,pPacket->ActualLength,"HTC - Application Msg");
+            }
+        }
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("-HTCProcessRecvHeader \n"));
+    return status;
+}
+
+/* asynchronous completion handler for recv packet fetching, when the device layer
+ * completes a read request, it will call this completion handler */
+void HTCRecvCompleteHandler(void *Context, HTC_PACKET *pPacket)
+{
+    HTC_TARGET      *target = (HTC_TARGET *)Context;
+    HTC_ENDPOINT    *pEndpoint;
+    A_UINT32        nextLookAhead = 0;
+    A_STATUS        status;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("+HTCRecvCompleteHandler (status:%d, ep:%d) \n",
+                pPacket->Status, pPacket->Endpoint));
+
+    AR_DEBUG_ASSERT(pPacket->Endpoint < ENDPOINT_MAX);
+    pEndpoint = &target->EndPoint[pPacket->Endpoint];
+    pPacket->Completion = NULL;
+
+        /* get completion status */
+    status = pPacket->Status;
+
+    do {
+        if (A_FAILED(status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("HTCRecvCompleteHandler: request failed (status:%d, ep:%d) \n",
+                pPacket->Status, pPacket->Endpoint));
+            break;
+        }
+            /* process the header for any trailer data */
+        status = HTCProcessRecvHeader(target,pPacket,&nextLookAhead);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+            /* was there a lookahead for the next packet? */
+        if (nextLookAhead != 0) {
+            A_STATUS nextStatus;
+            AR_DEBUG_PRINTF(ATH_DEBUG_RECV,
+                            ("HTCRecvCompleteHandler - next look ahead was non-zero : 0x%X \n",
+                             nextLookAhead));
+                /* we have another packet, get the next packet fetch started (pipelined) before
+                 * we call into the endpoint's callback, this will start another async request */
+            nextStatus = HTCRecvMessagePendingHandler(target,&nextLookAhead,NULL);
+            if (A_EPROTO == nextStatus) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                            ("Next look ahead from recv header was INVALID\n"));
+                DebugDumpBytes((A_UINT8 *)&nextLookAhead,
+                                4,
+                                "BAD lookahead from lookahead report");
+            }
+        } else {
+             AR_DEBUG_PRINTF(ATH_DEBUG_RECV,
+            ("HTCRecvCompleteHandler - rechecking for more messages...\n"));
+            /* if we did not get anything on the look-ahead,
+             * call device layer to asynchronously re-check for messages. If we can keep the async
+             * processing going we get better performance.  If there is a pending message we will keep processing
+             * messages asynchronously which should pipeline things nicely */
+            DevCheckPendingRecvMsgsAsync(&target->Device);
+        }
+
+        HTC_RX_STAT_PROFILE(target,pEndpoint,nextLookAhead);
+        DO_RCV_COMPLETION(target,pPacket,pEndpoint);
+
+    } while (FALSE);
+
+    if (A_FAILED(status)) {
+         AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                         ("HTCRecvCompleteHandler , message fetch failed (status = %d) \n",
+                         status));
+            /* recyle this packet */
+         HTC_RECYCLE_RX_PKT(target, pPacket, pEndpoint);
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("-HTCRecvCompleteHandler\n"));
+}
+
+/* synchronously wait for a control message from the target,
+ * This function is used at initialization time ONLY.  At init messages
+ * on ENDPOINT 0 are expected. */
+A_STATUS HTCWaitforControlMessage(HTC_TARGET *target, HTC_PACKET **ppControlPacket)
+{
+    A_STATUS        status;
+    A_UINT32        lookAhead;
+    HTC_PACKET      *pPacket = NULL;
+    HTC_FRAME_HDR   *pHdr;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV,("+HTCWaitforControlMessage \n"));
+
+    do  {
+
+        *ppControlPacket = NULL;
+
+            /* call the polling function to see if we have a message */
+        status = DevPollMboxMsgRecv(&target->Device,
+                                    &lookAhead,
+                                    HTC_TARGET_RESPONSE_TIMEOUT);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_RECV,
+                ("HTCWaitforControlMessage : lookAhead : 0x%X \n", lookAhead));
+
+            /* check the lookahead */
+        pHdr = (HTC_FRAME_HDR *)&lookAhead;
+
+        if (pHdr->EndpointID != ENDPOINT_0) {
+                /* unexpected endpoint number, should be zero */
+            AR_DEBUG_ASSERT(FALSE);
+            status = A_EPROTO;
+            break;
+        }
+
+        if (A_FAILED(status)) {
+                /* bad message */
+            AR_DEBUG_ASSERT(FALSE);
+            status = A_EPROTO;
+            break;
+        }
+
+        pPacket = HTC_ALLOC_CONTROL_RX(target);
+
+        if (pPacket == NULL) {
+            AR_DEBUG_ASSERT(FALSE);
+            status = A_NO_MEMORY;
+            break;
+        }
+
+        pPacket->HTCReserved = lookAhead;
+        pPacket->ActualLength = pHdr->PayloadLen + HTC_HDR_LENGTH;
+
+        if (pPacket->ActualLength > pPacket->BufferLength) {
+            AR_DEBUG_ASSERT(FALSE);
+            status = A_EPROTO;
+            break;
+        }
+
+            /* we want synchronous operation */
+        pPacket->Completion = NULL;
+
+            /* get the message from the device, this will block */
+        status = HTCIssueRecv(target, pPacket);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+            /* process receive header */
+        status = HTCProcessRecvHeader(target,pPacket,NULL);
+
+        pPacket->Status = status;
+
+        if (A_FAILED(status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                    ("HTCWaitforControlMessage, HTCProcessRecvHeader failed (status = %d) \n",
+                     status));
+            break;
+        }
+
+            /* give the caller this control message packet, they are responsible to free */
+        *ppControlPacket = pPacket;
+
+    } while (FALSE);
+
+    if (A_FAILED(status)) {
+        if (pPacket != NULL) {
+                /* cleanup buffer on error */
+            HTC_FREE_CONTROL_RX(target,pPacket);
+        }
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV,("-HTCWaitforControlMessage \n"));
+
+    return status;
+}
+
+/* callback when device layer or lookahead report parsing detects a pending message */
+A_STATUS HTCRecvMessagePendingHandler(void *Context, A_UINT32 *LookAhead, A_BOOL *pAsyncProc)
+{
+    HTC_TARGET      *target = (HTC_TARGET *)Context;
+    A_STATUS         status = A_OK;
+    HTC_PACKET      *pPacket = NULL;
+    HTC_FRAME_HDR   *pHdr = NULL;
+    HTC_ENDPOINT    *pEndpoint = NULL;
+    A_BOOL          asyncProc = FALSE;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV,("+HTCRecvMessagePendingHandler LookAhead:0x%X \n", *LookAhead));
+
+    if (IS_DEV_IRQ_PROCESSING_ASYNC_ALLOWED(&target->Device)) {
+            /* We use async mode to get the packets if the device layer supports it.
+             * The device layer interfaces with HIF in which HIF may have restrictions on
+             * how interrupts are processed */
+        asyncProc = TRUE;
+    }
+
+    if (pAsyncProc != NULL) {
+            /* indicate to caller how we decided to process this */
+        *pAsyncProc = asyncProc;
+    }
+
+    while (TRUE) {
+        pHdr = (HTC_FRAME_HDR *)LookAhead;
+
+        if (pHdr->EndpointID >= ENDPOINT_MAX) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Invalid Endpoint in look-ahead: %d \n",pHdr->EndpointID));
+                /* invalid endpoint */
+            status = A_EPROTO;
+            break;
+        }
+
+        if (pHdr->PayloadLen > HTC_MAX_PAYLOAD_LENGTH) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Payload length %d exceeds max HTC : %d !\n",
+                    pHdr->PayloadLen, HTC_MAX_PAYLOAD_LENGTH));
+            status = A_EPROTO;
+            break;
+        }
+
+        pEndpoint = &target->EndPoint[pHdr->EndpointID];
+
+        if (0 == pEndpoint->ServiceID) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Endpoint %d is not connected !\n",pHdr->EndpointID));
+                /* endpoint isn't even connected */
+            status = A_EPROTO;
+            break;
+        }
+
+        if (pEndpoint->EpCallBacks.EpRecvAlloc != NULL) {
+                /* user is using a per-packet allocation callback */
+            pPacket = pEndpoint->EpCallBacks.EpRecvAlloc(pEndpoint->EpCallBacks.pContext,
+                                                         (HTC_ENDPOINT_ID) pHdr->EndpointID,
+                                                         pHdr->PayloadLen + sizeof(HTC_FRAME_HDR));
+
+                /* lock RX, in case this allocation fails, we need to update internal state below */
+
+            LOCK_HTC_RX(target);
+
+        } else {
+                /* user is using a refill handler that can refill multiple HTC buffers */
+            /* lock RX to get a buffer */
+        LOCK_HTC_RX(target);
+
+            /* get a packet from the endpoint recv queue */
+        pPacket = HTC_PACKET_DEQUEUE(&pEndpoint->RxBuffers);
+
+        if (NULL == pPacket) {
+                /* check for refill handler */
+            if (pEndpoint->EpCallBacks.EpRecvRefill != NULL) {
+                UNLOCK_HTC_RX(target);
+                    /* call the re-fill handler */
+                pEndpoint->EpCallBacks.EpRecvRefill(pEndpoint->EpCallBacks.pContext,
+                                                        (HTC_ENDPOINT_ID) pHdr->EndpointID);
+                LOCK_HTC_RX(target);
+                    /* check if we have more buffers */
+                pPacket = HTC_PACKET_DEQUEUE(&pEndpoint->RxBuffers);
+                    /* fall through */
+            }
+        }
+        }
+
+        if (NULL == pPacket) {
+                /* this is not an error, we simply need to mark that we are waiting for buffers.*/
+            target->HTCStateFlags |= HTC_STATE_WAIT_BUFFERS;
+            target->EpWaitingForBuffers = (HTC_ENDPOINT_ID) pHdr->EndpointID;
+            status = A_NO_MEMORY;
+        }
+
+        if (HTC_STOPPING(target)) {
+            status = A_ECANCELED;
+        }
+
+        UNLOCK_HTC_RX(target);
+
+        if (A_FAILED(status)) {
+            /* no buffers or stopping */
+            break;
+        }
+
+        AR_DEBUG_ASSERT(pPacket->Endpoint == pHdr->EndpointID);
+
+            /* make sure this message can fit in the endpoint buffer */
+        if ((pHdr->PayloadLen + HTC_HDR_LENGTH) > pPacket->BufferLength) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                    ("Payload Length Error : header reports payload of: %d, endpoint buffer size: %d \n",
+                    pHdr->PayloadLen, pPacket->BufferLength));
+            status = A_EPROTO;
+            break;
+        }
+
+        pPacket->HTCReserved = *LookAhead; /* set expected look ahead */
+            /* set the amount of data to fetch */
+        pPacket->ActualLength = pHdr->PayloadLen + HTC_HDR_LENGTH;
+
+        if (asyncProc) {
+                /* we use async mode to get the packet if the device layer supports it
+                 * set our callback and context */
+            pPacket->Completion = HTCRecvCompleteHandler;
+            pPacket->pContext = target;
+        } else {
+                /* fully synchronous */
+            pPacket->Completion = NULL;
+        }
+
+            /* go fetch the packet */
+        status = HTCIssueRecv(target, pPacket);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        if (asyncProc) {
+                /* we did this asynchronously so we can get out of the loop, the asynch processing
+                 * creates a chain of requests to continue processing pending messages in the
+                 * context of callbacks  */
+            break;
+        }
+
+            /* in the sync case, we process the packet, check lookaheads and then repeat */
+
+        *LookAhead = 0;
+        status = HTCProcessRecvHeader(target,pPacket,LookAhead);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        HTC_RX_STAT_PROFILE(target,pEndpoint,*LookAhead);
+        DO_RCV_COMPLETION(target,pPacket,pEndpoint);
+
+        pPacket = NULL;
+
+        if (0 == *LookAhead) {
+            break;
+        }
+
+        /* check whether other OS contexts have queued any WMI command/data for WLAN.
+         * This check is needed only if WLAN Tx and Rx happens in same thread context */
+        A_CHECK_DRV_TX();
+    }
+
+    if (A_NO_MEMORY == status) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                (" Endpoint :%d has no buffers, blocking receiver to prevent overrun.. \n",
+                (pHdr != NULL) ? pHdr->EndpointID : 0xFFFF));
+            /* try to stop receive at the device layer */
+        DevStopRecv(&target->Device, asyncProc ? DEV_STOP_RECV_ASYNC : DEV_STOP_RECV_SYNC);
+        status = A_OK;
+    } else if (A_FAILED(status)) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                        ("Failed to get pending message : LookAhead Value: 0x%X (status = %d) \n",
+                        *LookAhead, status));
+        if (pPacket != NULL) {
+                /* clean up packet on error */
+            HTC_RECYCLE_RX_PKT(target, pPacket, pEndpoint);
+        }
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV,("-HTCRecvMessagePendingHandler \n"));
+
+    return status;
+}
+
+/* Makes a buffer available to the HTC module */
+A_STATUS HTCAddReceivePkt(HTC_HANDLE HTCHandle, HTC_PACKET *pPacket)
+{
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    HTC_ENDPOINT *pEndpoint;
+    A_BOOL       unblockRecv = FALSE;
+    A_STATUS     status = A_OK;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND,
+                    ("+- HTCAddReceivePkt: endPointId: %d, buffer: 0x%X, length: %d\n",
+                    pPacket->Endpoint, (A_UINT32)pPacket->pBuffer, pPacket->BufferLength));
+
+    do {
+        AR_DEBUG_ASSERT(pPacket->Endpoint < ENDPOINT_MAX);
+
+        pEndpoint = &target->EndPoint[pPacket->Endpoint];
+
+        LOCK_HTC_RX(target);
+
+        if (HTC_STOPPING(target)) {
+            pPacket->Status = A_ECANCELED;
+            status = A_ECANCELED;
+            UNLOCK_HTC_RX(target);
+            pEndpoint->EpCallBacks.EpRecv(pEndpoint->EpCallBacks.pContext, pPacket);
+            break;
+        }
+
+            /* store receive packet */
+        HTC_PACKET_ENQUEUE(&pEndpoint->RxBuffers, pPacket);
+
+            /* check if we are blocked waiting for a new buffer */
+        if (target->HTCStateFlags & HTC_STATE_WAIT_BUFFERS) {
+            if (target->EpWaitingForBuffers == pPacket->Endpoint) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_RECV,(" receiver was blocked on ep:%d, unblocking.. \n",
+                    target->EpWaitingForBuffers));
+                target->HTCStateFlags &= ~HTC_STATE_WAIT_BUFFERS;
+                target->EpWaitingForBuffers = ENDPOINT_MAX;
+                unblockRecv = TRUE;
+            }
+        }
+
+        UNLOCK_HTC_RX(target);
+
+        if (unblockRecv && !HTC_STOPPING(target)) {
+                /* TODO : implement a buffer threshold count? */
+            DevEnableRecv(&target->Device,DEV_ENABLE_RECV_SYNC);
+        }
+
+    } while (FALSE);
+
+    return status;
+}
+
+void HTCUnblockRecv(HTC_HANDLE HTCHandle)
+{
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    A_BOOL      unblockRecv = FALSE;
+
+    LOCK_HTC_RX(target);
+
+        /* check if we are blocked waiting for a new buffer */
+    if (target->HTCStateFlags & HTC_STATE_WAIT_BUFFERS) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_RECV,("HTCUnblockRx : receiver was blocked on ep:%d, unblocking.. \n",
+            target->EpWaitingForBuffers));
+        target->HTCStateFlags &= ~HTC_STATE_WAIT_BUFFERS;
+        target->EpWaitingForBuffers = ENDPOINT_MAX;
+        unblockRecv = TRUE;
+    }
+
+    UNLOCK_HTC_RX(target);
+
+    if (unblockRecv && !HTC_STOPPING(target)) {
+            /* re-enable */
+        DevEnableRecv(&target->Device,DEV_ENABLE_RECV_ASYNC);
+    }
+}
+
+static void HTCFlushEndpointRX(HTC_TARGET *target, HTC_ENDPOINT *pEndpoint)
+{
+    HTC_PACKET  *pPacket;
+
+    LOCK_HTC_RX(target);
+
+    while (1) {
+        pPacket = HTC_PACKET_DEQUEUE(&pEndpoint->RxBuffers);
+        if (NULL == pPacket) {
+            break;
+        }
+        UNLOCK_HTC_RX(target);
+        pPacket->Status = A_ECANCELED;
+        pPacket->ActualLength = 0;
+        AR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("  Flushing RX packet:0x%X, length:%d, ep:%d \n",
+                (A_UINT32)pPacket, pPacket->BufferLength, pPacket->Endpoint));
+            /* give the packet back */
+        pEndpoint->EpCallBacks.EpRecv(pEndpoint->EpCallBacks.pContext,
+                                      pPacket);
+        LOCK_HTC_RX(target);
+    }
+
+    UNLOCK_HTC_RX(target);
+
+
+}
+
+void HTCFlushRecvBuffers(HTC_TARGET *target)
+{
+    HTC_ENDPOINT    *pEndpoint;
+    int             i;
+
+    for (i = ENDPOINT_0; i < ENDPOINT_MAX; i++) {
+        pEndpoint = &target->EndPoint[i];
+        if (pEndpoint->ServiceID == 0) {
+                /* not in use.. */
+            continue;
+        }
+        HTCFlushEndpointRX(target,pEndpoint);
+    }
+}
+
+
+void HTCEnableRecv(HTC_HANDLE HTCHandle)
+{
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+
+    if (!HTC_STOPPING(target)) {
+            /* re-enable */
+        DevEnableRecv(&target->Device,DEV_ENABLE_RECV_SYNC);
+    }
+}
+
+void HTCDisableRecv(HTC_HANDLE HTCHandle)
+{
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+
+    if (!HTC_STOPPING(target)) {
+            /* disable */
+        DevStopRecv(&target->Device,DEV_ENABLE_RECV_SYNC);
+    }
+}
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/htc/htc_send.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/htc/htc_send.c
@@ -0,0 +1,591 @@
+/*
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "htc_internal.h"
+
+typedef enum _HTC_SEND_QUEUE_RESULT {
+    HTC_SEND_QUEUE_OK = 0,    /* packet was queued */
+    HTC_SEND_QUEUE_DROP = 1,  /* this packet should be dropped */
+} HTC_SEND_QUEUE_RESULT;
+
+#define DO_EP_TX_COMPLETION(ep,p)                                    \
+{                                                                    \
+    (p)->Completion = NULL;                                          \
+    (ep)->EpCallBacks.EpTxComplete((ep)->EpCallBacks.pContext,(p));  \
+}
+
+
+/* call the distribute credits callback with the distribution */
+#define DO_DISTRIBUTION(t,reason,description,pList) \
+{                                             \
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND,           \
+        ("  calling distribute function (%s) (dfn:0x%X, ctxt:0x%X, dist:0x%X) \n", \
+                (description),                                           \
+                (A_UINT32)(t)->DistributeCredits,                        \
+                (A_UINT32)(t)->pCredDistContext,                         \
+                (A_UINT32)pList));                                       \
+    (t)->DistributeCredits((t)->pCredDistContext,                        \
+                           (pList),                                      \
+                           (reason));                                    \
+}
+
+/* our internal send packet completion handler when packets are submited to the AR6K device
+ * layer */
+static void HTCSendPktCompletionHandler(void *Context, HTC_PACKET *pPacket)
+{
+    HTC_TARGET      *target = (HTC_TARGET *)Context;
+    HTC_ENDPOINT    *pEndpoint = &target->EndPoint[pPacket->Endpoint];
+
+
+    if (A_FAILED(pPacket->Status)) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+            ("HTCSendPktCompletionHandler: request failed (status:%d, ep:%d) \n",
+                pPacket->Status, pPacket->Endpoint));
+    }
+        /* first, fixup the head room we allocated */
+    pPacket->pBuffer += HTC_HDR_LENGTH;
+        /* do completion */
+    DO_EP_TX_COMPLETION(pEndpoint,pPacket);
+}
+
+A_STATUS HTCIssueSend(HTC_TARGET *target, HTC_PACKET *pPacket, A_UINT8 SendFlags)
+{
+    A_STATUS status;
+    A_UINT8 *pHdrBuf;
+    A_BOOL   sync = FALSE;
+
+        /* caller always provides headrooom */
+    pPacket->pBuffer -= HTC_HDR_LENGTH;
+    pHdrBuf = pPacket->pBuffer;
+        /* setup frame header */
+    A_SET_UINT16_FIELD(pHdrBuf,HTC_FRAME_HDR,PayloadLen,(A_UINT16)pPacket->ActualLength);
+    A_SET_UINT8_FIELD(pHdrBuf,HTC_FRAME_HDR,Flags,SendFlags);
+    A_SET_UINT8_FIELD(pHdrBuf,HTC_FRAME_HDR,EndpointID, (A_UINT8)pPacket->Endpoint);
+
+    if (pPacket->Completion == NULL) {
+            /* mark that this request was synchronously issued */
+        sync = TRUE;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND,
+                    ("+-HTCIssueSend: transmit length : %d (%s) \n",
+                    pPacket->ActualLength + HTC_HDR_LENGTH,
+                    sync ? "SYNC" : "ASYNC" ));
+
+        /* send message to device */
+    status = DevSendPacket(&target->Device,
+                           pPacket,
+                           pPacket->ActualLength + HTC_HDR_LENGTH);
+
+    if (sync) {
+            /* use local sync variable.  If this was issued asynchronously, pPacket is no longer
+             * safe to access. */
+        pPacket->pBuffer += HTC_HDR_LENGTH;
+    }
+
+    /* if this request was asynchronous, the packet completion routine will be invoked by
+     * the device layer when the HIF layer completes the request */
+
+    return status;
+}
+
+/* try to send the current packet or a packet at the head of the TX queue,
+ * if there are no credits, the packet remains in the queue.
+ * this function returns the result of the attempt to send the HTC packet */
+static HTC_SEND_QUEUE_RESULT HTCTrySend(HTC_TARGET   *target,
+                         HTC_ENDPOINT *pEndpoint,
+                         HTC_PACKET   *pPacketToSend)
+{
+    HTC_PACKET  *pPacket;
+    int         creditsRequired;
+    int         remainder;
+    A_UINT8     sendFlags;
+    HTC_SEND_QUEUE_RESULT result;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND,("+HTCTrySend (pPkt:0x%X)\n",(A_UINT32)pPacketToSend));
+
+    if (pPacketToSend != NULL) {
+            /* see if adding this packet hits the max depth */
+        if ((pEndpoint->CurrentTxQueueDepth + 1) >= pEndpoint->MaxTxQueueDepth) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_SEND, (" Endpoint %d, TX queue is full, Depth:%d, Max:%d \n",
+                    pPacketToSend->Endpoint, pEndpoint->CurrentTxQueueDepth, pEndpoint->MaxTxQueueDepth));
+                /* queue will be full, invoke any callbacks to determine what action to take */
+            if (pEndpoint->EpCallBacks.EpSendFull != NULL) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_SEND, (" Calling driver's send full callback.... \n"));
+                if (pEndpoint->EpCallBacks.EpSendFull(pEndpoint->EpCallBacks.pContext,
+                                                      pPacketToSend) == HTC_SEND_FULL_DROP) {
+                        /* callback wants the packet dropped */
+                    INC_HTC_EP_STAT(pEndpoint, TxDropped, 1);
+                    AR_DEBUG_PRINTF(ATH_DEBUG_SEND,("-HTCTrySend:  \n"));
+                    return HTC_SEND_QUEUE_DROP;
+                }
+            }
+        }
+    }
+
+    LOCK_HTC_TX(target);
+
+    result = HTC_SEND_QUEUE_OK;
+
+    if (pPacketToSend != NULL) {
+            /* packet was supplied to be queued */
+        HTC_PACKET_ENQUEUE(&pEndpoint->TxQueue,pPacketToSend);
+        pEndpoint->CurrentTxQueueDepth++;
+    }
+
+        /* now drain the TX queue for transmission as long as we have enough
+         * credits */
+
+    while (1) {
+
+        if (HTC_QUEUE_EMPTY(&pEndpoint->TxQueue)) {
+                /* nothing in the queue */
+            break;
+        }
+
+        if (HTC_STOPPING(target)) {
+            if (pPacketToSend != NULL) {
+                HTC_PACKET_REMOVE(pPacketToSend);
+                pEndpoint->CurrentTxQueueDepth--;
+                result = HTC_SEND_QUEUE_DROP;
+            }
+            break;
+        }
+
+        sendFlags = 0;
+
+            /* get packet at head, but don't remove it */
+        pPacket = HTC_GET_PKT_AT_HEAD(&pEndpoint->TxQueue);
+        AR_DEBUG_PRINTF(ATH_DEBUG_SEND,(" Got head packet:0x%X , Queue Depth: %d\n",
+                (A_UINT32)pPacket, pEndpoint->CurrentTxQueueDepth));
+
+            /* figure out how many credits this message requires */
+        creditsRequired = (pPacket->ActualLength + HTC_HDR_LENGTH) / target->TargetCreditSize;
+        remainder = (pPacket->ActualLength + HTC_HDR_LENGTH) % target->TargetCreditSize;
+
+        if (remainder) {
+            creditsRequired++;
+        }
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_SEND,(" Creds Required:%d   Got:%d\n",
+                            creditsRequired, pEndpoint->CreditDist.TxCredits));
+
+        if (pEndpoint->CreditDist.TxCredits < creditsRequired) {
+
+            /* not enough credits */
+
+            if (pPacket->Endpoint == ENDPOINT_0) {
+                    /* leave it in the queue */
+                break;
+            }
+                /* invoke the registered distribution function only if this is not
+                 * endpoint 0, we let the driver layer provide more credits if it can.
+                 * We pass the credit distribution list starting at the endpoint in question
+                 * */
+
+                /* set how many credits we need  */
+            pEndpoint->CreditDist.TxCreditsSeek =
+                                    creditsRequired - pEndpoint->CreditDist.TxCredits;
+            DO_DISTRIBUTION(target,
+                            HTC_CREDIT_DIST_SEEK_CREDITS,
+                            "Seek Credits",
+                            &pEndpoint->CreditDist);
+
+            pEndpoint->CreditDist.TxCreditsSeek = 0;
+
+            if (pEndpoint->CreditDist.TxCredits < creditsRequired) {
+                    /* still not enough credits to send, leave packet in the queue */
+                AR_DEBUG_PRINTF(ATH_DEBUG_SEND,
+                    (" Not enough credits for ep %d leaving packet in queue..\n",
+                    pPacket->Endpoint));
+                break;
+            }
+
+        }
+
+        pEndpoint->CreditDist.TxCredits -= creditsRequired;
+        INC_HTC_EP_STAT(pEndpoint, TxCreditsConsummed, creditsRequired);
+
+            /* check if we need credits back from the target */
+        if (pEndpoint->CreditDist.TxCredits < pEndpoint->CreditDist.TxCreditsPerMaxMsg) {
+                /* we are getting low on credits, see if we can ask for more from the distribution function */
+            pEndpoint->CreditDist.TxCreditsSeek =
+                        pEndpoint->CreditDist.TxCreditsPerMaxMsg - pEndpoint->CreditDist.TxCredits;
+
+            DO_DISTRIBUTION(target,
+                            HTC_CREDIT_DIST_SEEK_CREDITS,
+                            "Seek Credits",
+                            &pEndpoint->CreditDist);
+
+            pEndpoint->CreditDist.TxCreditsSeek = 0;
+                /* see if we were successful in getting more */
+        if (pEndpoint->CreditDist.TxCredits < pEndpoint->CreditDist.TxCreditsPerMaxMsg) {
+                    /* tell the target we need credits ASAP! */
+            sendFlags |= HTC_FLAGS_NEED_CREDIT_UPDATE;
+            INC_HTC_EP_STAT(pEndpoint, TxCreditLowIndications, 1);
+            AR_DEBUG_PRINTF(ATH_DEBUG_SEND,(" Host Needs Credits  \n"));
+        }
+        }
+
+            /* now we can fully dequeue */
+        pPacket = HTC_PACKET_DEQUEUE(&pEndpoint->TxQueue);
+        pEndpoint->CurrentTxQueueDepth--;
+
+        INC_HTC_EP_STAT(pEndpoint, TxIssued, 1);
+
+        UNLOCK_HTC_TX(target);
+
+        HTCIssueSend(target, pPacket, sendFlags);
+
+        LOCK_HTC_TX(target);
+
+        /* go back and check for more messages */
+    }
+
+    UNLOCK_HTC_TX(target);
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND,("-HTCTrySend:  \n"));
+
+    return result;
+}
+
+/* HTC API - HTCSendPkt */
+A_STATUS HTCSendPkt(HTC_HANDLE HTCHandle, HTC_PACKET *pPacket)
+{
+    HTC_TARGET      *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    HTC_ENDPOINT    *pEndpoint;
+    HTC_ENDPOINT_ID ep;
+    A_STATUS        status = A_OK;
+    HTC_SEND_QUEUE_RESULT result;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND,
+                    ("+HTCSendPkt: Enter endPointId: %d, buffer: 0x%X, length: %d \n",
+                    pPacket->Endpoint, (A_UINT32)pPacket->pBuffer, pPacket->ActualLength));
+
+    ep = pPacket->Endpoint;
+    AR_DEBUG_ASSERT(ep < ENDPOINT_MAX);
+    pEndpoint = &target->EndPoint[ep];
+
+    do {
+
+            /* everything sent through this interface is asynchronous */
+            /* fill in HTC completion routines */
+        pPacket->Completion = HTCSendPktCompletionHandler;
+        pPacket->pContext = target;
+
+        result = HTCTrySend(target, pEndpoint, pPacket);
+
+        if (HTC_SEND_QUEUE_DROP == result) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_SEND, (" Endpoint %d, TX packet dropped \n", ep));
+            if (HTC_STOPPING(target)) {
+                status = A_ECANCELED;
+            } else {
+                status = A_NO_RESOURCE;
+            }
+        }
+
+    } while (FALSE);
+
+    if (A_FAILED(status)) {
+        pPacket->Status = status;
+        DO_EP_TX_COMPLETION(pEndpoint,pPacket);
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND, ("-HTCSendPkt \n"));
+
+    return status;
+}
+
+
+/* check TX queues to drain because of credit distribution update */
+static INLINE void HTCCheckEndpointTxQueues(HTC_TARGET *target)
+{
+    HTC_ENDPOINT                *pEndpoint;
+    HTC_ENDPOINT_CREDIT_DIST    *pDistItem;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND, ("+HTCCheckEndpointTxQueues \n"));
+    pDistItem = target->EpCreditDistributionListHead;
+
+        /* run through the credit distribution list to see
+         * if there are packets queued
+         * NOTE: no locks need to be taken since the distribution list
+         * is not dynamic (cannot be re-ordered) and we are not modifying any state */
+    while (pDistItem != NULL) {
+        pEndpoint = (HTC_ENDPOINT *)pDistItem->pHTCReserved;
+
+        if (pEndpoint->CurrentTxQueueDepth > 0) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_SEND, (" Ep %d has %d credits and %d Packets in TX Queue \n",
+                    pDistItem->Endpoint, pEndpoint->CreditDist.TxCredits, pEndpoint->CurrentTxQueueDepth));
+                /* try to start the stalled queue, this list is ordered by priority.
+                 * Highest priority queue get's processed first, if there are credits available the
+                 * highest priority queue will get a chance to reclaim credits from lower priority
+                 * ones */
+            HTCTrySend(target, pEndpoint, NULL);
+        }
+
+        pDistItem = pDistItem->pNext;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND, ("-HTCCheckEndpointTxQueues \n"));
+}
+
+/* process credit reports and call distribution function */
+void HTCProcessCreditRpt(HTC_TARGET *target, HTC_CREDIT_REPORT *pRpt, int NumEntries, HTC_ENDPOINT_ID FromEndpoint)
+{
+    int             i;
+    HTC_ENDPOINT    *pEndpoint;
+    int             totalCredits = 0;
+    A_BOOL          doDist = FALSE;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND, ("+HTCProcessCreditRpt, Credit Report Entries:%d \n", NumEntries));
+
+        /* lock out TX while we update credits */
+    LOCK_HTC_TX(target);
+
+    for (i = 0; i < NumEntries; i++, pRpt++) {
+        if (pRpt->EndpointID >= ENDPOINT_MAX) {
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+
+        pEndpoint = &target->EndPoint[pRpt->EndpointID];
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_SEND, ("  Endpoint %d got %d credits \n",
+                pRpt->EndpointID, pRpt->Credits));
+
+
+#ifdef HTC_EP_STAT_PROFILING
+
+        INC_HTC_EP_STAT(pEndpoint, TxCreditRpts, 1);
+        INC_HTC_EP_STAT(pEndpoint, TxCreditsReturned, pRpt->Credits);
+
+        if (FromEndpoint == pRpt->EndpointID) {
+                /* this credit report arrived on the same endpoint indicating it arrived in an RX
+                 * packet */
+            INC_HTC_EP_STAT(pEndpoint, TxCreditsFromRx, pRpt->Credits);
+            INC_HTC_EP_STAT(pEndpoint, TxCreditRptsFromRx, 1);
+        } else if (FromEndpoint == ENDPOINT_0) {
+                /* this credit arrived on endpoint 0 as a NULL message */
+            INC_HTC_EP_STAT(pEndpoint, TxCreditsFromEp0, pRpt->Credits);
+            INC_HTC_EP_STAT(pEndpoint, TxCreditRptsFromEp0, 1);
+        } else {
+                /* arrived on another endpoint */
+            INC_HTC_EP_STAT(pEndpoint, TxCreditsFromOther, pRpt->Credits);
+            INC_HTC_EP_STAT(pEndpoint, TxCreditRptsFromOther, 1);
+        }
+
+#endif
+
+        if (ENDPOINT_0 == pRpt->EndpointID) {
+                /* always give endpoint 0 credits back */
+            pEndpoint->CreditDist.TxCredits += pRpt->Credits;
+        } else {
+                /* for all other endpoints, update credits to distribute, the distribution function
+                 * will handle giving out credits back to the endpoints */
+            pEndpoint->CreditDist.TxCreditsToDist += pRpt->Credits;
+                /* flag that we have to do the distribution */
+            doDist = TRUE;
+        }
+
+        totalCredits += pRpt->Credits;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND, ("  Report indicated %d credits to distribute \n", totalCredits));
+
+    if (doDist) {
+            /* this was a credit return based on a completed send operations
+             * note, this is done with the lock held */
+        DO_DISTRIBUTION(target,
+                        HTC_CREDIT_DIST_SEND_COMPLETE,
+                        "Send Complete",
+                        target->EpCreditDistributionListHead->pNext);
+    }
+
+    UNLOCK_HTC_TX(target);
+
+    if (totalCredits) {
+        HTCCheckEndpointTxQueues(target);
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND, ("-HTCProcessCreditRpt \n"));
+}
+
+/* flush endpoint TX queue */
+static void HTCFlushEndpointTX(HTC_TARGET *target, HTC_ENDPOINT *pEndpoint, HTC_TX_TAG Tag)
+{
+    HTC_PACKET          *pPacket;
+    HTC_PACKET_QUEUE    discardQueue;
+
+        /* initialize the discard queue */
+    INIT_HTC_PACKET_QUEUE(&discardQueue);
+
+    LOCK_HTC_TX(target);
+
+        /* interate from the front of the TX queue and flush out packets */
+    ITERATE_OVER_LIST_ALLOW_REMOVE(&pEndpoint->TxQueue, pPacket, HTC_PACKET, ListLink) {
+
+            /* check for removal */
+        if ((HTC_TX_PACKET_TAG_ALL == Tag) || (Tag == pPacket->PktInfo.AsTx.Tag)) {
+                /* remove from queue */
+            HTC_PACKET_REMOVE(pPacket);
+                /* add it to the discard pile */
+            HTC_PACKET_ENQUEUE(&discardQueue, pPacket);
+            pEndpoint->CurrentTxQueueDepth--;
+        }
+
+    } ITERATE_END;
+
+    UNLOCK_HTC_TX(target);
+
+        /* empty the discard queue */
+    while (1) {
+        pPacket = HTC_PACKET_DEQUEUE(&discardQueue);
+        if (NULL == pPacket) {
+            break;
+        }
+        pPacket->Status = A_ECANCELED;
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("  Flushing TX packet:0x%X, length:%d, ep:%d tag:0x%X \n",
+                (A_UINT32)pPacket, pPacket->ActualLength, pPacket->Endpoint, pPacket->PktInfo.AsTx.Tag));
+        DO_EP_TX_COMPLETION(pEndpoint,pPacket);
+    }
+
+}
+
+void DumpCreditDist(HTC_ENDPOINT_CREDIT_DIST *pEPDist)
+{
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, ("--- EP : %d  ServiceID: 0x%X    --------------\n",
+                        pEPDist->Endpoint, pEPDist->ServiceID));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" this:0x%X next:0x%X prev:0x%X\n",
+                (A_UINT32)pEPDist, (A_UINT32)pEPDist->pNext, (A_UINT32)pEPDist->pPrev));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" DistFlags          : 0x%X \n", pEPDist->DistFlags));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" TxCreditsNorm      : %d \n", pEPDist->TxCreditsNorm));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" TxCreditsMin       : %d \n", pEPDist->TxCreditsMin));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" TxCredits          : %d \n", pEPDist->TxCredits));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" TxCreditsAssigned  : %d \n", pEPDist->TxCreditsAssigned));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" TxCreditsSeek      : %d \n", pEPDist->TxCreditsSeek));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" TxCreditSize       : %d \n", pEPDist->TxCreditSize));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" TxCreditsPerMaxMsg : %d \n", pEPDist->TxCreditsPerMaxMsg));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" TxCreditsToDist    : %d \n", pEPDist->TxCreditsToDist));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" TxQueueDepth       : %d \n",
+                    ((HTC_ENDPOINT *) pEPDist->pHTCReserved)->CurrentTxQueueDepth));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, ("----------------------------------------------------\n"));
+}
+
+void DumpCreditDistStates(HTC_TARGET *target)
+{
+    HTC_ENDPOINT_CREDIT_DIST *pEPList = target->EpCreditDistributionListHead;
+
+    while (pEPList != NULL) {
+        DumpCreditDist(pEPList);
+        pEPList = pEPList->pNext;
+    }
+
+    if (target->DistributeCredits != NULL) {
+        DO_DISTRIBUTION(target,
+                        HTC_DUMP_CREDIT_STATE,
+                        "Dump State",
+                        NULL);
+    }
+}
+
+/* flush all send packets from all endpoint queues */
+void HTCFlushSendPkts(HTC_TARGET *target)
+{
+    HTC_ENDPOINT    *pEndpoint;
+    int             i;
+
+    DumpCreditDistStates(target);
+
+    for (i = ENDPOINT_0; i < ENDPOINT_MAX; i++) {
+        pEndpoint = &target->EndPoint[i];
+        if (pEndpoint->ServiceID == 0) {
+                /* not in use.. */
+            continue;
+        }
+        HTCFlushEndpointTX(target,pEndpoint,HTC_TX_PACKET_TAG_ALL);
+    }
+
+
+}
+
+/* HTC API to flush an endpoint's TX queue*/
+void HTCFlushEndpoint(HTC_HANDLE HTCHandle, HTC_ENDPOINT_ID Endpoint, HTC_TX_TAG Tag)
+{
+    HTC_TARGET      *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    HTC_ENDPOINT    *pEndpoint = &target->EndPoint[Endpoint];
+
+    if (pEndpoint->ServiceID == 0) {
+        AR_DEBUG_ASSERT(FALSE);
+        /* not in use.. */
+        return;
+    }
+
+    HTCFlushEndpointTX(target, pEndpoint, Tag);
+}
+
+/* HTC API to indicate activity to the credit distribution function */
+void HTCIndicateActivityChange(HTC_HANDLE      HTCHandle,
+                               HTC_ENDPOINT_ID Endpoint,
+                               A_BOOL          Active)
+{
+    HTC_TARGET      *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    HTC_ENDPOINT    *pEndpoint = &target->EndPoint[Endpoint];
+    A_BOOL          doDist = FALSE;
+
+    if (pEndpoint->ServiceID == 0) {
+        AR_DEBUG_ASSERT(FALSE);
+        /* not in use.. */
+        return;
+    }
+
+    LOCK_HTC_TX(target);
+
+    if (Active) {
+        if (!(pEndpoint->CreditDist.DistFlags & HTC_EP_ACTIVE)) {
+                /* mark active now */
+            pEndpoint->CreditDist.DistFlags |= HTC_EP_ACTIVE;
+            doDist = TRUE;
+        }
+    } else {
+        if (pEndpoint->CreditDist.DistFlags & HTC_EP_ACTIVE) {
+                /* mark inactive now */
+            pEndpoint->CreditDist.DistFlags &= ~HTC_EP_ACTIVE;
+            doDist = TRUE;
+        }
+    }
+
+    if (doDist) {
+        /* do distribution again based on activity change
+         * note, this is done with the lock held */
+        DO_DISTRIBUTION(target,
+                        HTC_CREDIT_DIST_ACTIVITY_CHANGE,
+                        "Activity Change",
+                        target->EpCreditDistributionListHead->pNext);
+    }
+
+    UNLOCK_HTC_TX(target);
+
+    if (doDist && !Active) {
+        /* if a stream went inactive and this resulted in a credit distribution change,
+         * some credits may now be available for HTC packets that are stuck in
+         * HTC queues */
+        HTCCheckEndpointTxQueues(target);
+    }
+}
+
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/htc/htc_services.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/htc/htc_services.c
@@ -0,0 +1,409 @@
+/*
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "htc_internal.h"
+
+void HTCControlTxComplete(void *Context, HTC_PACKET *pPacket)
+{
+        /* not implemented
+         * we do not send control TX frames during normal runtime, only during setup  */
+    AR_DEBUG_ASSERT(FALSE);
+}
+
+    /* callback when a control message arrives on this endpoint */
+void HTCControlRecv(void *Context, HTC_PACKET *pPacket)
+{
+    AR_DEBUG_ASSERT(pPacket->Endpoint == ENDPOINT_0);
+
+    if (pPacket->Status == A_ECANCELED) {
+        /* this is a flush operation, return the control packet back to the pool */
+        HTC_FREE_CONTROL_RX((HTC_TARGET*)Context,pPacket);
+        return;
+    }
+
+        /* the only control messages we are expecting are NULL messages (credit resports), which should
+         * never get here */
+    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                    ("HTCControlRecv, got message with length:%d \n",
+                    pPacket->ActualLength + HTC_HDR_LENGTH));
+
+        /* dump header and message */
+    DebugDumpBytes(pPacket->pBuffer - HTC_HDR_LENGTH,
+                   pPacket->ActualLength + HTC_HDR_LENGTH,
+                   "Unexpected ENDPOINT 0 Message");
+
+    HTC_RECYCLE_RX_PKT((HTC_TARGET*)Context,pPacket,&((HTC_TARGET*)Context)->EndPoint[0]);
+}
+
+A_STATUS HTCSendSetupComplete(HTC_TARGET *target)
+{
+    HTC_PACKET             *pSendPacket = NULL;
+    A_STATUS                status;
+    HTC_SETUP_COMPLETE_MSG *pSetupComplete;
+
+    do {
+           /* allocate a packet to send to the target */
+        pSendPacket = HTC_ALLOC_CONTROL_TX(target);
+
+        if (NULL == pSendPacket) {
+            status = A_NO_MEMORY;
+            break;
+        }
+
+            /* assemble setup complete message */
+        pSetupComplete = (HTC_SETUP_COMPLETE_MSG *)pSendPacket->pBuffer;
+        A_MEMZERO(pSetupComplete,sizeof(HTC_SETUP_COMPLETE_MSG));
+        pSetupComplete->MessageID = HTC_MSG_SETUP_COMPLETE_ID;
+
+        SET_HTC_PACKET_INFO_TX(pSendPacket,
+                               NULL,
+                               (A_UINT8 *)pSetupComplete,
+                               sizeof(HTC_SETUP_COMPLETE_MSG),
+                               ENDPOINT_0,
+                               HTC_SERVICE_TX_PACKET_TAG);
+
+            /* we want synchronous operation */
+        pSendPacket->Completion = NULL;
+            /* send the message */
+        status = HTCIssueSend(target,pSendPacket,0);
+
+    } while (FALSE);
+
+    if (pSendPacket != NULL) {
+        HTC_FREE_CONTROL_TX(target,pSendPacket);
+    }
+
+    return status;
+}
+
+
+A_STATUS HTCConnectService(HTC_HANDLE               HTCHandle,
+                           HTC_SERVICE_CONNECT_REQ  *pConnectReq,
+                           HTC_SERVICE_CONNECT_RESP *pConnectResp)
+{
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    A_STATUS                            status = A_OK;
+    HTC_PACKET                          *pRecvPacket = NULL;
+    HTC_PACKET                          *pSendPacket = NULL;
+    HTC_CONNECT_SERVICE_RESPONSE_MSG    *pResponseMsg;
+    HTC_CONNECT_SERVICE_MSG             *pConnectMsg;
+    HTC_ENDPOINT_ID                     assignedEndpoint = ENDPOINT_MAX;
+    HTC_ENDPOINT                        *pEndpoint;
+    int                                 maxMsgSize = 0;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("+HTCConnectService, target:0x%X SvcID:0x%X \n",
+               (A_UINT32)target, pConnectReq->ServiceID));
+
+    do {
+
+        AR_DEBUG_ASSERT(pConnectReq->ServiceID != 0);
+
+        if (HTC_CTRL_RSVD_SVC == pConnectReq->ServiceID) {
+                /* special case for pseudo control service */
+            assignedEndpoint = ENDPOINT_0;
+            maxMsgSize = HTC_MAX_CONTROL_MESSAGE_LENGTH;
+        } else {
+                /* allocate a packet to send to the target */
+            pSendPacket = HTC_ALLOC_CONTROL_TX(target);
+
+            if (NULL == pSendPacket) {
+                AR_DEBUG_ASSERT(FALSE);
+                status = A_NO_MEMORY;
+                break;
+            }
+                /* assemble connect service message */
+            pConnectMsg = (HTC_CONNECT_SERVICE_MSG *)pSendPacket->pBuffer;
+            AR_DEBUG_ASSERT(pConnectMsg != NULL);
+            A_MEMZERO(pConnectMsg,sizeof(HTC_CONNECT_SERVICE_MSG));
+            pConnectMsg->MessageID = HTC_MSG_CONNECT_SERVICE_ID;
+            pConnectMsg->ServiceID = pConnectReq->ServiceID;
+            pConnectMsg->ConnectionFlags = pConnectReq->ConnectionFlags;
+                /* check caller if it wants to transfer meta data */
+            if ((pConnectReq->pMetaData != NULL) &&
+                (pConnectReq->MetaDataLength <= HTC_SERVICE_META_DATA_MAX_LENGTH)) {
+                    /* copy meta data into message buffer (after header ) */
+                A_MEMCPY((A_UINT8 *)pConnectMsg + sizeof(HTC_CONNECT_SERVICE_MSG),
+                         pConnectReq->pMetaData,
+                         pConnectReq->MetaDataLength);
+                pConnectMsg->ServiceMetaLength = pConnectReq->MetaDataLength;
+            }
+
+            SET_HTC_PACKET_INFO_TX(pSendPacket,
+                                   NULL,
+                                   (A_UINT8 *)pConnectMsg,
+                                   sizeof(HTC_CONNECT_SERVICE_MSG) + pConnectMsg->ServiceMetaLength,
+                                   ENDPOINT_0,
+                                   HTC_SERVICE_TX_PACKET_TAG);
+
+                /* we want synchronous operation */
+            pSendPacket->Completion = NULL;
+
+            status = HTCIssueSend(target,pSendPacket,0);
+
+            if (A_FAILED(status)) {
+                break;
+            }
+
+                /* wait for response */
+            status = HTCWaitforControlMessage(target, &pRecvPacket);
+
+            if (A_FAILED(status)) {
+                break;
+            }
+                /* we controlled the buffer creation so it has to be properly aligned */
+            pResponseMsg = (HTC_CONNECT_SERVICE_RESPONSE_MSG *)pRecvPacket->pBuffer;
+
+            if ((pResponseMsg->MessageID != HTC_MSG_CONNECT_SERVICE_RESPONSE_ID) ||
+                (pRecvPacket->ActualLength < sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG))) {
+                    /* this message is not valid */
+                AR_DEBUG_ASSERT(FALSE);
+                status = A_EPROTO;
+                break;
+            }
+
+            pConnectResp->ConnectRespCode = pResponseMsg->Status;
+                /* check response status */
+            if (pResponseMsg->Status != HTC_SERVICE_SUCCESS) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                    (" Target failed service 0x%X connect request (status:%d)\n",
+                                pResponseMsg->ServiceID, pResponseMsg->Status));
+                status = A_EPROTO;
+                break;
+            }
+
+            assignedEndpoint = (HTC_ENDPOINT_ID) pResponseMsg->EndpointID;
+            maxMsgSize = pResponseMsg->MaxMsgSize;
+
+            if ((pConnectResp->pMetaData != NULL) &&
+                (pResponseMsg->ServiceMetaLength > 0) &&
+                (pResponseMsg->ServiceMetaLength <= HTC_SERVICE_META_DATA_MAX_LENGTH)) {
+                    /* caller supplied a buffer and the target responded with data */
+                int copyLength = min((int)pConnectResp->BufferLength, (int)pResponseMsg->ServiceMetaLength);
+                    /* copy the meta data */
+                A_MEMCPY(pConnectResp->pMetaData,
+                         ((A_UINT8 *)pResponseMsg) + sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG),
+                         copyLength);
+                pConnectResp->ActualLength = copyLength;
+            }
+
+        }
+
+            /* the rest of these are parameter checks so set the error status */
+        status = A_EPROTO;
+
+        if (assignedEndpoint >= ENDPOINT_MAX) {
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+
+        if (0 == maxMsgSize) {
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+
+        pEndpoint = &target->EndPoint[assignedEndpoint];
+
+        if (pEndpoint->ServiceID != 0) {
+            /* endpoint already in use! */
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+
+            /* return assigned endpoint to caller */
+        pConnectResp->Endpoint = assignedEndpoint;
+        pConnectResp->MaxMsgLength = maxMsgSize;
+
+            /* setup the endpoint */
+        pEndpoint->ServiceID = pConnectReq->ServiceID; /* this marks the endpoint in use */
+        pEndpoint->MaxTxQueueDepth = pConnectReq->MaxSendQueueDepth;
+        pEndpoint->MaxMsgLength = maxMsgSize;
+            /* copy all the callbacks */
+        pEndpoint->EpCallBacks = pConnectReq->EpCallbacks;
+        INIT_HTC_PACKET_QUEUE(&pEndpoint->RxBuffers);
+        INIT_HTC_PACKET_QUEUE(&pEndpoint->TxQueue);
+            /* set the credit distribution info for this endpoint, this information is
+             * passed back to the credit distribution callback function */
+        pEndpoint->CreditDist.ServiceID = pConnectReq->ServiceID;
+        pEndpoint->CreditDist.pHTCReserved = pEndpoint;
+        pEndpoint->CreditDist.Endpoint = assignedEndpoint;
+        pEndpoint->CreditDist.TxCreditSize = target->TargetCreditSize;
+        pEndpoint->CreditDist.TxCreditsPerMaxMsg = maxMsgSize / target->TargetCreditSize;
+
+        if (0 == pEndpoint->CreditDist.TxCreditsPerMaxMsg) {
+            pEndpoint->CreditDist.TxCreditsPerMaxMsg = 1;
+        }
+
+        status = A_OK;
+
+    } while (FALSE);
+
+    if (pSendPacket != NULL) {
+        HTC_FREE_CONTROL_TX(target,pSendPacket);
+    }
+
+    if (pRecvPacket != NULL) {
+        HTC_FREE_CONTROL_RX(target,pRecvPacket);
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("-HTCConnectService \n"));
+
+    return status;
+}
+
+static void AddToEndpointDistList(HTC_TARGET *target, HTC_ENDPOINT_CREDIT_DIST *pEpDist)
+{
+    HTC_ENDPOINT_CREDIT_DIST *pCurEntry,*pLastEntry;
+
+    if (NULL == target->EpCreditDistributionListHead) {
+        target->EpCreditDistributionListHead = pEpDist;
+        pEpDist->pNext = NULL;
+        pEpDist->pPrev = NULL;
+        return;
+    }
+
+        /* queue to the end of the list, this does not have to be very
+         * fast since this list is built at startup time */
+    pCurEntry = target->EpCreditDistributionListHead;
+
+    while (pCurEntry) {
+        pLastEntry = pCurEntry;
+        pCurEntry = pCurEntry->pNext;
+    }
+
+    pLastEntry->pNext = pEpDist;
+    pEpDist->pPrev = pLastEntry;
+    pEpDist->pNext = NULL;
+}
+
+
+
+/* default credit init callback */
+static void HTCDefaultCreditInit(void                     *Context,
+                                 HTC_ENDPOINT_CREDIT_DIST *pEPList,
+                                 int                      TotalCredits)
+{
+    HTC_ENDPOINT_CREDIT_DIST *pCurEpDist;
+    int                      totalEps = 0;
+    int                      creditsPerEndpoint;
+
+    pCurEpDist = pEPList;
+        /* first run through the list and figure out how many endpoints we are dealing with */
+    while (pCurEpDist != NULL) {
+        pCurEpDist = pCurEpDist->pNext;
+        totalEps++;
+    }
+
+        /* even distribution */
+    creditsPerEndpoint = TotalCredits/totalEps;
+
+    pCurEpDist = pEPList;
+        /* run through the list and set minimum and normal credits and
+         * provide the endpoint with some credits to start */
+    while (pCurEpDist != NULL) {
+
+        if (creditsPerEndpoint < pCurEpDist->TxCreditsPerMaxMsg) {
+                /* too many endpoints and not enough credits */
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+            /* our minimum is set for at least 1 max message */
+        pCurEpDist->TxCreditsMin = pCurEpDist->TxCreditsPerMaxMsg;
+            /* this value is ignored by our credit alg, since we do
+             * not dynamically adjust credits, this is the policy of
+             * the "default" credit distribution, something simple and easy */
+        pCurEpDist->TxCreditsNorm = 0xFFFF;
+            /* give the endpoint minimum credits */
+        pCurEpDist->TxCredits = creditsPerEndpoint;
+        pCurEpDist->TxCreditsAssigned = creditsPerEndpoint;
+        pCurEpDist = pCurEpDist->pNext;
+    }
+
+}
+
+/* default credit distribution callback, NOTE, this callback holds the TX lock */
+void HTCDefaultCreditDist(void                     *Context,
+                          HTC_ENDPOINT_CREDIT_DIST *pEPDistList,
+                          HTC_CREDIT_DIST_REASON   Reason)
+{
+    HTC_ENDPOINT_CREDIT_DIST *pCurEpDist;
+
+    if (Reason == HTC_CREDIT_DIST_SEND_COMPLETE) {
+        pCurEpDist = pEPDistList;
+            /* simple distribution */
+        while (pCurEpDist != NULL) {
+            if (pCurEpDist->TxCreditsToDist > 0) {
+                    /* just give the endpoint back the credits */
+                pCurEpDist->TxCredits += pCurEpDist->TxCreditsToDist;
+                pCurEpDist->TxCreditsToDist = 0;
+            }
+            pCurEpDist = pCurEpDist->pNext;
+        }
+    }
+
+    /* note we do not need to handle the other reason codes as this is a very
+     * simple distribution scheme, no need to seek for more credits or handle inactivity */
+}
+
+void HTCSetCreditDistribution(HTC_HANDLE               HTCHandle,
+                              void                     *pCreditDistContext,
+                              HTC_CREDIT_DIST_CALLBACK CreditDistFunc,
+                              HTC_CREDIT_INIT_CALLBACK CreditInitFunc,
+                              HTC_SERVICE_ID           ServicePriorityOrder[],
+                              int                      ListLength)
+{
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    int i;
+    int ep;
+
+    if (CreditInitFunc != NULL) {
+            /* caller has supplied their own distribution functions */
+        target->InitCredits = CreditInitFunc;
+        AR_DEBUG_ASSERT(CreditDistFunc != NULL);
+        target->DistributeCredits = CreditDistFunc;
+        target->pCredDistContext = pCreditDistContext;
+    } else {
+        /* caller wants HTC to do distribution */
+        /* if caller wants service to handle distributions then
+         * it must set both of these to NULL! */
+        AR_DEBUG_ASSERT(CreditDistFunc == NULL);
+        target->InitCredits = HTCDefaultCreditInit;
+        target->DistributeCredits = HTCDefaultCreditDist;
+        target->pCredDistContext = target;
+    }
+
+        /* always add HTC control endpoint first, we only expose the list after the
+         * first one, this is added for TX queue checking */
+    AddToEndpointDistList(target, &target->EndPoint[ENDPOINT_0].CreditDist);
+
+        /* build the list of credit distribution structures in priority order
+         * supplied by the caller, these will follow endpoint 0 */
+    for (i = 0; i < ListLength; i++) {
+            /* match services with endpoints and add the endpoints to the distribution list
+             * in FIFO order */
+        for (ep = ENDPOINT_1; ep < ENDPOINT_MAX; ep++) {
+            if (target->EndPoint[ep].ServiceID == ServicePriorityOrder[i]) {
+                    /* queue this one to the list */
+                AddToEndpointDistList(target, &target->EndPoint[ep].CreditDist);
+                break;
+            }
+        }
+        AR_DEBUG_ASSERT(ep < ENDPOINT_MAX);
+    }
+
+}
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/AR6K_version.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/AR6K_version.h
@@ -0,0 +1,52 @@
+//------------------------------------------------------------------------------
+// <copyright file="AR6K_version.h" company="Atheros">
+//    Copyright (c) 2004-2007 Atheros Corporation.  All rights reserved.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation;
+//
+// Software distributed under the License is distributed on an "AS
+// IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+// implied. See the License for the specific language governing
+// rights and limitations under the License.
+//
+//
+//------------------------------------------------------------------------------
+//==============================================================================
+// Author(s): ="Atheros"
+//==============================================================================
+
+#define __VER_MAJOR_ 2
+#define __VER_MINOR_ 1
+#define __VER_PATCH_ 2
+
+
+/* The makear6ksdk script (used for release builds) modifies the following line. */
+#define __BUILD_NUMBER_ 53
+
+
+/* Format of the version number. */
+#define VER_MAJOR_BIT_OFFSET		28
+#define VER_MINOR_BIT_OFFSET		24
+#define VER_PATCH_BIT_OFFSET		16
+#define VER_BUILD_NUM_BIT_OFFSET	0
+
+
+/*
+ * The version has the following format:
+ * Bits 28-31: Major version
+ * Bits 24-27: Minor version
+ * Bits 16-23: Patch version
+ * Bits 0-15:  Build number (automatically generated during build process )
+ * E.g. Build 1.1.3.7 would be represented as 0x11030007.
+ *
+ * DO NOT split the following macro into multiple lines as this may confuse the build scripts.
+ */
+#define AR6K_SW_VERSION 	( ( __VER_MAJOR_ << VER_MAJOR_BIT_OFFSET ) + ( __VER_MINOR_ << VER_MINOR_BIT_OFFSET ) + ( __VER_PATCH_ << VER_PATCH_BIT_OFFSET ) + ( __BUILD_NUMBER_ << VER_BUILD_NUM_BIT_OFFSET ) )
+
+#define AR6K_VERSION(major, minor, patch, build)	\
+	(((major) << VER_MAJOR_BIT_OFFSET)		\
+	 | ((minor) << VER_MINOR_BIT_OFFSET)		\
+	 | ((patch) << VER_PATCH_BIT_OFFSET)		\
+	 | ((build) << VER_BUILD_NUM_BIT_OFFSET))
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/a_drv_api.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/a_drv_api.h
@@ -0,0 +1,194 @@
+
+#ifndef _A_DRV_API_H_
+#define _A_DRV_API_H_
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/****************************************************************************/
+/****************************************************************************/
+/**                                                                        **/
+/** WMI related hooks                                                      **/
+/**                                                                        **/
+/****************************************************************************/
+/****************************************************************************/
+
+#include "../include/ar6000_api.h"
+
+#define A_WMI_CHANNELLIST_RX(devt, numChan, chanList)	\
+	ar6000_channelList_rx((devt), (numChan), (chanList))
+
+#define A_WMI_SET_NUMDATAENDPTS(devt, num)	\
+	ar6000_set_numdataendpts((devt), (num))
+
+#define A_WMI_CONTROL_TX(devt, osbuf, streamID)	\
+	ar6000_control_tx((devt), (osbuf), (streamID))
+
+#define A_WMI_TARGETSTATS_EVENT(devt, pStats)	\
+	ar6000_targetStats_event((devt), (pStats))
+
+#define A_WMI_SCANCOMPLETE_EVENT(devt, status)	\
+	ar6000_scanComplete_event((devt), (status))
+
+#ifdef CONFIG_HOST_DSET_SUPPORT
+
+#define A_WMI_DSET_DATA_REQ(devt, access_cookie, offset, length, targ_buf, targ_reply_fn, targ_reply_arg)	\
+	ar6000_dset_data_req((devt), (access_cookie), (offset), (length), (targ_buf), (targ_reply_fn), (targ_reply_arg))
+
+#define A_WMI_DSET_CLOSE(devt, access_cookie)	\
+	ar6000_dset_close((devt), (access_cookie))
+
+#endif
+
+#define A_WMI_DSET_OPEN_REQ(devt, id, targ_handle, targ_reply_fn, targ_reply_arg) \
+	ar6000_dset_open_req((devt), (id), (targ_handle), (targ_reply_fn), (targ_reply_arg))
+
+#define A_WMI_CONNECT_EVENT(devt, channel, bssid, listenInterval, beaconInterval, networkType, beaconIeLen, assocReqLen, assocRespLen, assocInfo) \
+	ar6000_connect_event((devt), (channel), (bssid), (listenInterval), (beaconInterval), (networkType), (beaconIeLen), (assocReqLen), (assocRespLen), (assocInfo))
+
+#define A_WMI_REGDOMAIN_EVENT(devt, regCode)	\
+	ar6000_regDomain_event((devt), (regCode))
+
+#define A_WMI_NEIGHBORREPORT_EVENT(devt, numAps, info)	\
+	ar6000_neighborReport_event((devt), (numAps), (info))
+
+#define A_WMI_DISCONNECT_EVENT(devt, reason, bssid, assocRespLen, assocInfo, protocolReasonStatus)	\
+	ar6000_disconnect_event((devt), (reason), (bssid), (assocRespLen), (assocInfo), (protocolReasonStatus))
+
+#define A_WMI_TKIP_MICERR_EVENT(devt, keyid, ismcast)	\
+	ar6000_tkip_micerr_event((devt), (keyid), (ismcast))
+
+#define A_WMI_BITRATE_RX(devt, rateKbps)	\
+	ar6000_bitrate_rx((devt), (rateKbps))
+
+#define A_WMI_TXPWR_RX(devt, txPwr)	\
+	ar6000_txPwr_rx((devt), (txPwr))
+
+#define A_WMI_READY_EVENT(devt, datap, phyCap, ver)	\
+	ar6000_ready_event((devt), (datap), (phyCap), (ver))
+
+#define A_WMI_DBGLOG_INIT_DONE(ar) \
+        ar6000_dbglog_init_done(ar);
+
+#define A_WMI_RSSI_THRESHOLD_EVENT(devt, newThreshold, rssi)	\
+	ar6000_rssiThreshold_event((devt), (newThreshold), (rssi))
+
+#define A_WMI_REPORT_ERROR_EVENT(devt, errorVal)	\
+	ar6000_reportError_event((devt), (errorVal))
+
+#define A_WMI_ROAM_TABLE_EVENT(devt, pTbl) \
+	ar6000_roam_tbl_event((devt), (pTbl))
+
+#define A_WMI_ROAM_DATA_EVENT(devt, p) \
+	ar6000_roam_data_event((devt), (p))
+
+#define A_WMI_WOW_LIST_EVENT(devt, num_filters, wow_filters)	\
+	ar6000_wow_list_event((devt), (num_filters), (wow_filters))
+
+#define A_WMI_CAC_EVENT(devt, ac, cac_indication, statusCode, tspecSuggestion)  \
+	ar6000_cac_event((devt), (ac), (cac_indication), (statusCode), (tspecSuggestion))
+
+#define A_WMI_CHANNEL_CHANGE_EVENT(devt, oldChannel, newChannel)  \
+	ar6000_channel_change_event((devt), (oldChannel), (newChannel))
+
+#define A_WMI_PMKID_LIST_EVENT(devt, num_pmkid, pmkid_list, bssid_list)	\
+	ar6000_pmkid_list_event((devt), (num_pmkid), (pmkid_list), (bssid_list))
+
+#ifdef CONFIG_HOST_GPIO_SUPPORT
+
+#define A_WMI_GPIO_INTR_RX(intr_mask, input_values) \
+	ar6000_gpio_intr_rx((intr_mask), (input_values))
+
+#define A_WMI_GPIO_DATA_RX(reg_id, value) \
+	ar6000_gpio_data_rx((reg_id), (value))
+
+#define A_WMI_GPIO_ACK_RX() \
+	ar6000_gpio_ack_rx()
+
+#endif
+
+#ifdef SEND_EVENT_TO_APP
+
+#define A_WMI_SEND_EVENT_TO_APP(ar, eventId, datap, len) \
+	ar6000_send_event_to_app((ar), (eventId), (datap), (len))
+
+#else
+
+#define A_WMI_SEND_EVENT_TO_APP(ar, eventId, datap, len)
+
+#endif
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+#define A_WMI_TCMD_RX_REPORT_EVENT(devt, results, len) \
+	ar6000_tcmd_rx_report_event((devt), (results), (len))
+#endif
+
+#define A_WMI_HBCHALLENGERESP_EVENT(devt, cookie, source)    \
+    ar6000_hbChallengeResp_event((devt), (cookie), (source))
+
+#define A_WMI_TX_RETRY_ERR_EVENT(devt) \
+	ar6000_tx_retry_err_event((devt))
+
+#define A_WMI_SNR_THRESHOLD_EVENT_RX(devt, newThreshold, snr) \
+	ar6000_snrThresholdEvent_rx((devt), (newThreshold), (snr))
+
+#define A_WMI_LQ_THRESHOLD_EVENT_RX(devt, range, lqVal) \
+	ar6000_lqThresholdEvent_rx((devt), (range), (lqVal))
+
+#define A_WMI_RATEMASK_RX(devt, ratemask) \
+	ar6000_ratemask_rx((devt), (ratemask))
+
+#define A_WMI_KEEPALIVE_RX(devt, configured)    \
+        ar6000_keepalive_rx((devt), (configured))
+
+#define A_WMI_BSSINFO_EVENT_RX(ar, datp, len)   \
+        ar6000_bssInfo_event_rx((ar), (datap), (len))
+
+#define A_WMI_DBGLOG_EVENT(ar, dropped, buffer, length) \
+        ar6000_dbglog_event((ar), (dropped), (buffer), (length));
+
+#define A_WMI_STREAM_TX_ACTIVE(devt,trafficClass) \
+    ar6000_indicate_tx_activity((devt),(trafficClass), TRUE)
+
+#define A_WMI_STREAM_TX_INACTIVE(devt,trafficClass) \
+    ar6000_indicate_tx_activity((devt),(trafficClass), FALSE)
+#define A_WMI_Ac2EndpointID(devht, ac)\
+    ar6000_ac2_endpoint_id((devht), (ac))
+
+#define A_WMI_Endpoint2Ac(devt, ep) \
+    ar6000_endpoint_id2_ac((devt), (ep))
+/****************************************************************************/
+/****************************************************************************/
+/**                                                                        **/
+/** HTC related hooks                                                      **/
+/**                                                                        **/
+/****************************************************************************/
+/****************************************************************************/
+
+#if defined(CONFIG_TARGET_PROFILE_SUPPORT)
+#define A_WMI_PROF_COUNT_RX(addr, count) prof_count_rx((addr), (count))
+#endif /* CONFIG_TARGET_PROFILE_SUPPORT */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/addrs.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/addrs.h
@@ -0,0 +1,63 @@
+//------------------------------------------------------------------------------
+// <copyright file="addrs.h" company="Atheros">
+//    Copyright (c) 2004-2007 Atheros Corporation.  All rights reserved.
+//
+// The software source and binaries included in this development package are
+// licensed, not sold. You, or your company, received the package under one
+// or more license agreements. The rights granted to you are specifically
+// listed in these license agreement(s). All other rights remain with Atheros
+// Communications, Inc., its subsidiaries, or the respective owner including
+// those listed on the included copyright notices.  Distribution of any
+// portion of this package must be in strict compliance with the license
+// agreement(s) terms.
+// </copyright>
+//
+// <summary>
+// 	Wifi driver for AR6002
+// </summary>
+//
+//------------------------------------------------------------------------------
+//==============================================================================
+// Author(s): ="Atheros"
+//==============================================================================
+
+#ifndef __ADDRS_H__
+#define __ADDRS_H__
+
+/*
+ * Special AR6002 Addresses that may be needed by special
+ * applications (e.g. ART) on the Host as well as Target.
+ */
+
+#define AR6K_RAM_START 0x00500000
+#define AR6K_RAM_ADDR(byte_offset) (AR6K_RAM_START+(byte_offset))
+#define TARG_RAM_ADDRS(byte_offset) AR6K_RAM_ADDR(byte_offset)
+#define TARG_RAM_OFFSET(vaddr) ((A_UINT32)(vaddr) & 0xfffff)
+#define TARG_RAM_SZ (184*1024)
+
+#define AR6K_ROM_START 0x004e0000
+#define AR6K_ROM_ADDR(byte_offset) (AR6K_ROM_START+(byte_offset))
+#define TARG_ROM_ADDRS(byte_offset) AR6K_ROM_ADDR(byte_offset)
+
+/*
+ * At this ROM address is a pointer to the start of the ROM DataSet Index.
+ * If there are no ROM DataSets, there's a 0 at this address.
+ */
+#define ROM_DATASET_INDEX_ADDR          0x004f3ff8
+#define ROM_MBIST_CKSUM_ADDR            0x004f3ffc
+
+/*
+ * The API A_BOARD_DATA_ADDR() is the proper way to get a read pointer to
+ * board data.
+ */
+
+/* Size of Board Data, in bytes */
+#define AR6002_BOARD_DATA_SZ 768
+#define BOARD_DATA_SZ AR6002_BOARD_DATA_SZ
+
+/*
+ * Constants used by ASM code to access fields of host_interest_s,
+ * which is at a fixed location in RAM.
+ */
+#define FLASH_IS_PRESENT_TARGADDR       0x0050040c
+#endif /* __ADDRS_H__ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/apb_map.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/apb_map.h
@@ -0,0 +1,37 @@
+// ------------------------------------------------------------------
+// Copyright (c) 2004-2007 Atheros Corporation.  All rights reserved.
+//
+// The software source and binaries included in this development package are
+// licensed, not sold. You, or your company, received the package under one
+// or more license agreements. The rights granted to you are specifically
+// listed in these license agreement(s). All other rights remain with Atheros
+// Communications, Inc., its subsidiaries, or the respective owner including
+// those listed on the included copyright notices.  Distribution of any
+// portion of this package must be in strict compliance with the license
+// agreement(s) terms.
+// </copyright>
+//
+// <summary>
+// 	Wifi driver for AR6002
+// </summary>
+//
+// ------------------------------------------------------------------
+//===================================================================
+// Author(s): ="Atheros"
+//===================================================================
+
+/* These values only apply to the AR6002 */
+
+#ifndef _APB_MAP_H_
+#define _APB_MAP_H_
+
+#define RTC_BASE_ADDRESS                         0x00004000
+#define VMC_BASE_ADDRESS                         0x00008000
+#define UART_BASE_ADDRESS                        0x0000c000
+#define SI_BASE_ADDRESS                          0x00010000
+#define GPIO_BASE_ADDRESS                        0x00014000
+#define MBOX_BASE_ADDRESS                        0x00018000
+#define ANALOG_INTF_BASE_ADDRESS                 0x0001c000
+#define MAC_BASE_ADDRESS                         0x00020000
+
+#endif /* _APB_MAP_REG_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/ar6000_api.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/ar6000_api.h
@@ -0,0 +1,32 @@
+
+#ifndef _AR6000_API_H_
+#define _AR6000_API_H_
+/*
+ * Copyright (c) 2004-2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * This file contains the API to access the OS dependent atheros host driver
+ * by the WMI or WLAN generic modules.
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/include/ar6000_api.h#1 $
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#if defined(__linux__) && !defined(LINUX_EMULATION)
+#include "../include/ar6xapi.h"
+#endif
+
+#endif /* _AR6000_API_H */
+
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/ar6000_diag.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/ar6000_diag.h
@@ -0,0 +1,38 @@
+
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef AR6000_DIAG_H_
+#define AR6000_DIAG_H_
+
+
+A_STATUS
+ar6000_ReadRegDiag(HIF_DEVICE *hifDevice, A_UINT32 *address, A_UINT32 *data);
+
+A_STATUS
+ar6000_WriteRegDiag(HIF_DEVICE *hifDevice, A_UINT32 *address, A_UINT32 *data);
+
+A_STATUS
+ar6000_ReadDataDiag(HIF_DEVICE *hifDevice, A_UINT32 address,
+                    A_UCHAR *data, A_UINT32 length);
+
+A_STATUS
+ar6000_WriteDataDiag(HIF_DEVICE *hifDevice, A_UINT32 address,
+                     A_UCHAR *data, A_UINT32 length);
+
+#endif /*AR6000_DIAG_H_*/
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/ar6000_drv.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/ar6000_drv.h
@@ -0,0 +1,382 @@
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef _AR6000_H_
+#define _AR6000_H_
+
+#include <linux/version.h>
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,17)
+#include <linux/config.h>
+#else
+#include <linux/autoconf.h>
+#endif
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/skbuff.h>
+#include <linux/if_ether.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <net/iw_handler.h>
+#include <linux/if_arp.h>
+#include <linux/ip.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#include <linux/wireless.h>
+#include <linux/module.h>
+#include <asm/io.h>
+
+#include "../include/config.h"
+#include "../include/athdefs.h"
+#include "../include/athtypes.h"
+#include "../include/osapi.h"
+#include "../include/htc_api.h"
+#include "../include/wmi.h"
+#include "../include/athdrv.h"
+#include "../include/bmi.h"
+#include "../include/ieee80211.h"
+#include "../include/ieee80211_ioctl.h"
+#include "../include/wlan_api.h"
+#include "../include/wmi_api.h"
+#include "../include/gpio_api.h"
+#include "../include/gpio.h"
+#include "../include/host_version.h"
+#include "../include/athdrv.h"
+#include <linux/rtnetlink.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <asm/uaccess.h>
+#else
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#endif
+#include "../include/ar6000_api.h"
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+#include "../include/testcmd.h"
+#endif
+
+#include "../include/targaddrs.h"
+#include "../include/dbglog_api.h"
+#include "../include/ar6000_diag.h"
+#include "../include/common_drv.h"
+#include "../include/roaming.h"
+
+#ifndef  __dev_put
+#define  __dev_put(dev) dev_put(dev)
+#endif
+
+#ifdef USER_KEYS
+
+#define USER_SAVEDKEYS_STAT_INIT     0
+#define USER_SAVEDKEYS_STAT_RUN      1
+
+// TODO this needs to move into the AR_SOFTC struct
+struct USER_SAVEDKEYS {
+    struct ieee80211req_key   ucast_ik;
+    struct ieee80211req_key   bcast_ik;
+    CRYPTO_TYPE               keyType;
+    A_BOOL                    keyOk;
+};
+#endif
+
+#define DBG_INFO		0x00000001
+#define DBG_ERROR		0x00000002
+#define DBG_WARNING		0x00000004
+#define DBG_SDIO		0x00000008
+#define DBG_HIF			0x00000010
+#define DBG_HTC			0x00000020
+#define DBG_WMI			0x00000040
+#define DBG_WMI2		0x00000080
+#define DBG_DRIVER		0x00000100
+
+#define DBG_DEFAULTS	(DBG_ERROR|DBG_WARNING)
+
+
+#ifdef DEBUG
+#define AR_DEBUG_PRINTF(args...)        if (debugdriver) A_PRINTF(args);
+#define AR_DEBUG2_PRINTF(args...)        if (debugdriver >= 2) A_PRINTF(args);
+extern int debugdriver;
+#else
+#define AR_DEBUG_PRINTF(args...)
+#define AR_DEBUG2_PRINTF(args...)
+#endif
+
+A_STATUS ar6000_ReadRegDiag(HIF_DEVICE *hifDevice, A_UINT32 *address, A_UINT32 *data);
+A_STATUS ar6000_WriteRegDiag(HIF_DEVICE *hifDevice, A_UINT32 *address, A_UINT32 *data);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	MAX_AR6000                        1
+#define AR6000_MAX_RX_BUFFERS             16
+#define AR6000_BUFFER_SIZE                1664
+#define AR6000_TX_TIMEOUT                 (2*HZ)
+#define	AR6000_ETH_ADDR_LEN               6
+#define	AR6000_MAX_ENDPOINTS              4
+#define MAX_NODE_NUM                      15
+#define MAX_COOKIE_NUM                    150
+#define AR6000_HB_CHALLENGE_RESP_FREQ_DEFAULT        1
+#define AR6000_HB_CHALLENGE_RESP_MISS_THRES_DEFAULT  1
+
+enum {
+    DRV_HB_CHALLENGE = 0,
+    APP_HB_CHALLENGE
+};
+
+/* HTC RAW streams */
+typedef enum _HTC_RAW_STREAM_ID {
+    HTC_RAW_STREAM_NOT_MAPPED = -1,
+    HTC_RAW_STREAM_0 = 0,
+    HTC_RAW_STREAM_1 = 1,
+    HTC_RAW_STREAM_2 = 2,
+    HTC_RAW_STREAM_3 = 3,
+    HTC_RAW_STREAM_NUM_MAX
+} HTC_RAW_STREAM_ID;
+
+#define RAW_HTC_READ_BUFFERS_NUM    4
+#define RAW_HTC_WRITE_BUFFERS_NUM   4
+
+typedef struct {
+    int currPtr;
+    int length;
+    unsigned char data[AR6000_BUFFER_SIZE];
+    HTC_PACKET    HTCPacket;
+} raw_htc_buffer;
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+/*
+ *  add TCMD_MODE besides wmi and bypasswmi
+ *  in TCMD_MODE, only few TCMD releated wmi commands
+ *  counld be hanlder
+ */
+enum {
+    AR6000_WMI_MODE = 0,
+    AR6000_BYPASS_MODE,
+    AR6000_TCMD_MODE,
+    AR6000_WLAN_MODE
+};
+#endif /* CONFIG_HOST_TCMD_SUPPORT */
+
+struct ar_wep_key {
+    A_UINT8                 arKeyIndex;
+    A_UINT8                 arKeyLen;
+    A_UINT8                 arKey[64];
+} ;
+
+struct ar_node_mapping {
+    A_UINT8                 macAddress[6];
+    A_UINT8                 epId;
+    A_UINT8                 txPending;
+};
+
+struct ar_cookie {
+    A_UINT32               arc_bp[2];    /* Must be first field */
+    HTC_PACKET             HtcPkt;       /* HTC packet wrapper */
+    struct ar_cookie *arc_list_next;
+};
+
+struct ar_hb_chlng_resp {
+    A_TIMER                 timer;
+    A_UINT32                frequency;
+    A_UINT32                seqNum;
+    A_BOOL                  outstanding;
+    A_UINT8                 missCnt;
+    A_UINT8                 missThres;
+};
+
+typedef struct ar6_softc {
+    struct net_device       *arNetDev;    /* net_device pointer */
+    void                    *arWmi;
+    int                     arTxPending[ENDPOINT_MAX];
+    int                     arTotalTxDataPending;
+    A_UINT8                 arNumDataEndPts;
+    A_BOOL                  arWmiEnabled;
+    A_BOOL                  arWmiReady;
+    A_BOOL                  arConnected;
+    HTC_HANDLE              arHtcTarget;
+    void                    *arHifDevice;
+    spinlock_t              arLock;
+    struct semaphore        arSem;
+    int                     arRxBuffers[ENDPOINT_MAX];
+    int                     arSsidLen;
+    u_char                  arSsid[32];
+    A_UINT8                 arNetworkType;
+    A_UINT8                 arDot11AuthMode;
+    A_UINT8                 arAuthMode;
+    A_UINT8                 arPairwiseCrypto;
+    A_UINT8                 arPairwiseCryptoLen;
+    A_UINT8                 arGroupCrypto;
+    A_UINT8                 arGroupCryptoLen;
+    A_UINT8                 arDefTxKeyIndex;
+    struct ar_wep_key       arWepKeyList[WMI_MAX_KEY_INDEX + 1];
+    A_UINT8                 arBssid[6];
+    A_UINT8                 arReqBssid[6];
+    A_UINT16                arChannelHint;
+    A_UINT16                arBssChannel;
+    A_UINT16                arListenInterval;
+    struct ar6000_version   arVersion;
+    A_UINT32                arTargetType;
+    A_INT8                  arRssi;
+    A_UINT8                 arTxPwr;
+    A_BOOL                  arTxPwrSet;
+    A_INT32                 arBitRate;
+    struct net_device_stats arNetStats;
+    struct iw_statistics 	arIwStats;
+    A_INT8                  arNumChannels;
+    A_UINT16                arChannelList[32];
+    A_UINT32                arRegCode;
+    A_BOOL                  statsUpdatePending;
+    TARGET_STATS            arTargetStats;
+    A_INT8                  arMaxRetries;
+    A_UINT8                 arPhyCapability;
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+    A_UINT8                 tcmdRxReport;
+    A_UINT32                tcmdRxTotalPkt;
+    A_INT32                 tcmdRxRssi;
+    A_UINT32                tcmdPm;
+    A_UINT32                arTargetMode;
+    A_UINT32                tcmdRxcrcErrPkt;
+    A_UINT32                tcmdRxsecErrPkt;
+#endif
+    AR6000_WLAN_STATE       arWlanState;
+    struct ar_node_mapping  arNodeMap[MAX_NODE_NUM];
+    A_UINT8                 arIbssPsEnable;
+    A_UINT8                 arNodeNum;
+    A_UINT8                 arNexEpId;
+    struct ar_cookie        *arCookieList;
+    A_UINT16                arRateMask;
+    A_UINT8                 arSkipScan;
+    A_UINT16                arBeaconInterval;
+    A_BOOL                  arConnectPending;
+    A_BOOL                  arWmmEnabled;
+    struct ar_hb_chlng_resp arHBChallengeResp;
+    A_UINT8                 arKeepaliveConfigured;
+    A_UINT32                arMgmtFilter;
+    HTC_ENDPOINT_ID         arAc2EpMapping[WMM_NUM_AC];
+    A_BOOL                  arAcStreamActive[WMM_NUM_AC];
+    A_UINT8                 arAcStreamPriMap[WMM_NUM_AC];
+    A_UINT8                 arHiAcStreamActivePri;
+    A_UINT8                 arEp2AcMapping[ENDPOINT_MAX];
+    HTC_ENDPOINT_ID         arControlEp;
+#ifdef HTC_RAW_INTERFACE
+    HTC_ENDPOINT_ID         arRaw2EpMapping[HTC_RAW_STREAM_NUM_MAX];
+    HTC_RAW_STREAM_ID       arEp2RawMapping[ENDPOINT_MAX];
+    struct semaphore        raw_htc_read_sem[HTC_RAW_STREAM_NUM_MAX];
+    struct semaphore        raw_htc_write_sem[HTC_RAW_STREAM_NUM_MAX];
+    wait_queue_head_t       raw_htc_read_queue[HTC_RAW_STREAM_NUM_MAX];
+    wait_queue_head_t       raw_htc_write_queue[HTC_RAW_STREAM_NUM_MAX];
+    raw_htc_buffer          raw_htc_read_buffer[HTC_RAW_STREAM_NUM_MAX][RAW_HTC_READ_BUFFERS_NUM];
+    raw_htc_buffer          raw_htc_write_buffer[HTC_RAW_STREAM_NUM_MAX][RAW_HTC_WRITE_BUFFERS_NUM];
+    A_BOOL                  write_buffer_available[HTC_RAW_STREAM_NUM_MAX];
+    A_BOOL                  read_buffer_available[HTC_RAW_STREAM_NUM_MAX];
+#endif
+    A_BOOL                  arRawIfInit;
+    int                     arDeviceIndex;
+    COMMON_CREDIT_STATE_INFO arCreditStateInfo;
+    A_BOOL                  arWMIControlEpFull;
+    A_BOOL                  dbgLogFetchInProgress;
+    A_UCHAR                 log_buffer[DBGLOG_HOST_LOG_BUFFER_SIZE];
+    A_UINT32                log_cnt;
+    A_UINT32                dbglog_init_done;
+    A_UINT32                arConnectCtrlFlags;
+#ifdef USER_KEYS
+    A_INT32                 user_savedkeys_stat;
+    A_UINT32                user_key_ctrl;
+    struct USER_SAVEDKEYS   user_saved_keys;
+#endif
+    USER_RSSI_THOLD rssi_map[12];
+    A_UINT8                arUserBssFilter;
+    unsigned long          siocsiwscan_timestamp;
+} AR_SOFTC_T;
+
+
+#define arAc2EndpointID(ar,ac)          (ar)->arAc2EpMapping[(ac)]
+#define arSetAc2EndpointIDMap(ar,ac,ep)  \
+{  (ar)->arAc2EpMapping[(ac)] = (ep); \
+   (ar)->arEp2AcMapping[(ep)] = (ac); }
+#define arEndpoint2Ac(ar,ep)           (ar)->arEp2AcMapping[(ep)]
+
+#define arRawIfEnabled(ar) (ar)->arRawIfInit
+#define arRawStream2EndpointID(ar,raw)          (ar)->arRaw2EpMapping[(raw)]
+#define arSetRawStream2EndpointIDMap(ar,raw,ep)  \
+{  (ar)->arRaw2EpMapping[(raw)] = (ep); \
+   (ar)->arEp2RawMapping[(ep)] = (raw); }
+#define arEndpoint2RawStreamID(ar,ep)           (ar)->arEp2RawMapping[(ep)]
+
+struct ar_giwscan_param {
+    char    *current_ev;
+    char    *end_buf;
+    A_UINT32 bytes_needed;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+    struct iw_request_info *info;
+#endif
+};
+
+#define AR6000_STAT_INC(ar, stat)       (ar->arNetStats.stat++)
+
+#define AR6000_SPIN_LOCK(lock, param)   do {                            \
+    if (irqs_disabled()) {                                              \
+        AR_DEBUG_PRINTF("IRQs disabled:AR6000_LOCK\n");                 \
+    }                                                                   \
+    spin_lock_bh(lock);                                                 \
+} while (0)
+
+#define AR6000_SPIN_UNLOCK(lock, param) do {                            \
+    if (irqs_disabled()) {                                              \
+        AR_DEBUG_PRINTF("IRQs disabled: AR6000_UNLOCK\n");              \
+    }                                                                   \
+    spin_unlock_bh(lock);                                               \
+} while (0)
+
+int ar6000_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+int ar6000_ioctl_dispatcher(struct net_device *dev, struct ifreq *rq, int cmd);
+void ar6000_ioctl_iwsetup(struct iw_handler_def *def);
+void ar6000_gpio_init(void);
+void ar6000_init_profile_info(AR_SOFTC_T *ar);
+void ar6000_install_static_wep_keys(AR_SOFTC_T *ar);
+int ar6000_init(struct net_device *dev);
+int ar6000_dbglog_get_debug_logs(AR_SOFTC_T *ar);
+
+#ifdef HTC_RAW_INTERFACE
+
+#ifndef __user
+#define __user
+#endif
+
+int ar6000_htc_raw_open(AR_SOFTC_T *ar);
+int ar6000_htc_raw_close(AR_SOFTC_T *ar);
+ssize_t ar6000_htc_raw_read(AR_SOFTC_T *ar,
+                            HTC_RAW_STREAM_ID StreamID,
+                            char __user *buffer, size_t count);
+ssize_t ar6000_htc_raw_write(AR_SOFTC_T *ar,
+                             HTC_RAW_STREAM_ID StreamID,
+                             char __user *buffer, size_t count);
+
+#endif /* HTC_RAW_INTERFACE */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _AR6000_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/ar6k.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/ar6k.h
@@ -0,0 +1,192 @@
+/*
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef AR6K_H_
+#define AR6K_H_
+
+#define AR6K_MAILBOXES 4
+
+/* HTC runs over mailbox 0 */
+#define HTC_MAILBOX          0
+
+#define AR6K_TARGET_DEBUG_INTR_MASK     0x01
+
+#define OTHER_INTS_ENABLED (INT_STATUS_ENABLE_ERROR_MASK |   \
+                            INT_STATUS_ENABLE_CPU_MASK   |   \
+                            INT_STATUS_ENABLE_COUNTER_MASK)
+
+//#define MBOXHW_UNIT_TEST 1
+
+typedef PREPACK struct _AR6K_IRQ_PROC_REGISTERS {
+    A_UINT8                      host_int_status;
+    A_UINT8                      cpu_int_status;
+    A_UINT8                      error_int_status;
+    A_UINT8                      counter_int_status;
+    A_UINT8                      mbox_frame;
+    A_UINT8                      rx_lookahead_valid;
+    A_UINT8                      hole[2];
+    A_UINT32                     rx_lookahead[2];
+} POSTPACK AR6K_IRQ_PROC_REGISTERS;
+
+#define AR6K_IRQ_PROC_REGS_SIZE sizeof(AR6K_IRQ_PROC_REGISTERS)
+
+
+
+typedef PREPACK struct _AR6K_IRQ_ENABLE_REGISTERS {
+    A_UINT8                      int_status_enable;
+    A_UINT8                      cpu_int_status_enable;
+    A_UINT8                      error_status_enable;
+    A_UINT8                      counter_int_status_enable;
+} POSTPACK AR6K_IRQ_ENABLE_REGISTERS;
+
+
+#define AR6K_IRQ_ENABLE_REGS_SIZE sizeof(AR6K_IRQ_ENABLE_REGISTERS)
+
+#define AR6K_REG_IO_BUFFER_SIZE     32
+#define AR6K_MAX_REG_IO_BUFFERS     8
+
+/* buffers for ASYNC I/O */
+typedef struct AR6K_ASYNC_REG_IO_BUFFER {
+    HTC_PACKET    HtcPacket;   /* we use an HTC packet as a wrapper for our async register-based I/O */
+    A_UINT8       Buffer[AR6K_REG_IO_BUFFER_SIZE];
+} AR6K_ASYNC_REG_IO_BUFFER;
+
+typedef struct _AR6K_DEVICE {
+    A_MUTEX_T                   Lock;
+    AR6K_IRQ_PROC_REGISTERS     IrqProcRegisters;
+    AR6K_IRQ_ENABLE_REGISTERS   IrqEnableRegisters;
+    void                        *HIFDevice;
+    A_UINT32                    BlockSize;
+    A_UINT32                    BlockMask;
+    A_UINT32                    MailboxAddress;
+    HIF_PENDING_EVENTS_FUNC     GetPendingEventsFunc;
+    void                        *HTCContext;
+    HTC_PACKET_QUEUE            RegisterIOList;
+    AR6K_ASYNC_REG_IO_BUFFER    RegIOBuffers[AR6K_MAX_REG_IO_BUFFERS];
+    void                        (*TargetFailureCallback)(void *Context);
+    A_STATUS                    (*MessagePendingCallback)(void *Context, A_UINT32 *LookAhead, A_BOOL *pAsyncProc);
+    HIF_DEVICE_IRQ_PROCESSING_MODE  HifIRQProcessingMode;
+    HIF_MASK_UNMASK_RECV_EVENT      HifMaskUmaskRecvEvent;
+} AR6K_DEVICE;
+
+#define IS_DEV_IRQ_PROCESSING_ASYNC_ALLOWED(pDev) ((pDev)->HifIRQProcessingMode != HIF_DEVICE_IRQ_SYNC_ONLY)
+
+A_STATUS DevSetup(AR6K_DEVICE *pDev);
+void     DevCleanup(AR6K_DEVICE *pDev);
+A_STATUS DevUnmaskInterrupts(AR6K_DEVICE *pDev);
+A_STATUS DevMaskInterrupts(AR6K_DEVICE *pDev);
+A_STATUS DevPollMboxMsgRecv(AR6K_DEVICE *pDev,
+                            A_UINT32    *pLookAhead,
+                            int          TimeoutMS);
+A_STATUS DevRWCompletionHandler(void *context, A_STATUS status);
+A_STATUS DevDsrHandler(void *context);
+A_STATUS DevCheckPendingRecvMsgsAsync(void *context);
+void     DevDumpRegisters(AR6K_IRQ_PROC_REGISTERS   *pIrqProcRegs,
+                          AR6K_IRQ_ENABLE_REGISTERS *pIrqEnableRegs);
+
+#define DEV_STOP_RECV_ASYNC TRUE
+#define DEV_STOP_RECV_SYNC  FALSE
+#define DEV_ENABLE_RECV_ASYNC TRUE
+#define DEV_ENABLE_RECV_SYNC  FALSE
+A_STATUS DevStopRecv(AR6K_DEVICE *pDev, A_BOOL ASyncMode);
+A_STATUS DevEnableRecv(AR6K_DEVICE *pDev, A_BOOL ASyncMode);
+A_STATUS DevEnableInterrupts(AR6K_DEVICE *pDev);
+A_STATUS DevDisableInterrupts(AR6K_DEVICE *pDev);
+
+static INLINE A_STATUS DevSendPacket(AR6K_DEVICE *pDev, HTC_PACKET *pPacket, A_UINT32 SendLength) {
+    A_UINT32 paddedLength;
+    A_BOOL   sync = (pPacket->Completion == NULL) ? TRUE : FALSE;
+    A_STATUS status;
+
+       /* adjust the length to be a multiple of block size if appropriate */
+    paddedLength = (SendLength + (pDev->BlockMask)) &
+                    (~(pDev->BlockMask));
+#if 0 // BufferLength may not be set in , fix this...
+    if (paddedLength > pPacket->BufferLength) {
+        AR_DEBUG_ASSERT(FALSE);
+        if (pPacket->Completion != NULL) {
+            COMPLETE_HTC_PACKET(pPacket,A_EINVAL);
+        }
+        return A_EINVAL;
+    }
+#endif
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND,
+                ("DevSendPacket, Padded Length: %d Mbox:0x%X (mode:%s)\n",
+                paddedLength,
+                pDev->MailboxAddress,
+                sync ? "SYNC" : "ASYNC"));
+
+    status = HIFReadWrite(pDev->HIFDevice,
+                          pDev->MailboxAddress,
+                          pPacket->pBuffer,
+                          paddedLength,     /* the padded length */
+                          sync ? HIF_WR_SYNC_BLOCK_INC : HIF_WR_ASYNC_BLOCK_INC,
+                          sync ? NULL : pPacket);  /* pass the packet as the context to the HIF request */
+
+    if (sync) {
+        pPacket->Status = status;
+    }
+
+    return status;
+}
+
+static INLINE A_STATUS DevRecvPacket(AR6K_DEVICE *pDev, HTC_PACKET *pPacket, A_UINT32 RecvLength) {
+    A_UINT32 paddedLength;
+    A_STATUS status;
+    A_BOOL   sync = (pPacket->Completion == NULL) ? TRUE : FALSE;
+
+        /* adjust the length to be a multiple of block size if appropriate */
+    paddedLength = (RecvLength + (pDev->BlockMask)) &
+                    (~(pDev->BlockMask));
+    if (paddedLength > pPacket->BufferLength) {
+        AR_DEBUG_ASSERT(FALSE);
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                ("DevRecvPacket, Not enough space for padlen:%d recvlen:%d bufferlen:%d \n",
+                    paddedLength,RecvLength,pPacket->BufferLength));
+        if (pPacket->Completion != NULL) {
+            COMPLETE_HTC_PACKET(pPacket,A_EINVAL);
+        }
+        return A_EINVAL;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV,
+                ("DevRecvPacket, Padded Length: %d Mbox:0x%X (mode:%s)\n",
+                paddedLength,
+                pDev->MailboxAddress,
+                sync ? "SYNC" : "ASYNC"));
+
+    status = HIFReadWrite(pDev->HIFDevice,
+                          pDev->MailboxAddress,
+                          pPacket->pBuffer,
+                          paddedLength,
+                          sync ? HIF_RD_SYNC_BLOCK_INC : HIF_RD_ASYNC_BLOCK_INC,
+                          sync ? NULL : pPacket);  /* pass the packet as the context to the HIF request */
+
+    if (sync) {
+        pPacket->Status = status;
+    }
+
+    return status;
+}
+
+#ifdef MBOXHW_UNIT_TEST
+A_STATUS DoMboxHWTest(AR6K_DEVICE *pDev);
+#endif
+
+#endif /*AR6K_H_*/
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/ar6xapi.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/ar6xapi.h
@@ -0,0 +1,139 @@
+#ifndef _AR6XAPI_LINUX_H
+#define _AR6XAPI_LINUX_H
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct ar6_softc;
+
+void ar6000_ready_event(void *devt, A_UINT8 *datap, A_UINT8 phyCap,
+                        A_UINT32 ver);
+A_STATUS ar6000_control_tx(void *devt, void *osbuf, HTC_ENDPOINT_ID eid);
+void ar6000_connect_event(struct ar6_softc *ar, A_UINT16 channel,
+                          A_UINT8 *bssid, A_UINT16 listenInterval,
+                          A_UINT16 beaconInterval, NETWORK_TYPE networkType,
+                          A_UINT8 beaconIeLen, A_UINT8 assocReqLen,
+                          A_UINT8 assocRespLen,A_UINT8 *assocInfo);
+void ar6000_disconnect_event(struct ar6_softc *ar, A_UINT8 reason,
+                             A_UINT8 *bssid, A_UINT8 assocRespLen,
+                             A_UINT8 *assocInfo, A_UINT16 protocolReasonStatus);
+void ar6000_tkip_micerr_event(struct ar6_softc *ar, A_UINT8 keyid,
+                              A_BOOL ismcast);
+void ar6000_bitrate_rx(void *devt, A_INT32 rateKbps);
+void ar6000_channelList_rx(void *devt, A_INT8 numChan, A_UINT16 *chanList);
+void ar6000_regDomain_event(struct ar6_softc *ar, A_UINT32 regCode);
+void ar6000_txPwr_rx(void *devt, A_UINT8 txPwr);
+void ar6000_keepalive_rx(void *devt, A_UINT8 configured);
+void ar6000_neighborReport_event(struct ar6_softc *ar, int numAps,
+                                 WMI_NEIGHBOR_INFO *info);
+void ar6000_set_numdataendpts(struct ar6_softc *ar, A_UINT32 num);
+void ar6000_scanComplete_event(struct ar6_softc *ar, A_STATUS status);
+void ar6000_targetStats_event(struct ar6_softc *ar,  WMI_TARGET_STATS *pStats);
+void ar6000_rssiThreshold_event(struct ar6_softc *ar,
+                                WMI_RSSI_THRESHOLD_VAL newThreshold,
+                                A_INT16 rssi);
+void ar6000_reportError_event(struct ar6_softc *, WMI_TARGET_ERROR_VAL errorVal);
+void ar6000_cac_event(struct ar6_softc *ar, A_UINT8 ac, A_UINT8 cac_indication,
+                                A_UINT8 statusCode, A_UINT8 *tspecSuggestion);
+void ar6000_channel_change_event(struct ar6_softc *ar, A_UINT16 oldChannel, A_UINT16 newChannel);
+void ar6000_hbChallengeResp_event(struct ar6_softc *, A_UINT32 cookie, A_UINT32 source);
+void
+ar6000_roam_tbl_event(struct ar6_softc *ar, WMI_TARGET_ROAM_TBL *pTbl);
+
+void
+ar6000_roam_data_event(struct ar6_softc *ar, WMI_TARGET_ROAM_DATA *p);
+
+void
+ar6000_wow_list_event(struct ar6_softc *ar, A_UINT8 num_filters,
+                      WMI_GET_WOW_LIST_REPLY *wow_reply);
+
+void ar6000_pmkid_list_event(void *devt, A_UINT8 numPMKID,
+                             WMI_PMKID *pmkidList, A_UINT8 *bssidList);
+
+void ar6000_gpio_intr_rx(A_UINT32 intr_mask, A_UINT32 input_values);
+void ar6000_gpio_data_rx(A_UINT32 reg_id, A_UINT32 value);
+void ar6000_gpio_ack_rx(void);
+
+void ar6000_dbglog_init_done(struct ar6_softc *ar);
+
+#ifdef SEND_EVENT_TO_APP
+void ar6000_send_event_to_app(struct ar6_softc *ar, A_UINT16 eventId, A_UINT8 *datap, int len);
+#endif
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+void ar6000_tcmd_rx_report_event(void *devt, A_UINT8 * results, int len);
+#endif
+
+void ar6000_tx_retry_err_event(void *devt);
+
+void ar6000_snrThresholdEvent_rx(void *devt,
+                                 WMI_SNR_THRESHOLD_VAL newThreshold,
+                                 A_UINT8 snr);
+
+void ar6000_lqThresholdEvent_rx(void *devt, WMI_LQ_THRESHOLD_VAL range, A_UINT8 lqVal);
+
+
+void ar6000_ratemask_rx(void *devt, A_UINT16 ratemask);
+
+A_STATUS ar6000_get_driver_cfg(struct net_device *dev,
+                                A_UINT16 cfgParam,
+                                void *result);
+void ar6000_bssInfo_event_rx(struct ar6_softc *ar, A_UINT8 *data, int len);
+
+void ar6000_dbglog_event(struct ar6_softc *ar, A_UINT32 dropped,
+                         A_INT8 *buffer, A_UINT32 length);
+
+int ar6000_dbglog_get_debug_logs(struct ar6_softc *ar);
+
+void ar6000_indicate_tx_activity(void *devt, A_UINT8 trafficClass, A_BOOL Active);
+HTC_ENDPOINT_ID  ar6000_ac2_endpoint_id ( void * devt, A_UINT8 ac);
+A_UINT8 ar6000_endpoint_id2_ac (void * devt, HTC_ENDPOINT_ID ep );
+
+void ar6000_dset_open_req(void *devt,
+                          A_UINT32 id,
+                          A_UINT32 targ_handle,
+                          A_UINT32 targ_reply_fn,
+                          A_UINT32 targ_reply_arg);
+void ar6000_dset_close(void *devt, A_UINT32 access_cookie);
+void ar6000_dset_data_req(void *devt,
+                          A_UINT32 access_cookie,
+                          A_UINT32 offset,
+                          A_UINT32 length,
+                          A_UINT32 targ_buf,
+                          A_UINT32 targ_reply_fn,
+                          A_UINT32 targ_reply_arg);
+
+
+#if defined(CONFIG_TARGET_PROFILE_SUPPORT)
+void prof_count_rx(unsigned int addr, unsigned int count);
+#endif
+
+A_UINT32 ar6000_getnodeAge (void);
+
+A_UINT32 ar6000_getclkfreq (void);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/athdefs.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/athdefs.h
@@ -0,0 +1,85 @@
+#ifndef __ATHDEFS_H__
+#define __ATHDEFS_H__
+
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ * This file contains definitions that may be used across both
+ * Host and Target software.  Nothing here is module-dependent
+ * or platform-dependent.
+ */
+
+/*
+ * Generic error codes that can be used by hw, sta, ap, sim, dk
+ * and any other environments. Since these are enums, feel free to
+ * add any more codes that you need.
+ */
+
+typedef enum {
+    A_ERROR = -1,               /* Generic error return */
+    A_OK = 0,                   /* success */
+                                /* Following values start at 1 */
+    A_DEVICE_NOT_FOUND,         /* not able to find PCI device */
+    A_NO_MEMORY,                /* not able to allocate memory, not available */
+    A_MEMORY_NOT_AVAIL,         /* memory region is not free for mapping */
+    A_NO_FREE_DESC,             /* no free descriptors available */
+    A_BAD_ADDRESS,              /* address does not match descriptor */
+    A_WIN_DRIVER_ERROR,         /* used in NT_HW version, if problem at init */
+    A_REGS_NOT_MAPPED,          /* registers not correctly mapped */
+    A_EPERM,                    /* Not superuser */
+    A_EACCES,                   /* Access denied */
+    A_ENOENT,                   /* No such entry, search failed, etc. */
+    A_EEXIST,                   /* The object already exists (can't create) */
+    A_EFAULT,                   /* Bad address fault */
+    A_EBUSY,                    /* Object is busy */
+    A_EINVAL,                   /* Invalid parameter */
+    A_EMSGSIZE,                 /* Inappropriate message buffer length */
+    A_ECANCELED,                /* Operation canceled */
+    A_ENOTSUP,                  /* Operation not supported */
+    A_ECOMM,                    /* Communication error on send */
+    A_EPROTO,                   /* Protocol error */
+    A_ENODEV,                   /* No such device */
+    A_EDEVNOTUP,                /* device is not UP */
+    A_NO_RESOURCE,              /* No resources for requested operation */
+    A_HARDWARE,                 /* Hardware failure */
+    A_PENDING,                  /* Asynchronous routine; will send up results la
+ter (typically in callback) */
+    A_EBADCHANNEL,              /* The channel cannot be used */
+    A_DECRYPT_ERROR,            /* Decryption error */
+    A_PHY_ERROR,                /* RX PHY error */
+    A_CONSUMED                  /* Object was consumed */
+} A_STATUS;
+
+#define A_SUCCESS(x)        (x == A_OK)
+#define A_FAILED(x)         (!A_SUCCESS(x))
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+/*
+ * The following definition is WLAN specific definition
+ */
+typedef enum {
+    MODE_11A = 0,   /* 11a Mode */
+    MODE_11G = 1,   /* 11g + 11b Mode */
+    MODE_11B = 2,   /* 11b Mode */
+    MODE_11GONLY = 3, /* 11g only Mode */
+    MODE_UNKNOWN = 4,
+    MODE_MAX = 4
+} WLAN_PHY_MODE;
+
+typedef enum {
+    WLAN_11A_CAPABILITY   = 1,
+    WLAN_11G_CAPABILITY   = 2,
+    WLAN_11AG_CAPABILITY  = 3,
+}WLAN_CAPABILITY;
+
+#endif /* __ATHDEFS_H__ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/athdrv.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/athdrv.h
@@ -0,0 +1,1049 @@
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef _ATHDRV_LINUX_H
+#define _ATHDRV_LINUX_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*
+ * There are two types of ioctl's here: Standard ioctls and
+ * eXtended ioctls.  All extended ioctls (XIOCTL) are multiplexed
+ * off of the single ioctl command, AR6000_IOCTL_EXTENDED.  The
+ * arguments for every XIOCTL starts with a 32-bit command word
+ * that is used to select which extended ioctl is in use.  After
+ * the command word are command-specific arguments.
+ */
+
+/* Linux standard Wireless Extensions, private ioctl interfaces */
+#define IEEE80211_IOCTL_SETPARAM             (SIOCIWFIRSTPRIV+0)
+#define IEEE80211_IOCTL_GETPARAM             (SIOCIWFIRSTPRIV+1)
+#define IEEE80211_IOCTL_SETKEY               (SIOCIWFIRSTPRIV+2)
+#define IEEE80211_IOCTL_SETWMMPARAMS         (SIOCIWFIRSTPRIV+3)
+#define IEEE80211_IOCTL_DELKEY               (SIOCIWFIRSTPRIV+4)
+#define IEEE80211_IOCTL_GETWMMPARAMS         (SIOCIWFIRSTPRIV+5)
+#define IEEE80211_IOCTL_SETOPTIE             (SIOCIWFIRSTPRIV+6)
+#define IEEE80211_IOCTL_SETMLME              (SIOCIWFIRSTPRIV+7)
+//#define IEEE80211_IOCTL_GETOPTIE             (SIOCIWFIRSTPRIV+7)
+#define IEEE80211_IOCTL_ADDPMKID             (SIOCIWFIRSTPRIV+8)
+//#define IEEE80211_IOCTL_SETAUTHALG           (SIOCIWFIRSTPRIV+10)
+#define IEEE80211_IOCTL_LASTONE              (SIOCIWFIRSTPRIV+9)
+
+
+
+/*                      ====WMI Ioctls====                                    */
+/*
+ *
+ * Many ioctls simply provide WMI services to application code:
+ * an application makes such an ioctl call with a set of arguments
+ * that are packaged into the corresponding WMI message, and sent
+ * to the Target.
+ */
+
+#define AR6000_IOCTL_WMI_GETREV              (SIOCIWFIRSTPRIV+10)
+/*
+ * arguments:
+ *   ar6000_version *revision
+ */
+
+#define AR6000_IOCTL_WMI_SETPWR              (SIOCIWFIRSTPRIV+11)
+/*
+ * arguments:
+ *   WMI_POWER_MODE_CMD pwrModeCmd (see include/wmi.h)
+ * uses: WMI_SET_POWER_MODE_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SETSCAN             (SIOCIWFIRSTPRIV+12)
+/*
+ * arguments:
+ *   WMI_SCAN_PARAMS_CMD scanParams (see include/wmi.h)
+ * uses: WMI_SET_SCAN_PARAMS_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SETLISTENINT        (SIOCIWFIRSTPRIV+13)
+/*
+ * arguments:
+ *   UINT32 listenInterval
+ * uses: WMI_SET_LISTEN_INT_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SETBSSFILTER        (SIOCIWFIRSTPRIV+14)
+/*
+ * arguments:
+ *   WMI_BSS_FILTER filter (see include/wmi.h)
+ * uses: WMI_SET_BSS_FILTER_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_CHANNELPARAMS   (SIOCIWFIRSTPRIV+16)
+/*
+ * arguments:
+ *   WMI_CHANNEL_PARAMS_CMD chParams
+ * uses: WMI_SET_CHANNEL_PARAMS_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_PROBEDSSID      (SIOCIWFIRSTPRIV+17)
+/*
+ * arguments:
+ *   WMI_PROBED_SSID_CMD probedSsids (see include/wmi.h)
+ * uses: WMI_SETPROBED_SSID_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_PMPARAMS        (SIOCIWFIRSTPRIV+18)
+/*
+ * arguments:
+ *   WMI_POWER_PARAMS_CMD powerParams (see include/wmi.h)
+ * uses: WMI_SET_POWER_PARAMS_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_BADAP           (SIOCIWFIRSTPRIV+19)
+/*
+ * arguments:
+ *   WMI_ADD_BAD_AP_CMD badAPs (see include/wmi.h)
+ * uses: WMI_ADD_BAD_AP_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_GET_QOS_QUEUE       (SIOCIWFIRSTPRIV+20)
+/*
+ * arguments:
+ *   ar6000_queuereq queueRequest (see below)
+ */
+
+#define AR6000_IOCTL_WMI_CREATE_QOS          (SIOCIWFIRSTPRIV+21)
+/*
+ * arguments:
+ *   WMI_CREATE_PSTREAM createPstreamCmd (see include/wmi.h)
+ * uses: WMI_CREATE_PSTREAM_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_DELETE_QOS          (SIOCIWFIRSTPRIV+22)
+/*
+ * arguments:
+ *   WMI_DELETE_PSTREAM_CMD deletePstreamCmd (see include/wmi.h)
+ * uses: WMI_DELETE_PSTREAM_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_SNRTHRESHOLD   (SIOCIWFIRSTPRIV+23)
+/*
+ * arguments:
+ *   WMI_SNR_THRESHOLD_PARAMS_CMD thresholdParams (see include/wmi.h)
+ * uses: WMI_SNR_THRESHOLD_PARAMS_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_ERROR_REPORT_BITMASK (SIOCIWFIRSTPRIV+24)
+/*
+ * arguments:
+ *   WMI_TARGET_ERROR_REPORT_BITMASK errorReportBitMask (see include/wmi.h)
+ * uses: WMI_TARGET_ERROR_REPORT_BITMASK_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_GET_TARGET_STATS    (SIOCIWFIRSTPRIV+25)
+/*
+ * arguments:
+ *   TARGET_STATS *targetStats (see below)
+ * uses: WMI_GET_STATISTICS_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_ASSOC_INFO      (SIOCIWFIRSTPRIV+26)
+/*
+ * arguments:
+ *   WMI_SET_ASSOC_INFO_CMD setAssocInfoCmd
+ * uses: WMI_SET_ASSOC_INFO_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_ACCESS_PARAMS   (SIOCIWFIRSTPRIV+27)
+/*
+ * arguments:
+ *   WMI_SET_ACCESS_PARAMS_CMD setAccessParams (see include/wmi.h)
+ * uses: WMI_SET_ACCESS_PARAMS_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_BMISS_TIME      (SIOCIWFIRSTPRIV+28)
+/*
+ * arguments:
+ *   UINT32 beaconMissTime
+ * uses: WMI_SET_BMISS_TIME_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_DISC_TIMEOUT    (SIOCIWFIRSTPRIV+29)
+/*
+ * arguments:
+ *   WMI_DISC_TIMEOUT_CMD disconnectTimeoutCmd (see include/wmi.h)
+ * uses: WMI_SET_DISC_TIMEOUT_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_IBSS_PM_CAPS    (SIOCIWFIRSTPRIV+30)
+/*
+ * arguments:
+ *   WMI_IBSS_PM_CAPS_CMD ibssPowerMgmtCapsCmd
+ * uses: WMI_SET_IBSS_PM_CAPS_CMDID
+ */
+
+/*
+ * There is a very small space available for driver-private
+ * wireless ioctls.  In order to circumvent this limitation,
+ * we multiplex a bunch of ioctls (XIOCTLs) on top of a
+ * single AR6000_IOCTL_EXTENDED ioctl.
+ */
+#define AR6000_IOCTL_EXTENDED                (SIOCIWFIRSTPRIV+31)
+
+
+/*                         ====BMI Extended Ioctls====                        */
+
+#define AR6000_XIOCTL_BMI_DONE                                  1
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_BMI_DONE)
+ * uses: BMI_DONE
+ */
+
+#define AR6000_XIOCTL_BMI_READ_MEMORY                           2
+/*
+ * arguments:
+ *   union {
+ *     struct {
+ *       UINT32 cmd (AR6000_XIOCTL_BMI_READ_MEMORY)
+ *       UINT32 address
+ *       UINT32 length
+ *     }
+ *     char results[length]
+ *   }
+ * uses: BMI_READ_MEMORY
+ */
+
+#define AR6000_XIOCTL_BMI_WRITE_MEMORY                          3
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_BMI_WRITE_MEMORY)
+ *   UINT32 address
+ *   UINT32 length
+ *   char data[length]
+ * uses: BMI_WRITE_MEMORY
+ */
+
+#define AR6000_XIOCTL_BMI_EXECUTE                               4
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_BMI_EXECUTE)
+ *   UINT32 TargetAddress
+ *   UINT32 parameter
+ * uses: BMI_EXECUTE
+ */
+
+#define AR6000_XIOCTL_BMI_SET_APP_START                         5
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_BMI_SET_APP_START)
+ *   UINT32 TargetAddress
+ * uses: BMI_SET_APP_START
+ */
+
+#define AR6000_XIOCTL_BMI_READ_SOC_REGISTER                     6
+/*
+ * arguments:
+ *   union {
+ *     struct {
+ *       UINT32 cmd (AR6000_XIOCTL_BMI_READ_SOC_REGISTER)
+ *       UINT32 TargetAddress, 32-bit aligned
+ *     }
+ *     UINT32 result
+ *   }
+ * uses: BMI_READ_SOC_REGISTER
+ */
+
+#define AR6000_XIOCTL_BMI_WRITE_SOC_REGISTER                    7
+/*
+ * arguments:
+ *     struct {
+ *       UINT32 cmd (AR6000_XIOCTL_BMI_WRITE_SOC_REGISTER)
+ *       UINT32 TargetAddress, 32-bit aligned
+ *       UINT32 newValue
+ *     }
+ * uses: BMI_WRITE_SOC_REGISTER
+ */
+
+#define AR6000_XIOCTL_BMI_TEST                                  8
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_BMI_TEST)
+ *   UINT32 address
+ *   UINT32 length
+ *   UINT32 count
+ */
+
+
+
+/* Historical Host-side DataSet support */
+#define AR6000_XIOCTL_UNUSED9                                   9
+#define AR6000_XIOCTL_UNUSED10                                  10
+#define AR6000_XIOCTL_UNUSED11                                  11
+
+/*                      ====Misc Extended Ioctls====                          */
+
+#define AR6000_XIOCTL_FORCE_TARGET_RESET                        12
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_FORCE_TARGET_RESET)
+ */
+
+
+#ifdef HTC_RAW_INTERFACE
+/* HTC Raw Interface Ioctls */
+#define AR6000_XIOCTL_HTC_RAW_OPEN                              13
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_HTC_RAW_OPEN)
+ */
+
+#define AR6000_XIOCTL_HTC_RAW_CLOSE                             14
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_HTC_RAW_CLOSE)
+ */
+
+#define AR6000_XIOCTL_HTC_RAW_READ                              15
+/*
+ * arguments:
+ *   union {
+ *     struct {
+ *       UINT32 cmd (AR6000_XIOCTL_HTC_RAW_READ)
+ *       UINT32 mailboxID
+ *       UINT32 length
+ *     }
+ *     results[length]
+ *   }
+ */
+
+#define AR6000_XIOCTL_HTC_RAW_WRITE                             16
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_HTC_RAW_WRITE)
+ *   UINT32 mailboxID
+ *   UINT32 length
+ *   char buffer[length]
+ */
+#endif /* HTC_RAW_INTERFACE */
+
+#define AR6000_XIOCTL_CHECK_TARGET_READY                        17
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_CHECK_TARGET_READY)
+ */
+
+
+
+/*                ====GPIO (General Purpose I/O) Extended Ioctls====          */
+
+#define AR6000_XIOCTL_GPIO_OUTPUT_SET                           18
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_GPIO_OUTPUT_SET)
+ *   ar6000_gpio_output_set_cmd_s (see below)
+ * uses: WMIX_GPIO_OUTPUT_SET_CMDID
+ */
+
+#define AR6000_XIOCTL_GPIO_INPUT_GET                            19
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_GPIO_INPUT_GET)
+ * uses: WMIX_GPIO_INPUT_GET_CMDID
+ */
+
+#define AR6000_XIOCTL_GPIO_REGISTER_SET                         20
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_GPIO_REGISTER_SET)
+ *   ar6000_gpio_register_cmd_s (see below)
+ * uses: WMIX_GPIO_REGISTER_SET_CMDID
+ */
+
+#define AR6000_XIOCTL_GPIO_REGISTER_GET                         21
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_GPIO_REGISTER_GET)
+ *   ar6000_gpio_register_cmd_s (see below)
+ * uses: WMIX_GPIO_REGISTER_GET_CMDID
+ */
+
+#define AR6000_XIOCTL_GPIO_INTR_ACK                             22
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_GPIO_INTR_ACK)
+ *   ar6000_cpio_intr_ack_cmd_s (see below)
+ * uses: WMIX_GPIO_INTR_ACK_CMDID
+ */
+
+#define AR6000_XIOCTL_GPIO_INTR_WAIT                            23
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_GPIO_INTR_WAIT)
+ */
+
+
+
+/*                    ====more wireless commands====                          */
+
+#define AR6000_XIOCTL_SET_ADHOC_BSSID                           24
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_SET_ADHOC_BSSID)
+ *   WMI_SET_ADHOC_BSSID_CMD setAdHocBssidCmd (see include/wmi.h)
+ */
+
+#define AR6000_XIOCTL_SET_OPT_MODE                              25
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_SET_OPT_MODE)
+ *   WMI_SET_OPT_MODE_CMD setOptModeCmd (see include/wmi.h)
+ * uses: WMI_SET_OPT_MODE_CMDID
+ */
+
+#define AR6000_XIOCTL_OPT_SEND_FRAME                            26
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_OPT_SEND_FRAME)
+ *   WMI_OPT_TX_FRAME_CMD optTxFrameCmd (see include/wmi.h)
+ * uses: WMI_OPT_TX_FRAME_CMDID
+ */
+
+#define AR6000_XIOCTL_SET_ADHOC_BEACON_INTVAL                   27
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_SET_ADHOC_BEACON_INTVAL)
+ *   WMI_BEACON_INT_CMD beaconIntCmd (see include/wmi.h)
+ * uses: WMI_SET_BEACON_INT_CMDID
+ */
+
+
+#define IEEE80211_IOCTL_SETAUTHALG                              28
+
+
+#define AR6000_XIOCTL_SET_VOICE_PKT_SIZE                        29
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_SET_VOICE_PKT_SIZE)
+ *   WMI_SET_VOICE_PKT_SIZE_CMD setVoicePktSizeCmd (see include/wmi.h)
+ * uses: WMI_SET_VOICE_PKT_SIZE_CMDID
+ */
+
+
+#define AR6000_XIOCTL_SET_MAX_SP                                30
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_SET_MAX_SP)
+ *   WMI_SET_MAX_SP_LEN_CMD maxSPLen(see include/wmi.h)
+ * uses: WMI_SET_MAX_SP_LEN_CMDID
+ */
+
+#define AR6000_XIOCTL_WMI_GET_ROAM_TBL                          31
+
+#define AR6000_XIOCTL_WMI_SET_ROAM_CTRL                         32
+
+#define AR6000_XIOCTRL_WMI_SET_POWERSAVE_TIMERS                 33
+
+
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTRL_WMI_SET_POWERSAVE_TIMERS)
+ *   WMI_SET_POWERSAVE_TIMERS_CMD powerSaveTimers(see include/wmi.h)
+ *   WMI_SET_POWERSAVE_TIMERS_CMDID
+ */
+
+#define AR6000_XIOCTRL_WMI_GET_POWER_MODE                        34
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTRL_WMI_GET_POWER_MODE)
+ */
+
+#define AR6000_XIOCTRL_WMI_SET_WLAN_STATE                       35
+typedef enum {
+    WLAN_DISABLED,
+    WLAN_ENABLED
+} AR6000_WLAN_STATE;
+/*
+ * arguments:
+ * enable/disable
+ */
+
+#define AR6000_XIOCTL_WMI_GET_ROAM_DATA                         36
+
+#define AR6000_XIOCTL_WMI_SETRETRYLIMITS                37
+/*
+ * arguments:
+ *   WMI_SET_RETRY_LIMITS_CMD ibssSetRetryLimitsCmd
+ * uses: WMI_SET_RETRY_LIMITS_CMDID
+ */
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+/*       ====extended commands for radio test ====                          */
+
+#define AR6000_XIOCTL_TCMD_CONT_TX                      38
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_TCMD_CONT_TX)
+ *   WMI_TCMD_CONT_TX_CMD contTxCmd (see include/wmi.h)
+ * uses: WMI_TCMD_CONT_TX_CMDID
+ */
+
+#define AR6000_XIOCTL_TCMD_CONT_RX                      39
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_TCMD_CONT_RX)
+ *   WMI_TCMD_CONT_RX_CMD rxCmd (see include/wmi.h)
+ * uses: WMI_TCMD_CONT_RX_CMDID
+ */
+
+#define AR6000_XIOCTL_TCMD_PM                           40
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_TCMD_PM)
+ *   WMI_TCMD_PM_CMD pmCmd (see include/wmi.h)
+ * uses: WMI_TCMD_PM_CMDID
+ */
+
+#endif /* CONFIG_HOST_TCMD_SUPPORT */
+
+#define AR6000_XIOCTL_WMI_STARTSCAN                     41
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_WMI_STARTSCAN)
+ *   UINT8  scanType
+ *   UINT8  scanConnected
+ *   A_BOOL forceFgScan
+ * uses: WMI_START_SCAN_CMDID
+ */
+
+#define AR6000_XIOCTL_WMI_SETFIXRATES                   42
+
+#define AR6000_XIOCTL_WMI_GETFIXRATES                   43
+
+
+#define AR6000_XIOCTL_WMI_SET_RSSITHRESHOLD             44
+/*
+ * arguments:
+ *   WMI_RSSI_THRESHOLD_PARAMS_CMD thresholdParams (see include/wmi.h)
+ * uses: WMI_RSSI_THRESHOLD_PARAMS_CMDID
+ */
+
+#define AR6000_XIOCTL_WMI_CLR_RSSISNR                   45
+/*
+ * arguments:
+ *   WMI_CLR_RSSISNR_CMD thresholdParams (see include/wmi.h)
+ * uses: WMI_CLR_RSSISNR_CMDID
+ */
+
+#define AR6000_XIOCTL_WMI_SET_LQTHRESHOLD               46
+/*
+ * arguments:
+ *   WMI_LQ_THRESHOLD_PARAMS_CMD thresholdParams (see include/wmi.h)
+ * uses: WMI_LQ_THRESHOLD_PARAMS_CMDID
+ */
+
+#define AR6000_XIOCTL_WMI_SET_RTS                        47
+/*
+ * arguments:
+ *   WMI_SET_RTS_MODE_CMD (see include/wmi.h)
+ * uses: WMI_SET_RTS_MODE_CMDID
+ */
+
+#define AR6000_XIOCTL_WMI_SET_LPREAMBLE                 48
+
+#define AR6000_XIOCTL_WMI_SET_AUTHMODE                  49
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_WMI_SET_AUTHMODE)
+ *   UINT8  mode
+ * uses: WMI_SET_RECONNECT_AUTH_MODE_CMDID
+ */
+
+#define AR6000_XIOCTL_WMI_SET_REASSOCMODE               50
+
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_WMI_SET_WMM)
+ *   UINT8  mode
+ * uses: WMI_SET_WMM_CMDID
+ */
+#define AR6000_XIOCTL_WMI_SET_WMM                       51
+
+/*
+ * arguments:
+ * UINT32 cmd (AR6000_XIOCTL_WMI_SET_HB_CHALLENGE_RESP_PARAMS)
+ * UINT32 frequency
+ * UINT8  threshold
+ */
+#define AR6000_XIOCTL_WMI_SET_HB_CHALLENGE_RESP_PARAMS  52
+
+/*
+ * arguments:
+ * UINT32 cmd (AR6000_XIOCTL_WMI_GET_HB_CHALLENGE_RESP)
+ * UINT32 cookie
+ */
+#define AR6000_XIOCTL_WMI_GET_HB_CHALLENGE_RESP         53
+
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_WMI_GET_RD)
+ *   UINT32 regDomain
+ */
+#define AR6000_XIOCTL_WMI_GET_RD                        54
+
+#define AR6000_XIOCTL_DIAG_READ                         55
+
+#define AR6000_XIOCTL_DIAG_WRITE                        56
+
+/*
+ * arguments cmd (AR6000_XIOCTL_SET_TXOP)
+ * WMI_TXOP_CFG  txopEnable
+ */
+#define AR6000_XIOCTL_WMI_SET_TXOP                      57
+
+#ifdef USER_KEYS
+/*
+ * arguments:
+ * UINT32 cmd (AR6000_XIOCTL_USER_SETKEYS)
+ * UINT32 keyOpCtrl
+ * uses AR6000_USER_SETKEYS_INFO
+ */
+#define AR6000_XIOCTL_USER_SETKEYS                      58
+#endif /* USER_KEYS */
+
+#define AR6000_XIOCTL_WMI_SET_KEEPALIVE                 59
+/*
+ * arguments:
+ *   UINT8 cmd (AR6000_XIOCTL_WMI_SET_KEEPALIVE)
+ *   UINT8 keepaliveInterval
+ * uses: WMI_SET_KEEPALIVE_CMDID
+ */
+
+#define AR6000_XIOCTL_WMI_GET_KEEPALIVE                 60
+/*
+ * arguments:
+ *   UINT8 cmd (AR6000_XIOCTL_WMI_GET_KEEPALIVE)
+ *   UINT8 keepaliveInterval
+ *   A_BOOL configured
+ * uses: WMI_GET_KEEPALIVE_CMDID
+ */
+
+/*               ====ROM Patching Extended Ioctls====                       */
+
+#define AR6000_XIOCTL_BMI_ROMPATCH_INSTALL              61
+/*
+ * arguments:
+ *     union {
+ *       struct {
+ *         UINT32 cmd (AR6000_XIOCTL_BMI_ROMPATCH_INSTALL)
+ *         UINT32 ROM Address
+ *         UINT32 RAM Address
+ *         UINT32 number of bytes
+ *         UINT32 activate? (0 or 1)
+ *       }
+ *       A_UINT32 resulting rompatch ID
+ *     }
+ * uses: BMI_ROMPATCH_INSTALL
+ */
+
+#define AR6000_XIOCTL_BMI_ROMPATCH_UNINSTALL            62
+/*
+ * arguments:
+ *     struct {
+ *       UINT32 cmd (AR6000_XIOCTL_BMI_ROMPATCH_UNINSTALL)
+ *       UINT32 rompatch ID
+ *     }
+ * uses: BMI_ROMPATCH_UNINSTALL
+ */
+
+#define AR6000_XIOCTL_BMI_ROMPATCH_ACTIVATE             63
+/*
+ * arguments:
+ *     struct {
+ *       UINT32 cmd (AR6000_XIOCTL_BMI_ROMPATCH_ACTIVATE)
+ *       UINT32 rompatch count
+ *       UINT32 rompatch IDs[rompatch count]
+ *     }
+ * uses: BMI_ROMPATCH_ACTIVATE
+ */
+
+#define AR6000_XIOCTL_BMI_ROMPATCH_DEACTIVATE           64
+/*
+ * arguments:
+ *     struct {
+ *       UINT32 cmd (AR6000_XIOCTL_BMI_ROMPATCH_DEACTIVATE)
+ *       UINT32 rompatch count
+ *       UINT32 rompatch IDs[rompatch count]
+ *     }
+ * uses: BMI_ROMPATCH_DEACTIVATE
+ */
+
+#define AR6000_XIOCTL_WMI_SET_APPIE             65
+/*
+ * arguments:
+ *      struct {
+ *          UINT32 cmd (AR6000_XIOCTL_WMI_SET_APPIE)
+ *          UINT32  app_frmtype;
+ *          UINT32  app_buflen;
+ *          UINT8   app_buf[];
+ *      }
+ */
+#define AR6000_XIOCTL_WMI_SET_MGMT_FRM_RX_FILTER    66
+/*
+ * arguments:
+ *      A_UINT32 filter_type;
+ */
+
+#define AR6000_XIOCTL_DBGLOG_CFG_MODULE             67
+
+#define AR6000_XIOCTL_DBGLOG_GET_DEBUG_LOGS         68
+
+#define AR6000_XIOCTL_WMI_SET_WSC_STATUS    		70
+/*
+ * arguments:
+ *      A_UINT32 wsc_status;
+ *            (WSC_REG_INACTIVE or WSC_REG_ACTIVE)
+ */
+
+/*
+ * arguments:
+ *      struct {
+ *          A_UINT8 streamType;
+ *          A_UINT8 status;
+ *      }
+ * uses: WMI_SET_BT_STATUS_CMDID
+ */
+#define AR6000_XIOCTL_WMI_SET_BT_STATUS             71
+
+/*
+ * arguments:
+ *      struct {
+ *           A_UINT8 paramType;
+ *           union {
+ *               A_UINT8 noSCOPkts;
+ *               BT_PARAMS_A2DP a2dpParams;
+ *               BT_COEX_REGS regs;
+ *           };
+ *      }
+ * uses: WMI_SET_BT_PARAM_CMDID
+ */
+#define AR6000_XIOCTL_WMI_SET_BT_PARAMS             72
+
+#define AR6000_XIOCTL_WMI_SET_HOST_SLEEP_MODE       73
+#define AR6000_XIOCTL_WMI_SET_WOW_MODE              74
+#define AR6000_XIOCTL_WMI_GET_WOW_LIST              75
+#define AR6000_XIOCTL_WMI_ADD_WOW_PATTERN           76
+#define AR6000_XIOCTL_WMI_DEL_WOW_PATTERN           77
+
+
+
+#define AR6000_XIOCTL_TARGET_INFO                   78
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_TARGET_INFO)
+ *   A_UINT32 TargetVersion (returned)
+ *   A_UINT32 TargetType    (returned)
+ * (See also bmi_msg.h target_ver and target_type)
+ */
+
+#define AR6000_XIOCTL_DUMP_HTC_CREDIT_STATE         79
+/*
+ * arguments:
+ *      none
+ */
+
+#define AR6000_XIOCTL_TRAFFIC_ACTIVITY_CHANGE       80
+/*
+ * This ioctl is used to emulate traffic activity
+ * timeouts.  Activity/inactivity will trigger the driver
+ * to re-balance credits.
+ *
+ * arguments:
+ *      ar6000_traffic_activity_change
+ */
+
+#define AR6000_XIOCTL_WMI_SET_CONNECT_CTRL_FLAGS    81
+/*
+ * This ioctl is used to set the connect control flags
+ *
+ * arguments:
+ *      A_UINT32 connectCtrlFlags
+ */
+
+#define AR6000_XIOCTL_WMI_SET_AKMP_PARAMS              82
+/*
+ * This IOCTL sets any Authentication,Key Management and Protection
+ * related parameters. This is used along with the information set in
+ * Connect Command.
+ * Currently this enables Multiple PMKIDs to an AP.
+ *
+ * arguments:
+ *      struct {
+ *          A_UINT32    akmpInfo;
+ *      }
+ * uses: WMI_SET_AKMP_PARAMS_CMD
+ */
+
+#define AR6000_XIOCTL_WMI_GET_PMKID_LIST            83
+
+#define AR6000_XIOCTL_WMI_SET_PMKID_LIST            84
+/*
+ * This IOCTL is used to set a list of PMKIDs. This list of
+ * PMKIDs is used in the [Re]AssocReq Frame. This list is used
+ * only if the MultiPMKID option is enabled via the
+ * AR6000_XIOCTL_WMI_SET_AKMP_PARAMS  IOCTL.
+ *
+ * arguments:
+ *      struct {
+ *          A_UINT32    numPMKID;
+ *          WMI_PMKID   pmkidList[WMI_MAX_PMKID_CACHE];
+ *      }
+ * uses: WMI_SET_PMKIDLIST_CMD
+ */
+
+#define AR6000_XIOCTL_WMI_SET_MCAST_FILTER          85
+#define AR6000_XIOCTL_WMI_DEL_MCAST_FILTER          86
+
+
+/* Historical DSETPATCH support for INI patches */
+#define AR6000_XIOCTL_UNUSED90                      90
+
+
+/* Support LZ-compressed firmware download */
+#define AR6000_XIOCTL_BMI_LZ_STREAM_START           91
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_BMI_LZ_STREAM_START)
+ *   UINT32 address
+ * uses: BMI_LZ_STREAM_START
+ */
+
+#define AR6000_XIOCTL_BMI_LZ_DATA                   92
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_BMI_LZ_DATA)
+ *   UINT32 length
+ *   char data[length]
+ * uses: BMI_LZ_DATA
+ */
+
+#define AR6000_XIOCTL_PROF_CFG                      93
+/*
+ * arguments:
+ *   A_UINT32 period
+ *   A_UINT32 nbins
+ */
+
+#define AR6000_XIOCTL_PROF_ADDR_SET                 94
+/*
+ * arguments:
+ *   A_UINT32 Target address
+ */
+
+#define AR6000_XIOCTL_PROF_START                    95
+
+#define AR6000_XIOCTL_PROF_STOP                     96
+
+#define AR6000_XIOCTL_PROF_COUNT_GET                97
+
+#define AR6000_XIOCTL_WMI_ABORT_SCAN            98
+
+#define AR6000_XIOCTL_WMI_TARGET_EVENT_REPORT   99
+
+/* used by AR6000_IOCTL_WMI_GETREV */
+struct ar6000_version {
+    A_UINT32        host_ver;
+    A_UINT32        target_ver;
+    A_UINT32        wlan_ver;
+};
+
+/* used by AR6000_IOCTL_WMI_GET_QOS_QUEUE */
+struct ar6000_queuereq {
+    A_UINT8         trafficClass;
+    A_UINT16        activeTsids;
+};
+
+/* used by AR6000_IOCTL_WMI_GET_TARGET_STATS */
+typedef struct targetStats_t {
+    A_UINT64    tx_packets;
+    A_UINT64    tx_bytes;
+    A_UINT64    tx_unicast_pkts;
+    A_UINT64    tx_unicast_bytes;
+    A_UINT64    tx_multicast_pkts;
+    A_UINT64    tx_multicast_bytes;
+    A_UINT64    tx_broadcast_pkts;
+    A_UINT64    tx_broadcast_bytes;
+    A_UINT64    tx_rts_success_cnt;
+    A_UINT64    tx_packet_per_ac[4];
+
+    A_UINT64    tx_errors;
+    A_UINT64    tx_failed_cnt;
+    A_UINT64    tx_retry_cnt;
+    A_UINT64    tx_mult_retry_cnt;
+    A_UINT64    tx_rts_fail_cnt;
+
+    A_UINT64    rx_packets;
+    A_UINT64    rx_bytes;
+    A_UINT64    rx_unicast_pkts;
+    A_UINT64    rx_unicast_bytes;
+    A_UINT64    rx_multicast_pkts;
+    A_UINT64    rx_multicast_bytes;
+    A_UINT64    rx_broadcast_pkts;
+    A_UINT64    rx_broadcast_bytes;
+    A_UINT64    rx_fragment_pkt;
+
+    A_UINT64    rx_errors;
+    A_UINT64    rx_crcerr;
+    A_UINT64    rx_key_cache_miss;
+    A_UINT64    rx_decrypt_err;
+    A_UINT64    rx_duplicate_frames;
+
+    A_UINT64    tkip_local_mic_failure;
+    A_UINT64    tkip_counter_measures_invoked;
+    A_UINT64    tkip_replays;
+    A_UINT64    tkip_format_errors;
+    A_UINT64    ccmp_format_errors;
+    A_UINT64    ccmp_replays;
+
+    A_UINT64    power_save_failure_cnt;
+
+    A_UINT64    cs_bmiss_cnt;
+    A_UINT64    cs_lowRssi_cnt;
+    A_UINT64    cs_connect_cnt;
+    A_UINT64    cs_disconnect_cnt;
+
+    A_INT32     tx_unicast_rate;
+    A_INT32     rx_unicast_rate;
+
+    A_UINT32    lq_val;
+
+    A_UINT32    wow_num_pkts_dropped;
+    A_UINT16    wow_num_events_discarded;
+
+    A_INT16     noise_floor_calibation;
+    A_INT16     cs_rssi;
+    A_INT16     cs_aveBeacon_rssi;
+    A_UINT8     cs_aveBeacon_snr;
+    A_UINT8     cs_lastRoam_msec;
+    A_UINT8     cs_snr;
+
+    A_UINT8     wow_num_host_pkt_wakeups;
+    A_UINT8     wow_num_host_event_wakeups;
+
+}TARGET_STATS;
+
+typedef struct targetStats_cmd_t {
+    TARGET_STATS targetStats;
+    int clearStats;
+} TARGET_STATS_CMD;
+
+/* used by AR6000_XIOCTL_USER_SETKEYS */
+
+/*
+ * Setting this bit to 1 doesnot initialize the RSC on the firmware
+ */
+#define AR6000_XIOCTL_USER_SETKEYS_RSC_CTRL    1
+#define AR6000_USER_SETKEYS_RSC_UNCHANGED     0x00000002
+
+typedef struct {
+    A_UINT32  keyOpCtrl;  /* Bit Map of Key Mgmt Ctrl Flags */
+} AR6000_USER_SETKEYS_INFO;
+
+
+/* used by AR6000_XIOCTL_GPIO_OUTPUT_SET */
+struct ar6000_gpio_output_set_cmd_s {
+    A_UINT32 set_mask;
+    A_UINT32 clear_mask;
+    A_UINT32 enable_mask;
+    A_UINT32 disable_mask;
+};
+
+/*
+ * used by AR6000_XIOCTL_GPIO_REGISTER_GET and AR6000_XIOCTL_GPIO_REGISTER_SET
+ */
+struct ar6000_gpio_register_cmd_s {
+    A_UINT32 gpioreg_id;
+    A_UINT32 value;
+};
+
+/* used by AR6000_XIOCTL_GPIO_INTR_ACK */
+struct ar6000_gpio_intr_ack_cmd_s {
+    A_UINT32 ack_mask;
+};
+
+/* used by AR6000_XIOCTL_GPIO_INTR_WAIT */
+struct ar6000_gpio_intr_wait_cmd_s {
+    A_UINT32 intr_mask;
+    A_UINT32 input_values;
+};
+
+/* used by the AR6000_XIOCTL_DBGLOG_CFG_MODULE */
+typedef struct ar6000_dbglog_module_config_s {
+    A_UINT32 valid;
+    A_UINT16 mmask;
+    A_UINT16 tsr;
+    A_BOOL   rep;
+    A_UINT16 size;
+} DBGLOG_MODULE_CONFIG;
+
+typedef struct user_rssi_thold_t {
+    A_INT16     tag;
+    A_INT16     rssi;
+} USER_RSSI_THOLD;
+
+typedef struct user_rssi_params_t {
+    A_UINT8            weight;
+    A_UINT32           pollTime;
+    USER_RSSI_THOLD    tholds[12];
+} USER_RSSI_PARAMS;
+
+/*
+ * Host driver may have some config parameters. Typically, these
+ * config params are one time config parameters. These could
+ * correspond to any of the underlying modules. Host driver exposes
+ * an api for the underlying modules to get this config.
+ */
+#define AR6000_DRIVER_CFG_BASE                  0x8000
+
+/* Should driver perform wlan node caching? */
+#define AR6000_DRIVER_CFG_GET_WLANNODECACHING   0x8001
+/*Should we log raw WMI msgs */
+#define AR6000_DRIVER_CFG_LOG_RAW_WMI_MSGS      0x8002
+
+/* used by AR6000_XIOCTL_DIAG_READ & AR6000_XIOCTL_DIAG_WRITE */
+struct ar6000_diag_window_cmd_s {
+    unsigned int addr;
+    unsigned int value;
+};
+
+
+struct ar6000_traffic_activity_change {
+    A_UINT32    StreamID;   /* stream ID to indicate activity change */
+    A_UINT32    Active;     /* active (1) or inactive (0) */
+};
+
+/* Used with AR6000_XIOCTL_PROF_COUNT_GET */
+struct prof_count_s {
+    A_UINT32    addr;       /* bin start address */
+    A_UINT32    count;      /* hit count */
+};
+
+#ifdef __cplusplus
+}
+#endif
+#endif
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/athtypes.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/athtypes.h
@@ -0,0 +1,45 @@
+/*
+ * This file contains the definitions of the basic atheros data types.
+ * It is used to map the data types in atheros files to a platform specific
+ * type.
+ *
+ * Copyright 2003-2005 Atheros Communications, Inc.,  All Rights Reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef _ATHTYPES_LINUX_H_
+#define _ATHTYPES_LINUX_H_
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#endif
+
+typedef int8_t      A_INT8;
+typedef int16_t     A_INT16;
+typedef int32_t     A_INT32;
+typedef int64_t     A_INT64;
+
+typedef u_int8_t     A_UINT8;
+typedef u_int16_t    A_UINT16;
+typedef u_int32_t    A_UINT32;
+typedef u_int64_t    A_UINT64;
+
+typedef int             A_BOOL;
+typedef char            A_CHAR;
+typedef unsigned char   A_UCHAR;
+typedef unsigned long   A_ATH_TIMER;
+
+
+#endif /* _ATHTYPES_LINUX_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/bmi.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/bmi.h
@@ -0,0 +1,110 @@
+
+#ifndef _BMI_H_
+#define _BMI_H_
+/*
+ * Copyright (c) 2004-2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ * BMI declarations and prototypes
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Header files */
+#include "../include/config.h"
+#include "../include/athdefs.h"
+#include "../include/athtypes.h"
+#include "../include/hif.h"
+#include "../include/osapi.h"
+#include "../include/bmi_msg.h"
+
+void
+BMIInit(void);
+
+A_STATUS
+BMIDone(HIF_DEVICE *device);
+
+A_STATUS
+BMIGetTargetInfo(HIF_DEVICE *device, struct bmi_target_info *targ_info);
+
+A_STATUS
+BMIReadMemory(HIF_DEVICE *device,
+              A_UINT32 address,
+              A_UCHAR *buffer,
+              A_UINT32 length);
+
+A_STATUS
+BMIWriteMemory(HIF_DEVICE *device,
+               A_UINT32 address,
+               const A_UCHAR *buffer,
+               A_UINT32 length);
+
+A_STATUS
+BMIExecute(HIF_DEVICE *device,
+           A_UINT32 address,
+           A_UINT32 *param);
+
+A_STATUS
+BMISetAppStart(HIF_DEVICE *device,
+               A_UINT32 address);
+
+A_STATUS
+BMIReadSOCRegister(HIF_DEVICE *device,
+                   A_UINT32 address,
+                   A_UINT32 *param);
+
+A_STATUS
+BMIWriteSOCRegister(HIF_DEVICE *device,
+                    A_UINT32 address,
+                    A_UINT32 param);
+
+A_STATUS
+BMIrompatchInstall(HIF_DEVICE *device,
+                   A_UINT32 ROM_addr,
+                   A_UINT32 RAM_addr,
+                   A_UINT32 nbytes,
+                   A_UINT32 do_activate,
+                   A_UINT32 *patch_id);
+
+A_STATUS
+BMIrompatchUninstall(HIF_DEVICE *device,
+                     A_UINT32 rompatch_id);
+
+A_STATUS
+BMIrompatchActivate(HIF_DEVICE *device,
+                    A_UINT32 rompatch_count,
+                    A_UINT32 *rompatch_list);
+
+A_STATUS
+BMIrompatchDeactivate(HIF_DEVICE *device,
+                      A_UINT32 rompatch_count,
+                      A_UINT32 *rompatch_list);
+
+A_STATUS
+BMILZStreamStart(HIF_DEVICE *device,
+                 A_UINT32 address);
+
+A_STATUS
+BMILZData(HIF_DEVICE *device,
+          A_UCHAR *buffer,
+          A_UINT32 length);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _BMI_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/bmi_msg.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/bmi_msg.h
@@ -0,0 +1,216 @@
+#ifndef __BMI_MSG_H__
+#define __BMI_MSG_H__
+
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ * Bootloader Messaging Interface (BMI)
+ *
+ * BMI is a very simple messaging interface used during initialization
+ * to read memory, write memory, execute code, and to define an
+ * application entry PC.
+ *
+ * It is used to download an application to AR6K, to provide
+ * patches to code that is already resident on AR6K, and generally
+ * to examine and modify state.  The Host has an opportunity to use
+ * BMI only once during bootup.  Once the Host issues a BMI_DONE
+ * command, this opportunity ends.
+ *
+ * The Host writes BMI requests to mailbox0, and reads BMI responses
+ * from mailbox0.   BMI requests all begin with a command
+ * (see below for specific commands), and are followed by
+ * command-specific data.
+ *
+ * Flow control:
+ * The Host can only issue a command once the Target gives it a
+ * "BMI Command Credit", using AR6K Counter #4.  As soon as the
+ * Target has completed a command, it issues another BMI Command
+ * Credit (so the Host can issue the next command).
+ *
+ * BMI handles all required Target-side cache flushing.
+ */
+
+
+/* Maximum data size used for BMI transfers */
+#define BMI_DATASZ_MAX                      256
+
+/* BMI Commands */
+
+#define BMI_NO_COMMAND                      0
+
+#define BMI_DONE                            1
+        /*
+         * Semantics: Host is done using BMI
+         * Request format:
+         *    A_UINT32      command (BMI_DONE)
+         * Response format: none
+         */
+
+#define BMI_READ_MEMORY                     2
+        /*
+         * Semantics: Host reads AR6K memory
+         * Request format:
+         *    A_UINT32      command (BMI_READ_MEMORY)
+         *    A_UINT32      address
+         *    A_UINT32      length, at most BMI_DATASZ_MAX
+         * Response format:
+         *    A_UINT8       data[length]
+         */
+
+#define BMI_WRITE_MEMORY                    3
+        /*
+         * Semantics: Host writes AR6K memory
+         * Request format:
+         *    A_UINT32       command (BMI_WRITE_MEMORY)
+         *    A_UINT32      address
+         *    A_UINT32      length, at most BMI_DATASZ_MAX
+         *    A_UINT8       data[length]
+         * Response format: none
+         */
+
+#define BMI_EXECUTE                         4
+        /*
+         * Semantics: Causes AR6K to execute code
+         * Request format:
+         *    A_UINT32      command (BMI_EXECUTE)
+         *    A_UINT32      address
+         *    A_UINT32      parameter
+         * Response format:
+         *    A_UINT32      return value
+         */
+
+#define BMI_SET_APP_START                   5
+        /*
+         * Semantics: Set Target application starting address
+         * Request format:
+         *    A_UINT32      command (BMI_SET_APP_START)
+         *    A_UINT32      address
+         * Response format: none
+         */
+
+#define BMI_READ_SOC_REGISTER               6
+        /*
+         * Semantics: Read a 32-bit Target SOC register.
+         * Request format:
+         *    A_UINT32      command (BMI_READ_REGISTER)
+         *    A_UINT32      address
+         * Response format:
+         *    A_UINT32      value
+         */
+
+#define BMI_WRITE_SOC_REGISTER              7
+        /*
+         * Semantics: Write a 32-bit Target SOC register.
+         * Request format:
+         *    A_UINT32      command (BMI_WRITE_REGISTER)
+         *    A_UINT32      address
+         *    A_UINT32      value
+         *
+         * Response format: none
+         */
+
+#define BMI_GET_TARGET_ID                  8
+#define BMI_GET_TARGET_INFO                8
+        /*
+         * Semantics: Fetch the 4-byte Target information
+         * Request format:
+         *    A_UINT32      command (BMI_GET_TARGET_ID/INFO)
+         * Response format1 (old firmware):
+         *    A_UINT32      TargetVersionID
+         * Response format2 (newer firmware):
+         *    A_UINT32      TARGET_VERSION_SENTINAL
+         *    struct bmi_target_info;
+         */
+
+struct bmi_target_info {
+    A_UINT32 target_info_byte_count; /* size of this structure */
+    A_UINT32 target_ver;             /* Target Version ID */
+    A_UINT32 target_type;            /* Target type */
+};
+#define TARGET_VERSION_SENTINAL 0xffffffff
+#define TARGET_TYPE_AR6001 1
+#define TARGET_TYPE_AR6002 2
+
+
+#define BMI_ROMPATCH_INSTALL               9
+        /*
+         * Semantics: Install a ROM Patch.
+         * Request format:
+         *    A_UINT32      command (BMI_ROMPATCH_INSTALL)
+         *    A_UINT32      Target ROM Address
+         *    A_UINT32      Target RAM Address
+         *    A_UINT32      Size, in bytes
+         *    A_UINT32      Activate? 1-->activate;
+         *                            0-->install but do not activate
+         * Response format:
+         *    A_UINT32      PatchID
+         */
+
+#define BMI_ROMPATCH_UNINSTALL             10
+        /*
+         * Semantics: Uninstall a previously-installed ROM Patch,
+         * automatically deactivating, if necessary.
+         * Request format:
+         *    A_UINT32      command (BMI_ROMPATCH_UNINSTALL)
+         *    A_UINT32      PatchID
+         *
+         * Response format: none
+         */
+
+#define BMI_ROMPATCH_ACTIVATE              11
+        /*
+         * Semantics: Activate a list of previously-installed ROM Patches.
+         * Request format:
+         *    A_UINT32      command (BMI_ROMPATCH_ACTIVATE)
+         *    A_UINT32      rompatch_count
+         *    A_UINT32      PatchID[rompatch_count]
+         *
+         * Response format: none
+         */
+
+#define BMI_ROMPATCH_DEACTIVATE            12
+        /*
+         * Semantics: Deactivate a list of active ROM Patches.
+         * Request format:
+         *    A_UINT32      command (BMI_ROMPATCH_DEACTIVATE)
+         *    A_UINT32      rompatch_count
+         *    A_UINT32      PatchID[rompatch_count]
+         *
+         * Response format: none
+         */
+
+
+#define BMI_LZ_STREAM_START                13
+        /*
+         * Semantics: Begin an LZ-compressed stream of input
+         * which is to be uncompressed by the Target to an
+         * output buffer at address.  The output buffer must
+         * be sufficiently large to hold the uncompressed
+         * output from the compressed input stream.  This BMI
+         * command should be followed by a series of 1 or more
+         * BMI_LZ_DATA commands.
+         *    A_UINT32      command (BMI_LZ_STREAM_START)
+         *    A_UINT32      address
+         * Note: Not supported on all versions of ROM firmware.
+         */
+
+#define BMI_LZ_DATA                        14
+        /*
+         * Semantics: Host writes AR6K memory with LZ-compressed
+         * data which is uncompressed by the Target.  This command
+         * must be preceded by a BMI_LZ_STREAM_START command. A series
+         * of BMI_LZ_DATA commands are considered part of a single
+         * input stream until another BMI_LZ_STREAM_START is issued.
+         * Request format:
+         *    A_UINT32      command (BMI_LZ_DATA)
+         *    A_UINT32      length (of compressed data),
+         *                  at most BMI_DATASZ_MAX
+         *    A_UINT8       CompressedData[length]
+         * Response format: none
+         * Note: Not supported on all versions of ROM firmware.
+         */
+
+#endif /* __BMI_MSG_H__ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/common_drv.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/common_drv.h
@@ -0,0 +1,79 @@
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+
+#ifndef COMMON_DRV_H_
+#define COMMON_DRV_H_
+
+#include "../include/hif.h"
+#include "../include/htc_packet.h"
+
+
+
+/* structure that is the state information for the default credit distribution callback
+ * drivers should instantiate (zero-init as well) this structure in their driver instance
+ * and pass it as a context to the HTC credit distribution functions */
+typedef struct _COMMON_CREDIT_STATE_INFO {
+    int TotalAvailableCredits;      /* total credits in the system at startup */
+    int CurrentFreeCredits;         /* credits available in the pool that have not been
+                                       given out to endpoints */
+    HTC_ENDPOINT_CREDIT_DIST *pLowestPriEpDist;  /* pointer to the lowest priority endpoint dist struct */
+} COMMON_CREDIT_STATE_INFO;
+
+
+/* HTC TX packet tagging definitions */
+#define AR6K_CONTROL_PKT_TAG    HTC_TX_PACKET_TAG_USER_DEFINED
+#define AR6K_DATA_PKT_TAG       (AR6K_CONTROL_PKT_TAG + 1)
+
+#define AR6002_VERSION_REV1     0x20000086
+#define AR6002_VERSION_REV2     0x20000188
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* OS-independent APIs */
+A_STATUS ar6000_setup_credit_dist(HTC_HANDLE HTCHandle, COMMON_CREDIT_STATE_INFO *pCredInfo);
+
+A_STATUS ar6000_ReadRegDiag(HIF_DEVICE *hifDevice, A_UINT32 *address, A_UINT32 *data);
+
+A_STATUS ar6000_WriteRegDiag(HIF_DEVICE *hifDevice, A_UINT32 *address, A_UINT32 *data);
+
+A_STATUS ar6000_ReadDataDiag(HIF_DEVICE *hifDevice, A_UINT32 address,  A_UCHAR *data, A_UINT32 length);
+
+A_STATUS ar6000_reset_device(HIF_DEVICE *hifDevice, A_UINT32 TargetType, A_BOOL waitForCompletion);
+
+void ar6000_dump_target_assert_info(HIF_DEVICE *hifDevice, A_UINT32 TargetType);
+
+A_STATUS ar6000_reset_device_skipflash(HIF_DEVICE *hifDevice);
+
+A_STATUS ar6000_set_htc_params(HIF_DEVICE *hifDevice,
+                               A_UINT32    TargetType,
+                               A_UINT32    MboxIsrYieldValue,
+                               A_UINT8     HtcControlBuffers);
+
+A_STATUS ar6000_prepare_target(HIF_DEVICE *hifDevice,
+                               A_UINT32    TargetType,
+                               A_UINT32    TargetVersion);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*COMMON_DRV_H_*/
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/config.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/config.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef _CONFIG_LINUX_H_
+#define _CONFIG_LINUX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Host-side GPIO support is optional.
+ * If run-time access to GPIO pins is not required, then
+ * this should be changed to #undef.
+ */
+#define CONFIG_HOST_GPIO_SUPPORT
+
+/*
+ * Host side Test Command support
+ */
+#define CONFIG_HOST_TCMD_SUPPORT
+
+#define USE_4BYTE_REGISTER_ACCESS
+
+/* Host-side support for Target-side profiling */
+#undef CONFIG_TARGET_PROFILE_SUPPORT
+
+/* Force AR6002 REV1 hardware to recognize Host */
+#undef CONFIG_AR6002_REV1_FORCE_HOST
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/dbglog.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/dbglog.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ * This file contains the definitions and data structures associated with
+ * the log based debug mechanism.
+ *
+ */
+
+#ifndef _DBGLOG_H_
+#define _DBGLOG_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define DBGLOG_TIMESTAMP_OFFSET          0
+#define DBGLOG_TIMESTAMP_MASK            0x0000FFFF /* Bit 0-15. Contains bit
+                                                       8-23 of the LF0 timer */
+#define DBGLOG_DBGID_OFFSET              16
+#define DBGLOG_DBGID_MASK                0x03FF0000 /* Bit 16-25 */
+#define DBGLOG_DBGID_NUM_MAX             256 /* Upper limit is width of mask */
+
+#define DBGLOG_MODULEID_OFFSET           26
+#define DBGLOG_MODULEID_MASK             0x3C000000 /* Bit 26-29 */
+#define DBGLOG_MODULEID_NUM_MAX          16 /* Upper limit is width of mask */
+
+/*
+ * Please ensure that the definition of any new module intrduced is captured
+ * between the DBGLOG_MODULEID_START and DBGLOG_MODULEID_END defines. The
+ * structure is required for the parser to correctly pick up the values for
+ * different modules.
+ */
+#define DBGLOG_MODULEID_START
+#define DBGLOG_MODULEID_INF                   0
+#define DBGLOG_MODULEID_WMI                   1
+#define DBGLOG_MODULEID_CSERV                 2
+#define DBGLOG_MODULEID_PM                    3
+#define DBGLOG_MODULEID_TXRX_MGMTBUF          4
+#define DBGLOG_MODULEID_TXRX_TXBUF            5
+#define DBGLOG_MODULEID_TXRX_RXBUF            6
+#define DBGLOG_MODULEID_WOW                   7
+#define DBGLOG_MODULEID_WHAL                  8
+#define DBGLOG_MODULEID_DC                    9
+#define DBGLOG_MODULEID_CO                    10
+#define DBGLOG_MODULEID_RO                    11
+#define DBGLOG_MODULEID_CM                    12
+#define DBGLOG_MODULEID_TMR                   13
+#define DBGLOG_MODULEID_END
+
+#define DBGLOG_NUM_ARGS_OFFSET             30
+#define DBGLOG_NUM_ARGS_MASK               0xC0000000 /* Bit 30-31 */
+#define DBGLOG_NUM_ARGS_MAX                2 /* Upper limit is width of mask */
+
+#define DBGLOG_MODULE_LOG_ENABLE_OFFSET    0
+#define DBGLOG_MODULE_LOG_ENABLE_MASK      0x0000FFFF
+
+#define DBGLOG_REPORTING_ENABLED_OFFSET    16
+#define DBGLOG_REPORTING_ENABLED_MASK      0x00010000
+
+#define DBGLOG_TIMESTAMP_RESOLUTION_OFFSET 17
+#define DBGLOG_TIMESTAMP_RESOLUTION_MASK   0x000E0000
+
+#define DBGLOG_REPORT_SIZE_OFFSET          20
+#define DBGLOG_REPORT_SIZE_MASK            0x3FF00000
+
+#define DBGLOG_LOG_BUFFER_SIZE             1500
+    /* set the max length to 90 characters, even though the majority of the
+     * text here is 81 columns/chars per line or less..
+     ***WARNING** this has to be >= to the number of columns in this file
+     * This file is parsed by the target logging tools */
+#define DBGLOG_DBGID_DEFINITION_LEN_MAX    90
+
+struct dbglog_buf_s {
+    struct dbglog_buf_s *next;
+    A_INT8              *buffer;
+    A_UINT32             bufsize;
+    A_UINT32             length;
+    A_UINT32             count;
+    A_UINT32             free;
+};
+
+struct dbglog_hdr_s {
+    struct dbglog_buf_s *dbuf;
+    A_UINT32             dropped;
+};
+
+struct dbglog_config_s {
+    A_UINT32                    cfgvalid; /* Mask with valid config bits */
+    union {
+        /* TODO: Take care of endianness */
+        struct {
+            A_UINT32            mmask:16; /* Mask of modules with logging on */
+            A_UINT32            rep:1; /* Reporting enabled or not */
+            A_UINT32            tsr:3; /* Time stamp resolution. Def: 1 ms */
+            A_UINT32            size:10; /* Report size in number of messages */
+            A_UINT32            reserved:2;
+        } dbglog_config;
+
+        A_UINT32                value;
+    } u;
+};
+
+#define cfgmmask                   u.dbglog_config.mmask
+#define cfgrep                     u.dbglog_config.rep
+#define cfgtsr                     u.dbglog_config.tsr
+#define cfgsize                    u.dbglog_config.size
+#define cfgvalue                   u.value
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _DBGLOG_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/dbglog_api.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/dbglog_api.h
@@ -0,0 +1,47 @@
+
+#ifndef _DBGLOG_API_H_
+#define _DBGLOG_API_H_
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ * This file contains host side debug primitives.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "../include/dbglog.h"
+
+#define DBGLOG_HOST_LOG_BUFFER_SIZE            DBGLOG_LOG_BUFFER_SIZE
+
+#define DBGLOG_GET_DBGID(arg) \
+    ((arg & DBGLOG_DBGID_MASK) >> DBGLOG_DBGID_OFFSET)
+
+#define DBGLOG_GET_MODULEID(arg) \
+    ((arg & DBGLOG_MODULEID_MASK) >> DBGLOG_MODULEID_OFFSET)
+
+#define DBGLOG_GET_NUMARGS(arg) \
+    ((arg & DBGLOG_NUM_ARGS_MASK) >> DBGLOG_NUM_ARGS_OFFSET)
+
+#define DBGLOG_GET_TIMESTAMP(arg) \
+    ((arg & DBGLOG_TIMESTAMP_MASK) >> DBGLOG_TIMESTAMP_OFFSET)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _DBGLOG_API_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/debug.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/debug.h
@@ -0,0 +1,42 @@
+
+#ifndef _A_DEBUG_H_
+#define _A_DEBUG_H_
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "../include/athtypes.h"
+#include "../include/osapi.h"
+
+#define DBG_INFO		0x00000001
+#define DBG_ERROR		0x00000002
+#define DBG_WARNING		0x00000004
+#define DBG_SDIO		0x00000008
+#define DBG_HIF			0x00000010
+#define DBG_HTC			0x00000020
+#define DBG_WMI			0x00000040
+#define DBG_WMI2		0x00000080
+#define DBG_DRIVER		0x00000100
+
+#define DBG_DEFAULTS	(DBG_ERROR|DBG_WARNING)
+
+#include "../include/debug_linux.h"
+
+#endif
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/debug_linux.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/debug_linux.h
@@ -0,0 +1,87 @@
+
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef _DEBUG_LINUX_H_
+#define _DEBUG_LINUX_H_
+
+#define DBG_DEFAULTS	(DBG_ERROR|DBG_WARNING)
+
+extern A_UINT32 g_dbg_flags;
+
+#define DBGFMT  "%s() : "
+#define DBGARG  __func__
+#define DBGFN	A_PRINTF
+
+/* ------- Debug related stuff ------- */
+enum {
+    ATH_DEBUG_SEND = 0x0001,
+    ATH_DEBUG_RECV = 0x0002,
+    ATH_DEBUG_SYNC = 0x0004,
+    ATH_DEBUG_DUMP = 0x0008,
+    ATH_DEBUG_IRQ  = 0x0010,
+    ATH_DEBUG_TRC  = 0x0020,
+    ATH_DEBUG_WARN = 0x0040,
+    ATH_DEBUG_ERR  = 0x0080,
+    ATH_LOG_INF	   = 0x0100,
+    ATH_DEBUG_BMI  = 0x0110,
+    ATH_DEBUG_WMI  = 0x0120,
+    ATH_DEBUG_HIF  = 0x0140,
+    ATH_DEBUG_HTC  = 0x0180,
+    ATH_DEBUG_WLAN = 0x1000,
+    ATH_LOG_ERR	   = 0x1010,
+    ATH_DEBUG_ANY  = 0xFFFF,
+};
+
+#ifdef DEBUG
+
+#define A_DPRINTF(f, a) \
+	if(g_dbg_flags & (f)) \
+	{	\
+		DBGFN a ; \
+	}
+
+
+// TODO FIX usage of A_PRINTF!
+#define AR_DEBUG_LVL_CHECK(lvl) (debughtc & (lvl))
+#define AR_DEBUG_PRINTBUF(buffer, length, desc) do {   \
+    if (debughtc & ATH_DEBUG_DUMP) {             \
+        DebugDumpBytes(buffer, length,desc);               \
+    }                                            \
+} while(0)
+#define PRINTX_ARG(arg...) arg
+#define AR_DEBUG_PRINTF(flags, args) do {        \
+    if (debughtc & (flags)) {                    \
+        A_PRINTF(KERN_ALERT PRINTX_ARG args);    \
+    }                                            \
+} while (0)
+#define AR_DEBUG_ASSERT(test) do {               \
+    if (!(test)) {                               \
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Debug Assert Caught, File %s, Line: %d, Test:%s \n",__FILE__, __LINE__,#test));         \
+    }                                            \
+} while(0)
+extern int debughtc;
+#else
+#define AR_DEBUG_PRINTF(flags, args)
+#define AR_DEBUG_PRINTBUF(buffer, length, desc)
+#define AR_DEBUG_ASSERT(test)
+#define AR_DEBUG_LVL_CHECK(lvl) 0
+#define A_DPRINTF(f, a)
+#endif
+
+#endif /* _DEBUG_LINUX_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/dl_list.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/dl_list.h
@@ -0,0 +1,115 @@
+
+/*
+ *
+ * Double-link list definitions (adapted from Atheros SDIO stack)
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+#ifndef __DL_LIST_H___
+#define __DL_LIST_H___
+
+#define A_CONTAINING_STRUCT(address, struct_type, field_name)\
+            ((struct_type *)((A_UINT32)(address) - (A_UINT32)(&((struct_type *)0)->field_name)))
+
+/* list functions */
+/* pointers for the list */
+typedef struct _DL_LIST {
+    struct _DL_LIST *pPrev;
+    struct _DL_LIST *pNext;
+}DL_LIST, *PDL_LIST;
+/*
+ * DL_LIST_INIT , initialize doubly linked list
+*/
+#define DL_LIST_INIT(pList)\
+    {(pList)->pPrev = pList; (pList)->pNext = pList;}
+
+#define DL_LIST_IS_EMPTY(pList) (((pList)->pPrev == (pList)) && ((pList)->pNext == (pList)))
+#define DL_LIST_GET_ITEM_AT_HEAD(pList) (pList)->pNext
+#define DL_LIST_GET_ITEM_AT_TAIL(pList) (pList)->pPrev
+/*
+ * ITERATE_OVER_LIST pStart is the list, pTemp is a temp list member
+ * NOT: do not use this function if the items in the list are deleted inside the
+ * iteration loop
+*/
+#define ITERATE_OVER_LIST(pStart, pTemp) \
+    for((pTemp) =(pStart)->pNext; pTemp != (pStart); (pTemp) = (pTemp)->pNext)
+
+
+/* safe iterate macro that allows the item to be removed from the list
+ * the iteration continues to the next item in the list
+ */
+#define ITERATE_OVER_LIST_ALLOW_REMOVE(pStart,pItem,st,offset)  \
+{                                                       \
+    PDL_LIST  pTemp;                                     \
+    pTemp = (pStart)->pNext;                            \
+    while (pTemp != (pStart)) {                         \
+        (pItem) = A_CONTAINING_STRUCT(pTemp,st,offset);   \
+         pTemp = pTemp->pNext;                          \
+
+#define ITERATE_END }}
+
+/*
+ * DL_ListInsertTail - insert pAdd to the end of the list
+*/
+static INLINE PDL_LIST DL_ListInsertTail(PDL_LIST pList, PDL_LIST pAdd) {
+        /* insert at tail */
+    pAdd->pPrev = pList->pPrev;
+    pAdd->pNext = pList;
+    pList->pPrev->pNext = pAdd;
+    pList->pPrev = pAdd;
+    return pAdd;
+}
+
+/*
+ * DL_ListInsertHead - insert pAdd into the head of the list
+*/
+static INLINE PDL_LIST DL_ListInsertHead(PDL_LIST pList, PDL_LIST pAdd) {
+        /* insert at head */
+    pAdd->pPrev = pList;
+    pAdd->pNext = pList->pNext;
+    pList->pNext->pPrev = pAdd;
+    pList->pNext = pAdd;
+    return pAdd;
+}
+
+#define DL_ListAdd(pList,pItem) DL_ListInsertHead((pList),(pItem))
+/*
+ * DL_ListRemove - remove pDel from list
+*/
+static INLINE PDL_LIST DL_ListRemove(PDL_LIST pDel) {
+    pDel->pNext->pPrev = pDel->pPrev;
+    pDel->pPrev->pNext = pDel->pNext;
+        /* point back to itself just to be safe, incase remove is called again */
+    pDel->pNext = pDel;
+    pDel->pPrev = pDel;
+    return pDel;
+}
+
+/*
+ * DL_ListRemoveItemFromHead - get a list item from the head
+*/
+static INLINE PDL_LIST DL_ListRemoveItemFromHead(PDL_LIST pList) {
+    PDL_LIST pItem = NULL;
+    if (pList->pNext != pList) {
+        pItem = pList->pNext;
+            /* remove the first item from head */
+        DL_ListRemove(pItem);
+    }
+    return pItem;
+}
+
+#endif /* __DL_LIST_H___ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/dset_api.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/dset_api.h
@@ -0,0 +1,64 @@
+
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/include/dset_api.h#1 $
+ *
+ * Host-side DataSet API.
+ *
+ */
+
+#ifndef _DSET_API_H_
+#define _DSET_API_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/*
+ * Host-side DataSet support is optional, and is not
+ * currently required for correct operation.  To disable
+ * Host-side DataSet support, set this to 0.
+ */
+#ifndef CONFIG_HOST_DSET_SUPPORT
+#define CONFIG_HOST_DSET_SUPPORT 1
+#endif
+
+/* Called to send a DataSet Open Reply back to the Target. */
+A_STATUS wmi_dset_open_reply(struct wmi_t *wmip,
+                             A_UINT32 status,
+                             A_UINT32 access_cookie,
+                             A_UINT32 size,
+                             A_UINT32 version,
+                             A_UINT32 targ_handle,
+                             A_UINT32 targ_reply_fn,
+                             A_UINT32 targ_reply_arg);
+
+/* Called to send a DataSet Data Reply back to the Target. */
+A_STATUS wmi_dset_data_reply(struct wmi_t *wmip,
+                             A_UINT32 status,
+                             A_UINT8 *host_buf,
+                             A_UINT32 length,
+                             A_UINT32 targ_buf,
+                             A_UINT32 targ_reply_fn,
+                             A_UINT32 targ_reply_arg);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* _DSET_API_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/engine.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/engine.h
@@ -0,0 +1,93 @@
+/*
+ *
+ * Copyright (c) 2008 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation;
+//
+// Software distributed under the License is distributed on an "AS
+// IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+// implied. See the License for the specific language governing
+// rights and limitations under the License.
+//
+//
+ *
+ */
+/*
+ * athloader.h - definitions for atheros firmware loader.
+ *
+ * Firmware image format:
+ *
+ * unsigned char 0xFF                //  "magic"
+ * unsigned char version             //  fw loader / tool version, not fw version major/minor 4 bits each
+ * char hostname[variable]           //  zero delimited hostname where the image was built
+ * unsigned char month               //
+ * unsigned char day                 //  Date and time when the image was built
+ * unsigned char year                //  year is a number of years after 2008, i.e. 2008 is coided as 0
+ * unsigned char hour                //
+ * unsigned char min                 //
+ * // the rest are optional blocks that may be repeated and/or mixed
+ * unsigned char instruction
+ *   unsigned char argument[4]       // optional constant, mask or offset
+ *   unsigned char image[variable]   // optional loadable image
+ * // repeated as necessary
+ * unsigned char crc32[4]            // inverted crc32
+ *
+ */
+#ifndef ATHLOADER_IS_SEEN
+#define ATHLOADER_IS_SEEN
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#define FW_AUTOLOAD
+/* Uncomment the following to build standalone application for testing
+
+#define UNIT_TEST
+#define syserr printf
+#define sysprint printf
+#include "crc32.h"
+#include <stdio.h>
+ */
+
+#ifndef UNIT_TEST
+#if defined(__linux__) || defined(LINUX)
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/crc32.h>
+#include <linux/firmware.h>
+#define syserr(arg...) printk( KERN_ERR arg)
+#define sysprint(arg...) printk( KERN_INFO arg)
+#endif /* __linux__ */
+#endif /* UNIT_TEST */
+
+#define VERSION (0x01)
+
+/* Opcodes */
+#define RLoad (0x10)
+#define Ror   (0x20)
+#define Rand  (0x30)
+#define Add   (0x40)
+#define Rstor (0x50)
+#define Shift (0x60)
+#define Nneg  (0x70)
+#define Trr   (0x80)
+#define Trw   (0x90)
+#define Trx   (0xA0)
+#define Exit  (0xB0)
+#define Cmp   (0xC0)
+#define Ldprn (0xD0)
+#define Jump  (0xE0)
+
+extern int get_target_reg( unsigned address, unsigned *val, void *ar );
+extern int write_target_reg( unsigned address, unsigned value, void *ar );
+extern int execute_on_target( unsigned int address, unsigned int arg, void *ar );
+extern int load_binary(unsigned int addr, const unsigned char *data, void *ar);
+extern void bmidone( void *ar );
+#endif /* KERNEL 2.6 only */
+#endif /* ATHLOADER_IS_SEEN */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/gpio.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/gpio.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ */
+
+#if defined(AR6001)
+#define GPIO_PIN_COUNT 18
+#else
+#define GPIO_PIN_COUNT 18
+#endif
+
+/*
+ * Possible values for WMIX_GPIO_SET_REGISTER_CMDID.
+ * NB: These match hardware order, so that addresses can
+ * easily be computed.
+ */
+#define GPIO_ID_OUT             0x00000000
+#define GPIO_ID_OUT_W1TS        0x00000001
+#define GPIO_ID_OUT_W1TC        0x00000002
+#define GPIO_ID_ENABLE          0x00000003
+#define GPIO_ID_ENABLE_W1TS     0x00000004
+#define GPIO_ID_ENABLE_W1TC     0x00000005
+#define GPIO_ID_IN              0x00000006
+#define GPIO_ID_STATUS          0x00000007
+#define GPIO_ID_STATUS_W1TS     0x00000008
+#define GPIO_ID_STATUS_W1TC     0x00000009
+#define GPIO_ID_PIN0            0x0000000a
+#define GPIO_ID_PIN(n)          (GPIO_ID_PIN0+(n))
+
+#define GPIO_LAST_REGISTER_ID   GPIO_ID_PIN(17)
+#define GPIO_ID_NONE            0xffffffff
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/gpio_api.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/gpio_api.h
@@ -0,0 +1,58 @@
+
+#ifndef _GPIO_API_H_
+#define _GPIO_API_H_
+/*
+ * Copyright 2005 Atheros Communications, Inc.,  All Rights Reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+/*
+ * Host-side General Purpose I/O API.
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/include/gpio_api.h#1 $
+ */
+
+/*
+ * Send a command to the Target in order to change output on GPIO pins.
+ */
+A_STATUS wmi_gpio_output_set(struct wmi_t *wmip,
+                             A_UINT32 set_mask,
+                             A_UINT32 clear_mask,
+                             A_UINT32 enable_mask,
+                             A_UINT32 disable_mask);
+
+/*
+ * Send a command to the Target requesting input state of GPIO pins.
+ */
+A_STATUS wmi_gpio_input_get(struct wmi_t *wmip);
+
+/*
+ * Send a command to the Target to change the value of a GPIO register.
+ */
+A_STATUS wmi_gpio_register_set(struct wmi_t *wmip,
+                               A_UINT32 gpioreg_id,
+                               A_UINT32 value);
+
+/*
+ * Send a command to the Target to fetch the value of a GPIO register.
+ */
+A_STATUS wmi_gpio_register_get(struct wmi_t *wmip, A_UINT32 gpioreg_id);
+
+/*
+ * Send a command to the Target, acknowledging some GPIO interrupts.
+ */
+A_STATUS wmi_gpio_intr_ack(struct wmi_t *wmip, A_UINT32 ack_mask);
+
+#endif /* _GPIO_API_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/gpio_reg.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/gpio_reg.h
@@ -0,0 +1,1001 @@
+// ------------------------------------------------------------------
+// Copyright (c) 2004-2007 Atheros Corporation.  All rights reserved.
+//
+// The software source and binaries included in this development package are
+// licensed, not sold. You, or your company, received the package under one
+// or more license agreements. The rights granted to you are specifically
+// listed in these license agreement(s). All other rights remain with Atheros
+// Communications, Inc., its subsidiaries, or the respective owner including
+// those listed on the included copyright notices.  Distribution of any
+// portion of this package must be in strict compliance with the license
+// agreement(s) terms.
+// </copyright>
+//
+// <summary>
+// 	Wifi driver for AR6002
+// </summary>
+//
+// ------------------------------------------------------------------
+//===================================================================
+// Author(s): ="Atheros"
+//===================================================================
+
+/* These values only apply to the AR6002 */
+
+#ifndef _GPIO_REG_REG_H_
+#define _GPIO_REG_REG_H_
+
+#define GPIO_OUT_ADDRESS                         0x00000000
+#define GPIO_OUT_OFFSET                          0x00000000
+#define GPIO_OUT_DATA_MSB                        17
+#define GPIO_OUT_DATA_LSB                        0
+#define GPIO_OUT_DATA_MASK                       0x0003ffff
+#define GPIO_OUT_DATA_GET(x)                     (((x) & GPIO_OUT_DATA_MASK) >> GPIO_OUT_DATA_LSB)
+#define GPIO_OUT_DATA_SET(x)                     (((x) << GPIO_OUT_DATA_LSB) & GPIO_OUT_DATA_MASK)
+
+#define GPIO_OUT_W1TS_ADDRESS                    0x00000004
+#define GPIO_OUT_W1TS_OFFSET                     0x00000004
+#define GPIO_OUT_W1TS_DATA_MSB                   17
+#define GPIO_OUT_W1TS_DATA_LSB                   0
+#define GPIO_OUT_W1TS_DATA_MASK                  0x0003ffff
+#define GPIO_OUT_W1TS_DATA_GET(x)                (((x) & GPIO_OUT_W1TS_DATA_MASK) >> GPIO_OUT_W1TS_DATA_LSB)
+#define GPIO_OUT_W1TS_DATA_SET(x)                (((x) << GPIO_OUT_W1TS_DATA_LSB) & GPIO_OUT_W1TS_DATA_MASK)
+
+#define GPIO_OUT_W1TC_ADDRESS                    0x00000008
+#define GPIO_OUT_W1TC_OFFSET                     0x00000008
+#define GPIO_OUT_W1TC_DATA_MSB                   17
+#define GPIO_OUT_W1TC_DATA_LSB                   0
+#define GPIO_OUT_W1TC_DATA_MASK                  0x0003ffff
+#define GPIO_OUT_W1TC_DATA_GET(x)                (((x) & GPIO_OUT_W1TC_DATA_MASK) >> GPIO_OUT_W1TC_DATA_LSB)
+#define GPIO_OUT_W1TC_DATA_SET(x)                (((x) << GPIO_OUT_W1TC_DATA_LSB) & GPIO_OUT_W1TC_DATA_MASK)
+
+#define GPIO_ENABLE_ADDRESS                      0x0000000c
+#define GPIO_ENABLE_OFFSET                       0x0000000c
+#define GPIO_ENABLE_DATA_MSB                     17
+#define GPIO_ENABLE_DATA_LSB                     0
+#define GPIO_ENABLE_DATA_MASK                    0x0003ffff
+#define GPIO_ENABLE_DATA_GET(x)                  (((x) & GPIO_ENABLE_DATA_MASK) >> GPIO_ENABLE_DATA_LSB)
+#define GPIO_ENABLE_DATA_SET(x)                  (((x) << GPIO_ENABLE_DATA_LSB) & GPIO_ENABLE_DATA_MASK)
+
+#define GPIO_ENABLE_W1TS_ADDRESS                 0x00000010
+#define GPIO_ENABLE_W1TS_OFFSET                  0x00000010
+#define GPIO_ENABLE_W1TS_DATA_MSB                17
+#define GPIO_ENABLE_W1TS_DATA_LSB                0
+#define GPIO_ENABLE_W1TS_DATA_MASK               0x0003ffff
+#define GPIO_ENABLE_W1TS_DATA_GET(x)             (((x) & GPIO_ENABLE_W1TS_DATA_MASK) >> GPIO_ENABLE_W1TS_DATA_LSB)
+#define GPIO_ENABLE_W1TS_DATA_SET(x)             (((x) << GPIO_ENABLE_W1TS_DATA_LSB) & GPIO_ENABLE_W1TS_DATA_MASK)
+
+#define GPIO_ENABLE_W1TC_ADDRESS                 0x00000014
+#define GPIO_ENABLE_W1TC_OFFSET                  0x00000014
+#define GPIO_ENABLE_W1TC_DATA_MSB                17
+#define GPIO_ENABLE_W1TC_DATA_LSB                0
+#define GPIO_ENABLE_W1TC_DATA_MASK               0x0003ffff
+#define GPIO_ENABLE_W1TC_DATA_GET(x)             (((x) & GPIO_ENABLE_W1TC_DATA_MASK) >> GPIO_ENABLE_W1TC_DATA_LSB)
+#define GPIO_ENABLE_W1TC_DATA_SET(x)             (((x) << GPIO_ENABLE_W1TC_DATA_LSB) & GPIO_ENABLE_W1TC_DATA_MASK)
+
+#define GPIO_IN_ADDRESS                          0x00000018
+#define GPIO_IN_OFFSET                           0x00000018
+#define GPIO_IN_DATA_MSB                         17
+#define GPIO_IN_DATA_LSB                         0
+#define GPIO_IN_DATA_MASK                        0x0003ffff
+#define GPIO_IN_DATA_GET(x)                      (((x) & GPIO_IN_DATA_MASK) >> GPIO_IN_DATA_LSB)
+#define GPIO_IN_DATA_SET(x)                      (((x) << GPIO_IN_DATA_LSB) & GPIO_IN_DATA_MASK)
+
+#define GPIO_STATUS_ADDRESS                      0x0000001c
+#define GPIO_STATUS_OFFSET                       0x0000001c
+#define GPIO_STATUS_INTERRUPT_MSB                17
+#define GPIO_STATUS_INTERRUPT_LSB                0
+#define GPIO_STATUS_INTERRUPT_MASK               0x0003ffff
+#define GPIO_STATUS_INTERRUPT_GET(x)             (((x) & GPIO_STATUS_INTERRUPT_MASK) >> GPIO_STATUS_INTERRUPT_LSB)
+#define GPIO_STATUS_INTERRUPT_SET(x)             (((x) << GPIO_STATUS_INTERRUPT_LSB) & GPIO_STATUS_INTERRUPT_MASK)
+
+#define GPIO_STATUS_W1TS_ADDRESS                 0x00000020
+#define GPIO_STATUS_W1TS_OFFSET                  0x00000020
+#define GPIO_STATUS_W1TS_INTERRUPT_MSB           17
+#define GPIO_STATUS_W1TS_INTERRUPT_LSB           0
+#define GPIO_STATUS_W1TS_INTERRUPT_MASK          0x0003ffff
+#define GPIO_STATUS_W1TS_INTERRUPT_GET(x)        (((x) & GPIO_STATUS_W1TS_INTERRUPT_MASK) >> GPIO_STATUS_W1TS_INTERRUPT_LSB)
+#define GPIO_STATUS_W1TS_INTERRUPT_SET(x)        (((x) << GPIO_STATUS_W1TS_INTERRUPT_LSB) & GPIO_STATUS_W1TS_INTERRUPT_MASK)
+
+#define GPIO_STATUS_W1TC_ADDRESS                 0x00000024
+#define GPIO_STATUS_W1TC_OFFSET                  0x00000024
+#define GPIO_STATUS_W1TC_INTERRUPT_MSB           17
+#define GPIO_STATUS_W1TC_INTERRUPT_LSB           0
+#define GPIO_STATUS_W1TC_INTERRUPT_MASK          0x0003ffff
+#define GPIO_STATUS_W1TC_INTERRUPT_GET(x)        (((x) & GPIO_STATUS_W1TC_INTERRUPT_MASK) >> GPIO_STATUS_W1TC_INTERRUPT_LSB)
+#define GPIO_STATUS_W1TC_INTERRUPT_SET(x)        (((x) << GPIO_STATUS_W1TC_INTERRUPT_LSB) & GPIO_STATUS_W1TC_INTERRUPT_MASK)
+
+#define GPIO_PIN0_ADDRESS                        0x00000028
+#define GPIO_PIN0_OFFSET                         0x00000028
+#define GPIO_PIN0_CONFIG_MSB                     12
+#define GPIO_PIN0_CONFIG_LSB                     11
+#define GPIO_PIN0_CONFIG_MASK                    0x00001800
+#define GPIO_PIN0_CONFIG_GET(x)                  (((x) & GPIO_PIN0_CONFIG_MASK) >> GPIO_PIN0_CONFIG_LSB)
+#define GPIO_PIN0_CONFIG_SET(x)                  (((x) << GPIO_PIN0_CONFIG_LSB) & GPIO_PIN0_CONFIG_MASK)
+#define GPIO_PIN0_WAKEUP_ENABLE_MSB              10
+#define GPIO_PIN0_WAKEUP_ENABLE_LSB              10
+#define GPIO_PIN0_WAKEUP_ENABLE_MASK             0x00000400
+#define GPIO_PIN0_WAKEUP_ENABLE_GET(x)           (((x) & GPIO_PIN0_WAKEUP_ENABLE_MASK) >> GPIO_PIN0_WAKEUP_ENABLE_LSB)
+#define GPIO_PIN0_WAKEUP_ENABLE_SET(x)           (((x) << GPIO_PIN0_WAKEUP_ENABLE_LSB) & GPIO_PIN0_WAKEUP_ENABLE_MASK)
+#define GPIO_PIN0_INT_TYPE_MSB                   9
+#define GPIO_PIN0_INT_TYPE_LSB                   7
+#define GPIO_PIN0_INT_TYPE_MASK                  0x00000380
+#define GPIO_PIN0_INT_TYPE_GET(x)                (((x) & GPIO_PIN0_INT_TYPE_MASK) >> GPIO_PIN0_INT_TYPE_LSB)
+#define GPIO_PIN0_INT_TYPE_SET(x)                (((x) << GPIO_PIN0_INT_TYPE_LSB) & GPIO_PIN0_INT_TYPE_MASK)
+#define GPIO_PIN0_PAD_DRIVER_MSB                 2
+#define GPIO_PIN0_PAD_DRIVER_LSB                 2
+#define GPIO_PIN0_PAD_DRIVER_MASK                0x00000004
+#define GPIO_PIN0_PAD_DRIVER_GET(x)              (((x) & GPIO_PIN0_PAD_DRIVER_MASK) >> GPIO_PIN0_PAD_DRIVER_LSB)
+#define GPIO_PIN0_PAD_DRIVER_SET(x)              (((x) << GPIO_PIN0_PAD_DRIVER_LSB) & GPIO_PIN0_PAD_DRIVER_MASK)
+#define GPIO_PIN0_SOURCE_MSB                     0
+#define GPIO_PIN0_SOURCE_LSB                     0
+#define GPIO_PIN0_SOURCE_MASK                    0x00000001
+#define GPIO_PIN0_SOURCE_GET(x)                  (((x) & GPIO_PIN0_SOURCE_MASK) >> GPIO_PIN0_SOURCE_LSB)
+#define GPIO_PIN0_SOURCE_SET(x)                  (((x) << GPIO_PIN0_SOURCE_LSB) & GPIO_PIN0_SOURCE_MASK)
+
+#define GPIO_PIN1_ADDRESS                        0x0000002c
+#define GPIO_PIN1_OFFSET                         0x0000002c
+#define GPIO_PIN1_CONFIG_MSB                     12
+#define GPIO_PIN1_CONFIG_LSB                     11
+#define GPIO_PIN1_CONFIG_MASK                    0x00001800
+#define GPIO_PIN1_CONFIG_GET(x)                  (((x) & GPIO_PIN1_CONFIG_MASK) >> GPIO_PIN1_CONFIG_LSB)
+#define GPIO_PIN1_CONFIG_SET(x)                  (((x) << GPIO_PIN1_CONFIG_LSB) & GPIO_PIN1_CONFIG_MASK)
+#define GPIO_PIN1_WAKEUP_ENABLE_MSB              10
+#define GPIO_PIN1_WAKEUP_ENABLE_LSB              10
+#define GPIO_PIN1_WAKEUP_ENABLE_MASK             0x00000400
+#define GPIO_PIN1_WAKEUP_ENABLE_GET(x)           (((x) & GPIO_PIN1_WAKEUP_ENABLE_MASK) >> GPIO_PIN1_WAKEUP_ENABLE_LSB)
+#define GPIO_PIN1_WAKEUP_ENABLE_SET(x)           (((x) << GPIO_PIN1_WAKEUP_ENABLE_LSB) & GPIO_PIN1_WAKEUP_ENABLE_MASK)
+#define GPIO_PIN1_INT_TYPE_MSB                   9
+#define GPIO_PIN1_INT_TYPE_LSB                   7
+#define GPIO_PIN1_INT_TYPE_MASK                  0x00000380
+#define GPIO_PIN1_INT_TYPE_GET(x)                (((x) & GPIO_PIN1_INT_TYPE_MASK) >> GPIO_PIN1_INT_TYPE_LSB)
+#define GPIO_PIN1_INT_TYPE_SET(x)                (((x) << GPIO_PIN1_INT_TYPE_LSB) & GPIO_PIN1_INT_TYPE_MASK)
+#define GPIO_PIN1_PAD_DRIVER_MSB                 2
+#define GPIO_PIN1_PAD_DRIVER_LSB                 2
+#define GPIO_PIN1_PAD_DRIVER_MASK                0x00000004
+#define GPIO_PIN1_PAD_DRIVER_GET(x)              (((x) & GPIO_PIN1_PAD_DRIVER_MASK) >> GPIO_PIN1_PAD_DRIVER_LSB)
+#define GPIO_PIN1_PAD_DRIVER_SET(x)              (((x) << GPIO_PIN1_PAD_DRIVER_LSB) & GPIO_PIN1_PAD_DRIVER_MASK)
+#define GPIO_PIN1_SOURCE_MSB                     0
+#define GPIO_PIN1_SOURCE_LSB                     0
+#define GPIO_PIN1_SOURCE_MASK                    0x00000001
+#define GPIO_PIN1_SOURCE_GET(x)                  (((x) & GPIO_PIN1_SOURCE_MASK) >> GPIO_PIN1_SOURCE_LSB)
+#define GPIO_PIN1_SOURCE_SET(x)                  (((x) << GPIO_PIN1_SOURCE_LSB) & GPIO_PIN1_SOURCE_MASK)
+
+#define GPIO_PIN2_ADDRESS                        0x00000030
+#define GPIO_PIN2_OFFSET                         0x00000030
+#define GPIO_PIN2_CONFIG_MSB                     12
+#define GPIO_PIN2_CONFIG_LSB                     11
+#define GPIO_PIN2_CONFIG_MASK                    0x00001800
+#define GPIO_PIN2_CONFIG_GET(x)                  (((x) & GPIO_PIN2_CONFIG_MASK) >> GPIO_PIN2_CONFIG_LSB)
+#define GPIO_PIN2_CONFIG_SET(x)                  (((x) << GPIO_PIN2_CONFIG_LSB) & GPIO_PIN2_CONFIG_MASK)
+#define GPIO_PIN2_WAKEUP_ENABLE_MSB              10
+#define GPIO_PIN2_WAKEUP_ENABLE_LSB              10
+#define GPIO_PIN2_WAKEUP_ENABLE_MASK             0x00000400
+#define GPIO_PIN2_WAKEUP_ENABLE_GET(x)           (((x) & GPIO_PIN2_WAKEUP_ENABLE_MASK) >> GPIO_PIN2_WAKEUP_ENABLE_LSB)
+#define GPIO_PIN2_WAKEUP_ENABLE_SET(x)           (((x) << GPIO_PIN2_WAKEUP_ENABLE_LSB) & GPIO_PIN2_WAKEUP_ENABLE_MASK)
+#define GPIO_PIN2_INT_TYPE_MSB                   9
+#define GPIO_PIN2_INT_TYPE_LSB                   7
+#define GPIO_PIN2_INT_TYPE_MASK                  0x00000380
+#define GPIO_PIN2_INT_TYPE_GET(x)                (((x) & GPIO_PIN2_INT_TYPE_MASK) >> GPIO_PIN2_INT_TYPE_LSB)
+#define GPIO_PIN2_INT_TYPE_SET(x)                (((x) << GPIO_PIN2_INT_TYPE_LSB) & GPIO_PIN2_INT_TYPE_MASK)
+#define GPIO_PIN2_PAD_DRIVER_MSB                 2
+#define GPIO_PIN2_PAD_DRIVER_LSB                 2
+#define GPIO_PIN2_PAD_DRIVER_MASK                0x00000004
+#define GPIO_PIN2_PAD_DRIVER_GET(x)              (((x) & GPIO_PIN2_PAD_DRIVER_MASK) >> GPIO_PIN2_PAD_DRIVER_LSB)
+#define GPIO_PIN2_PAD_DRIVER_SET(x)              (((x) << GPIO_PIN2_PAD_DRIVER_LSB) & GPIO_PIN2_PAD_DRIVER_MASK)
+#define GPIO_PIN2_SOURCE_MSB                     0
+#define GPIO_PIN2_SOURCE_LSB                     0
+#define GPIO_PIN2_SOURCE_MASK                    0x00000001
+#define GPIO_PIN2_SOURCE_GET(x)                  (((x) & GPIO_PIN2_SOURCE_MASK) >> GPIO_PIN2_SOURCE_LSB)
+#define GPIO_PIN2_SOURCE_SET(x)                  (((x) << GPIO_PIN2_SOURCE_LSB) & GPIO_PIN2_SOURCE_MASK)
+
+#define GPIO_PIN3_ADDRESS                        0x00000034
+#define GPIO_PIN3_OFFSET                         0x00000034
+#define GPIO_PIN3_CONFIG_MSB                     12
+#define GPIO_PIN3_CONFIG_LSB                     11
+#define GPIO_PIN3_CONFIG_MASK                    0x00001800
+#define GPIO_PIN3_CONFIG_GET(x)                  (((x) & GPIO_PIN3_CONFIG_MASK) >> GPIO_PIN3_CONFIG_LSB)
+#define GPIO_PIN3_CONFIG_SET(x)                  (((x) << GPIO_PIN3_CONFIG_LSB) & GPIO_PIN3_CONFIG_MASK)
+#define GPIO_PIN3_WAKEUP_ENABLE_MSB              10
+#define GPIO_PIN3_WAKEUP_ENABLE_LSB              10
+#define GPIO_PIN3_WAKEUP_ENABLE_MASK             0x00000400
+#define GPIO_PIN3_WAKEUP_ENABLE_GET(x)           (((x) & GPIO_PIN3_WAKEUP_ENABLE_MASK) >> GPIO_PIN3_WAKEUP_ENABLE_LSB)
+#define GPIO_PIN3_WAKEUP_ENABLE_SET(x)           (((x) << GPIO_PIN3_WAKEUP_ENABLE_LSB) & GPIO_PIN3_WAKEUP_ENABLE_MASK)
+#define GPIO_PIN3_INT_TYPE_MSB                   9
+#define GPIO_PIN3_INT_TYPE_LSB                   7
+#define GPIO_PIN3_INT_TYPE_MASK                  0x00000380
+#define GPIO_PIN3_INT_TYPE_GET(x)                (((x) & GPIO_PIN3_INT_TYPE_MASK) >> GPIO_PIN3_INT_TYPE_LSB)
+#define GPIO_PIN3_INT_TYPE_SET(x)                (((x) << GPIO_PIN3_INT_TYPE_LSB) & GPIO_PIN3_INT_TYPE_MASK)
+#define GPIO_PIN3_PAD_DRIVER_MSB                 2
+#define GPIO_PIN3_PAD_DRIVER_LSB                 2
+#define GPIO_PIN3_PAD_DRIVER_MASK                0x00000004
+#define GPIO_PIN3_PAD_DRIVER_GET(x)              (((x) & GPIO_PIN3_PAD_DRIVER_MASK) >> GPIO_PIN3_PAD_DRIVER_LSB)
+#define GPIO_PIN3_PAD_DRIVER_SET(x)              (((x) << GPIO_PIN3_PAD_DRIVER_LSB) & GPIO_PIN3_PAD_DRIVER_MASK)
+#define GPIO_PIN3_SOURCE_MSB                     0
+#define GPIO_PIN3_SOURCE_LSB                     0
+#define GPIO_PIN3_SOURCE_MASK                    0x00000001
+#define GPIO_PIN3_SOURCE_GET(x)                  (((x) & GPIO_PIN3_SOURCE_MASK) >> GPIO_PIN3_SOURCE_LSB)
+#define GPIO_PIN3_SOURCE_SET(x)                  (((x) << GPIO_PIN3_SOURCE_LSB) & GPIO_PIN3_SOURCE_MASK)
+
+#define GPIO_PIN4_ADDRESS                        0x00000038
+#define GPIO_PIN4_OFFSET                         0x00000038
+#define GPIO_PIN4_CONFIG_MSB                     12
+#define GPIO_PIN4_CONFIG_LSB                     11
+#define GPIO_PIN4_CONFIG_MASK                    0x00001800
+#define GPIO_PIN4_CONFIG_GET(x)                  (((x) & GPIO_PIN4_CONFIG_MASK) >> GPIO_PIN4_CONFIG_LSB)
+#define GPIO_PIN4_CONFIG_SET(x)                  (((x) << GPIO_PIN4_CONFIG_LSB) & GPIO_PIN4_CONFIG_MASK)
+#define GPIO_PIN4_WAKEUP_ENABLE_MSB              10
+#define GPIO_PIN4_WAKEUP_ENABLE_LSB              10
+#define GPIO_PIN4_WAKEUP_ENABLE_MASK             0x00000400
+#define GPIO_PIN4_WAKEUP_ENABLE_GET(x)           (((x) & GPIO_PIN4_WAKEUP_ENABLE_MASK) >> GPIO_PIN4_WAKEUP_ENABLE_LSB)
+#define GPIO_PIN4_WAKEUP_ENABLE_SET(x)           (((x) << GPIO_PIN4_WAKEUP_ENABLE_LSB) & GPIO_PIN4_WAKEUP_ENABLE_MASK)
+#define GPIO_PIN4_INT_TYPE_MSB                   9
+#define GPIO_PIN4_INT_TYPE_LSB                   7
+#define GPIO_PIN4_INT_TYPE_MASK                  0x00000380
+#define GPIO_PIN4_INT_TYPE_GET(x)                (((x) & GPIO_PIN4_INT_TYPE_MASK) >> GPIO_PIN4_INT_TYPE_LSB)
+#define GPIO_PIN4_INT_TYPE_SET(x)                (((x) << GPIO_PIN4_INT_TYPE_LSB) & GPIO_PIN4_INT_TYPE_MASK)
+#define GPIO_PIN4_PAD_DRIVER_MSB                 2
+#define GPIO_PIN4_PAD_DRIVER_LSB                 2
+#define GPIO_PIN4_PAD_DRIVER_MASK                0x00000004
+#define GPIO_PIN4_PAD_DRIVER_GET(x)              (((x) & GPIO_PIN4_PAD_DRIVER_MASK) >> GPIO_PIN4_PAD_DRIVER_LSB)
+#define GPIO_PIN4_PAD_DRIVER_SET(x)              (((x) << GPIO_PIN4_PAD_DRIVER_LSB) & GPIO_PIN4_PAD_DRIVER_MASK)
+#define GPIO_PIN4_SOURCE_MSB                     0
+#define GPIO_PIN4_SOURCE_LSB                     0
+#define GPIO_PIN4_SOURCE_MASK                    0x00000001
+#define GPIO_PIN4_SOURCE_GET(x)                  (((x) & GPIO_PIN4_SOURCE_MASK) >> GPIO_PIN4_SOURCE_LSB)
+#define GPIO_PIN4_SOURCE_SET(x)                  (((x) << GPIO_PIN4_SOURCE_LSB) & GPIO_PIN4_SOURCE_MASK)
+
+#define GPIO_PIN5_ADDRESS                        0x0000003c
+#define GPIO_PIN5_OFFSET                         0x0000003c
+#define GPIO_PIN5_CONFIG_MSB                     12
+#define GPIO_PIN5_CONFIG_LSB                     11
+#define GPIO_PIN5_CONFIG_MASK                    0x00001800
+#define GPIO_PIN5_CONFIG_GET(x)                  (((x) & GPIO_PIN5_CONFIG_MASK) >> GPIO_PIN5_CONFIG_LSB)
+#define GPIO_PIN5_CONFIG_SET(x)                  (((x) << GPIO_PIN5_CONFIG_LSB) & GPIO_PIN5_CONFIG_MASK)
+#define GPIO_PIN5_WAKEUP_ENABLE_MSB              10
+#define GPIO_PIN5_WAKEUP_ENABLE_LSB              10
+#define GPIO_PIN5_WAKEUP_ENABLE_MASK             0x00000400
+#define GPIO_PIN5_WAKEUP_ENABLE_GET(x)           (((x) & GPIO_PIN5_WAKEUP_ENABLE_MASK) >> GPIO_PIN5_WAKEUP_ENABLE_LSB)
+#define GPIO_PIN5_WAKEUP_ENABLE_SET(x)           (((x) << GPIO_PIN5_WAKEUP_ENABLE_LSB) & GPIO_PIN5_WAKEUP_ENABLE_MASK)
+#define GPIO_PIN5_INT_TYPE_MSB                   9
+#define GPIO_PIN5_INT_TYPE_LSB                   7
+#define GPIO_PIN5_INT_TYPE_MASK                  0x00000380
+#define GPIO_PIN5_INT_TYPE_GET(x)                (((x) & GPIO_PIN5_INT_TYPE_MASK) >> GPIO_PIN5_INT_TYPE_LSB)
+#define GPIO_PIN5_INT_TYPE_SET(x)                (((x) << GPIO_PIN5_INT_TYPE_LSB) & GPIO_PIN5_INT_TYPE_MASK)
+#define GPIO_PIN5_PAD_DRIVER_MSB                 2
+#define GPIO_PIN5_PAD_DRIVER_LSB                 2
+#define GPIO_PIN5_PAD_DRIVER_MASK                0x00000004
+#define GPIO_PIN5_PAD_DRIVER_GET(x)              (((x) & GPIO_PIN5_PAD_DRIVER_MASK) >> GPIO_PIN5_PAD_DRIVER_LSB)
+#define GPIO_PIN5_PAD_DRIVER_SET(x)              (((x) << GPIO_PIN5_PAD_DRIVER_LSB) & GPIO_PIN5_PAD_DRIVER_MASK)
+#define GPIO_PIN5_SOURCE_MSB                     0
+#define GPIO_PIN5_SOURCE_LSB                     0
+#define GPIO_PIN5_SOURCE_MASK                    0x00000001
+#define GPIO_PIN5_SOURCE_GET(x)                  (((x) & GPIO_PIN5_SOURCE_MASK) >> GPIO_PIN5_SOURCE_LSB)
+#define GPIO_PIN5_SOURCE_SET(x)                  (((x) << GPIO_PIN5_SOURCE_LSB) & GPIO_PIN5_SOURCE_MASK)
+
+#define GPIO_PIN6_ADDRESS                        0x00000040
+#define GPIO_PIN6_OFFSET                         0x00000040
+#define GPIO_PIN6_CONFIG_MSB                     12
+#define GPIO_PIN6_CONFIG_LSB                     11
+#define GPIO_PIN6_CONFIG_MASK                    0x00001800
+#define GPIO_PIN6_CONFIG_GET(x)                  (((x) & GPIO_PIN6_CONFIG_MASK) >> GPIO_PIN6_CONFIG_LSB)
+#define GPIO_PIN6_CONFIG_SET(x)                  (((x) << GPIO_PIN6_CONFIG_LSB) & GPIO_PIN6_CONFIG_MASK)
+#define GPIO_PIN6_WAKEUP_ENABLE_MSB              10
+#define GPIO_PIN6_WAKEUP_ENABLE_LSB              10
+#define GPIO_PIN6_WAKEUP_ENABLE_MASK             0x00000400
+#define GPIO_PIN6_WAKEUP_ENABLE_GET(x)           (((x) & GPIO_PIN6_WAKEUP_ENABLE_MASK) >> GPIO_PIN6_WAKEUP_ENABLE_LSB)
+#define GPIO_PIN6_WAKEUP_ENABLE_SET(x)           (((x) << GPIO_PIN6_WAKEUP_ENABLE_LSB) & GPIO_PIN6_WAKEUP_ENABLE_MASK)
+#define GPIO_PIN6_INT_TYPE_MSB                   9
+#define GPIO_PIN6_INT_TYPE_LSB                   7
+#define GPIO_PIN6_INT_TYPE_MASK                  0x00000380
+#define GPIO_PIN6_INT_TYPE_GET(x)                (((x) & GPIO_PIN6_INT_TYPE_MASK) >> GPIO_PIN6_INT_TYPE_LSB)
+#define GPIO_PIN6_INT_TYPE_SET(x)                (((x) << GPIO_PIN6_INT_TYPE_LSB) & GPIO_PIN6_INT_TYPE_MASK)
+#define GPIO_PIN6_PAD_DRIVER_MSB                 2
+#define GPIO_PIN6_PAD_DRIVER_LSB                 2
+#define GPIO_PIN6_PAD_DRIVER_MASK                0x00000004
+#define GPIO_PIN6_PAD_DRIVER_GET(x)              (((x) & GPIO_PIN6_PAD_DRIVER_MASK) >> GPIO_PIN6_PAD_DRIVER_LSB)
+#define GPIO_PIN6_PAD_DRIVER_SET(x)              (((x) << GPIO_PIN6_PAD_DRIVER_LSB) & GPIO_PIN6_PAD_DRIVER_MASK)
+#define GPIO_PIN6_SOURCE_MSB                     0
+#define GPIO_PIN6_SOURCE_LSB                     0
+#define GPIO_PIN6_SOURCE_MASK                    0x00000001
+#define GPIO_PIN6_SOURCE_GET(x)                  (((x) & GPIO_PIN6_SOURCE_MASK) >> GPIO_PIN6_SOURCE_LSB)
+#define GPIO_PIN6_SOURCE_SET(x)                  (((x) << GPIO_PIN6_SOURCE_LSB) & GPIO_PIN6_SOURCE_MASK)
+
+#define GPIO_PIN7_ADDRESS                        0x00000044
+#define GPIO_PIN7_OFFSET                         0x00000044
+#define GPIO_PIN7_CONFIG_MSB                     12
+#define GPIO_PIN7_CONFIG_LSB                     11
+#define GPIO_PIN7_CONFIG_MASK                    0x00001800
+#define GPIO_PIN7_CONFIG_GET(x)                  (((x) & GPIO_PIN7_CONFIG_MASK) >> GPIO_PIN7_CONFIG_LSB)
+#define GPIO_PIN7_CONFIG_SET(x)                  (((x) << GPIO_PIN7_CONFIG_LSB) & GPIO_PIN7_CONFIG_MASK)
+#define GPIO_PIN7_WAKEUP_ENABLE_MSB              10
+#define GPIO_PIN7_WAKEUP_ENABLE_LSB              10
+#define GPIO_PIN7_WAKEUP_ENABLE_MASK             0x00000400
+#define GPIO_PIN7_WAKEUP_ENABLE_GET(x)           (((x) & GPIO_PIN7_WAKEUP_ENABLE_MASK) >> GPIO_PIN7_WAKEUP_ENABLE_LSB)
+#define GPIO_PIN7_WAKEUP_ENABLE_SET(x)           (((x) << GPIO_PIN7_WAKEUP_ENABLE_LSB) & GPIO_PIN7_WAKEUP_ENABLE_MASK)
+#define GPIO_PIN7_INT_TYPE_MSB                   9
+#define GPIO_PIN7_INT_TYPE_LSB                   7
+#define GPIO_PIN7_INT_TYPE_MASK                  0x00000380
+#define GPIO_PIN7_INT_TYPE_GET(x)                (((x) & GPIO_PIN7_INT_TYPE_MASK) >> GPIO_PIN7_INT_TYPE_LSB)
+#define GPIO_PIN7_INT_TYPE_SET(x)                (((x) << GPIO_PIN7_INT_TYPE_LSB) & GPIO_PIN7_INT_TYPE_MASK)
+#define GPIO_PIN7_PAD_DRIVER_MSB                 2
+#define GPIO_PIN7_PAD_DRIVER_LSB                 2
+#define GPIO_PIN7_PAD_DRIVER_MASK                0x00000004
+#define GPIO_PIN7_PAD_DRIVER_GET(x)              (((x) & GPIO_PIN7_PAD_DRIVER_MASK) >> GPIO_PIN7_PAD_DRIVER_LSB)
+#define GPIO_PIN7_PAD_DRIVER_SET(x)              (((x) << GPIO_PIN7_PAD_DRIVER_LSB) & GPIO_PIN7_PAD_DRIVER_MASK)
+#define GPIO_PIN7_SOURCE_MSB                     0
+#define GPIO_PIN7_SOURCE_LSB                     0
+#define GPIO_PIN7_SOURCE_MASK                    0x00000001
+#define GPIO_PIN7_SOURCE_GET(x)                  (((x) & GPIO_PIN7_SOURCE_MASK) >> GPIO_PIN7_SOURCE_LSB)
+#define GPIO_PIN7_SOURCE_SET(x)                  (((x) << GPIO_PIN7_SOURCE_LSB) & GPIO_PIN7_SOURCE_MASK)
+
+#define GPIO_PIN8_ADDRESS                        0x00000048
+#define GPIO_PIN8_OFFSET                         0x00000048
+#define GPIO_PIN8_CONFIG_MSB                     12
+#define GPIO_PIN8_CONFIG_LSB                     11
+#define GPIO_PIN8_CONFIG_MASK                    0x00001800
+#define GPIO_PIN8_CONFIG_GET(x)                  (((x) & GPIO_PIN8_CONFIG_MASK) >> GPIO_PIN8_CONFIG_LSB)
+#define GPIO_PIN8_CONFIG_SET(x)                  (((x) << GPIO_PIN8_CONFIG_LSB) & GPIO_PIN8_CONFIG_MASK)
+#define GPIO_PIN8_WAKEUP_ENABLE_MSB              10
+#define GPIO_PIN8_WAKEUP_ENABLE_LSB              10
+#define GPIO_PIN8_WAKEUP_ENABLE_MASK             0x00000400
+#define GPIO_PIN8_WAKEUP_ENABLE_GET(x)           (((x) & GPIO_PIN8_WAKEUP_ENABLE_MASK) >> GPIO_PIN8_WAKEUP_ENABLE_LSB)
+#define GPIO_PIN8_WAKEUP_ENABLE_SET(x)           (((x) << GPIO_PIN8_WAKEUP_ENABLE_LSB) & GPIO_PIN8_WAKEUP_ENABLE_MASK)
+#define GPIO_PIN8_INT_TYPE_MSB                   9
+#define GPIO_PIN8_INT_TYPE_LSB                   7
+#define GPIO_PIN8_INT_TYPE_MASK                  0x00000380
+#define GPIO_PIN8_INT_TYPE_GET(x)                (((x) & GPIO_PIN8_INT_TYPE_MASK) >> GPIO_PIN8_INT_TYPE_LSB)
+#define GPIO_PIN8_INT_TYPE_SET(x)                (((x) << GPIO_PIN8_INT_TYPE_LSB) & GPIO_PIN8_INT_TYPE_MASK)
+#define GPIO_PIN8_PAD_DRIVER_MSB                 2
+#define GPIO_PIN8_PAD_DRIVER_LSB                 2
+#define GPIO_PIN8_PAD_DRIVER_MASK                0x00000004
+#define GPIO_PIN8_PAD_DRIVER_GET(x)              (((x) & GPIO_PIN8_PAD_DRIVER_MASK) >> GPIO_PIN8_PAD_DRIVER_LSB)
+#define GPIO_PIN8_PAD_DRIVER_SET(x)              (((x) << GPIO_PIN8_PAD_DRIVER_LSB) & GPIO_PIN8_PAD_DRIVER_MASK)
+#define GPIO_PIN8_SOURCE_MSB                     0
+#define GPIO_PIN8_SOURCE_LSB                     0
+#define GPIO_PIN8_SOURCE_MASK                    0x00000001
+#define GPIO_PIN8_SOURCE_GET(x)                  (((x) & GPIO_PIN8_SOURCE_MASK) >> GPIO_PIN8_SOURCE_LSB)
+#define GPIO_PIN8_SOURCE_SET(x)                  (((x) << GPIO_PIN8_SOURCE_LSB) & GPIO_PIN8_SOURCE_MASK)
+
+#define GPIO_PIN9_ADDRESS                        0x0000004c
+#define GPIO_PIN9_OFFSET                         0x0000004c
+#define GPIO_PIN9_CONFIG_MSB                     12
+#define GPIO_PIN9_CONFIG_LSB                     11
+#define GPIO_PIN9_CONFIG_MASK                    0x00001800
+#define GPIO_PIN9_CONFIG_GET(x)                  (((x) & GPIO_PIN9_CONFIG_MASK) >> GPIO_PIN9_CONFIG_LSB)
+#define GPIO_PIN9_CONFIG_SET(x)                  (((x) << GPIO_PIN9_CONFIG_LSB) & GPIO_PIN9_CONFIG_MASK)
+#define GPIO_PIN9_WAKEUP_ENABLE_MSB              10
+#define GPIO_PIN9_WAKEUP_ENABLE_LSB              10
+#define GPIO_PIN9_WAKEUP_ENABLE_MASK             0x00000400
+#define GPIO_PIN9_WAKEUP_ENABLE_GET(x)           (((x) & GPIO_PIN9_WAKEUP_ENABLE_MASK) >> GPIO_PIN9_WAKEUP_ENABLE_LSB)
+#define GPIO_PIN9_WAKEUP_ENABLE_SET(x)           (((x) << GPIO_PIN9_WAKEUP_ENABLE_LSB) & GPIO_PIN9_WAKEUP_ENABLE_MASK)
+#define GPIO_PIN9_INT_TYPE_MSB                   9
+#define GPIO_PIN9_INT_TYPE_LSB                   7
+#define GPIO_PIN9_INT_TYPE_MASK                  0x00000380
+#define GPIO_PIN9_INT_TYPE_GET(x)                (((x) & GPIO_PIN9_INT_TYPE_MASK) >> GPIO_PIN9_INT_TYPE_LSB)
+#define GPIO_PIN9_INT_TYPE_SET(x)                (((x) << GPIO_PIN9_INT_TYPE_LSB) & GPIO_PIN9_INT_TYPE_MASK)
+#define GPIO_PIN9_PAD_DRIVER_MSB                 2
+#define GPIO_PIN9_PAD_DRIVER_LSB                 2
+#define GPIO_PIN9_PAD_DRIVER_MASK                0x00000004
+#define GPIO_PIN9_PAD_DRIVER_GET(x)              (((x) & GPIO_PIN9_PAD_DRIVER_MASK) >> GPIO_PIN9_PAD_DRIVER_LSB)
+#define GPIO_PIN9_PAD_DRIVER_SET(x)              (((x) << GPIO_PIN9_PAD_DRIVER_LSB) & GPIO_PIN9_PAD_DRIVER_MASK)
+#define GPIO_PIN9_SOURCE_MSB                     0
+#define GPIO_PIN9_SOURCE_LSB                     0
+#define GPIO_PIN9_SOURCE_MASK                    0x00000001
+#define GPIO_PIN9_SOURCE_GET(x)                  (((x) & GPIO_PIN9_SOURCE_MASK) >> GPIO_PIN9_SOURCE_LSB)
+#define GPIO_PIN9_SOURCE_SET(x)                  (((x) << GPIO_PIN9_SOURCE_LSB) & GPIO_PIN9_SOURCE_MASK)
+
+#define GPIO_PIN10_ADDRESS                       0x00000050
+#define GPIO_PIN10_OFFSET                        0x00000050
+#define GPIO_PIN10_CONFIG_MSB                    12
+#define GPIO_PIN10_CONFIG_LSB                    11
+#define GPIO_PIN10_CONFIG_MASK                   0x00001800
+#define GPIO_PIN10_CONFIG_GET(x)                 (((x) & GPIO_PIN10_CONFIG_MASK) >> GPIO_PIN10_CONFIG_LSB)
+#define GPIO_PIN10_CONFIG_SET(x)                 (((x) << GPIO_PIN10_CONFIG_LSB) & GPIO_PIN10_CONFIG_MASK)
+#define GPIO_PIN10_WAKEUP_ENABLE_MSB             10
+#define GPIO_PIN10_WAKEUP_ENABLE_LSB             10
+#define GPIO_PIN10_WAKEUP_ENABLE_MASK            0x00000400
+#define GPIO_PIN10_WAKEUP_ENABLE_GET(x)          (((x) & GPIO_PIN10_WAKEUP_ENABLE_MASK) >> GPIO_PIN10_WAKEUP_ENABLE_LSB)
+#define GPIO_PIN10_WAKEUP_ENABLE_SET(x)          (((x) << GPIO_PIN10_WAKEUP_ENABLE_LSB) & GPIO_PIN10_WAKEUP_ENABLE_MASK)
+#define GPIO_PIN10_INT_TYPE_MSB                  9
+#define GPIO_PIN10_INT_TYPE_LSB                  7
+#define GPIO_PIN10_INT_TYPE_MASK                 0x00000380
+#define GPIO_PIN10_INT_TYPE_GET(x)               (((x) & GPIO_PIN10_INT_TYPE_MASK) >> GPIO_PIN10_INT_TYPE_LSB)
+#define GPIO_PIN10_INT_TYPE_SET(x)               (((x) << GPIO_PIN10_INT_TYPE_LSB) & GPIO_PIN10_INT_TYPE_MASK)
+#define GPIO_PIN10_PAD_DRIVER_MSB                2
+#define GPIO_PIN10_PAD_DRIVER_LSB                2
+#define GPIO_PIN10_PAD_DRIVER_MASK               0x00000004
+#define GPIO_PIN10_PAD_DRIVER_GET(x)             (((x) & GPIO_PIN10_PAD_DRIVER_MASK) >> GPIO_PIN10_PAD_DRIVER_LSB)
+#define GPIO_PIN10_PAD_DRIVER_SET(x)             (((x) << GPIO_PIN10_PAD_DRIVER_LSB) & GPIO_PIN10_PAD_DRIVER_MASK)
+#define GPIO_PIN10_SOURCE_MSB                    0
+#define GPIO_PIN10_SOURCE_LSB                    0
+#define GPIO_PIN10_SOURCE_MASK                   0x00000001
+#define GPIO_PIN10_SOURCE_GET(x)                 (((x) & GPIO_PIN10_SOURCE_MASK) >> GPIO_PIN10_SOURCE_LSB)
+#define GPIO_PIN10_SOURCE_SET(x)                 (((x) << GPIO_PIN10_SOURCE_LSB) & GPIO_PIN10_SOURCE_MASK)
+
+#define GPIO_PIN11_ADDRESS                       0x00000054
+#define GPIO_PIN11_OFFSET                        0x00000054
+#define GPIO_PIN11_CONFIG_MSB                    12
+#define GPIO_PIN11_CONFIG_LSB                    11
+#define GPIO_PIN11_CONFIG_MASK                   0x00001800
+#define GPIO_PIN11_CONFIG_GET(x)                 (((x) & GPIO_PIN11_CONFIG_MASK) >> GPIO_PIN11_CONFIG_LSB)
+#define GPIO_PIN11_CONFIG_SET(x)                 (((x) << GPIO_PIN11_CONFIG_LSB) & GPIO_PIN11_CONFIG_MASK)
+#define GPIO_PIN11_WAKEUP_ENABLE_MSB             10
+#define GPIO_PIN11_WAKEUP_ENABLE_LSB             10
+#define GPIO_PIN11_WAKEUP_ENABLE_MASK            0x00000400
+#define GPIO_PIN11_WAKEUP_ENABLE_GET(x)          (((x) & GPIO_PIN11_WAKEUP_ENABLE_MASK) >> GPIO_PIN11_WAKEUP_ENABLE_LSB)
+#define GPIO_PIN11_WAKEUP_ENABLE_SET(x)          (((x) << GPIO_PIN11_WAKEUP_ENABLE_LSB) & GPIO_PIN11_WAKEUP_ENABLE_MASK)
+#define GPIO_PIN11_INT_TYPE_MSB                  9
+#define GPIO_PIN11_INT_TYPE_LSB                  7
+#define GPIO_PIN11_INT_TYPE_MASK                 0x00000380
+#define GPIO_PIN11_INT_TYPE_GET(x)               (((x) & GPIO_PIN11_INT_TYPE_MASK) >> GPIO_PIN11_INT_TYPE_LSB)
+#define GPIO_PIN11_INT_TYPE_SET(x)               (((x) << GPIO_PIN11_INT_TYPE_LSB) & GPIO_PIN11_INT_TYPE_MASK)
+#define GPIO_PIN11_PAD_DRIVER_MSB                2
+#define GPIO_PIN11_PAD_DRIVER_LSB                2
+#define GPIO_PIN11_PAD_DRIVER_MASK               0x00000004
+#define GPIO_PIN11_PAD_DRIVER_GET(x)             (((x) & GPIO_PIN11_PAD_DRIVER_MASK) >> GPIO_PIN11_PAD_DRIVER_LSB)
+#define GPIO_PIN11_PAD_DRIVER_SET(x)             (((x) << GPIO_PIN11_PAD_DRIVER_LSB) & GPIO_PIN11_PAD_DRIVER_MASK)
+#define GPIO_PIN11_SOURCE_MSB                    0
+#define GPIO_PIN11_SOURCE_LSB                    0
+#define GPIO_PIN11_SOURCE_MASK                   0x00000001
+#define GPIO_PIN11_SOURCE_GET(x)                 (((x) & GPIO_PIN11_SOURCE_MASK) >> GPIO_PIN11_SOURCE_LSB)
+#define GPIO_PIN11_SOURCE_SET(x)                 (((x) << GPIO_PIN11_SOURCE_LSB) & GPIO_PIN11_SOURCE_MASK)
+
+#define GPIO_PIN12_ADDRESS                       0x00000058
+#define GPIO_PIN12_OFFSET                        0x00000058
+#define GPIO_PIN12_CONFIG_MSB                    12
+#define GPIO_PIN12_CONFIG_LSB                    11
+#define GPIO_PIN12_CONFIG_MASK                   0x00001800
+#define GPIO_PIN12_CONFIG_GET(x)                 (((x) & GPIO_PIN12_CONFIG_MASK) >> GPIO_PIN12_CONFIG_LSB)
+#define GPIO_PIN12_CONFIG_SET(x)                 (((x) << GPIO_PIN12_CONFIG_LSB) & GPIO_PIN12_CONFIG_MASK)
+#define GPIO_PIN12_WAKEUP_ENABLE_MSB             10
+#define GPIO_PIN12_WAKEUP_ENABLE_LSB             10
+#define GPIO_PIN12_WAKEUP_ENABLE_MASK            0x00000400
+#define GPIO_PIN12_WAKEUP_ENABLE_GET(x)          (((x) & GPIO_PIN12_WAKEUP_ENABLE_MASK) >> GPIO_PIN12_WAKEUP_ENABLE_LSB)
+#define GPIO_PIN12_WAKEUP_ENABLE_SET(x)          (((x) << GPIO_PIN12_WAKEUP_ENABLE_LSB) & GPIO_PIN12_WAKEUP_ENABLE_MASK)
+#define GPIO_PIN12_INT_TYPE_MSB                  9
+#define GPIO_PIN12_INT_TYPE_LSB                  7
+#define GPIO_PIN12_INT_TYPE_MASK                 0x00000380
+#define GPIO_PIN12_INT_TYPE_GET(x)               (((x) & GPIO_PIN12_INT_TYPE_MASK) >> GPIO_PIN12_INT_TYPE_LSB)
+#define GPIO_PIN12_INT_TYPE_SET(x)               (((x) << GPIO_PIN12_INT_TYPE_LSB) & GPIO_PIN12_INT_TYPE_MASK)
+#define GPIO_PIN12_PAD_DRIVER_MSB                2
+#define GPIO_PIN12_PAD_DRIVER_LSB                2
+#define GPIO_PIN12_PAD_DRIVER_MASK               0x00000004
+#define GPIO_PIN12_PAD_DRIVER_GET(x)             (((x) & GPIO_PIN12_PAD_DRIVER_MASK) >> GPIO_PIN12_PAD_DRIVER_LSB)
+#define GPIO_PIN12_PAD_DRIVER_SET(x)             (((x) << GPIO_PIN12_PAD_DRIVER_LSB) & GPIO_PIN12_PAD_DRIVER_MASK)
+#define GPIO_PIN12_SOURCE_MSB                    0
+#define GPIO_PIN12_SOURCE_LSB                    0
+#define GPIO_PIN12_SOURCE_MASK                   0x00000001
+#define GPIO_PIN12_SOURCE_GET(x)                 (((x) & GPIO_PIN12_SOURCE_MASK) >> GPIO_PIN12_SOURCE_LSB)
+#define GPIO_PIN12_SOURCE_SET(x)                 (((x) << GPIO_PIN12_SOURCE_LSB) & GPIO_PIN12_SOURCE_MASK)
+
+#define GPIO_PIN13_ADDRESS                       0x0000005c
+#define GPIO_PIN13_OFFSET                        0x0000005c
+#define GPIO_PIN13_CONFIG_MSB                    12
+#define GPIO_PIN13_CONFIG_LSB                    11
+#define GPIO_PIN13_CONFIG_MASK                   0x00001800
+#define GPIO_PIN13_CONFIG_GET(x)                 (((x) & GPIO_PIN13_CONFIG_MASK) >> GPIO_PIN13_CONFIG_LSB)
+#define GPIO_PIN13_CONFIG_SET(x)                 (((x) << GPIO_PIN13_CONFIG_LSB) & GPIO_PIN13_CONFIG_MASK)
+#define GPIO_PIN13_WAKEUP_ENABLE_MSB             10
+#define GPIO_PIN13_WAKEUP_ENABLE_LSB             10
+#define GPIO_PIN13_WAKEUP_ENABLE_MASK            0x00000400
+#define GPIO_PIN13_WAKEUP_ENABLE_GET(x)          (((x) & GPIO_PIN13_WAKEUP_ENABLE_MASK) >> GPIO_PIN13_WAKEUP_ENABLE_LSB)
+#define GPIO_PIN13_WAKEUP_ENABLE_SET(x)          (((x) << GPIO_PIN13_WAKEUP_ENABLE_LSB) & GPIO_PIN13_WAKEUP_ENABLE_MASK)
+#define GPIO_PIN13_INT_TYPE_MSB                  9
+#define GPIO_PIN13_INT_TYPE_LSB                  7
+#define GPIO_PIN13_INT_TYPE_MASK                 0x00000380
+#define GPIO_PIN13_INT_TYPE_GET(x)               (((x) & GPIO_PIN13_INT_TYPE_MASK) >> GPIO_PIN13_INT_TYPE_LSB)
+#define GPIO_PIN13_INT_TYPE_SET(x)               (((x) << GPIO_PIN13_INT_TYPE_LSB) & GPIO_PIN13_INT_TYPE_MASK)
+#define GPIO_PIN13_PAD_DRIVER_MSB                2
+#define GPIO_PIN13_PAD_DRIVER_LSB                2
+#define GPIO_PIN13_PAD_DRIVER_MASK               0x00000004
+#define GPIO_PIN13_PAD_DRIVER_GET(x)             (((x) & GPIO_PIN13_PAD_DRIVER_MASK) >> GPIO_PIN13_PAD_DRIVER_LSB)
+#define GPIO_PIN13_PAD_DRIVER_SET(x)             (((x) << GPIO_PIN13_PAD_DRIVER_LSB) & GPIO_PIN13_PAD_DRIVER_MASK)
+#define GPIO_PIN13_SOURCE_MSB                    0
+#define GPIO_PIN13_SOURCE_LSB                    0
+#define GPIO_PIN13_SOURCE_MASK                   0x00000001
+#define GPIO_PIN13_SOURCE_GET(x)                 (((x) & GPIO_PIN13_SOURCE_MASK) >> GPIO_PIN13_SOURCE_LSB)
+#define GPIO_PIN13_SOURCE_SET(x)                 (((x) << GPIO_PIN13_SOURCE_LSB) & GPIO_PIN13_SOURCE_MASK)
+
+#define GPIO_PIN14_ADDRESS                       0x00000060
+#define GPIO_PIN14_OFFSET                        0x00000060
+#define GPIO_PIN14_CONFIG_MSB                    12
+#define GPIO_PIN14_CONFIG_LSB                    11
+#define GPIO_PIN14_CONFIG_MASK                   0x00001800
+#define GPIO_PIN14_CONFIG_GET(x)                 (((x) & GPIO_PIN14_CONFIG_MASK) >> GPIO_PIN14_CONFIG_LSB)
+#define GPIO_PIN14_CONFIG_SET(x)                 (((x) << GPIO_PIN14_CONFIG_LSB) & GPIO_PIN14_CONFIG_MASK)
+#define GPIO_PIN14_WAKEUP_ENABLE_MSB             10
+#define GPIO_PIN14_WAKEUP_ENABLE_LSB             10
+#define GPIO_PIN14_WAKEUP_ENABLE_MASK            0x00000400
+#define GPIO_PIN14_WAKEUP_ENABLE_GET(x)          (((x) & GPIO_PIN14_WAKEUP_ENABLE_MASK) >> GPIO_PIN14_WAKEUP_ENABLE_LSB)
+#define GPIO_PIN14_WAKEUP_ENABLE_SET(x)          (((x) << GPIO_PIN14_WAKEUP_ENABLE_LSB) & GPIO_PIN14_WAKEUP_ENABLE_MASK)
+#define GPIO_PIN14_INT_TYPE_MSB                  9
+#define GPIO_PIN14_INT_TYPE_LSB                  7
+#define GPIO_PIN14_INT_TYPE_MASK                 0x00000380
+#define GPIO_PIN14_INT_TYPE_GET(x)               (((x) & GPIO_PIN14_INT_TYPE_MASK) >> GPIO_PIN14_INT_TYPE_LSB)
+#define GPIO_PIN14_INT_TYPE_SET(x)               (((x) << GPIO_PIN14_INT_TYPE_LSB) & GPIO_PIN14_INT_TYPE_MASK)
+#define GPIO_PIN14_PAD_DRIVER_MSB                2
+#define GPIO_PIN14_PAD_DRIVER_LSB                2
+#define GPIO_PIN14_PAD_DRIVER_MASK               0x00000004
+#define GPIO_PIN14_PAD_DRIVER_GET(x)             (((x) & GPIO_PIN14_PAD_DRIVER_MASK) >> GPIO_PIN14_PAD_DRIVER_LSB)
+#define GPIO_PIN14_PAD_DRIVER_SET(x)             (((x) << GPIO_PIN14_PAD_DRIVER_LSB) & GPIO_PIN14_PAD_DRIVER_MASK)
+#define GPIO_PIN14_SOURCE_MSB                    0
+#define GPIO_PIN14_SOURCE_LSB                    0
+#define GPIO_PIN14_SOURCE_MASK                   0x00000001
+#define GPIO_PIN14_SOURCE_GET(x)                 (((x) & GPIO_PIN14_SOURCE_MASK) >> GPIO_PIN14_SOURCE_LSB)
+#define GPIO_PIN14_SOURCE_SET(x)                 (((x) << GPIO_PIN14_SOURCE_LSB) & GPIO_PIN14_SOURCE_MASK)
+
+#define GPIO_PIN15_ADDRESS                       0x00000064
+#define GPIO_PIN15_OFFSET                        0x00000064
+#define GPIO_PIN15_CONFIG_MSB                    12
+#define GPIO_PIN15_CONFIG_LSB                    11
+#define GPIO_PIN15_CONFIG_MASK                   0x00001800
+#define GPIO_PIN15_CONFIG_GET(x)                 (((x) & GPIO_PIN15_CONFIG_MASK) >> GPIO_PIN15_CONFIG_LSB)
+#define GPIO_PIN15_CONFIG_SET(x)                 (((x) << GPIO_PIN15_CONFIG_LSB) & GPIO_PIN15_CONFIG_MASK)
+#define GPIO_PIN15_WAKEUP_ENABLE_MSB             10
+#define GPIO_PIN15_WAKEUP_ENABLE_LSB             10
+#define GPIO_PIN15_WAKEUP_ENABLE_MASK            0x00000400
+#define GPIO_PIN15_WAKEUP_ENABLE_GET(x)          (((x) & GPIO_PIN15_WAKEUP_ENABLE_MASK) >> GPIO_PIN15_WAKEUP_ENABLE_LSB)
+#define GPIO_PIN15_WAKEUP_ENABLE_SET(x)          (((x) << GPIO_PIN15_WAKEUP_ENABLE_LSB) & GPIO_PIN15_WAKEUP_ENABLE_MASK)
+#define GPIO_PIN15_INT_TYPE_MSB                  9
+#define GPIO_PIN15_INT_TYPE_LSB                  7
+#define GPIO_PIN15_INT_TYPE_MASK                 0x00000380
+#define GPIO_PIN15_INT_TYPE_GET(x)               (((x) & GPIO_PIN15_INT_TYPE_MASK) >> GPIO_PIN15_INT_TYPE_LSB)
+#define GPIO_PIN15_INT_TYPE_SET(x)               (((x) << GPIO_PIN15_INT_TYPE_LSB) & GPIO_PIN15_INT_TYPE_MASK)
+#define GPIO_PIN15_PAD_DRIVER_MSB                2
+#define GPIO_PIN15_PAD_DRIVER_LSB                2
+#define GPIO_PIN15_PAD_DRIVER_MASK               0x00000004
+#define GPIO_PIN15_PAD_DRIVER_GET(x)             (((x) & GPIO_PIN15_PAD_DRIVER_MASK) >> GPIO_PIN15_PAD_DRIVER_LSB)
+#define GPIO_PIN15_PAD_DRIVER_SET(x)             (((x) << GPIO_PIN15_PAD_DRIVER_LSB) & GPIO_PIN15_PAD_DRIVER_MASK)
+#define GPIO_PIN15_SOURCE_MSB                    0
+#define GPIO_PIN15_SOURCE_LSB                    0
+#define GPIO_PIN15_SOURCE_MASK                   0x00000001
+#define GPIO_PIN15_SOURCE_GET(x)                 (((x) & GPIO_PIN15_SOURCE_MASK) >> GPIO_PIN15_SOURCE_LSB)
+#define GPIO_PIN15_SOURCE_SET(x)                 (((x) << GPIO_PIN15_SOURCE_LSB) & GPIO_PIN15_SOURCE_MASK)
+
+#define GPIO_PIN16_ADDRESS                       0x00000068
+#define GPIO_PIN16_OFFSET                        0x00000068
+#define GPIO_PIN16_CONFIG_MSB                    12
+#define GPIO_PIN16_CONFIG_LSB                    11
+#define GPIO_PIN16_CONFIG_MASK                   0x00001800
+#define GPIO_PIN16_CONFIG_GET(x)                 (((x) & GPIO_PIN16_CONFIG_MASK) >> GPIO_PIN16_CONFIG_LSB)
+#define GPIO_PIN16_CONFIG_SET(x)                 (((x) << GPIO_PIN16_CONFIG_LSB) & GPIO_PIN16_CONFIG_MASK)
+#define GPIO_PIN16_WAKEUP_ENABLE_MSB             10
+#define GPIO_PIN16_WAKEUP_ENABLE_LSB             10
+#define GPIO_PIN16_WAKEUP_ENABLE_MASK            0x00000400
+#define GPIO_PIN16_WAKEUP_ENABLE_GET(x)          (((x) & GPIO_PIN16_WAKEUP_ENABLE_MASK) >> GPIO_PIN16_WAKEUP_ENABLE_LSB)
+#define GPIO_PIN16_WAKEUP_ENABLE_SET(x)          (((x) << GPIO_PIN16_WAKEUP_ENABLE_LSB) & GPIO_PIN16_WAKEUP_ENABLE_MASK)
+#define GPIO_PIN16_INT_TYPE_MSB                  9
+#define GPIO_PIN16_INT_TYPE_LSB                  7
+#define GPIO_PIN16_INT_TYPE_MASK                 0x00000380
+#define GPIO_PIN16_INT_TYPE_GET(x)               (((x) & GPIO_PIN16_INT_TYPE_MASK) >> GPIO_PIN16_INT_TYPE_LSB)
+#define GPIO_PIN16_INT_TYPE_SET(x)               (((x) << GPIO_PIN16_INT_TYPE_LSB) & GPIO_PIN16_INT_TYPE_MASK)
+#define GPIO_PIN16_PAD_DRIVER_MSB                2
+#define GPIO_PIN16_PAD_DRIVER_LSB                2
+#define GPIO_PIN16_PAD_DRIVER_MASK               0x00000004
+#define GPIO_PIN16_PAD_DRIVER_GET(x)             (((x) & GPIO_PIN16_PAD_DRIVER_MASK) >> GPIO_PIN16_PAD_DRIVER_LSB)
+#define GPIO_PIN16_PAD_DRIVER_SET(x)             (((x) << GPIO_PIN16_PAD_DRIVER_LSB) & GPIO_PIN16_PAD_DRIVER_MASK)
+#define GPIO_PIN16_SOURCE_MSB                    0
+#define GPIO_PIN16_SOURCE_LSB                    0
+#define GPIO_PIN16_SOURCE_MASK                   0x00000001
+#define GPIO_PIN16_SOURCE_GET(x)                 (((x) & GPIO_PIN16_SOURCE_MASK) >> GPIO_PIN16_SOURCE_LSB)
+#define GPIO_PIN16_SOURCE_SET(x)                 (((x) << GPIO_PIN16_SOURCE_LSB) & GPIO_PIN16_SOURCE_MASK)
+
+#define GPIO_PIN17_ADDRESS                       0x0000006c
+#define GPIO_PIN17_OFFSET                        0x0000006c
+#define GPIO_PIN17_CONFIG_MSB                    12
+#define GPIO_PIN17_CONFIG_LSB                    11
+#define GPIO_PIN17_CONFIG_MASK                   0x00001800
+#define GPIO_PIN17_CONFIG_GET(x)                 (((x) & GPIO_PIN17_CONFIG_MASK) >> GPIO_PIN17_CONFIG_LSB)
+#define GPIO_PIN17_CONFIG_SET(x)                 (((x) << GPIO_PIN17_CONFIG_LSB) & GPIO_PIN17_CONFIG_MASK)
+#define GPIO_PIN17_WAKEUP_ENABLE_MSB             10
+#define GPIO_PIN17_WAKEUP_ENABLE_LSB             10
+#define GPIO_PIN17_WAKEUP_ENABLE_MASK            0x00000400
+#define GPIO_PIN17_WAKEUP_ENABLE_GET(x)          (((x) & GPIO_PIN17_WAKEUP_ENABLE_MASK) >> GPIO_PIN17_WAKEUP_ENABLE_LSB)
+#define GPIO_PIN17_WAKEUP_ENABLE_SET(x)          (((x) << GPIO_PIN17_WAKEUP_ENABLE_LSB) & GPIO_PIN17_WAKEUP_ENABLE_MASK)
+#define GPIO_PIN17_INT_TYPE_MSB                  9
+#define GPIO_PIN17_INT_TYPE_LSB                  7
+#define GPIO_PIN17_INT_TYPE_MASK                 0x00000380
+#define GPIO_PIN17_INT_TYPE_GET(x)               (((x) & GPIO_PIN17_INT_TYPE_MASK) >> GPIO_PIN17_INT_TYPE_LSB)
+#define GPIO_PIN17_INT_TYPE_SET(x)               (((x) << GPIO_PIN17_INT_TYPE_LSB) & GPIO_PIN17_INT_TYPE_MASK)
+#define GPIO_PIN17_PAD_DRIVER_MSB                2
+#define GPIO_PIN17_PAD_DRIVER_LSB                2
+#define GPIO_PIN17_PAD_DRIVER_MASK               0x00000004
+#define GPIO_PIN17_PAD_DRIVER_GET(x)             (((x) & GPIO_PIN17_PAD_DRIVER_MASK) >> GPIO_PIN17_PAD_DRIVER_LSB)
+#define GPIO_PIN17_PAD_DRIVER_SET(x)             (((x) << GPIO_PIN17_PAD_DRIVER_LSB) & GPIO_PIN17_PAD_DRIVER_MASK)
+#define GPIO_PIN17_SOURCE_MSB                    0
+#define GPIO_PIN17_SOURCE_LSB                    0
+#define GPIO_PIN17_SOURCE_MASK                   0x00000001
+#define GPIO_PIN17_SOURCE_GET(x)                 (((x) & GPIO_PIN17_SOURCE_MASK) >> GPIO_PIN17_SOURCE_LSB)
+#define GPIO_PIN17_SOURCE_SET(x)                 (((x) << GPIO_PIN17_SOURCE_LSB) & GPIO_PIN17_SOURCE_MASK)
+
+#define SDIO_PIN_ADDRESS                         0x00000070
+#define SDIO_PIN_OFFSET                          0x00000070
+#define SDIO_PIN_PAD_PULL_MSB                    3
+#define SDIO_PIN_PAD_PULL_LSB                    2
+#define SDIO_PIN_PAD_PULL_MASK                   0x0000000c
+#define SDIO_PIN_PAD_PULL_GET(x)                 (((x) & SDIO_PIN_PAD_PULL_MASK) >> SDIO_PIN_PAD_PULL_LSB)
+#define SDIO_PIN_PAD_PULL_SET(x)                 (((x) << SDIO_PIN_PAD_PULL_LSB) & SDIO_PIN_PAD_PULL_MASK)
+#define SDIO_PIN_PAD_STRENGTH_MSB                1
+#define SDIO_PIN_PAD_STRENGTH_LSB                0
+#define SDIO_PIN_PAD_STRENGTH_MASK               0x00000003
+#define SDIO_PIN_PAD_STRENGTH_GET(x)             (((x) & SDIO_PIN_PAD_STRENGTH_MASK) >> SDIO_PIN_PAD_STRENGTH_LSB)
+#define SDIO_PIN_PAD_STRENGTH_SET(x)             (((x) << SDIO_PIN_PAD_STRENGTH_LSB) & SDIO_PIN_PAD_STRENGTH_MASK)
+
+#define CLK_REQ_PIN_ADDRESS                      0x00000074
+#define CLK_REQ_PIN_OFFSET                       0x00000074
+#define CLK_REQ_PIN_ATE_OE_L_MSB                 4
+#define CLK_REQ_PIN_ATE_OE_L_LSB                 4
+#define CLK_REQ_PIN_ATE_OE_L_MASK                0x00000010
+#define CLK_REQ_PIN_ATE_OE_L_GET(x)              (((x) & CLK_REQ_PIN_ATE_OE_L_MASK) >> CLK_REQ_PIN_ATE_OE_L_LSB)
+#define CLK_REQ_PIN_ATE_OE_L_SET(x)              (((x) << CLK_REQ_PIN_ATE_OE_L_LSB) & CLK_REQ_PIN_ATE_OE_L_MASK)
+#define CLK_REQ_PIN_PAD_PULL_MSB                 3
+#define CLK_REQ_PIN_PAD_PULL_LSB                 2
+#define CLK_REQ_PIN_PAD_PULL_MASK                0x0000000c
+#define CLK_REQ_PIN_PAD_PULL_GET(x)              (((x) & CLK_REQ_PIN_PAD_PULL_MASK) >> CLK_REQ_PIN_PAD_PULL_LSB)
+#define CLK_REQ_PIN_PAD_PULL_SET(x)              (((x) << CLK_REQ_PIN_PAD_PULL_LSB) & CLK_REQ_PIN_PAD_PULL_MASK)
+#define CLK_REQ_PIN_PAD_STRENGTH_MSB             1
+#define CLK_REQ_PIN_PAD_STRENGTH_LSB             0
+#define CLK_REQ_PIN_PAD_STRENGTH_MASK            0x00000003
+#define CLK_REQ_PIN_PAD_STRENGTH_GET(x)          (((x) & CLK_REQ_PIN_PAD_STRENGTH_MASK) >> CLK_REQ_PIN_PAD_STRENGTH_LSB)
+#define CLK_REQ_PIN_PAD_STRENGTH_SET(x)          (((x) << CLK_REQ_PIN_PAD_STRENGTH_LSB) & CLK_REQ_PIN_PAD_STRENGTH_MASK)
+
+#define SIGMA_DELTA_ADDRESS                      0x00000078
+#define SIGMA_DELTA_OFFSET                       0x00000078
+#define SIGMA_DELTA_ENABLE_MSB                   16
+#define SIGMA_DELTA_ENABLE_LSB                   16
+#define SIGMA_DELTA_ENABLE_MASK                  0x00010000
+#define SIGMA_DELTA_ENABLE_GET(x)                (((x) & SIGMA_DELTA_ENABLE_MASK) >> SIGMA_DELTA_ENABLE_LSB)
+#define SIGMA_DELTA_ENABLE_SET(x)                (((x) << SIGMA_DELTA_ENABLE_LSB) & SIGMA_DELTA_ENABLE_MASK)
+#define SIGMA_DELTA_PRESCALAR_MSB                15
+#define SIGMA_DELTA_PRESCALAR_LSB                8
+#define SIGMA_DELTA_PRESCALAR_MASK               0x0000ff00
+#define SIGMA_DELTA_PRESCALAR_GET(x)             (((x) & SIGMA_DELTA_PRESCALAR_MASK) >> SIGMA_DELTA_PRESCALAR_LSB)
+#define SIGMA_DELTA_PRESCALAR_SET(x)             (((x) << SIGMA_DELTA_PRESCALAR_LSB) & SIGMA_DELTA_PRESCALAR_MASK)
+#define SIGMA_DELTA_TARGET_MSB                   7
+#define SIGMA_DELTA_TARGET_LSB                   0
+#define SIGMA_DELTA_TARGET_MASK                  0x000000ff
+#define SIGMA_DELTA_TARGET_GET(x)                (((x) & SIGMA_DELTA_TARGET_MASK) >> SIGMA_DELTA_TARGET_LSB)
+#define SIGMA_DELTA_TARGET_SET(x)                (((x) << SIGMA_DELTA_TARGET_LSB) & SIGMA_DELTA_TARGET_MASK)
+
+#define DEBUG_CONTROL_ADDRESS                    0x0000007c
+#define DEBUG_CONTROL_OFFSET                     0x0000007c
+#define DEBUG_CONTROL_OBS_OE_L_MSB               1
+#define DEBUG_CONTROL_OBS_OE_L_LSB               1
+#define DEBUG_CONTROL_OBS_OE_L_MASK              0x00000002
+#define DEBUG_CONTROL_OBS_OE_L_GET(x)            (((x) & DEBUG_CONTROL_OBS_OE_L_MASK) >> DEBUG_CONTROL_OBS_OE_L_LSB)
+#define DEBUG_CONTROL_OBS_OE_L_SET(x)            (((x) << DEBUG_CONTROL_OBS_OE_L_LSB) & DEBUG_CONTROL_OBS_OE_L_MASK)
+#define DEBUG_CONTROL_ENABLE_MSB                 0
+#define DEBUG_CONTROL_ENABLE_LSB                 0
+#define DEBUG_CONTROL_ENABLE_MASK                0x00000001
+#define DEBUG_CONTROL_ENABLE_GET(x)              (((x) & DEBUG_CONTROL_ENABLE_MASK) >> DEBUG_CONTROL_ENABLE_LSB)
+#define DEBUG_CONTROL_ENABLE_SET(x)              (((x) << DEBUG_CONTROL_ENABLE_LSB) & DEBUG_CONTROL_ENABLE_MASK)
+
+#define DEBUG_INPUT_SEL_ADDRESS                  0x00000080
+#define DEBUG_INPUT_SEL_OFFSET                   0x00000080
+#define DEBUG_INPUT_SEL_SRC_MSB                  3
+#define DEBUG_INPUT_SEL_SRC_LSB                  0
+#define DEBUG_INPUT_SEL_SRC_MASK                 0x0000000f
+#define DEBUG_INPUT_SEL_SRC_GET(x)               (((x) & DEBUG_INPUT_SEL_SRC_MASK) >> DEBUG_INPUT_SEL_SRC_LSB)
+#define DEBUG_INPUT_SEL_SRC_SET(x)               (((x) << DEBUG_INPUT_SEL_SRC_LSB) & DEBUG_INPUT_SEL_SRC_MASK)
+
+#define DEBUG_OUT_ADDRESS                        0x00000084
+#define DEBUG_OUT_OFFSET                         0x00000084
+#define DEBUG_OUT_DATA_MSB                       17
+#define DEBUG_OUT_DATA_LSB                       0
+#define DEBUG_OUT_DATA_MASK                      0x0003ffff
+#define DEBUG_OUT_DATA_GET(x)                    (((x) & DEBUG_OUT_DATA_MASK) >> DEBUG_OUT_DATA_LSB)
+#define DEBUG_OUT_DATA_SET(x)                    (((x) << DEBUG_OUT_DATA_LSB) & DEBUG_OUT_DATA_MASK)
+
+#define LA_CONTROL_ADDRESS                       0x00000088
+#define LA_CONTROL_OFFSET                        0x00000088
+#define LA_CONTROL_RUN_MSB                       1
+#define LA_CONTROL_RUN_LSB                       1
+#define LA_CONTROL_RUN_MASK                      0x00000002
+#define LA_CONTROL_RUN_GET(x)                    (((x) & LA_CONTROL_RUN_MASK) >> LA_CONTROL_RUN_LSB)
+#define LA_CONTROL_RUN_SET(x)                    (((x) << LA_CONTROL_RUN_LSB) & LA_CONTROL_RUN_MASK)
+#define LA_CONTROL_TRIGGERED_MSB                 0
+#define LA_CONTROL_TRIGGERED_LSB                 0
+#define LA_CONTROL_TRIGGERED_MASK                0x00000001
+#define LA_CONTROL_TRIGGERED_GET(x)              (((x) & LA_CONTROL_TRIGGERED_MASK) >> LA_CONTROL_TRIGGERED_LSB)
+#define LA_CONTROL_TRIGGERED_SET(x)              (((x) << LA_CONTROL_TRIGGERED_LSB) & LA_CONTROL_TRIGGERED_MASK)
+
+#define LA_CLOCK_ADDRESS                         0x0000008c
+#define LA_CLOCK_OFFSET                          0x0000008c
+#define LA_CLOCK_DIV_MSB                         7
+#define LA_CLOCK_DIV_LSB                         0
+#define LA_CLOCK_DIV_MASK                        0x000000ff
+#define LA_CLOCK_DIV_GET(x)                      (((x) & LA_CLOCK_DIV_MASK) >> LA_CLOCK_DIV_LSB)
+#define LA_CLOCK_DIV_SET(x)                      (((x) << LA_CLOCK_DIV_LSB) & LA_CLOCK_DIV_MASK)
+
+#define LA_STATUS_ADDRESS                        0x00000090
+#define LA_STATUS_OFFSET                         0x00000090
+#define LA_STATUS_INTERRUPT_MSB                  0
+#define LA_STATUS_INTERRUPT_LSB                  0
+#define LA_STATUS_INTERRUPT_MASK                 0x00000001
+#define LA_STATUS_INTERRUPT_GET(x)               (((x) & LA_STATUS_INTERRUPT_MASK) >> LA_STATUS_INTERRUPT_LSB)
+#define LA_STATUS_INTERRUPT_SET(x)               (((x) << LA_STATUS_INTERRUPT_LSB) & LA_STATUS_INTERRUPT_MASK)
+
+#define LA_TRIGGER_SAMPLE_ADDRESS                0x00000094
+#define LA_TRIGGER_SAMPLE_OFFSET                 0x00000094
+#define LA_TRIGGER_SAMPLE_COUNT_MSB              15
+#define LA_TRIGGER_SAMPLE_COUNT_LSB              0
+#define LA_TRIGGER_SAMPLE_COUNT_MASK             0x0000ffff
+#define LA_TRIGGER_SAMPLE_COUNT_GET(x)           (((x) & LA_TRIGGER_SAMPLE_COUNT_MASK) >> LA_TRIGGER_SAMPLE_COUNT_LSB)
+#define LA_TRIGGER_SAMPLE_COUNT_SET(x)           (((x) << LA_TRIGGER_SAMPLE_COUNT_LSB) & LA_TRIGGER_SAMPLE_COUNT_MASK)
+
+#define LA_TRIGGER_POSITION_ADDRESS              0x00000098
+#define LA_TRIGGER_POSITION_OFFSET               0x00000098
+#define LA_TRIGGER_POSITION_VALUE_MSB            15
+#define LA_TRIGGER_POSITION_VALUE_LSB            0
+#define LA_TRIGGER_POSITION_VALUE_MASK           0x0000ffff
+#define LA_TRIGGER_POSITION_VALUE_GET(x)         (((x) & LA_TRIGGER_POSITION_VALUE_MASK) >> LA_TRIGGER_POSITION_VALUE_LSB)
+#define LA_TRIGGER_POSITION_VALUE_SET(x)         (((x) << LA_TRIGGER_POSITION_VALUE_LSB) & LA_TRIGGER_POSITION_VALUE_MASK)
+
+#define LA_PRE_TRIGGER_ADDRESS                   0x0000009c
+#define LA_PRE_TRIGGER_OFFSET                    0x0000009c
+#define LA_PRE_TRIGGER_COUNT_MSB                 15
+#define LA_PRE_TRIGGER_COUNT_LSB                 0
+#define LA_PRE_TRIGGER_COUNT_MASK                0x0000ffff
+#define LA_PRE_TRIGGER_COUNT_GET(x)              (((x) & LA_PRE_TRIGGER_COUNT_MASK) >> LA_PRE_TRIGGER_COUNT_LSB)
+#define LA_PRE_TRIGGER_COUNT_SET(x)              (((x) << LA_PRE_TRIGGER_COUNT_LSB) & LA_PRE_TRIGGER_COUNT_MASK)
+
+#define LA_POST_TRIGGER_ADDRESS                  0x000000a0
+#define LA_POST_TRIGGER_OFFSET                   0x000000a0
+#define LA_POST_TRIGGER_COUNT_MSB                15
+#define LA_POST_TRIGGER_COUNT_LSB                0
+#define LA_POST_TRIGGER_COUNT_MASK               0x0000ffff
+#define LA_POST_TRIGGER_COUNT_GET(x)             (((x) & LA_POST_TRIGGER_COUNT_MASK) >> LA_POST_TRIGGER_COUNT_LSB)
+#define LA_POST_TRIGGER_COUNT_SET(x)             (((x) << LA_POST_TRIGGER_COUNT_LSB) & LA_POST_TRIGGER_COUNT_MASK)
+
+#define LA_FILTER_CONTROL_ADDRESS                0x000000a4
+#define LA_FILTER_CONTROL_OFFSET                 0x000000a4
+#define LA_FILTER_CONTROL_DELTA_MSB              0
+#define LA_FILTER_CONTROL_DELTA_LSB              0
+#define LA_FILTER_CONTROL_DELTA_MASK             0x00000001
+#define LA_FILTER_CONTROL_DELTA_GET(x)           (((x) & LA_FILTER_CONTROL_DELTA_MASK) >> LA_FILTER_CONTROL_DELTA_LSB)
+#define LA_FILTER_CONTROL_DELTA_SET(x)           (((x) << LA_FILTER_CONTROL_DELTA_LSB) & LA_FILTER_CONTROL_DELTA_MASK)
+
+#define LA_FILTER_DATA_ADDRESS                   0x000000a8
+#define LA_FILTER_DATA_OFFSET                    0x000000a8
+#define LA_FILTER_DATA_MATCH_MSB                 17
+#define LA_FILTER_DATA_MATCH_LSB                 0
+#define LA_FILTER_DATA_MATCH_MASK                0x0003ffff
+#define LA_FILTER_DATA_MATCH_GET(x)              (((x) & LA_FILTER_DATA_MATCH_MASK) >> LA_FILTER_DATA_MATCH_LSB)
+#define LA_FILTER_DATA_MATCH_SET(x)              (((x) << LA_FILTER_DATA_MATCH_LSB) & LA_FILTER_DATA_MATCH_MASK)
+
+#define LA_FILTER_WILDCARD_ADDRESS               0x000000ac
+#define LA_FILTER_WILDCARD_OFFSET                0x000000ac
+#define LA_FILTER_WILDCARD_MATCH_MSB             17
+#define LA_FILTER_WILDCARD_MATCH_LSB             0
+#define LA_FILTER_WILDCARD_MATCH_MASK            0x0003ffff
+#define LA_FILTER_WILDCARD_MATCH_GET(x)          (((x) & LA_FILTER_WILDCARD_MATCH_MASK) >> LA_FILTER_WILDCARD_MATCH_LSB)
+#define LA_FILTER_WILDCARD_MATCH_SET(x)          (((x) << LA_FILTER_WILDCARD_MATCH_LSB) & LA_FILTER_WILDCARD_MATCH_MASK)
+
+#define LA_TRIGGERA_DATA_ADDRESS                 0x000000b0
+#define LA_TRIGGERA_DATA_OFFSET                  0x000000b0
+#define LA_TRIGGERA_DATA_MATCH_MSB               17
+#define LA_TRIGGERA_DATA_MATCH_LSB               0
+#define LA_TRIGGERA_DATA_MATCH_MASK              0x0003ffff
+#define LA_TRIGGERA_DATA_MATCH_GET(x)            (((x) & LA_TRIGGERA_DATA_MATCH_MASK) >> LA_TRIGGERA_DATA_MATCH_LSB)
+#define LA_TRIGGERA_DATA_MATCH_SET(x)            (((x) << LA_TRIGGERA_DATA_MATCH_LSB) & LA_TRIGGERA_DATA_MATCH_MASK)
+
+#define LA_TRIGGERA_WILDCARD_ADDRESS             0x000000b4
+#define LA_TRIGGERA_WILDCARD_OFFSET              0x000000b4
+#define LA_TRIGGERA_WILDCARD_MATCH_MSB           17
+#define LA_TRIGGERA_WILDCARD_MATCH_LSB           0
+#define LA_TRIGGERA_WILDCARD_MATCH_MASK          0x0003ffff
+#define LA_TRIGGERA_WILDCARD_MATCH_GET(x)        (((x) & LA_TRIGGERA_WILDCARD_MATCH_MASK) >> LA_TRIGGERA_WILDCARD_MATCH_LSB)
+#define LA_TRIGGERA_WILDCARD_MATCH_SET(x)        (((x) << LA_TRIGGERA_WILDCARD_MATCH_LSB) & LA_TRIGGERA_WILDCARD_MATCH_MASK)
+
+#define LA_TRIGGERB_DATA_ADDRESS                 0x000000b8
+#define LA_TRIGGERB_DATA_OFFSET                  0x000000b8
+#define LA_TRIGGERB_DATA_MATCH_MSB               17
+#define LA_TRIGGERB_DATA_MATCH_LSB               0
+#define LA_TRIGGERB_DATA_MATCH_MASK              0x0003ffff
+#define LA_TRIGGERB_DATA_MATCH_GET(x)            (((x) & LA_TRIGGERB_DATA_MATCH_MASK) >> LA_TRIGGERB_DATA_MATCH_LSB)
+#define LA_TRIGGERB_DATA_MATCH_SET(x)            (((x) << LA_TRIGGERB_DATA_MATCH_LSB) & LA_TRIGGERB_DATA_MATCH_MASK)
+
+#define LA_TRIGGERB_WILDCARD_ADDRESS             0x000000bc
+#define LA_TRIGGERB_WILDCARD_OFFSET              0x000000bc
+#define LA_TRIGGERB_WILDCARD_MATCH_MSB           17
+#define LA_TRIGGERB_WILDCARD_MATCH_LSB           0
+#define LA_TRIGGERB_WILDCARD_MATCH_MASK          0x0003ffff
+#define LA_TRIGGERB_WILDCARD_MATCH_GET(x)        (((x) & LA_TRIGGERB_WILDCARD_MATCH_MASK) >> LA_TRIGGERB_WILDCARD_MATCH_LSB)
+#define LA_TRIGGERB_WILDCARD_MATCH_SET(x)        (((x) << LA_TRIGGERB_WILDCARD_MATCH_LSB) & LA_TRIGGERB_WILDCARD_MATCH_MASK)
+
+#define LA_TRIGGER_ADDRESS                       0x000000c0
+#define LA_TRIGGER_OFFSET                        0x000000c0
+#define LA_TRIGGER_EVENT_MSB                     2
+#define LA_TRIGGER_EVENT_LSB                     0
+#define LA_TRIGGER_EVENT_MASK                    0x00000007
+#define LA_TRIGGER_EVENT_GET(x)                  (((x) & LA_TRIGGER_EVENT_MASK) >> LA_TRIGGER_EVENT_LSB)
+#define LA_TRIGGER_EVENT_SET(x)                  (((x) << LA_TRIGGER_EVENT_LSB) & LA_TRIGGER_EVENT_MASK)
+
+#define LA_FIFO_ADDRESS                          0x000000c4
+#define LA_FIFO_OFFSET                           0x000000c4
+#define LA_FIFO_FULL_MSB                         1
+#define LA_FIFO_FULL_LSB                         1
+#define LA_FIFO_FULL_MASK                        0x00000002
+#define LA_FIFO_FULL_GET(x)                      (((x) & LA_FIFO_FULL_MASK) >> LA_FIFO_FULL_LSB)
+#define LA_FIFO_FULL_SET(x)                      (((x) << LA_FIFO_FULL_LSB) & LA_FIFO_FULL_MASK)
+#define LA_FIFO_EMPTY_MSB                        0
+#define LA_FIFO_EMPTY_LSB                        0
+#define LA_FIFO_EMPTY_MASK                       0x00000001
+#define LA_FIFO_EMPTY_GET(x)                     (((x) & LA_FIFO_EMPTY_MASK) >> LA_FIFO_EMPTY_LSB)
+#define LA_FIFO_EMPTY_SET(x)                     (((x) << LA_FIFO_EMPTY_LSB) & LA_FIFO_EMPTY_MASK)
+
+#define LA_ADDRESS                               0x000000c8
+#define LA_OFFSET                                0x000000c8
+#define LA_DATA_MSB                              17
+#define LA_DATA_LSB                              0
+#define LA_DATA_MASK                             0x0003ffff
+#define LA_DATA_GET(x)                           (((x) & LA_DATA_MASK) >> LA_DATA_LSB)
+#define LA_DATA_SET(x)                           (((x) << LA_DATA_LSB) & LA_DATA_MASK)
+
+#define ANT_PIN_ADDRESS                          0x000000d0
+#define ANT_PIN_OFFSET                           0x000000d0
+#define ANT_PIN_PAD_PULL_MSB                     3
+#define ANT_PIN_PAD_PULL_LSB                     2
+#define ANT_PIN_PAD_PULL_MASK                    0x0000000c
+#define ANT_PIN_PAD_PULL_GET(x)                  (((x) & ANT_PIN_PAD_PULL_MASK) >> ANT_PIN_PAD_PULL_LSB)
+#define ANT_PIN_PAD_PULL_SET(x)                  (((x) << ANT_PIN_PAD_PULL_LSB) & ANT_PIN_PAD_PULL_MASK)
+#define ANT_PIN_PAD_STRENGTH_MSB                 1
+#define ANT_PIN_PAD_STRENGTH_LSB                 0
+#define ANT_PIN_PAD_STRENGTH_MASK                0x00000003
+#define ANT_PIN_PAD_STRENGTH_GET(x)              (((x) & ANT_PIN_PAD_STRENGTH_MASK) >> ANT_PIN_PAD_STRENGTH_LSB)
+#define ANT_PIN_PAD_STRENGTH_SET(x)              (((x) << ANT_PIN_PAD_STRENGTH_LSB) & ANT_PIN_PAD_STRENGTH_MASK)
+
+#define ANTD_PIN_ADDRESS                         0x000000d4
+#define ANTD_PIN_OFFSET                          0x000000d4
+#define ANTD_PIN_PAD_PULL_MSB                    1
+#define ANTD_PIN_PAD_PULL_LSB                    0
+#define ANTD_PIN_PAD_PULL_MASK                   0x00000003
+#define ANTD_PIN_PAD_PULL_GET(x)                 (((x) & ANTD_PIN_PAD_PULL_MASK) >> ANTD_PIN_PAD_PULL_LSB)
+#define ANTD_PIN_PAD_PULL_SET(x)                 (((x) << ANTD_PIN_PAD_PULL_LSB) & ANTD_PIN_PAD_PULL_MASK)
+
+#define GPIO_PIN_ADDRESS                         0x000000d8
+#define GPIO_PIN_OFFSET                          0x000000d8
+#define GPIO_PIN_PAD_PULL_MSB                    3
+#define GPIO_PIN_PAD_PULL_LSB                    2
+#define GPIO_PIN_PAD_PULL_MASK                   0x0000000c
+#define GPIO_PIN_PAD_PULL_GET(x)                 (((x) & GPIO_PIN_PAD_PULL_MASK) >> GPIO_PIN_PAD_PULL_LSB)
+#define GPIO_PIN_PAD_PULL_SET(x)                 (((x) << GPIO_PIN_PAD_PULL_LSB) & GPIO_PIN_PAD_PULL_MASK)
+#define GPIO_PIN_PAD_STRENGTH_MSB                1
+#define GPIO_PIN_PAD_STRENGTH_LSB                0
+#define GPIO_PIN_PAD_STRENGTH_MASK               0x00000003
+#define GPIO_PIN_PAD_STRENGTH_GET(x)             (((x) & GPIO_PIN_PAD_STRENGTH_MASK) >> GPIO_PIN_PAD_STRENGTH_LSB)
+#define GPIO_PIN_PAD_STRENGTH_SET(x)             (((x) << GPIO_PIN_PAD_STRENGTH_LSB) & GPIO_PIN_PAD_STRENGTH_MASK)
+
+#define GPIO_H_PIN_ADDRESS                       0x000000dc
+#define GPIO_H_PIN_OFFSET                        0x000000dc
+#define GPIO_H_PIN_PAD_PULL_MSB                  1
+#define GPIO_H_PIN_PAD_PULL_LSB                  0
+#define GPIO_H_PIN_PAD_PULL_MASK                 0x00000003
+#define GPIO_H_PIN_PAD_PULL_GET(x)               (((x) & GPIO_H_PIN_PAD_PULL_MASK) >> GPIO_H_PIN_PAD_PULL_LSB)
+#define GPIO_H_PIN_PAD_PULL_SET(x)               (((x) << GPIO_H_PIN_PAD_PULL_LSB) & GPIO_H_PIN_PAD_PULL_MASK)
+
+#define BT_PIN_ADDRESS                           0x000000e0
+#define BT_PIN_OFFSET                            0x000000e0
+#define BT_PIN_PAD_PULL_MSB                      3
+#define BT_PIN_PAD_PULL_LSB                      2
+#define BT_PIN_PAD_PULL_MASK                     0x0000000c
+#define BT_PIN_PAD_PULL_GET(x)                   (((x) & BT_PIN_PAD_PULL_MASK) >> BT_PIN_PAD_PULL_LSB)
+#define BT_PIN_PAD_PULL_SET(x)                   (((x) << BT_PIN_PAD_PULL_LSB) & BT_PIN_PAD_PULL_MASK)
+#define BT_PIN_PAD_STRENGTH_MSB                  1
+#define BT_PIN_PAD_STRENGTH_LSB                  0
+#define BT_PIN_PAD_STRENGTH_MASK                 0x00000003
+#define BT_PIN_PAD_STRENGTH_GET(x)               (((x) & BT_PIN_PAD_STRENGTH_MASK) >> BT_PIN_PAD_STRENGTH_LSB)
+#define BT_PIN_PAD_STRENGTH_SET(x)               (((x) << BT_PIN_PAD_STRENGTH_LSB) & BT_PIN_PAD_STRENGTH_MASK)
+
+#define BT_WLAN_PIN_ADDRESS                      0x000000e4
+#define BT_WLAN_PIN_OFFSET                       0x000000e4
+#define BT_WLAN_PIN_PAD_PULL_MSB                 1
+#define BT_WLAN_PIN_PAD_PULL_LSB                 0
+#define BT_WLAN_PIN_PAD_PULL_MASK                0x00000003
+#define BT_WLAN_PIN_PAD_PULL_GET(x)              (((x) & BT_WLAN_PIN_PAD_PULL_MASK) >> BT_WLAN_PIN_PAD_PULL_LSB)
+#define BT_WLAN_PIN_PAD_PULL_SET(x)              (((x) << BT_WLAN_PIN_PAD_PULL_LSB) & BT_WLAN_PIN_PAD_PULL_MASK)
+
+#define SI_UART_PIN_ADDRESS                      0x000000e8
+#define SI_UART_PIN_OFFSET                       0x000000e8
+#define SI_UART_PIN_PAD_PULL_MSB                 3
+#define SI_UART_PIN_PAD_PULL_LSB                 2
+#define SI_UART_PIN_PAD_PULL_MASK                0x0000000c
+#define SI_UART_PIN_PAD_PULL_GET(x)              (((x) & SI_UART_PIN_PAD_PULL_MASK) >> SI_UART_PIN_PAD_PULL_LSB)
+#define SI_UART_PIN_PAD_PULL_SET(x)              (((x) << SI_UART_PIN_PAD_PULL_LSB) & SI_UART_PIN_PAD_PULL_MASK)
+#define SI_UART_PIN_PAD_STRENGTH_MSB             1
+#define SI_UART_PIN_PAD_STRENGTH_LSB             0
+#define SI_UART_PIN_PAD_STRENGTH_MASK            0x00000003
+#define SI_UART_PIN_PAD_STRENGTH_GET(x)          (((x) & SI_UART_PIN_PAD_STRENGTH_MASK) >> SI_UART_PIN_PAD_STRENGTH_LSB)
+#define SI_UART_PIN_PAD_STRENGTH_SET(x)          (((x) << SI_UART_PIN_PAD_STRENGTH_LSB) & SI_UART_PIN_PAD_STRENGTH_MASK)
+
+#define CLK32K_PIN_ADDRESS                       0x000000ec
+#define CLK32K_PIN_OFFSET                        0x000000ec
+#define CLK32K_PIN_PAD_PULL_MSB                  1
+#define CLK32K_PIN_PAD_PULL_LSB                  0
+#define CLK32K_PIN_PAD_PULL_MASK                 0x00000003
+#define CLK32K_PIN_PAD_PULL_GET(x)               (((x) & CLK32K_PIN_PAD_PULL_MASK) >> CLK32K_PIN_PAD_PULL_LSB)
+#define CLK32K_PIN_PAD_PULL_SET(x)               (((x) << CLK32K_PIN_PAD_PULL_LSB) & CLK32K_PIN_PAD_PULL_MASK)
+
+#define RESET_TUPLE_STATUS_ADDRESS               0x000000f0
+#define RESET_TUPLE_STATUS_OFFSET                0x000000f0
+#define RESET_TUPLE_STATUS_TEST_RESET_TUPLE_MSB  11
+#define RESET_TUPLE_STATUS_TEST_RESET_TUPLE_LSB  8
+#define RESET_TUPLE_STATUS_TEST_RESET_TUPLE_MASK 0x00000f00
+#define RESET_TUPLE_STATUS_TEST_RESET_TUPLE_GET(x) (((x) & RESET_TUPLE_STATUS_TEST_RESET_TUPLE_MASK) >> RESET_TUPLE_STATUS_TEST_RESET_TUPLE_LSB)
+#define RESET_TUPLE_STATUS_TEST_RESET_TUPLE_SET(x) (((x) << RESET_TUPLE_STATUS_TEST_RESET_TUPLE_LSB) & RESET_TUPLE_STATUS_TEST_RESET_TUPLE_MASK)
+#define RESET_TUPLE_STATUS_PIN_RESET_TUPLE_MSB   7
+#define RESET_TUPLE_STATUS_PIN_RESET_TUPLE_LSB   0
+#define RESET_TUPLE_STATUS_PIN_RESET_TUPLE_MASK  0x000000ff
+#define RESET_TUPLE_STATUS_PIN_RESET_TUPLE_GET(x) (((x) & RESET_TUPLE_STATUS_PIN_RESET_TUPLE_MASK) >> RESET_TUPLE_STATUS_PIN_RESET_TUPLE_LSB)
+#define RESET_TUPLE_STATUS_PIN_RESET_TUPLE_SET(x) (((x) << RESET_TUPLE_STATUS_PIN_RESET_TUPLE_LSB) & RESET_TUPLE_STATUS_PIN_RESET_TUPLE_MASK)
+
+
+#ifndef __ASSEMBLER__
+
+typedef struct gpio_reg_reg_s {
+  volatile unsigned int gpio_out;
+  volatile unsigned int gpio_out_w1ts;
+  volatile unsigned int gpio_out_w1tc;
+  volatile unsigned int gpio_enable;
+  volatile unsigned int gpio_enable_w1ts;
+  volatile unsigned int gpio_enable_w1tc;
+  volatile unsigned int gpio_in;
+  volatile unsigned int gpio_status;
+  volatile unsigned int gpio_status_w1ts;
+  volatile unsigned int gpio_status_w1tc;
+  volatile unsigned int gpio_pin0;
+  volatile unsigned int gpio_pin1;
+  volatile unsigned int gpio_pin2;
+  volatile unsigned int gpio_pin3;
+  volatile unsigned int gpio_pin4;
+  volatile unsigned int gpio_pin5;
+  volatile unsigned int gpio_pin6;
+  volatile unsigned int gpio_pin7;
+  volatile unsigned int gpio_pin8;
+  volatile unsigned int gpio_pin9;
+  volatile unsigned int gpio_pin10;
+  volatile unsigned int gpio_pin11;
+  volatile unsigned int gpio_pin12;
+  volatile unsigned int gpio_pin13;
+  volatile unsigned int gpio_pin14;
+  volatile unsigned int gpio_pin15;
+  volatile unsigned int gpio_pin16;
+  volatile unsigned int gpio_pin17;
+  volatile unsigned int sdio_pin;
+  volatile unsigned int clk_req_pin;
+  volatile unsigned int sigma_delta;
+  volatile unsigned int debug_control;
+  volatile unsigned int debug_input_sel;
+  volatile unsigned int debug_out;
+  volatile unsigned int la_control;
+  volatile unsigned int la_clock;
+  volatile unsigned int la_status;
+  volatile unsigned int la_trigger_sample;
+  volatile unsigned int la_trigger_position;
+  volatile unsigned int la_pre_trigger;
+  volatile unsigned int la_post_trigger;
+  volatile unsigned int la_filter_control;
+  volatile unsigned int la_filter_data;
+  volatile unsigned int la_filter_wildcard;
+  volatile unsigned int la_triggera_data;
+  volatile unsigned int la_triggera_wildcard;
+  volatile unsigned int la_triggerb_data;
+  volatile unsigned int la_triggerb_wildcard;
+  volatile unsigned int la_trigger;
+  volatile unsigned int la_fifo;
+  volatile unsigned int la[2];
+  volatile unsigned int ant_pin;
+  volatile unsigned int antd_pin;
+  volatile unsigned int gpio_pin;
+  volatile unsigned int gpio_h_pin;
+  volatile unsigned int bt_pin;
+  volatile unsigned int bt_wlan_pin;
+  volatile unsigned int si_uart_pin;
+  volatile unsigned int clk32k_pin;
+  volatile unsigned int reset_tuple_status;
+} gpio_reg_reg_t;
+
+#endif /* __ASSEMBLER__ */
+
+#endif /* _GPIO_REG_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/hif.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/hif.h
@@ -0,0 +1,315 @@
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ * HIF specific declarations and prototypes
+ */
+
+#ifndef _HIF_H_
+#define _HIF_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Header files */
+#include "../include/config.h"
+#include "../include/athdefs.h"
+#include "../include/athtypes.h"
+#include "../include/osapi.h"
+
+typedef struct htc_callbacks HTC_CALLBACKS;
+typedef struct hif_device HIF_DEVICE;
+
+/*
+ * direction - Direction of transfer (HIF_READ/HIF_WRITE).
+ */
+#define HIF_READ                    0x00000001
+#define HIF_WRITE                   0x00000002
+#define HIF_DIR_MASK                (HIF_READ | HIF_WRITE)
+
+/*
+ *     type - An interface may support different kind of read/write commands.
+ *            For example: SDIO supports CMD52/CMD53s. In case of MSIO it
+ *            translates to using different kinds of TPCs. The command type
+ *            is thus divided into a basic and an extended command and can
+ *            be specified using HIF_BASIC_IO/HIF_EXTENDED_IO.
+ */
+#define HIF_BASIC_IO                0x00000004
+#define HIF_EXTENDED_IO             0x00000008
+#define HIF_TYPE_MASK               (HIF_BASIC_IO | HIF_EXTENDED_IO)
+
+/*
+ *     emode - This indicates the whether the command is to be executed in a
+ *             blocking or non-blocking fashion (HIF_SYNCHRONOUS/
+ *             HIF_ASYNCHRONOUS). The read/write data paths in HTC have been
+ *             implemented using the asynchronous mode allowing the the bus
+ *             driver to indicate the completion of operation through the
+ *             registered callback routine. The requirement primarily comes
+ *             from the contexts these operations get called from (a driver's
+ *             transmit context or the ISR context in case of receive).
+ *             Support for both of these modes is essential.
+ */
+#define HIF_SYNCHRONOUS             0x00000010
+#define HIF_ASYNCHRONOUS            0x00000020
+#define HIF_EMODE_MASK              (HIF_SYNCHRONOUS | HIF_ASYNCHRONOUS)
+
+/*
+ *     dmode - An interface may support different kinds of commands based on
+ *             the tradeoff between the amount of data it can carry and the
+ *             setup time. Byte and Block modes are supported (HIF_BYTE_BASIS/
+ *             HIF_BLOCK_BASIS). In case of latter, the data is rounded off
+ *             to the nearest block size by padding. The size of the block is
+ *             configurable at compile time using the HIF_BLOCK_SIZE and is
+ *             negotiated with the target during initialization after the
+ *             AR6000 interrupts are enabled.
+ */
+#define HIF_BYTE_BASIS              0x00000040
+#define HIF_BLOCK_BASIS             0x00000080
+#define HIF_DMODE_MASK              (HIF_BYTE_BASIS | HIF_BLOCK_BASIS)
+
+/*
+ *     amode - This indicates if the address has to be incremented on AR6000
+ *             after every read/write operation (HIF?FIXED_ADDRESS/
+ *             HIF_INCREMENTAL_ADDRESS).
+ */
+#define HIF_FIXED_ADDRESS           0x00000100
+#define HIF_INCREMENTAL_ADDRESS     0x00000200
+#define HIF_AMODE_MASK              (HIF_FIXED_ADDRESS | HIF_INCREMENTAL_ADDRESS)
+
+#define HIF_WR_ASYNC_BYTE_FIX   \
+    (HIF_WRITE | HIF_ASYNCHRONOUS | HIF_EXTENDED_IO | HIF_BYTE_BASIS | HIF_FIXED_ADDRESS)
+#define HIF_WR_ASYNC_BYTE_INC   \
+    (HIF_WRITE | HIF_ASYNCHRONOUS | HIF_EXTENDED_IO | HIF_BYTE_BASIS | HIF_INCREMENTAL_ADDRESS)
+#define HIF_WR_ASYNC_BLOCK_INC  \
+    (HIF_WRITE | HIF_ASYNCHRONOUS | HIF_EXTENDED_IO | HIF_BLOCK_BASIS | HIF_INCREMENTAL_ADDRESS)
+#define HIF_WR_SYNC_BYTE_FIX    \
+    (HIF_WRITE | HIF_SYNCHRONOUS | HIF_EXTENDED_IO | HIF_BYTE_BASIS | HIF_FIXED_ADDRESS)
+#define HIF_WR_SYNC_BYTE_INC    \
+    (HIF_WRITE | HIF_SYNCHRONOUS | HIF_EXTENDED_IO | HIF_BYTE_BASIS | HIF_INCREMENTAL_ADDRESS)
+#define HIF_WR_SYNC_BLOCK_INC  \
+    (HIF_WRITE | HIF_SYNCHRONOUS | HIF_EXTENDED_IO | HIF_BLOCK_BASIS | HIF_INCREMENTAL_ADDRESS)
+#define HIF_RD_SYNC_BYTE_INC    \
+    (HIF_READ | HIF_SYNCHRONOUS | HIF_EXTENDED_IO | HIF_BYTE_BASIS | HIF_INCREMENTAL_ADDRESS)
+#define HIF_RD_SYNC_BYTE_FIX    \
+    (HIF_READ | HIF_SYNCHRONOUS | HIF_EXTENDED_IO | HIF_BYTE_BASIS | HIF_FIXED_ADDRESS)
+#define HIF_RD_ASYNC_BYTE_FIX   \
+    (HIF_READ | HIF_ASYNCHRONOUS | HIF_EXTENDED_IO | HIF_BYTE_BASIS | HIF_FIXED_ADDRESS)
+#define HIF_RD_ASYNC_BLOCK_FIX  \
+    (HIF_READ | HIF_ASYNCHRONOUS | HIF_EXTENDED_IO | HIF_BLOCK_BASIS | HIF_FIXED_ADDRESS)
+#define HIF_RD_ASYNC_BYTE_INC   \
+    (HIF_READ | HIF_ASYNCHRONOUS | HIF_EXTENDED_IO | HIF_BYTE_BASIS | HIF_INCREMENTAL_ADDRESS)
+#define HIF_RD_ASYNC_BLOCK_INC  \
+    (HIF_READ | HIF_ASYNCHRONOUS | HIF_EXTENDED_IO | HIF_BLOCK_BASIS | HIF_INCREMENTAL_ADDRESS)
+#define HIF_RD_SYNC_BLOCK_INC  \
+    (HIF_READ | HIF_SYNCHRONOUS | HIF_EXTENDED_IO | HIF_BLOCK_BASIS | HIF_INCREMENTAL_ADDRESS)
+
+
+typedef enum {
+    HIF_DEVICE_POWER_STATE = 0,
+    HIF_DEVICE_GET_MBOX_BLOCK_SIZE,
+    HIF_DEVICE_GET_MBOX_ADDR,
+    HIF_DEVICE_GET_PENDING_EVENTS_FUNC,
+    HIF_DEVICE_GET_IRQ_PROC_MODE,
+    HIF_DEVICE_GET_RECV_EVENT_MASK_UNMASK_FUNC,
+    HIF_DEVICE_POWER_STATE_CHANGE,
+} HIF_DEVICE_CONFIG_OPCODE;
+
+/*
+ * HIF CONFIGURE definitions:
+ *
+ *   HIF_DEVICE_GET_MBOX_BLOCK_SIZE
+ *   input : none
+ *   output : array of 4 A_UINT32s
+ *   notes: block size is returned for each mailbox (4)
+ *
+ *   HIF_DEVICE_GET_MBOX_ADDR
+ *   input : none
+ *   output : array of 4 A_UINT32
+ *   notes: address is returned for each mailbox (4) in the array
+ *
+ *   HIF_DEVICE_GET_PENDING_EVENTS_FUNC
+ *   input : none
+ *   output: HIF_PENDING_EVENTS_FUNC function pointer
+ *   notes: this is optional for the HIF layer, if the request is
+ *          not handled then it indicates that the upper layer can use
+ *          the standard device methods to get pending events (IRQs, mailbox messages etc..)
+ *          otherwise it can call the function pointer to check pending events.
+ *
+ *   HIF_DEVICE_GET_IRQ_PROC_MODE
+ *   input : none
+ *   output : HIF_DEVICE_IRQ_PROCESSING_MODE (interrupt processing mode)
+ *   note: the hif layer interfaces with the underlying OS-specific bus driver. The HIF
+ *         layer can report whether IRQ processing is requires synchronous behavior or
+ *         can be processed using asynchronous bus requests (typically faster).
+ *
+ *   HIF_DEVICE_GET_RECV_EVENT_MASK_UNMASK_FUNC
+ *   input :
+ *   output : HIF_MASK_UNMASK_RECV_EVENT function pointer
+ *   notes: this is optional for the HIF layer.  The HIF layer may require a special mechanism
+ *          to mask receive message events.  The upper layer can call this pointer when it needs
+ *          to mask/unmask receive events (in case it runs out of buffers).
+ *
+ *   HIF_DEVICE_POWER_STATE_CHANGE
+ *
+ *   input : HIF_DEVICE_POWER_CHANGE_TYPE
+ *   output : none
+ *   note: this is optional for the HIF layer.  The HIF layer can handle power on/off state change
+ *         requests in an interconnect specific way.  This is highly OS and bus driver dependent.
+ *         The caller must guarantee that no HIF read/write requests will be made after the device
+ *         is powered down.
+ *
+ *
+ *
+ */
+
+typedef enum {
+    HIF_DEVICE_IRQ_SYNC_ONLY,   /* for HIF implementations that require the DSR to process all
+                                   interrupts before returning */
+    HIF_DEVICE_IRQ_ASYNC_SYNC,  /* for HIF implementations that allow DSR to process interrupts
+                                   using ASYNC I/O (that is HIFAckInterrupt can be called at a
+                                   later time */
+} HIF_DEVICE_IRQ_PROCESSING_MODE;
+
+typedef enum {
+    HIF_DEVICE_POWER_UP,    /* HIF layer should power up interface and/or module */
+    HIF_DEVICE_POWER_DOWN,  /* HIF layer should initiate bus-specific measures to minimize power */
+    HIF_DEVICE_POWER_CUT    /* HIF layer should initiate bus-specific AND/OR platform-specific measures
+                               to completely power-off the module and associated hardware (i.e. cut power supplies)
+                            */
+} HIF_DEVICE_POWER_CHANGE_TYPE;
+
+#define HIF_MAX_DEVICES                 1
+
+struct htc_callbacks {
+    A_UCHAR *name;
+    A_UINT32 id;
+    A_STATUS (* deviceInsertedHandler)(void *hif_handle);
+    A_STATUS (* deviceRemovedHandler)(void *htc_handle, A_STATUS status);
+    A_STATUS (* deviceSuspendHandler)(void *htc_handle);
+    A_STATUS (* deviceResumeHandler)(void *htc_handle);
+    A_STATUS (* deviceWakeupHandler)(void *htc_handle);
+    A_STATUS (* rwCompletionHandler)(void *context, A_STATUS status);
+    A_STATUS (* dsrHandler)(void *htc_handle);
+};
+
+
+#define HIF_OTHER_EVENTS     (1 << 0)   /* other interrupts (non-Recv) are pending, host
+                                           needs to read the register table to figure out what */
+#define HIF_RECV_MSG_AVAIL   (1 << 1)   /* pending recv packet */
+
+typedef struct _HIF_PENDING_EVENTS_INFO {
+    A_UINT32 Events;
+    A_UINT32 LookAhead;
+} HIF_PENDING_EVENTS_INFO;
+
+    /* function to get pending events , some HIF modules use special mechanisms
+     * to detect packet available and other interrupts */
+typedef A_STATUS ( *HIF_PENDING_EVENTS_FUNC)(HIF_DEVICE              *device,
+                                             HIF_PENDING_EVENTS_INFO *pEvents,
+                                             void                    *AsyncContext);
+
+#define HIF_MASK_RECV    TRUE
+#define HIF_UNMASK_RECV  FALSE
+    /* function to mask recv events */
+typedef A_STATUS ( *HIF_MASK_UNMASK_RECV_EVENT)(HIF_DEVICE  *device,
+                                                A_BOOL      Mask,
+                                                void        *AsyncContext);
+
+
+/*
+ * This API is used by the HTC layer to initialize the HIF layer and to
+ * register different callback routines. Support for following events has
+ * been captured - DSR, Read/Write completion, Device insertion/removal,
+ * Device suspension/resumption/wakeup. In addition to this, the API is
+ * also used to register the name and the revision of the chip. The latter
+ * can be used to verify the revision of the chip read from the device
+ * before reporting it to HTC.
+ */
+int HIFInit(HTC_CALLBACKS *callbacks);
+
+/*
+ * This API is used to provide the read/write interface over the specific bus
+ * interface.
+ * address - Starting address in the AR6000's address space. For mailbox
+ *           writes, it refers to the start of the mbox boundary. It should
+ *           be ensured that the last byte falls on the mailbox's EOM. For
+ *           mailbox reads, it refers to the end of the mbox boundary.
+ * buffer - Pointer to the buffer containg the data to be transmitted or
+ *          received.
+ * length - Amount of data to be transmitted or received.
+ * request - Characterizes the attributes of the command.
+ */
+A_STATUS
+HIFReadWrite(HIF_DEVICE    *device,
+             A_UINT32       address,
+             A_UCHAR       *buffer,
+             A_UINT32       length,
+             A_UINT32       request,
+             void          *context);
+
+/*
+ * This can be initiated from the unload driver context ie when the HTCShutdown
+ * routine is called.
+ */
+void HIFShutDownDevice(HIF_DEVICE *device);
+
+/*
+ * This should translate to an acknowledgment to the bus driver indicating that
+ * the previous interrupt request has been serviced and the all the relevant
+ * sources have been cleared. HTC is ready to process more interrupts.
+ * This should prevent the bus driver from raising an interrupt unless the
+ * previous one has been serviced and acknowledged using the previous API.
+ */
+void HIFAckInterrupt(HIF_DEVICE *device);
+
+void HIFMaskInterrupt(HIF_DEVICE *device);
+
+void HIFUnMaskInterrupt(HIF_DEVICE *device);
+
+/*
+ * This set of functions are to be used by the bus driver to notify
+ * the HIF module about various events.
+ * These are not implemented if the bus driver provides an alternative
+ * way for this notification though callbacks for instance.
+ */
+int HIFInsertEventNotify(void);
+
+int HIFRemoveEventNotify(void);
+
+int HIFIRQEventNotify(void);
+
+int HIFRWCompleteEventNotify(void);
+
+/*
+ * This function associates a opaque handle with the HIF layer
+ * to be used in communication with upper layer i.e. HTC.
+ * This would normaly be a pointer to htc_target data structure.
+ */
+void HIFSetHandle(void *hif_handle, void *handle);
+
+A_STATUS
+HIFConfigureDevice(HIF_DEVICE *device, HIF_DEVICE_CONFIG_OPCODE opcode,
+                   void *config, A_UINT32 configLen);
+
+struct device;
+struct device*
+HIFGetOSDevice(HIF_DEVICE *device);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _HIF_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/host_version.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/host_version.h
@@ -0,0 +1,50 @@
+
+#ifndef _HOST_VERSION_H_
+#define _HOST_VERSION_H_
+/*
+ * Copyright (c) 2004-2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * This file contains version information for the sample host driver for the
+ * AR6000 chip
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/include/host_version.h#2 $
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "../include/AR6K_version.h"
+
+/*
+ * The version number is made up of major, minor, patch and build
+ * numbers. These are 16 bit numbers.  The build and release script will
+ * set the build number using a Perforce counter.  Here the build number is
+ * set to 9999 so that builds done without the build-release script are easily
+ * identifiable.
+ */
+
+#define ATH_SW_VER_MAJOR      __VER_MAJOR_
+#define ATH_SW_VER_MINOR      __VER_MINOR_
+#define ATH_SW_VER_PATCH      __VER_PATCH_
+#define ATH_SW_VER_BUILD      __BUILD_NUMBER_
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _HOST_VERSION_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/htc.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/htc.h
@@ -0,0 +1,182 @@
+/*
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ */
+
+
+#ifndef __HTC_H__
+#define __HTC_H__
+
+#define A_OFFSETOF(type,field) (int)(&(((type *)NULL)->field))
+
+#define ASSEMBLE_UNALIGNED_UINT16(p,highbyte,lowbyte) \
+        (((A_UINT16)(((A_UINT8 *)(p))[(highbyte)])) << 8 | (A_UINT16)(((A_UINT8 *)(p))[(lowbyte)]))
+
+/* alignment independent macros (little-endian) to fetch UINT16s or UINT8s from a
+ * structure using only the type and field name.
+ * Use these macros if there is the potential for unaligned buffer accesses. */
+#define A_GET_UINT16_FIELD(p,type,field) \
+    ASSEMBLE_UNALIGNED_UINT16(p,\
+                              A_OFFSETOF(type,field) + 1, \
+                              A_OFFSETOF(type,field))
+
+#define A_SET_UINT16_FIELD(p,type,field,value) \
+{                                              \
+    ((A_UINT8 *)(p))[A_OFFSETOF(type,field)] = (A_UINT8)(value);        \
+    ((A_UINT8 *)(p))[A_OFFSETOF(type,field) + 1] = (A_UINT8)((value) >> 8); \
+}
+
+#define A_GET_UINT8_FIELD(p,type,field) \
+            ((A_UINT8 *)(p))[A_OFFSETOF(type,field)]
+
+#define A_SET_UINT8_FIELD(p,type,field,value) \
+    ((A_UINT8 *)(p))[A_OFFSETOF(type,field)] = (value)
+
+/****** DANGER DANGER ***************
+ *
+ *   The frame header length and message formats defined herein were
+ *   selected to accommodate optimal alignment for target processing.  This reduces code
+ *   size and improves performance.
+ *
+ *   Any changes to the header length may alter the alignment and cause exceptions
+ *   on the target. When adding to the message structures insure that fields are
+ *   properly aligned.
+ *
+ */
+
+/* HTC frame header */
+typedef PREPACK struct _HTC_FRAME_HDR{
+        /* do not remove or re-arrange these fields, these are minimally required
+         * to take advantage of 4-byte lookaheads in some hardware implementations */
+    A_UINT8   EndpointID;
+    A_UINT8   Flags;
+    A_UINT16  PayloadLen;       /* length of data (including trailer) that follows the header */
+
+    /***** end of 4-byte lookahead ****/
+
+    A_UINT8   ControlBytes[2];
+
+    /* message payload starts after the header */
+
+} POSTPACK HTC_FRAME_HDR;
+
+/* frame header flags */
+#define HTC_FLAGS_NEED_CREDIT_UPDATE (1 << 0)
+#define HTC_FLAGS_RECV_TRAILER       (1 << 1)
+
+
+#define HTC_HDR_LENGTH  (sizeof(HTC_FRAME_HDR))
+#define HTC_MAX_TRAILER_LENGTH   255
+#define HTC_MAX_PAYLOAD_LENGTH   (2048 - sizeof(HTC_FRAME_HDR))
+
+/* HTC control message IDs */
+typedef enum {
+    HTC_MSG_READY_ID = 1,
+    HTC_MSG_CONNECT_SERVICE_ID = 2,
+    HTC_MSG_CONNECT_SERVICE_RESPONSE_ID = 3,
+    HTC_MSG_SETUP_COMPLETE_ID = 4,
+} HTC_MSG_IDS;
+
+#define HTC_MAX_CONTROL_MESSAGE_LENGTH  256
+
+/* base message ID header */
+typedef PREPACK struct {
+    A_UINT16 MessageID;
+} POSTPACK HTC_UNKNOWN_MSG;
+
+/* HTC ready message
+ * direction : target-to-host  */
+typedef PREPACK struct {
+    A_UINT16  MessageID;    /* ID */
+    A_UINT16  CreditCount;  /* number of credits the target can offer */
+    A_UINT16  CreditSize;   /* size of each credit */
+    A_UINT8   MaxEndpoints; /* maximum number of endpoints the target has resources for */
+    A_UINT8   _Pad1;
+} POSTPACK HTC_READY_MSG;
+
+#define HTC_SERVICE_META_DATA_MAX_LENGTH 128
+
+/* connect service
+ * direction : host-to-target */
+typedef PREPACK struct {
+    A_UINT16  MessageID;
+    A_UINT16  ServiceID;           /* service ID of the service to connect to */
+    A_UINT16  ConnectionFlags;     /* connection flags */
+
+#define HTC_CONNECT_FLAGS_REDUCE_CREDIT_DRIBBLE (1 << 2)  /* reduce credit dribbling when
+                                                             the host needs credits */
+#define HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_MASK             (0x3)
+#define HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_ONE_FOURTH        0x0
+#define HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_ONE_HALF          0x1
+#define HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_THREE_FOURTHS     0x2
+#define HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_UNITY             0x3
+
+    A_UINT8   ServiceMetaLength;   /* length of meta data that follows */
+    A_UINT8   _Pad1;
+
+    /* service-specific meta data starts after the header */
+
+} POSTPACK HTC_CONNECT_SERVICE_MSG;
+
+/* connect response
+ * direction : target-to-host */
+typedef PREPACK struct {
+    A_UINT16  MessageID;
+    A_UINT16  ServiceID;            /* service ID that the connection request was made */
+    A_UINT8   Status;               /* service connection status */
+    A_UINT8   EndpointID;           /* assigned endpoint ID */
+    A_UINT16  MaxMsgSize;           /* maximum expected message size on this endpoint */
+    A_UINT8   ServiceMetaLength;    /* length of meta data that follows */
+    A_UINT8   _Pad1;
+
+    /* service-specific meta data starts after the header */
+
+} POSTPACK HTC_CONNECT_SERVICE_RESPONSE_MSG;
+
+typedef PREPACK struct {
+    A_UINT16  MessageID;
+    /* currently, no other fields */
+} POSTPACK HTC_SETUP_COMPLETE_MSG;
+
+
+/* connect response status codes */
+#define HTC_SERVICE_SUCCESS      0  /* success */
+#define HTC_SERVICE_NOT_FOUND    1  /* service could not be found */
+#define HTC_SERVICE_FAILED       2  /* specific service failed the connect */
+#define HTC_SERVICE_NO_RESOURCES 3  /* no resources (i.e. no more endpoints) */
+#define HTC_SERVICE_NO_MORE_EP   4  /* specific service is not allowing any more
+                                       endpoints */
+
+/* report record IDs */
+typedef enum {
+    HTC_RECORD_NULL  = 0,
+    HTC_RECORD_CREDITS   = 1,
+    HTC_RECORD_LOOKAHEAD = 2,
+} HTC_RPT_IDS;
+
+typedef PREPACK struct {
+    A_UINT8 RecordID;     /* Record ID */
+    A_UINT8 Length;       /* Length of record */
+} POSTPACK HTC_RECORD_HDR;
+
+typedef PREPACK struct {
+    A_UINT8 EndpointID;     /* Endpoint that owns these credits */
+    A_UINT8 Credits;        /* credits to report since last report */
+} POSTPACK HTC_CREDIT_REPORT;
+
+typedef PREPACK struct {
+    A_UINT8 PreValid;         /* pre valid guard */
+    A_UINT8 LookAhead[4];     /* 4 byte lookahead */
+    A_UINT8 PostValid;        /* post valid guard */
+
+   /* NOTE: the LookAhead array is guarded by a PreValid and Post Valid guard bytes.
+    * The PreValid bytes must equal the inverse of the PostValid byte */
+
+} POSTPACK HTC_LOOKAHEAD_REPORT;
+
+
+#endif /* __HTC_H__ */
+
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/htc_api.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/htc_api.h
@@ -0,0 +1,471 @@
+/*
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef _HTC_API_H_
+#define _HTC_API_H_
+
+#include "../include/htc.h"
+#include "../include/htc_services.h"
+#include "../include/htc_packet.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* TODO.. for BMI */
+#define ENDPOINT1 0
+// TODO -remove me, but we have to fix BMI first
+#define HTC_MAILBOX_NUM_MAX    4
+
+/* this is the amount of header room required by users of HTC */
+#define HTC_HEADER_LEN         HTC_HDR_LENGTH
+
+typedef void *HTC_HANDLE;
+
+typedef A_UINT16 HTC_SERVICE_ID;
+
+typedef struct _HTC_INIT_INFO {
+    void   (*AddInstance)(HTC_HANDLE);
+    void   (*DeleteInstance)(void *Instance);
+    void   (*TargetFailure)(void *Instance, A_STATUS Status);
+} HTC_INIT_INFO;
+
+/* per service connection send completion */
+typedef void   (*HTC_EP_SEND_PKT_COMPLETE)(void *,HTC_PACKET *);
+/* per service connection pkt received */
+typedef void   (*HTC_EP_RECV_PKT)(void *,HTC_PACKET *);
+
+/* Optional per service connection receive buffer re-fill callback,
+ * On some OSes (like Linux) packets are allocated from a global pool and indicated up
+ * to the network stack.  The driver never gets the packets back from the OS.  For these OSes
+ * a refill callback can be used to allocate and re-queue buffers into HTC.
+ *
+ * On other OSes, the network stack can call into the driver's OS-specifc "return_packet" handler and
+ * the driver can re-queue these buffers into HTC. In this regard a refill callback is
+ * unnecessary */
+typedef void   (*HTC_EP_RECV_REFILL)(void *, HTC_ENDPOINT_ID Endpoint);
+
+/* Optional per service connection receive buffer allocation callback.
+ * On some systems packet buffers are an extremely limited resource.  Rather than
+ * queue largest-possible-sized buffers to HTC, some systems would rather
+ * allocate a specific size as the packet is received.  The trade off is
+ * slightly more processing (callback invoked for each RX packet)
+ * for the benefit of committing fewer buffer resources into HTC.
+ *
+ * The callback is provided the length of the pending packet to fetch. This includes the
+ * HTC header length plus the length of payload.  The callback can return a pointer to
+ * the allocated HTC packet for immediate use.
+ *
+ * NOTE*** This callback is mutually exclusive with the the refill callback above.
+ *
+ * */
+typedef HTC_PACKET *(*HTC_EP_RECV_ALLOC)(void *, HTC_ENDPOINT_ID Endpoint, int Length);
+
+typedef enum _HTC_SEND_FULL_ACTION {
+    HTC_SEND_FULL_KEEP = 0,  /* packet that overflowed should be kept in the queue */
+    HTC_SEND_FULL_DROP = 1,  /* packet that overflowed should be dropped */
+} HTC_SEND_FULL_ACTION;
+
+/* Optional per service connection callback when a send queue is full. This can occur if the
+ * host continues queueing up TX packets faster than credits can arrive
+ * To prevent the host (on some Oses like Linux) from continuously queueing packets
+ * and consuming resources, this callback is provided so that that the host
+ * can disable TX in the subsystem (i.e. network stack).
+ * This callback is invoked for each packet that "overflows" the HTC queue. The callback can
+ * determine whether the new packet that overflowed the queue can be kept (HTC_SEND_FULL_KEEP) or
+ * dropped (HTC_SEND_FULL_DROP).  If a packet is dropped, the EpTxComplete handler will be called
+ * and the packet's status field will be set to A_NO_RESOURCE.
+ * Other OSes require a "per-packet" indication for each completed TX packet, this
+ * closed loop mechanism will prevent the network stack from overunning the NIC
+ * The packet to keep or drop is passed for inspection to the registered handler the handler
+ * must ONLY inspect the packet, it may not free or reclaim the packet. */
+typedef HTC_SEND_FULL_ACTION (*HTC_EP_SEND_QUEUE_FULL)(void *, HTC_PACKET *pPacket);
+
+typedef struct _HTC_EP_CALLBACKS {
+    void                     *pContext;     /* context for each callback */
+    HTC_EP_SEND_PKT_COMPLETE EpTxComplete;  /* tx completion callback for connected endpoint */
+    HTC_EP_RECV_PKT          EpRecv;        /* receive callback for connected endpoint */
+    HTC_EP_RECV_REFILL       EpRecvRefill;  /* OPTIONAL receive re-fill callback for connected endpoint */
+    HTC_EP_SEND_QUEUE_FULL   EpSendFull;    /* OPTIONAL send full callback */
+    HTC_EP_RECV_ALLOC        EpRecvAlloc;   /* OPTIONAL recv allocation callback */
+} HTC_EP_CALLBACKS;
+
+/* service connection information */
+typedef struct _HTC_SERVICE_CONNECT_REQ {
+    HTC_SERVICE_ID   ServiceID;                 /* service ID to connect to */
+    A_UINT16         ConnectionFlags;           /* connection flags, see htc protocol definition */
+    A_UINT8         *pMetaData;                 /* ptr to optional service-specific meta-data */
+    A_UINT8          MetaDataLength;            /* optional meta data length */
+    HTC_EP_CALLBACKS EpCallbacks;               /* endpoint callbacks */
+    int              MaxSendQueueDepth;         /* maximum depth of any send queue */
+} HTC_SERVICE_CONNECT_REQ;
+
+/* service connection response information */
+typedef struct _HTC_SERVICE_CONNECT_RESP {
+    A_UINT8     *pMetaData;             /* caller supplied buffer to optional meta-data */
+    A_UINT8     BufferLength;           /* length of caller supplied buffer */
+    A_UINT8     ActualLength;           /* actual length of meta data */
+    HTC_ENDPOINT_ID Endpoint;           /* endpoint to communicate over */
+    int         MaxMsgLength;           /* max length of all messages over this endpoint */
+    A_UINT8     ConnectRespCode;        /* connect response code from target */
+} HTC_SERVICE_CONNECT_RESP;
+
+/* endpoint distribution structure */
+typedef struct _HTC_ENDPOINT_CREDIT_DIST {
+    struct _HTC_ENDPOINT_CREDIT_DIST *pNext;
+    struct _HTC_ENDPOINT_CREDIT_DIST *pPrev;
+    HTC_SERVICE_ID      ServiceID;          /* Service ID (set by HTC) */
+    HTC_ENDPOINT_ID     Endpoint;           /* endpoint for this distribution struct (set by HTC) */
+    A_UINT32            DistFlags;          /* distribution flags, distribution function can
+                                               set default activity using SET_EP_ACTIVE() macro */
+    int                 TxCreditsNorm;      /* credits for normal operation, anything above this
+                                               indicates the endpoint is over-subscribed, this field
+                                               is only relevant to the credit distribution function */
+    int                 TxCreditsMin;       /* floor for credit distribution, this field is
+                                               only relevant to the credit distribution function */
+    int                 TxCreditsAssigned;  /* number of credits assigned to this EP, this field
+                                               is only relevant to the credit dist function */
+    int                 TxCredits;          /* current credits available, this field is used by
+                                               HTC to determine whether a message can be sent or
+                                               must be queued */
+    int                 TxCreditsToDist;    /* pending credits to distribute on this endpoint, this
+                                               is set by HTC when credit reports arrive.
+                                               The credit distribution functions sets this to zero
+                                               when it distributes the credits */
+    int                 TxCreditsSeek;      /* this is the number of credits that the current pending TX
+                                               packet needs to transmit.  This is set by HTC when
+                                               and endpoint needs credits in order to transmit */
+    int                 TxCreditSize;       /* size in bytes of each credit (set by HTC) */
+    int                 TxCreditsPerMaxMsg; /* credits required for a maximum sized messages (set by HTC) */
+    void                *pHTCReserved;      /* reserved for HTC use */
+} HTC_ENDPOINT_CREDIT_DIST;
+
+#define HTC_EP_ACTIVE                            ((A_UINT32) (1 << 31))
+
+/* macro to check if an endpoint has gone active, useful for credit
+ * distributions */
+#define IS_EP_ACTIVE(epDist)  ((epDist)->DistFlags & HTC_EP_ACTIVE)
+#define SET_EP_ACTIVE(epDist) (epDist)->DistFlags |= HTC_EP_ACTIVE
+
+    /* credit distibution code that is passed into the distrbution function,
+     * there are mandatory and optional codes that must be handled */
+typedef enum _HTC_CREDIT_DIST_REASON {
+    HTC_CREDIT_DIST_SEND_COMPLETE = 0,     /* credits available as a result of completed
+                                              send operations (MANDATORY) resulting in credit reports */
+    HTC_CREDIT_DIST_ACTIVITY_CHANGE = 1,   /* a change in endpoint activity occured (OPTIONAL) */
+    HTC_CREDIT_DIST_SEEK_CREDITS,          /* an endpoint needs to "seek" credits (OPTIONAL) */
+    HTC_DUMP_CREDIT_STATE                  /* for debugging, dump any state information that is kept by
+                                              the distribution function */
+} HTC_CREDIT_DIST_REASON;
+
+typedef void (*HTC_CREDIT_DIST_CALLBACK)(void                     *Context,
+                                         HTC_ENDPOINT_CREDIT_DIST *pEPList,
+                                         HTC_CREDIT_DIST_REASON   Reason);
+
+typedef void (*HTC_CREDIT_INIT_CALLBACK)(void *Context,
+                                         HTC_ENDPOINT_CREDIT_DIST *pEPList,
+                                         int                      TotalCredits);
+
+    /* endpoint statistics action */
+typedef enum _HTC_ENDPOINT_STAT_ACTION {
+    HTC_EP_STAT_SAMPLE = 0,                /* only read statistics */
+    HTC_EP_STAT_SAMPLE_AND_CLEAR = 1,      /* sample and immediately clear statistics */
+    HTC_EP_STAT_CLEAR                      /* clear only */
+} HTC_ENDPOINT_STAT_ACTION;
+
+    /* endpoint statistics */
+typedef struct _HTC_ENDPOINT_STATS {
+    A_UINT32  TxCreditLowIndications;  /* number of times the host set the credit-low flag in a send message on
+                                        this endpoint */
+    A_UINT32  TxIssued;               /* running count of TX packets issued */
+    A_UINT32  TxDropped;              /* tx packets that were dropped */
+    A_UINT32  TxCreditRpts;           /* running count of total credit reports received for this endpoint */
+    A_UINT32  TxCreditRptsFromRx;     /* credit reports received from this endpoint's RX packets */
+    A_UINT32  TxCreditRptsFromOther;  /* credit reports received from RX packets of other endpoints */
+    A_UINT32  TxCreditRptsFromEp0;    /* credit reports received from endpoint 0 RX packets */
+    A_UINT32  TxCreditsFromRx;        /* count of credits received via Rx packets on this endpoint */
+    A_UINT32  TxCreditsFromOther;     /* count of credits received via another endpoint */
+    A_UINT32  TxCreditsFromEp0;       /* count of credits received via another endpoint */
+    A_UINT32  TxCreditsConsummed;     /* count of consummed credits */
+    A_UINT32  TxCreditsReturned;      /* count of credits returned */
+    A_UINT32  RxReceived;             /* count of RX packets received */
+    A_UINT32  RxLookAheads;           /* count of lookahead records
+                                         found in messages received on this endpoint */
+} HTC_ENDPOINT_STATS;
+
+/* ------ Function Prototypes ------ */
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Initialize HTC
+  @function name: HTCInit
+  @input:  pInfo - initialization information
+  @output:
+  @return: A_OK on success
+  @notes: The caller initializes global HTC state and registers various instance
+          notification callbacks (see HTC_INIT_INFO).
+
+  @example:
+  @see also: HTCShutdown
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+A_STATUS    HTCInit(HTC_INIT_INFO *pInfo);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Get the underlying HIF device handle
+  @function name: HTCGetHifDevice
+  @input:  HTCHandle - handle passed into the AddInstance callback
+  @output:
+  @return: opaque HIF device handle usable in HIF API calls.
+  @notes:
+  @example:
+  @see also:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void       *HTCGetHifDevice(HTC_HANDLE HTCHandle);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Set the associated instance for the HTC handle
+  @function name: HTCSetInstance
+  @input:  HTCHandle - handle passed into the AddInstance callback
+           Instance - caller supplied instance object
+  @output:
+  @return:
+  @notes:  Caller must set the instance information for the HTC handle in order to receive
+           notifications for instance deletion (DeleteInstance callback is called) and for target
+           failure notification.
+  @example:
+  @see also:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void        HTCSetInstance(HTC_HANDLE HTCHandle, void *Instance);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Set credit distribution parameters
+  @function name: HTCSetCreditDistribution
+  @input:  HTCHandle - HTC handle
+           pCreditDistCont - caller supplied context to pass into distribution functions
+           CreditDistFunc - Distribution function callback
+           CreditDistInit - Credit Distribution initialization callback
+           ServicePriorityOrder - Array containing list of service IDs, lowest index is highest
+                                  priority
+           ListLength - number of elements in ServicePriorityOrder
+  @output:
+  @return:
+  @notes:  The user can set a custom credit distribution function to handle special requirements
+           for each endpoint.  A default credit distribution routine can be used by setting
+           CreditInitFunc to NULL.  The default credit distribution is only provided for simple
+           "fair" credit distribution without regard to any prioritization.
+
+  @example:
+  @see also:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void        HTCSetCreditDistribution(HTC_HANDLE               HTCHandle,
+                                     void                     *pCreditDistContext,
+                                     HTC_CREDIT_DIST_CALLBACK CreditDistFunc,
+                                     HTC_CREDIT_INIT_CALLBACK CreditInitFunc,
+                                     HTC_SERVICE_ID           ServicePriorityOrder[],
+                                     int                      ListLength);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Wait for the target to indicate the HTC layer is ready
+  @function name: HTCWaitTarget
+  @input:  HTCHandle - HTC handle
+  @output:
+  @return:
+  @notes:  This API blocks until the target responds with an HTC ready message.
+           The caller should not connect services until the target has indicated it is
+           ready.
+  @example:
+  @see also: HTCConnectService
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+A_STATUS    HTCWaitTarget(HTC_HANDLE HTCHandle);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Start target service communications
+  @function name: HTCStart
+  @input:  HTCHandle - HTC handle
+  @output:
+  @return:
+  @notes: This API indicates to the target that the service connection phase is complete
+          and the target can freely start all connected services.  This API should only be
+          called AFTER all service connections have been made.  TCStart will issue a
+          SETUP_COMPLETE message to the target to indicate that all service connections
+          have been made and the target can start communicating over the endpoints.
+  @example:
+  @see also: HTCConnectService
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+A_STATUS    HTCStart(HTC_HANDLE HTCHandle);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Add receive packet to HTC
+  @function name: HTCAddReceivePkt
+  @input:  HTCHandle - HTC handle
+           pPacket - HTC receive packet to add
+  @output:
+  @return: A_OK on success
+  @notes:  user must supply HTC packets for capturing incomming HTC frames.  The caller
+           must initialize each HTC packet using the SET_HTC_PACKET_INFO_RX_REFILL()
+           macro.
+  @example:
+  @see also:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+A_STATUS    HTCAddReceivePkt(HTC_HANDLE HTCHandle, HTC_PACKET *pPacket);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Connect to an HTC service
+  @function name: HTCConnectService
+  @input:  HTCHandle - HTC handle
+           pReq - connection details
+  @output: pResp - connection response
+  @return:
+  @notes:  Service connections must be performed before HTCStart.  User provides callback handlers
+           for various endpoint events.
+  @example:
+  @see also: HTCStart
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+A_STATUS    HTCConnectService(HTC_HANDLE HTCHandle,
+                              HTC_SERVICE_CONNECT_REQ  *pReq,
+                              HTC_SERVICE_CONNECT_RESP *pResp);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Send an HTC packet
+  @function name: HTCSendPkt
+  @input:  HTCHandle - HTC handle
+           pPacket - packet to send
+  @output:
+  @return: A_OK
+  @notes:  Caller must initialize packet using SET_HTC_PACKET_INFO_TX() macro.
+           This interface is fully asynchronous.  On error, HTC SendPkt will
+           call the registered Endpoint callback to cleanup the packet.
+  @example:
+  @see also: HTCFlushEndpoint
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+A_STATUS    HTCSendPkt(HTC_HANDLE HTCHandle, HTC_PACKET *pPacket);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Stop HTC service communications
+  @function name: HTCStop
+  @input:  HTCHandle - HTC handle
+  @output:
+  @return:
+  @notes: HTC communications is halted.  All receive and pending TX packets will
+          be flushed.
+  @example:
+  @see also:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void        HTCStop(HTC_HANDLE HTCHandle);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Shutdown HTC
+  @function name: HTCShutdown
+  @input:
+  @output:
+  @return:
+  @notes:  This cleans up all resources allocated by HTCInit().
+  @example:
+  @see also: HTCInit
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void        HTCShutDown(void);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Flush pending TX packets
+  @function name: HTCFlushEndpoint
+  @input:  HTCHandle - HTC handle
+           Endpoint - Endpoint to flush
+           Tag - flush tag
+  @output:
+  @return:
+  @notes:  The Tag parameter is used to selectively flush packets with matching tags.
+           The value of 0 forces all packets to be flush regardless of tag.
+  @example:
+  @see also: HTCSendPkt
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void        HTCFlushEndpoint(HTC_HANDLE HTCHandle, HTC_ENDPOINT_ID Endpoint, HTC_TX_TAG Tag);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Dump credit distribution state
+  @function name: HTCDumpCreditStates
+  @input:  HTCHandle - HTC handle
+  @output:
+  @return:
+  @notes:  This dumps all credit distribution information to the debugger
+  @example:
+  @see also:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void        HTCDumpCreditStates(HTC_HANDLE HTCHandle);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Indicate a traffic activity change on an endpoint
+  @function name: HTCIndicateActivityChange
+  @input:  HTCHandle - HTC handle
+           Endpoint - endpoint in which activity has changed
+           Active - TRUE if active, FALSE if it has become inactive
+  @output:
+  @return:
+  @notes:  This triggers the registered credit distribution function to
+           re-adjust credits for active/inactive endpoints.
+  @example:
+  @see also:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void        HTCIndicateActivityChange(HTC_HANDLE      HTCHandle,
+                                      HTC_ENDPOINT_ID Endpoint,
+                                      A_BOOL          Active);
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Get endpoint statistics
+  @function name: HTCGetEndpointStatistics
+  @input:  HTCHandle - HTC handle
+           Endpoint - Endpoint identifier
+           Action - action to take with statistics
+  @output:
+           pStats - statistics that were sampled (can be NULL if Action is HTC_EP_STAT_CLEAR)
+
+  @return: TRUE if statistics profiling is enabled, otherwise FALSE.
+
+  @notes:  Statistics is a compile-time option and this function may return FALSE
+           if HTC is not compiled with profiling.
+
+           The caller can specify the statistic "action" to take when sampling
+           the statistics.  This includes:
+
+           HTC_EP_STAT_SAMPLE: The pStats structure is filled with the current values.
+           HTC_EP_STAT_SAMPLE_AND_CLEAR: The structure is filled and the current statistics
+                             are cleared.
+           HTC_EP_STAT_CLEA : the statistics are cleared, the called can pass a NULL value for
+                   pStats
+
+  @example:
+  @see also:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+A_BOOL       HTCGetEndpointStatistics(HTC_HANDLE               HTCHandle,
+                                      HTC_ENDPOINT_ID          Endpoint,
+                                      HTC_ENDPOINT_STAT_ACTION Action,
+                                      HTC_ENDPOINT_STATS       *pStats);
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Unblock HTC message reception
+  @function name: HTCUnblockRecv
+  @input:  HTCHandle - HTC handle
+  @output:
+  @return:
+  @notes:
+           HTC will block the receiver if the EpRecvAlloc callback fails to provide a packet.
+           The caller can use this API to indicate to HTC when resources (buffers) are available
+           such that the  receiver can be unblocked and HTC may re-attempt fetching the pending message.
+
+           This API is not required if the user uses the EpRecvRefill callback or uses the HTCAddReceivePacket()
+           API to recycle or provide receive packets to HTC.
+
+  @example:
+  @see also:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void HTCUnblockRecv(HTC_HANDLE HTCHandle);
+
+/* internally used functions for testing... */
+void HTCEnableRecv(HTC_HANDLE HTCHandle);
+void HTCDisableRecv(HTC_HANDLE HTCHandle);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _HTC_API_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/htc_packet.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/htc_packet.h
@@ -0,0 +1,157 @@
+/*
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef HTC_PACKET_H_
+#define HTC_PACKET_H_
+
+
+#include "../include/dl_list.h"
+
+/* ------ Endpoint IDS ------ */
+typedef enum
+{
+    ENDPOINT_UNUSED = -1,
+    ENDPOINT_0 = 0,
+    ENDPOINT_1 = 1,
+    ENDPOINT_2 = 2,
+    ENDPOINT_3,
+    ENDPOINT_4,
+    ENDPOINT_5,
+    ENDPOINT_6,
+    ENDPOINT_7,
+    ENDPOINT_8,
+    ENDPOINT_MAX,
+} HTC_ENDPOINT_ID;
+
+struct _HTC_PACKET;
+
+typedef void (* HTC_PACKET_COMPLETION)(void *,struct _HTC_PACKET *);
+
+typedef A_UINT16 HTC_TX_TAG;
+
+typedef struct _HTC_TX_PACKET_INFO {
+    HTC_TX_TAG    Tag;            /* tag used to selective flush packets */
+} HTC_TX_PACKET_INFO;
+
+#define HTC_TX_PACKET_TAG_ALL          0    /* a tag of zero is reserved and used to flush ALL packets */
+#define HTC_TX_PACKET_TAG_INTERNAL     1                                /* internal tags start here */
+#define HTC_TX_PACKET_TAG_USER_DEFINED (HTC_TX_PACKET_TAG_INTERNAL + 9) /* user-defined tags start here */
+
+typedef struct _HTC_RX_PACKET_INFO {
+    A_UINT32    Unused;          /* for future use and to make compilers happy */
+} HTC_RX_PACKET_INFO;
+
+/* wrapper around endpoint-specific packets */
+typedef struct _HTC_PACKET {
+    DL_LIST         ListLink;       /* double link */
+    void            *pPktContext;   /* caller's per packet specific context */
+
+    A_UINT8         *pBufferStart;  /* the true buffer start , the caller can
+                                       store the real buffer start here.  In
+                                       receive callbacks, the HTC layer sets pBuffer
+                                       to the start of the payload past the header. This
+                                       field allows the caller to reset pBuffer when it
+                                       recycles receive packets back to HTC */
+    /*
+     * Pointer to the start of the buffer. In the transmit
+     * direction this points to the start of the payload. In the
+     * receive direction, however, the buffer when queued up
+     * points to the start of the HTC header but when returned
+     * to the caller points to the start of the payload
+     */
+    A_UINT8         *pBuffer;       /* payload start (RX/TX) */
+    A_UINT32        BufferLength;   /* length of buffer */
+    A_UINT32        ActualLength;   /* actual length of payload */
+    HTC_ENDPOINT_ID Endpoint;       /* endpoint that this packet was sent/recv'd from */
+    A_STATUS        Status;         /* completion status */
+    union {
+        HTC_TX_PACKET_INFO  AsTx;   /* Tx Packet specific info */
+        HTC_RX_PACKET_INFO  AsRx;   /* Rx Packet specific info */
+    } PktInfo;
+
+    /* the following fields are for internal HTC use */
+    HTC_PACKET_COMPLETION Completion;   /* completion */
+    void                  *pContext;    /* HTC private completion context */
+    A_UINT32              HTCReserved;  /* reserved */
+} HTC_PACKET;
+
+
+
+#define COMPLETE_HTC_PACKET(p,status)        \
+{                                            \
+    (p)->Status = (status);                  \
+    (p)->Completion((p)->pContext,(p));      \
+}
+
+#define INIT_HTC_PACKET_INFO(p,b,len)             \
+{                                                 \
+    (p)->pBufferStart = (b);                      \
+    (p)->BufferLength = (len);                    \
+}
+
+/* macro to set an initial RX packet for refilling HTC */
+#define SET_HTC_PACKET_INFO_RX_REFILL(p,c,b,len,ep) \
+{                                                 \
+    (p)->pPktContext = (c);                       \
+    (p)->pBuffer = (b);                           \
+    (p)->pBufferStart = (b);                      \
+    (p)->BufferLength = (len);                    \
+    (p)->Endpoint = (ep);                         \
+}
+
+/* fast macro to recycle an RX packet that will be re-queued to HTC */
+#define HTC_PACKET_RESET_RX(p)              \
+    (p)->pBuffer = (p)->pBufferStart
+
+/* macro to set packet parameters for TX */
+#define SET_HTC_PACKET_INFO_TX(p,c,b,len,ep,tag)  \
+{                                                 \
+    (p)->pPktContext = (c);                       \
+    (p)->pBuffer = (b);                           \
+    (p)->ActualLength = (len);                    \
+    (p)->Endpoint = (ep);                         \
+    (p)->PktInfo.AsTx.Tag = (tag);                \
+}
+
+/* HTC Packet Queueing Macros */
+typedef DL_LIST HTC_PACKET_QUEUE;
+/* initialize queue */
+#define INIT_HTC_PACKET_QUEUE(pQ) DL_LIST_INIT((pQ))
+/* enqueue HTC packet to the tail of the queue */
+#define HTC_PACKET_ENQUEUE(pQ,p)  DL_ListInsertTail((pQ),&(p)->ListLink)
+/* test if a queue is empty */
+#define HTC_QUEUE_EMPTY(pQ)       DL_LIST_IS_EMPTY((pQ))
+/* get packet at head without removing it */
+#define HTC_GET_PKT_AT_HEAD(pQ)   A_CONTAINING_STRUCT((DL_LIST_GET_ITEM_AT_HEAD(pQ)),HTC_PACKET,ListLink);
+/* remove a packet from the current list it is linked to */
+#define HTC_PACKET_REMOVE(p)      DL_ListRemove(&(p)->ListLink)
+
+/* dequeue an HTC packet from the head of the queue */
+static INLINE HTC_PACKET *HTC_PACKET_DEQUEUE(HTC_PACKET_QUEUE *queue) {
+    DL_LIST    *pItem = DL_ListRemoveItemFromHead(queue);
+    if (pItem != NULL) {
+        return A_CONTAINING_STRUCT(pItem, HTC_PACKET, ListLink);
+    }
+    return NULL;
+}
+
+#define HTC_GET_ENDPOINT_FROM_PKT(p) (p)->Endpoint
+#define HTC_GET_TAG_FROM_PKT(p)      (p)->PktInfo.AsTx.Tag
+
+#endif /*HTC_PACKET_H_*/
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/htc_services.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/htc_services.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ */
+
+#ifndef __HTC_SERVICES_H__
+#define __HTC_SERVICES_H__
+
+/* Current service IDs */
+
+typedef enum {
+    RSVD_SERVICE_GROUP  = 0,
+    WMI_SERVICE_GROUP   = 1,
+
+    HTC_TEST_GROUP = 254,
+    HTC_SERVICE_GROUP_LAST = 255
+}HTC_SERVICE_GROUP_IDS;
+
+#define MAKE_SERVICE_ID(group,index) \
+            (int)(((int)group << 8) | (int)(index))
+
+/* NOTE: service ID of 0x0000 is reserved and should never be used */
+#define HTC_CTRL_RSVD_SVC MAKE_SERVICE_ID(RSVD_SERVICE_GROUP,1)
+#define WMI_CONTROL_SVC   MAKE_SERVICE_ID(WMI_SERVICE_GROUP,0)
+#define WMI_DATA_BE_SVC   MAKE_SERVICE_ID(WMI_SERVICE_GROUP,1)
+#define WMI_DATA_BK_SVC   MAKE_SERVICE_ID(WMI_SERVICE_GROUP,2)
+#define WMI_DATA_VI_SVC   MAKE_SERVICE_ID(WMI_SERVICE_GROUP,3)
+#define WMI_DATA_VO_SVC   MAKE_SERVICE_ID(WMI_SERVICE_GROUP,4)
+#define WMI_MAX_SERVICES  5
+
+/* raw stream service (i.e. flash, tcmd, calibration apps) */
+#define HTC_RAW_STREAMS_SVC MAKE_SERVICE_ID(HTC_TEST_GROUP,0)
+
+#endif /*HTC_SERVICES_H_*/
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/ieee80211.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/ieee80211.h
@@ -0,0 +1,343 @@
+/*-
+ * Copyright (c) 2001 Atsushi Onoe
+ * Copyright (c) 2002-2004 Sam Leffler, Errno Consulting
+ * Copyright (c) 2006 Atheros Communications, Inc.
+ *
+ * Wireless Network driver for Atheros AR6001
+ * All rights reserved.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef _NET80211_IEEE80211_H_
+#define _NET80211_IEEE80211_H_
+
+
+/*
+ * 802.11 protocol definitions.
+ */
+
+#define IEEE80211_ADDR_LEN  6       /* size of 802.11 address */
+/* is 802.11 address multicast/broadcast? */
+#define IEEE80211_IS_MULTICAST(_a)  (*(_a) & 0x01)
+#define IEEE80211_ADDR_EQ(addr1, addr2)     \
+    (A_MEMCMP(addr1, addr2, IEEE80211_ADDR_LEN) == 0)
+
+#define IEEE80211_KEYBUF_SIZE 16
+#define IEEE80211_MICBUF_SIZE (8+8)  /* space for both tx and rx */
+
+/*
+ * NB: these values are ordered carefully; there are lots of
+ * of implications in any reordering.  In particular beware
+ * that 4 is not used to avoid conflicting with IEEE80211_F_PRIVACY.
+ */
+#define IEEE80211_CIPHER_WEP            0
+#define IEEE80211_CIPHER_TKIP           1
+#define IEEE80211_CIPHER_AES_OCB        2
+#define IEEE80211_CIPHER_AES_CCM        3
+#define IEEE80211_CIPHER_CKIP           5
+#define IEEE80211_CIPHER_CCKM_KRK       6
+#define IEEE80211_CIPHER_NONE           7       /* pseudo value */
+
+#define IEEE80211_CIPHER_MAX            (IEEE80211_CIPHER_NONE+1)
+
+#define IEEE80211_IS_VALID_WEP_CIPHER_LEN(len) \
+        (((len) == 5) || ((len) == 13) || ((len) == 16))
+
+
+
+/*
+ * generic definitions for IEEE 802.11 frames
+ */
+PREPACK struct ieee80211_frame {
+    A_UINT8    i_fc[2];
+    A_UINT8    i_dur[2];
+    A_UINT8    i_addr1[IEEE80211_ADDR_LEN];
+    A_UINT8    i_addr2[IEEE80211_ADDR_LEN];
+    A_UINT8    i_addr3[IEEE80211_ADDR_LEN];
+    A_UINT8    i_seq[2];
+    /* possibly followed by addr4[IEEE80211_ADDR_LEN]; */
+    /* see below */
+} POSTPACK;
+
+#define IEEE80211_FC0_VERSION_MASK          0x03
+#define IEEE80211_FC0_VERSION_SHIFT         0
+#define IEEE80211_FC0_VERSION_0             0x00
+#define IEEE80211_FC0_TYPE_MASK             0x0c
+#define IEEE80211_FC0_TYPE_SHIFT            2
+#define IEEE80211_FC0_TYPE_MGT              0x00
+#define IEEE80211_FC0_TYPE_CTL              0x04
+#define IEEE80211_FC0_TYPE_DATA             0x08
+
+#define IEEE80211_FC0_SUBTYPE_MASK          0xf0
+#define IEEE80211_FC0_SUBTYPE_SHIFT         4
+/* for TYPE_MGT */
+#define IEEE80211_FC0_SUBTYPE_ASSOC_REQ     0x00
+#define IEEE80211_FC0_SUBTYPE_ASSOC_RESP    0x10
+#define IEEE80211_FC0_SUBTYPE_REASSOC_REQ   0x20
+#define IEEE80211_FC0_SUBTYPE_REASSOC_RESP  0x30
+#define IEEE80211_FC0_SUBTYPE_PROBE_REQ     0x40
+#define IEEE80211_FC0_SUBTYPE_PROBE_RESP    0x50
+#define IEEE80211_FC0_SUBTYPE_BEACON        0x80
+#define IEEE80211_FC0_SUBTYPE_ATIM          0x90
+#define IEEE80211_FC0_SUBTYPE_DISASSOC      0xa0
+#define IEEE80211_FC0_SUBTYPE_AUTH          0xb0
+#define IEEE80211_FC0_SUBTYPE_DEAUTH        0xc0
+/* for TYPE_CTL */
+#define IEEE80211_FC0_SUBTYPE_PS_POLL       0xa0
+#define IEEE80211_FC0_SUBTYPE_RTS           0xb0
+#define IEEE80211_FC0_SUBTYPE_CTS           0xc0
+#define IEEE80211_FC0_SUBTYPE_ACK           0xd0
+#define IEEE80211_FC0_SUBTYPE_CF_END        0xe0
+#define IEEE80211_FC0_SUBTYPE_CF_END_ACK    0xf0
+/* for TYPE_DATA (bit combination) */
+#define IEEE80211_FC0_SUBTYPE_DATA          0x00
+#define IEEE80211_FC0_SUBTYPE_CF_ACK        0x10
+#define IEEE80211_FC0_SUBTYPE_CF_POLL       0x20
+#define IEEE80211_FC0_SUBTYPE_CF_ACPL       0x30
+#define IEEE80211_FC0_SUBTYPE_NODATA        0x40
+#define IEEE80211_FC0_SUBTYPE_CFACK         0x50
+#define IEEE80211_FC0_SUBTYPE_CFPOLL        0x60
+#define IEEE80211_FC0_SUBTYPE_CF_ACK_CF_ACK 0x70
+#define IEEE80211_FC0_SUBTYPE_QOS           0x80
+#define IEEE80211_FC0_SUBTYPE_QOS_NULL      0xc0
+
+#define IEEE80211_FC1_DIR_MASK              0x03
+#define IEEE80211_FC1_DIR_NODS              0x00    /* STA->STA */
+#define IEEE80211_FC1_DIR_TODS              0x01    /* STA->AP  */
+#define IEEE80211_FC1_DIR_FROMDS            0x02    /* AP ->STA */
+#define IEEE80211_FC1_DIR_DSTODS            0x03    /* AP ->AP  */
+
+#define IEEE80211_FC1_MORE_FRAG             0x04
+#define IEEE80211_FC1_RETRY                 0x08
+#define IEEE80211_FC1_PWR_MGT               0x10
+#define IEEE80211_FC1_MORE_DATA             0x20
+#define IEEE80211_FC1_WEP                   0x40
+#define IEEE80211_FC1_ORDER                 0x80
+
+#define IEEE80211_SEQ_FRAG_MASK             0x000f
+#define IEEE80211_SEQ_FRAG_SHIFT            0
+#define IEEE80211_SEQ_SEQ_MASK              0xfff0
+#define IEEE80211_SEQ_SEQ_SHIFT             4
+
+#define IEEE80211_NWID_LEN                  32
+
+/*
+ * 802.11 rate set.
+ */
+#define IEEE80211_RATE_SIZE     8       /* 802.11 standard */
+#define IEEE80211_RATE_MAXSIZE  15      /* max rates we'll handle */
+
+#define WMM_NUM_AC                  4   /* 4 AC categories */
+
+#define WMM_PARAM_ACI_M         0x60    /* Mask for ACI field */
+#define WMM_PARAM_ACI_S         5   /* Shift for ACI field */
+#define WMM_PARAM_ACM_M         0x10    /* Mask for ACM bit */
+#define WMM_PARAM_ACM_S         4       /* Shift for ACM bit */
+#define WMM_PARAM_AIFSN_M       0x0f    /* Mask for aifsn field */
+#define WMM_PARAM_LOGCWMIN_M    0x0f    /* Mask for CwMin field (in log) */
+#define WMM_PARAM_LOGCWMAX_M    0xf0    /* Mask for CwMax field (in log) */
+#define WMM_PARAM_LOGCWMAX_S    4   /* Shift for CwMax field */
+
+#define WMM_AC_TO_TID(_ac) (       \
+    ((_ac) == WMM_AC_VO) ? 6 : \
+    ((_ac) == WMM_AC_VI) ? 5 : \
+    ((_ac) == WMM_AC_BK) ? 1 : \
+    0)
+
+#define TID_TO_WMM_AC(_tid) (      \
+    ((_tid) < 1) ? WMM_AC_BE : \
+    ((_tid) < 3) ? WMM_AC_BK : \
+    ((_tid) < 6) ? WMM_AC_VI : \
+    WMM_AC_VO)
+/*
+ * Management information element payloads.
+ */
+
+enum {
+    IEEE80211_ELEMID_SSID       = 0,
+    IEEE80211_ELEMID_RATES      = 1,
+    IEEE80211_ELEMID_FHPARMS    = 2,
+    IEEE80211_ELEMID_DSPARMS    = 3,
+    IEEE80211_ELEMID_CFPARMS    = 4,
+    IEEE80211_ELEMID_TIM        = 5,
+    IEEE80211_ELEMID_IBSSPARMS  = 6,
+    IEEE80211_ELEMID_COUNTRY    = 7,
+    IEEE80211_ELEMID_CHALLENGE  = 16,
+    /* 17-31 reserved for challenge text extension */
+    IEEE80211_ELEMID_PWRCNSTR   = 32,
+    IEEE80211_ELEMID_PWRCAP     = 33,
+    IEEE80211_ELEMID_TPCREQ     = 34,
+    IEEE80211_ELEMID_TPCREP     = 35,
+    IEEE80211_ELEMID_SUPPCHAN   = 36,
+    IEEE80211_ELEMID_CHANSWITCH = 37,
+    IEEE80211_ELEMID_MEASREQ    = 38,
+    IEEE80211_ELEMID_MEASREP    = 39,
+    IEEE80211_ELEMID_QUIET      = 40,
+    IEEE80211_ELEMID_IBSSDFS    = 41,
+    IEEE80211_ELEMID_ERP        = 42,
+    IEEE80211_ELEMID_RSN        = 48,
+    IEEE80211_ELEMID_XRATES     = 50,
+    IEEE80211_ELEMID_TPC        = 150,
+    IEEE80211_ELEMID_CCKM       = 156,
+    IEEE80211_ELEMID_VENDOR     = 221,  /* vendor private */
+};
+
+#define ATH_OUI             0x7f0300        /* Atheros OUI */
+#define ATH_OUI_TYPE        0x01
+#define ATH_OUI_SUBTYPE     0x01
+#define ATH_OUI_VERSION     0x00
+
+#define WPA_OUI             0xf25000
+#define WPA_OUI_TYPE        0x01
+#define WPA_VERSION         1          /* current supported version */
+
+#define WPA_CSE_NULL        0x00
+#define WPA_CSE_WEP40       0x01
+#define WPA_CSE_TKIP        0x02
+#define WPA_CSE_CCMP        0x04
+#define WPA_CSE_WEP104      0x05
+
+#define WPA_ASE_NONE        0x00
+#define WPA_ASE_8021X_UNSPEC    0x01
+#define WPA_ASE_8021X_PSK   0x02
+
+#define RSN_OUI         0xac0f00
+#define RSN_VERSION     1       /* current supported version */
+
+#define RSN_CSE_NULL        0x00
+#define RSN_CSE_WEP40       0x01
+#define RSN_CSE_TKIP        0x02
+#define RSN_CSE_WRAP        0x03
+#define RSN_CSE_CCMP        0x04
+#define RSN_CSE_WEP104      0x05
+
+#define RSN_ASE_NONE        0x00
+#define RSN_ASE_8021X_UNSPEC    0x01
+#define RSN_ASE_8021X_PSK   0x02
+
+#define RSN_CAP_PREAUTH     0x01
+
+#define WMM_OUI         0xf25000
+#define WMM_OUI_TYPE        0x02
+#define WMM_INFO_OUI_SUBTYPE    0x00
+#define WMM_PARAM_OUI_SUBTYPE   0x01
+#define WMM_VERSION     1
+
+/* WMM stream classes */
+#define WMM_NUM_AC  4
+#define WMM_AC_BE   0       /* best effort */
+#define WMM_AC_BK   1       /* background */
+#define WMM_AC_VI   2       /* video */
+#define WMM_AC_VO   3       /* voice */
+
+/* TSPEC related */
+#define ACTION_CATEGORY_CODE_TSPEC                 17
+#define ACTION_CODE_TSPEC_ADDTS                    0
+#define ACTION_CODE_TSPEC_ADDTS_RESP               1
+#define ACTION_CODE_TSPEC_DELTS                    2
+
+typedef enum {
+    TSPEC_STATUS_CODE_ADMISSION_ACCEPTED = 0,
+    TSPEC_STATUS_CODE_ADDTS_INVALID_PARAMS = 0x1,
+    TSPEC_STATUS_CODE_ADDTS_REQUEST_REFUSED = 0x3,
+    TSPEC_STATUS_CODE_UNSPECIFIED_QOS_RELATED_FAILURE = 0xC8,
+    TSPEC_STATUS_CODE_REQUESTED_REFUSED_POLICY_CONFIGURATION = 0xC9,
+    TSPEC_STATUS_CODE_INSUFFCIENT_BANDWIDTH = 0xCA,
+    TSPEC_STATUS_CODE_INVALID_PARAMS = 0xCB,
+    TSPEC_STATUS_CODE_DELTS_SENT    = 0x30,
+    TSPEC_STATUS_CODE_DELTS_RECV    = 0x31,
+} TSPEC_STATUS_CODE;
+
+#define TSPEC_TSID_MASK             0xF
+#define TSPEC_TSID_S                1
+
+/*
+ * WMM/802.11e Tspec Element
+ */
+typedef PREPACK struct wmm_tspec_ie_t {
+    A_UINT8     elementId;
+    A_UINT8     len;
+    A_UINT8     oui[3];
+    A_UINT8     ouiType;
+    A_UINT8     ouiSubType;
+    A_UINT8     version;
+    A_UINT16    tsInfo_info;
+    A_UINT8     tsInfo_reserved;
+    A_UINT16    nominalMSDU;
+    A_UINT16    maxMSDU;
+    A_UINT32    minServiceInt;
+    A_UINT32    maxServiceInt;
+    A_UINT32    inactivityInt;
+    A_UINT32    suspensionInt;
+    A_UINT32    serviceStartTime;
+    A_UINT32    minDataRate;
+    A_UINT32    meanDataRate;
+    A_UINT32    peakDataRate;
+    A_UINT32    maxBurstSize;
+    A_UINT32    delayBound;
+    A_UINT32    minPhyRate;
+    A_UINT16    sba;
+    A_UINT16    mediumTime;
+} POSTPACK WMM_TSPEC_IE;
+
+
+/*
+ * BEACON management packets
+ *
+ *  octet timestamp[8]
+ *  octet beacon interval[2]
+ *  octet capability information[2]
+ *  information element
+ *      octet elemid
+ *      octet length
+ *      octet information[length]
+ */
+
+#define IEEE80211_BEACON_INTERVAL(beacon) \
+    ((beacon)[8] | ((beacon)[9] << 8))
+#define IEEE80211_BEACON_CAPABILITY(beacon) \
+    ((beacon)[10] | ((beacon)[11] << 8))
+
+#define IEEE80211_CAPINFO_ESS               0x0001
+#define IEEE80211_CAPINFO_IBSS              0x0002
+#define IEEE80211_CAPINFO_CF_POLLABLE       0x0004
+#define IEEE80211_CAPINFO_CF_POLLREQ        0x0008
+#define IEEE80211_CAPINFO_PRIVACY           0x0010
+#define IEEE80211_CAPINFO_SHORT_PREAMBLE    0x0020
+#define IEEE80211_CAPINFO_PBCC              0x0040
+#define IEEE80211_CAPINFO_CHNL_AGILITY      0x0080
+/* bits 8-9 are reserved */
+#define IEEE80211_CAPINFO_SHORT_SLOTTIME    0x0400
+#define IEEE80211_CAPINFO_APSD              0x0800
+/* bit 12 is reserved */
+#define IEEE80211_CAPINFO_DSSSOFDM          0x2000
+/* bits 14-15 are reserved */
+
+/*
+ * Authentication Modes
+ */
+
+enum ieee80211_authmode {
+    IEEE80211_AUTH_NONE     = 0,
+    IEEE80211_AUTH_OPEN     = 1,
+    IEEE80211_AUTH_SHARED   = 2,
+    IEEE80211_AUTH_8021X    = 3,
+    IEEE80211_AUTH_AUTO     = 4,   /* auto-select/accept */
+    /* NB: these are used only for ioctls */
+    IEEE80211_AUTH_WPA      = 5,  /* WPA/RSN  w/ 802.1x */
+    IEEE80211_AUTH_WPA_PSK  = 6,  /* WPA/RSN  w/ PSK */
+    IEEE80211_AUTH_WPA_CCKM = 7,  /* WPA/RSN IE  w/ CCKM */
+};
+
+
+#endif /* _NET80211_IEEE80211_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/ieee80211_ioctl.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/ieee80211_ioctl.h
@@ -0,0 +1,163 @@
+/*
+ * Copyright (c) 2004-2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/os/linux/include/ieee80211_ioctl.h#1 $
+ */
+
+#ifndef _IEEE80211_IOCTL_H_
+#define _IEEE80211_IOCTL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Extracted from the MADWIFI net80211/ieee80211_ioctl.h
+ */
+
+/*
+ * WPA/RSN get/set key request.  Specify the key/cipher
+ * type and whether the key is to be used for sending and/or
+ * receiving.  The key index should be set only when working
+ * with global keys (use IEEE80211_KEYIX_NONE for ``no index'').
+ * Otherwise a unicast/pairwise key is specified by the bssid
+ * (on a station) or mac address (on an ap).  They key length
+ * must include any MIC key data; otherwise it should be no
+ more than IEEE80211_KEYBUF_SIZE.
+ */
+struct ieee80211req_key {
+	u_int8_t	ik_type;	/* key/cipher type */
+	u_int8_t	ik_pad;
+	u_int16_t	ik_keyix;	/* key index */
+	u_int8_t	ik_keylen;	/* key length in bytes */
+	u_int8_t	ik_flags;
+#define IEEE80211_KEY_XMIT  0x01
+#define IEEE80211_KEY_RECV  0x02
+#define	IEEE80211_KEY_DEFAULT	0x80	/* default xmit key */
+	u_int8_t	ik_macaddr[IEEE80211_ADDR_LEN];
+	u_int64_t	ik_keyrsc;	/* key receive sequence counter */
+	u_int64_t	ik_keytsc;	/* key transmit sequence counter */
+	u_int8_t	ik_keydata[IEEE80211_KEYBUF_SIZE+IEEE80211_MICBUF_SIZE];
+};
+/*
+ * Delete a key either by index or address.  Set the index
+ * to IEEE80211_KEYIX_NONE when deleting a unicast key.
+ */
+struct ieee80211req_del_key {
+	u_int8_t	idk_keyix;	/* key index */
+	u_int8_t	idk_macaddr[IEEE80211_ADDR_LEN];
+};
+/*
+ * MLME state manipulation request.  IEEE80211_MLME_ASSOC
+ * only makes sense when operating as a station.  The other
+ * requests can be used when operating as a station or an
+ * ap (to effect a station).
+ */
+struct ieee80211req_mlme {
+	u_int8_t	im_op;		/* operation to perform */
+#define	IEEE80211_MLME_ASSOC		1	/* associate station */
+#define	IEEE80211_MLME_DISASSOC		2	/* disassociate station */
+#define	IEEE80211_MLME_DEAUTH		3	/* deauthenticate station */
+#define	IEEE80211_MLME_AUTHORIZE	4	/* authorize station */
+#define	IEEE80211_MLME_UNAUTHORIZE	5	/* unauthorize station */
+	u_int16_t	im_reason;	/* 802.11 reason code */
+	u_int8_t	im_macaddr[IEEE80211_ADDR_LEN];
+};
+
+struct ieee80211req_addpmkid {
+    u_int8_t    pi_bssid[IEEE80211_ADDR_LEN];
+    u_int8_t    pi_enable;
+    u_int8_t    pi_pmkid[16];
+};
+
+#define AUTH_ALG_OPEN_SYSTEM	0x01
+#define AUTH_ALG_SHARED_KEY	0x02
+#define AUTH_ALG_LEAP		0x04
+
+struct ieee80211req_authalg {
+   u_int8_t auth_alg;
+};
+
+/*
+ * Request to add an IE to a Management Frame
+ */
+enum{
+    IEEE80211_APPIE_FRAME_BEACON     = 0,
+    IEEE80211_APPIE_FRAME_PROBE_REQ  = 1,
+    IEEE80211_APPIE_FRAME_PROBE_RESP = 2,
+    IEEE80211_APPIE_FRAME_ASSOC_REQ  = 3,
+    IEEE80211_APPIE_FRAME_ASSOC_RESP = 4,
+    IEEE80211_APPIE_NUM_OF_FRAME     = 5
+};
+
+/*
+ * The Maximum length of the IE that can be added to a Management frame
+ */
+#define IEEE80211_APPIE_FRAME_MAX_LEN  78
+
+struct ieee80211req_getset_appiebuf {
+    u_int32_t app_frmtype; /* management frame type for which buffer is added */
+    u_int32_t app_buflen;  /*application supplied buffer length */
+    u_int8_t  app_buf[];
+};
+
+/*
+ * The following definitions are used by an application to set filter
+ * for receiving management frames
+ */
+enum {
+     IEEE80211_FILTER_TYPE_BEACON      =   0x1,
+     IEEE80211_FILTER_TYPE_PROBE_REQ   =   0x2,
+     IEEE80211_FILTER_TYPE_PROBE_RESP  =   0x4,
+     IEEE80211_FILTER_TYPE_ASSOC_REQ   =   0x8,
+     IEEE80211_FILTER_TYPE_ASSOC_RESP  =   0x10,
+     IEEE80211_FILTER_TYPE_AUTH        =   0x20,
+     IEEE80211_FILTER_TYPE_DEAUTH      =   0x40,
+     IEEE80211_FILTER_TYPE_DISASSOC    =   0x80,
+     IEEE80211_FILTER_TYPE_ALL         =   0xFF  /* used to check the valid filter bits */
+};
+
+struct ieee80211req_set_filter {
+      u_int32_t app_filterype; /* management frame filter type */
+};
+
+enum {
+    IEEE80211_PARAM_AUTHMODE = 3,   /* Authentication Mode */
+    IEEE80211_PARAM_MCASTCIPHER = 5,
+    IEEE80211_PARAM_MCASTKEYLEN = 6,    /* multicast key length */
+    IEEE80211_PARAM_UCASTCIPHER = 8,
+    IEEE80211_PARAM_UCASTKEYLEN = 9,    /* unicast key length */
+	IEEE80211_PARAM_WPA		= 10,	/* WPA mode (0,1,2) */
+	IEEE80211_PARAM_ROAMING		= 12,	/* roaming mode */
+	IEEE80211_PARAM_PRIVACY		= 13,	/* privacy invoked */
+	IEEE80211_PARAM_COUNTERMEASURES	= 14,	/* WPA/TKIP countermeasures */
+	IEEE80211_PARAM_DROPUNENCRYPTED	= 15,	/* discard unencrypted frames */
+};
+
+/*
+ * Values for IEEE80211_PARAM_WPA
+ */
+#define WPA_MODE_WPA1   1
+#define WPA_MODE_WPA2   2
+#define WPA_MODE_AUTO   3
+#define WPA_MODE_NONE   4
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IEEE80211_IOCTL_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/ieee80211_node.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/ieee80211_node.h
@@ -0,0 +1,80 @@
+
+/*-
+ * Copyright (c) 2001 Atsushi Onoe
+ * Copyright (c) 2002-2004 Sam Leffler, Errno Consulting
+ * Copyright (c) 2006 Atheros Communications, Inc.
+ *
+ * Wireless Network driver for Atheros AR6001
+ * All rights reserved.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef _IEEE80211_NODE_H_
+#define _IEEE80211_NODE_H_
+
+/*
+ * Node locking definitions.
+ */
+#define IEEE80211_NODE_LOCK_INIT(_nt)   A_MUTEX_INIT(&(_nt)->nt_nodelock)
+#define IEEE80211_NODE_LOCK_DESTROY(_nt) if (A_IS_MUTEX_VALID(&(_nt)->nt_nodelock)) { \
+                                               A_MUTEX_DELETE(&(_nt)->nt_nodelock); }
+
+#define IEEE80211_NODE_LOCK(_nt)        A_MUTEX_LOCK(&(_nt)->nt_nodelock)
+#define IEEE80211_NODE_UNLOCK(_nt)      A_MUTEX_UNLOCK(&(_nt)->nt_nodelock)
+#define IEEE80211_NODE_LOCK_ASSERT(_nt)
+
+/*
+ * Node reference counting definitions.
+ *
+ * ieee80211_node_incref    add a reference
+ * ieee80211_node_decref    remove a reference
+ * ieee80211_node_dectestref    remove a reference and return 1 if this
+ *              is the last reference, otherwise 0
+ * ieee80211_node_refcnt    reference count for printing (only)
+ */
+#define ieee80211_node_incref(_ni)      ((_ni)->ni_refcnt++)
+#define ieee80211_node_decref(_ni)      ((_ni)->ni_refcnt--)
+#define ieee80211_node_dectestref(_ni)  ((--(_ni)->ni_refcnt) == 0)
+#define ieee80211_node_refcnt(_ni)      ((_ni)->ni_refcnt)
+
+#define IEEE80211_NODE_HASHSIZE 32
+/* simple hash is enough for variation of macaddr */
+#define IEEE80211_NODE_HASH(addr)   \
+    (((const A_UINT8 *)(addr))[IEEE80211_ADDR_LEN - 1] % \
+        IEEE80211_NODE_HASHSIZE)
+
+/*
+ * Table of ieee80211_node instances.  Each ieee80211com
+ * has at least one for holding the scan candidates.
+ * When operating as an access point or in ibss mode there
+ * is a second table for associated stations or neighbors.
+ */
+struct ieee80211_node_table {
+    void                   *nt_wmip;       /* back reference */
+    A_MUTEX_T               nt_nodelock;    /* on node table */
+    struct bss              *nt_node_first; /* information of all nodes */
+    struct bss              *nt_node_last;  /* information of all nodes */
+    struct bss              *nt_hash[IEEE80211_NODE_HASHSIZE];
+    const char              *nt_name;   /* for debugging */
+    A_UINT32                nt_scangen; /* gen# for timeout scan */
+    A_TIMER                 nt_inact_timer;
+    A_UINT8                 isTimerArmed;   /* is the node timer armed */
+    A_UINT32                nt_nodeAge; /* node aging time */
+#ifdef OS_ROAM_MANAGEMENT
+    A_UINT32                nt_si_gen; /* gen# for scan indication*/
+#endif
+};
+
+#define WLAN_NODE_INACT_TIMEOUT_MSEC            120000
+
+#endif /* _IEEE80211_NODE_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/mbox_host_reg.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/mbox_host_reg.h
@@ -0,0 +1,405 @@
+// ------------------------------------------------------------------
+// Copyright (c) 2004-2007 Atheros Corporation.  All rights reserved.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation;
+//
+// Software distributed under the License is distributed on an "AS
+// IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+// implied. See the License for the specific language governing
+// rights and limitations under the License.
+//
+//
+// ------------------------------------------------------------------
+//===================================================================
+// Author(s): ="Atheros"
+//===================================================================
+
+
+#ifndef _MBOX_HOST_REG_REG_H_
+#define _MBOX_HOST_REG_REG_H_
+
+#define HOST_INT_STATUS_ADDRESS                  0x00000400
+#define HOST_INT_STATUS_OFFSET                   0x00000400
+#define HOST_INT_STATUS_ERROR_MSB                7
+#define HOST_INT_STATUS_ERROR_LSB                7
+#define HOST_INT_STATUS_ERROR_MASK               0x00000080
+#define HOST_INT_STATUS_ERROR_GET(x)             (((x) & HOST_INT_STATUS_ERROR_MASK) >> HOST_INT_STATUS_ERROR_LSB)
+#define HOST_INT_STATUS_ERROR_SET(x)             (((x) << HOST_INT_STATUS_ERROR_LSB) & HOST_INT_STATUS_ERROR_MASK)
+#define HOST_INT_STATUS_CPU_MSB                  6
+#define HOST_INT_STATUS_CPU_LSB                  6
+#define HOST_INT_STATUS_CPU_MASK                 0x00000040
+#define HOST_INT_STATUS_CPU_GET(x)               (((x) & HOST_INT_STATUS_CPU_MASK) >> HOST_INT_STATUS_CPU_LSB)
+#define HOST_INT_STATUS_CPU_SET(x)               (((x) << HOST_INT_STATUS_CPU_LSB) & HOST_INT_STATUS_CPU_MASK)
+#define HOST_INT_STATUS_DRAGON_INT_MSB           5
+#define HOST_INT_STATUS_DRAGON_INT_LSB           5
+#define HOST_INT_STATUS_DRAGON_INT_MASK          0x00000020
+#define HOST_INT_STATUS_DRAGON_INT_GET(x)        (((x) & HOST_INT_STATUS_DRAGON_INT_MASK) >> HOST_INT_STATUS_DRAGON_INT_LSB)
+#define HOST_INT_STATUS_DRAGON_INT_SET(x)        (((x) << HOST_INT_STATUS_DRAGON_INT_LSB) & HOST_INT_STATUS_DRAGON_INT_MASK)
+#define HOST_INT_STATUS_COUNTER_MSB              4
+#define HOST_INT_STATUS_COUNTER_LSB              4
+#define HOST_INT_STATUS_COUNTER_MASK             0x00000010
+#define HOST_INT_STATUS_COUNTER_GET(x)           (((x) & HOST_INT_STATUS_COUNTER_MASK) >> HOST_INT_STATUS_COUNTER_LSB)
+#define HOST_INT_STATUS_COUNTER_SET(x)           (((x) << HOST_INT_STATUS_COUNTER_LSB) & HOST_INT_STATUS_COUNTER_MASK)
+#define HOST_INT_STATUS_MBOX_DATA_MSB            3
+#define HOST_INT_STATUS_MBOX_DATA_LSB            0
+#define HOST_INT_STATUS_MBOX_DATA_MASK           0x0000000f
+#define HOST_INT_STATUS_MBOX_DATA_GET(x)         (((x) & HOST_INT_STATUS_MBOX_DATA_MASK) >> HOST_INT_STATUS_MBOX_DATA_LSB)
+#define HOST_INT_STATUS_MBOX_DATA_SET(x)         (((x) << HOST_INT_STATUS_MBOX_DATA_LSB) & HOST_INT_STATUS_MBOX_DATA_MASK)
+
+#define CPU_INT_STATUS_ADDRESS                   0x00000401
+#define CPU_INT_STATUS_OFFSET                    0x00000401
+#define CPU_INT_STATUS_BIT_MSB                   7
+#define CPU_INT_STATUS_BIT_LSB                   0
+#define CPU_INT_STATUS_BIT_MASK                  0x000000ff
+#define CPU_INT_STATUS_BIT_GET(x)                (((x) & CPU_INT_STATUS_BIT_MASK) >> CPU_INT_STATUS_BIT_LSB)
+#define CPU_INT_STATUS_BIT_SET(x)                (((x) << CPU_INT_STATUS_BIT_LSB) & CPU_INT_STATUS_BIT_MASK)
+
+#define ERROR_INT_STATUS_ADDRESS                 0x00000402
+#define ERROR_INT_STATUS_OFFSET                  0x00000402
+#define ERROR_INT_STATUS_SPI_MSB                 3
+#define ERROR_INT_STATUS_SPI_LSB                 3
+#define ERROR_INT_STATUS_SPI_MASK                0x00000008
+#define ERROR_INT_STATUS_SPI_GET(x)              (((x) & ERROR_INT_STATUS_SPI_MASK) >> ERROR_INT_STATUS_SPI_LSB)
+#define ERROR_INT_STATUS_SPI_SET(x)              (((x) << ERROR_INT_STATUS_SPI_LSB) & ERROR_INT_STATUS_SPI_MASK)
+#define ERROR_INT_STATUS_WAKEUP_MSB              2
+#define ERROR_INT_STATUS_WAKEUP_LSB              2
+#define ERROR_INT_STATUS_WAKEUP_MASK             0x00000004
+#define ERROR_INT_STATUS_WAKEUP_GET(x)           (((x) & ERROR_INT_STATUS_WAKEUP_MASK) >> ERROR_INT_STATUS_WAKEUP_LSB)
+#define ERROR_INT_STATUS_WAKEUP_SET(x)           (((x) << ERROR_INT_STATUS_WAKEUP_LSB) & ERROR_INT_STATUS_WAKEUP_MASK)
+#define ERROR_INT_STATUS_RX_UNDERFLOW_MSB        1
+#define ERROR_INT_STATUS_RX_UNDERFLOW_LSB        1
+#define ERROR_INT_STATUS_RX_UNDERFLOW_MASK       0x00000002
+#define ERROR_INT_STATUS_RX_UNDERFLOW_GET(x)     (((x) & ERROR_INT_STATUS_RX_UNDERFLOW_MASK) >> ERROR_INT_STATUS_RX_UNDERFLOW_LSB)
+#define ERROR_INT_STATUS_RX_UNDERFLOW_SET(x)     (((x) << ERROR_INT_STATUS_RX_UNDERFLOW_LSB) & ERROR_INT_STATUS_RX_UNDERFLOW_MASK)
+#define ERROR_INT_STATUS_TX_OVERFLOW_MSB         0
+#define ERROR_INT_STATUS_TX_OVERFLOW_LSB         0
+#define ERROR_INT_STATUS_TX_OVERFLOW_MASK        0x00000001
+#define ERROR_INT_STATUS_TX_OVERFLOW_GET(x)      (((x) & ERROR_INT_STATUS_TX_OVERFLOW_MASK) >> ERROR_INT_STATUS_TX_OVERFLOW_LSB)
+#define ERROR_INT_STATUS_TX_OVERFLOW_SET(x)      (((x) << ERROR_INT_STATUS_TX_OVERFLOW_LSB) & ERROR_INT_STATUS_TX_OVERFLOW_MASK)
+
+#define COUNTER_INT_STATUS_ADDRESS               0x00000403
+#define COUNTER_INT_STATUS_OFFSET                0x00000403
+#define COUNTER_INT_STATUS_COUNTER_MSB           7
+#define COUNTER_INT_STATUS_COUNTER_LSB           0
+#define COUNTER_INT_STATUS_COUNTER_MASK          0x000000ff
+#define COUNTER_INT_STATUS_COUNTER_GET(x)        (((x) & COUNTER_INT_STATUS_COUNTER_MASK) >> COUNTER_INT_STATUS_COUNTER_LSB)
+#define COUNTER_INT_STATUS_COUNTER_SET(x)        (((x) << COUNTER_INT_STATUS_COUNTER_LSB) & COUNTER_INT_STATUS_COUNTER_MASK)
+
+#define MBOX_FRAME_ADDRESS                       0x00000404
+#define MBOX_FRAME_OFFSET                        0x00000404
+#define MBOX_FRAME_RX_EOM_MSB                    7
+#define MBOX_FRAME_RX_EOM_LSB                    4
+#define MBOX_FRAME_RX_EOM_MASK                   0x000000f0
+#define MBOX_FRAME_RX_EOM_GET(x)                 (((x) & MBOX_FRAME_RX_EOM_MASK) >> MBOX_FRAME_RX_EOM_LSB)
+#define MBOX_FRAME_RX_EOM_SET(x)                 (((x) << MBOX_FRAME_RX_EOM_LSB) & MBOX_FRAME_RX_EOM_MASK)
+#define MBOX_FRAME_RX_SOM_MSB                    3
+#define MBOX_FRAME_RX_SOM_LSB                    0
+#define MBOX_FRAME_RX_SOM_MASK                   0x0000000f
+#define MBOX_FRAME_RX_SOM_GET(x)                 (((x) & MBOX_FRAME_RX_SOM_MASK) >> MBOX_FRAME_RX_SOM_LSB)
+#define MBOX_FRAME_RX_SOM_SET(x)                 (((x) << MBOX_FRAME_RX_SOM_LSB) & MBOX_FRAME_RX_SOM_MASK)
+
+#define RX_LOOKAHEAD_VALID_ADDRESS               0x00000405
+#define RX_LOOKAHEAD_VALID_OFFSET                0x00000405
+#define RX_LOOKAHEAD_VALID_MBOX_MSB              3
+#define RX_LOOKAHEAD_VALID_MBOX_LSB              0
+#define RX_LOOKAHEAD_VALID_MBOX_MASK             0x0000000f
+#define RX_LOOKAHEAD_VALID_MBOX_GET(x)           (((x) & RX_LOOKAHEAD_VALID_MBOX_MASK) >> RX_LOOKAHEAD_VALID_MBOX_LSB)
+#define RX_LOOKAHEAD_VALID_MBOX_SET(x)           (((x) << RX_LOOKAHEAD_VALID_MBOX_LSB) & RX_LOOKAHEAD_VALID_MBOX_MASK)
+
+#define RX_LOOKAHEAD0_ADDRESS                    0x00000408
+#define RX_LOOKAHEAD0_OFFSET                     0x00000408
+#define RX_LOOKAHEAD0_DATA_MSB                   7
+#define RX_LOOKAHEAD0_DATA_LSB                   0
+#define RX_LOOKAHEAD0_DATA_MASK                  0x000000ff
+#define RX_LOOKAHEAD0_DATA_GET(x)                (((x) & RX_LOOKAHEAD0_DATA_MASK) >> RX_LOOKAHEAD0_DATA_LSB)
+#define RX_LOOKAHEAD0_DATA_SET(x)                (((x) << RX_LOOKAHEAD0_DATA_LSB) & RX_LOOKAHEAD0_DATA_MASK)
+
+#define RX_LOOKAHEAD1_ADDRESS                    0x0000040c
+#define RX_LOOKAHEAD1_OFFSET                     0x0000040c
+#define RX_LOOKAHEAD1_DATA_MSB                   7
+#define RX_LOOKAHEAD1_DATA_LSB                   0
+#define RX_LOOKAHEAD1_DATA_MASK                  0x000000ff
+#define RX_LOOKAHEAD1_DATA_GET(x)                (((x) & RX_LOOKAHEAD1_DATA_MASK) >> RX_LOOKAHEAD1_DATA_LSB)
+#define RX_LOOKAHEAD1_DATA_SET(x)                (((x) << RX_LOOKAHEAD1_DATA_LSB) & RX_LOOKAHEAD1_DATA_MASK)
+
+#define RX_LOOKAHEAD2_ADDRESS                    0x00000410
+#define RX_LOOKAHEAD2_OFFSET                     0x00000410
+#define RX_LOOKAHEAD2_DATA_MSB                   7
+#define RX_LOOKAHEAD2_DATA_LSB                   0
+#define RX_LOOKAHEAD2_DATA_MASK                  0x000000ff
+#define RX_LOOKAHEAD2_DATA_GET(x)                (((x) & RX_LOOKAHEAD2_DATA_MASK) >> RX_LOOKAHEAD2_DATA_LSB)
+#define RX_LOOKAHEAD2_DATA_SET(x)                (((x) << RX_LOOKAHEAD2_DATA_LSB) & RX_LOOKAHEAD2_DATA_MASK)
+
+#define RX_LOOKAHEAD3_ADDRESS                    0x00000414
+#define RX_LOOKAHEAD3_OFFSET                     0x00000414
+#define RX_LOOKAHEAD3_DATA_MSB                   7
+#define RX_LOOKAHEAD3_DATA_LSB                   0
+#define RX_LOOKAHEAD3_DATA_MASK                  0x000000ff
+#define RX_LOOKAHEAD3_DATA_GET(x)                (((x) & RX_LOOKAHEAD3_DATA_MASK) >> RX_LOOKAHEAD3_DATA_LSB)
+#define RX_LOOKAHEAD3_DATA_SET(x)                (((x) << RX_LOOKAHEAD3_DATA_LSB) & RX_LOOKAHEAD3_DATA_MASK)
+
+#define INT_STATUS_ENABLE_ADDRESS                0x00000418
+#define INT_STATUS_ENABLE_OFFSET                 0x00000418
+#define INT_STATUS_ENABLE_ERROR_MSB              7
+#define INT_STATUS_ENABLE_ERROR_LSB              7
+#define INT_STATUS_ENABLE_ERROR_MASK             0x00000080
+#define INT_STATUS_ENABLE_ERROR_GET(x)           (((x) & INT_STATUS_ENABLE_ERROR_MASK) >> INT_STATUS_ENABLE_ERROR_LSB)
+#define INT_STATUS_ENABLE_ERROR_SET(x)           (((x) << INT_STATUS_ENABLE_ERROR_LSB) & INT_STATUS_ENABLE_ERROR_MASK)
+#define INT_STATUS_ENABLE_CPU_MSB                6
+#define INT_STATUS_ENABLE_CPU_LSB                6
+#define INT_STATUS_ENABLE_CPU_MASK               0x00000040
+#define INT_STATUS_ENABLE_CPU_GET(x)             (((x) & INT_STATUS_ENABLE_CPU_MASK) >> INT_STATUS_ENABLE_CPU_LSB)
+#define INT_STATUS_ENABLE_CPU_SET(x)             (((x) << INT_STATUS_ENABLE_CPU_LSB) & INT_STATUS_ENABLE_CPU_MASK)
+#define INT_STATUS_ENABLE_DRAGON_INT_MSB         5
+#define INT_STATUS_ENABLE_DRAGON_INT_LSB         5
+#define INT_STATUS_ENABLE_DRAGON_INT_MASK        0x00000020
+#define INT_STATUS_ENABLE_DRAGON_INT_GET(x)      (((x) & INT_STATUS_ENABLE_DRAGON_INT_MASK) >> INT_STATUS_ENABLE_DRAGON_INT_LSB)
+#define INT_STATUS_ENABLE_DRAGON_INT_SET(x)      (((x) << INT_STATUS_ENABLE_DRAGON_INT_LSB) & INT_STATUS_ENABLE_DRAGON_INT_MASK)
+#define INT_STATUS_ENABLE_COUNTER_MSB            4
+#define INT_STATUS_ENABLE_COUNTER_LSB            4
+#define INT_STATUS_ENABLE_COUNTER_MASK           0x00000010
+#define INT_STATUS_ENABLE_COUNTER_GET(x)         (((x) & INT_STATUS_ENABLE_COUNTER_MASK) >> INT_STATUS_ENABLE_COUNTER_LSB)
+#define INT_STATUS_ENABLE_COUNTER_SET(x)         (((x) << INT_STATUS_ENABLE_COUNTER_LSB) & INT_STATUS_ENABLE_COUNTER_MASK)
+#define INT_STATUS_ENABLE_MBOX_DATA_MSB          3
+#define INT_STATUS_ENABLE_MBOX_DATA_LSB          0
+#define INT_STATUS_ENABLE_MBOX_DATA_MASK         0x0000000f
+#define INT_STATUS_ENABLE_MBOX_DATA_GET(x)       (((x) & INT_STATUS_ENABLE_MBOX_DATA_MASK) >> INT_STATUS_ENABLE_MBOX_DATA_LSB)
+#define INT_STATUS_ENABLE_MBOX_DATA_SET(x)       (((x) << INT_STATUS_ENABLE_MBOX_DATA_LSB) & INT_STATUS_ENABLE_MBOX_DATA_MASK)
+
+#define CPU_INT_STATUS_ENABLE_ADDRESS            0x00000419
+#define CPU_INT_STATUS_ENABLE_OFFSET             0x00000419
+#define CPU_INT_STATUS_ENABLE_BIT_MSB            7
+#define CPU_INT_STATUS_ENABLE_BIT_LSB            0
+#define CPU_INT_STATUS_ENABLE_BIT_MASK           0x000000ff
+#define CPU_INT_STATUS_ENABLE_BIT_GET(x)         (((x) & CPU_INT_STATUS_ENABLE_BIT_MASK) >> CPU_INT_STATUS_ENABLE_BIT_LSB)
+#define CPU_INT_STATUS_ENABLE_BIT_SET(x)         (((x) << CPU_INT_STATUS_ENABLE_BIT_LSB) & CPU_INT_STATUS_ENABLE_BIT_MASK)
+
+#define ERROR_STATUS_ENABLE_ADDRESS              0x0000041a
+#define ERROR_STATUS_ENABLE_OFFSET               0x0000041a
+#define ERROR_STATUS_ENABLE_WAKEUP_MSB           2
+#define ERROR_STATUS_ENABLE_WAKEUP_LSB           2
+#define ERROR_STATUS_ENABLE_WAKEUP_MASK          0x00000004
+#define ERROR_STATUS_ENABLE_WAKEUP_GET(x)        (((x) & ERROR_STATUS_ENABLE_WAKEUP_MASK) >> ERROR_STATUS_ENABLE_WAKEUP_LSB)
+#define ERROR_STATUS_ENABLE_WAKEUP_SET(x)        (((x) << ERROR_STATUS_ENABLE_WAKEUP_LSB) & ERROR_STATUS_ENABLE_WAKEUP_MASK)
+#define ERROR_STATUS_ENABLE_RX_UNDERFLOW_MSB     1
+#define ERROR_STATUS_ENABLE_RX_UNDERFLOW_LSB     1
+#define ERROR_STATUS_ENABLE_RX_UNDERFLOW_MASK    0x00000002
+#define ERROR_STATUS_ENABLE_RX_UNDERFLOW_GET(x)  (((x) & ERROR_STATUS_ENABLE_RX_UNDERFLOW_MASK) >> ERROR_STATUS_ENABLE_RX_UNDERFLOW_LSB)
+#define ERROR_STATUS_ENABLE_RX_UNDERFLOW_SET(x)  (((x) << ERROR_STATUS_ENABLE_RX_UNDERFLOW_LSB) & ERROR_STATUS_ENABLE_RX_UNDERFLOW_MASK)
+#define ERROR_STATUS_ENABLE_TX_OVERFLOW_MSB      0
+#define ERROR_STATUS_ENABLE_TX_OVERFLOW_LSB      0
+#define ERROR_STATUS_ENABLE_TX_OVERFLOW_MASK     0x00000001
+#define ERROR_STATUS_ENABLE_TX_OVERFLOW_GET(x)   (((x) & ERROR_STATUS_ENABLE_TX_OVERFLOW_MASK) >> ERROR_STATUS_ENABLE_TX_OVERFLOW_LSB)
+#define ERROR_STATUS_ENABLE_TX_OVERFLOW_SET(x)   (((x) << ERROR_STATUS_ENABLE_TX_OVERFLOW_LSB) & ERROR_STATUS_ENABLE_TX_OVERFLOW_MASK)
+
+#define COUNTER_INT_STATUS_ENABLE_ADDRESS        0x0000041b
+#define COUNTER_INT_STATUS_ENABLE_OFFSET         0x0000041b
+#define COUNTER_INT_STATUS_ENABLE_BIT_MSB        7
+#define COUNTER_INT_STATUS_ENABLE_BIT_LSB        0
+#define COUNTER_INT_STATUS_ENABLE_BIT_MASK       0x000000ff
+#define COUNTER_INT_STATUS_ENABLE_BIT_GET(x)     (((x) & COUNTER_INT_STATUS_ENABLE_BIT_MASK) >> COUNTER_INT_STATUS_ENABLE_BIT_LSB)
+#define COUNTER_INT_STATUS_ENABLE_BIT_SET(x)     (((x) << COUNTER_INT_STATUS_ENABLE_BIT_LSB) & COUNTER_INT_STATUS_ENABLE_BIT_MASK)
+
+#define COUNT_ADDRESS                            0x00000420
+#define COUNT_OFFSET                             0x00000420
+#define COUNT_VALUE_MSB                          7
+#define COUNT_VALUE_LSB                          0
+#define COUNT_VALUE_MASK                         0x000000ff
+#define COUNT_VALUE_GET(x)                       (((x) & COUNT_VALUE_MASK) >> COUNT_VALUE_LSB)
+#define COUNT_VALUE_SET(x)                       (((x) << COUNT_VALUE_LSB) & COUNT_VALUE_MASK)
+
+#define COUNT_DEC_ADDRESS                        0x00000440
+#define COUNT_DEC_OFFSET                         0x00000440
+#define COUNT_DEC_VALUE_MSB                      7
+#define COUNT_DEC_VALUE_LSB                      0
+#define COUNT_DEC_VALUE_MASK                     0x000000ff
+#define COUNT_DEC_VALUE_GET(x)                   (((x) & COUNT_DEC_VALUE_MASK) >> COUNT_DEC_VALUE_LSB)
+#define COUNT_DEC_VALUE_SET(x)                   (((x) << COUNT_DEC_VALUE_LSB) & COUNT_DEC_VALUE_MASK)
+
+#define SCRATCH_ADDRESS                          0x00000460
+#define SCRATCH_OFFSET                           0x00000460
+#define SCRATCH_VALUE_MSB                        7
+#define SCRATCH_VALUE_LSB                        0
+#define SCRATCH_VALUE_MASK                       0x000000ff
+#define SCRATCH_VALUE_GET(x)                     (((x) & SCRATCH_VALUE_MASK) >> SCRATCH_VALUE_LSB)
+#define SCRATCH_VALUE_SET(x)                     (((x) << SCRATCH_VALUE_LSB) & SCRATCH_VALUE_MASK)
+
+#define FIFO_TIMEOUT_ADDRESS                     0x00000468
+#define FIFO_TIMEOUT_OFFSET                      0x00000468
+#define FIFO_TIMEOUT_VALUE_MSB                   7
+#define FIFO_TIMEOUT_VALUE_LSB                   0
+#define FIFO_TIMEOUT_VALUE_MASK                  0x000000ff
+#define FIFO_TIMEOUT_VALUE_GET(x)                (((x) & FIFO_TIMEOUT_VALUE_MASK) >> FIFO_TIMEOUT_VALUE_LSB)
+#define FIFO_TIMEOUT_VALUE_SET(x)                (((x) << FIFO_TIMEOUT_VALUE_LSB) & FIFO_TIMEOUT_VALUE_MASK)
+
+#define FIFO_TIMEOUT_ENABLE_ADDRESS              0x00000469
+#define FIFO_TIMEOUT_ENABLE_OFFSET               0x00000469
+#define FIFO_TIMEOUT_ENABLE_SET_MSB              0
+#define FIFO_TIMEOUT_ENABLE_SET_LSB              0
+#define FIFO_TIMEOUT_ENABLE_SET_MASK             0x00000001
+#define FIFO_TIMEOUT_ENABLE_SET_GET(x)           (((x) & FIFO_TIMEOUT_ENABLE_SET_MASK) >> FIFO_TIMEOUT_ENABLE_SET_LSB)
+#define FIFO_TIMEOUT_ENABLE_SET_SET(x)           (((x) << FIFO_TIMEOUT_ENABLE_SET_LSB) & FIFO_TIMEOUT_ENABLE_SET_MASK)
+
+#define DISABLE_SLEEP_ADDRESS                    0x0000046a
+#define DISABLE_SLEEP_OFFSET                     0x0000046a
+#define DISABLE_SLEEP_FOR_INT_MSB                1
+#define DISABLE_SLEEP_FOR_INT_LSB                1
+#define DISABLE_SLEEP_FOR_INT_MASK               0x00000002
+#define DISABLE_SLEEP_FOR_INT_GET(x)             (((x) & DISABLE_SLEEP_FOR_INT_MASK) >> DISABLE_SLEEP_FOR_INT_LSB)
+#define DISABLE_SLEEP_FOR_INT_SET(x)             (((x) << DISABLE_SLEEP_FOR_INT_LSB) & DISABLE_SLEEP_FOR_INT_MASK)
+#define DISABLE_SLEEP_ON_MSB                     0
+#define DISABLE_SLEEP_ON_LSB                     0
+#define DISABLE_SLEEP_ON_MASK                    0x00000001
+#define DISABLE_SLEEP_ON_GET(x)                  (((x) & DISABLE_SLEEP_ON_MASK) >> DISABLE_SLEEP_ON_LSB)
+#define DISABLE_SLEEP_ON_SET(x)                  (((x) << DISABLE_SLEEP_ON_LSB) & DISABLE_SLEEP_ON_MASK)
+
+#define LOCAL_BUS_ADDRESS                        0x00000470
+#define LOCAL_BUS_OFFSET                         0x00000470
+#define LOCAL_BUS_STATE_MSB                      1
+#define LOCAL_BUS_STATE_LSB                      0
+#define LOCAL_BUS_STATE_MASK                     0x00000003
+#define LOCAL_BUS_STATE_GET(x)                   (((x) & LOCAL_BUS_STATE_MASK) >> LOCAL_BUS_STATE_LSB)
+#define LOCAL_BUS_STATE_SET(x)                   (((x) << LOCAL_BUS_STATE_LSB) & LOCAL_BUS_STATE_MASK)
+
+#define INT_WLAN_ADDRESS                         0x00000472
+#define INT_WLAN_OFFSET                          0x00000472
+#define INT_WLAN_VECTOR_MSB                      7
+#define INT_WLAN_VECTOR_LSB                      0
+#define INT_WLAN_VECTOR_MASK                     0x000000ff
+#define INT_WLAN_VECTOR_GET(x)                   (((x) & INT_WLAN_VECTOR_MASK) >> INT_WLAN_VECTOR_LSB)
+#define INT_WLAN_VECTOR_SET(x)                   (((x) << INT_WLAN_VECTOR_LSB) & INT_WLAN_VECTOR_MASK)
+
+#define WINDOW_DATA_ADDRESS                      0x00000474
+#define WINDOW_DATA_OFFSET                       0x00000474
+#define WINDOW_DATA_DATA_MSB                     7
+#define WINDOW_DATA_DATA_LSB                     0
+#define WINDOW_DATA_DATA_MASK                    0x000000ff
+#define WINDOW_DATA_DATA_GET(x)                  (((x) & WINDOW_DATA_DATA_MASK) >> WINDOW_DATA_DATA_LSB)
+#define WINDOW_DATA_DATA_SET(x)                  (((x) << WINDOW_DATA_DATA_LSB) & WINDOW_DATA_DATA_MASK)
+
+#define WINDOW_WRITE_ADDR_ADDRESS                0x00000478
+#define WINDOW_WRITE_ADDR_OFFSET                 0x00000478
+#define WINDOW_WRITE_ADDR_ADDR_MSB               7
+#define WINDOW_WRITE_ADDR_ADDR_LSB               0
+#define WINDOW_WRITE_ADDR_ADDR_MASK              0x000000ff
+#define WINDOW_WRITE_ADDR_ADDR_GET(x)            (((x) & WINDOW_WRITE_ADDR_ADDR_MASK) >> WINDOW_WRITE_ADDR_ADDR_LSB)
+#define WINDOW_WRITE_ADDR_ADDR_SET(x)            (((x) << WINDOW_WRITE_ADDR_ADDR_LSB) & WINDOW_WRITE_ADDR_ADDR_MASK)
+
+#define WINDOW_READ_ADDR_ADDRESS                 0x0000047c
+#define WINDOW_READ_ADDR_OFFSET                  0x0000047c
+#define WINDOW_READ_ADDR_ADDR_MSB                7
+#define WINDOW_READ_ADDR_ADDR_LSB                0
+#define WINDOW_READ_ADDR_ADDR_MASK               0x000000ff
+#define WINDOW_READ_ADDR_ADDR_GET(x)             (((x) & WINDOW_READ_ADDR_ADDR_MASK) >> WINDOW_READ_ADDR_ADDR_LSB)
+#define WINDOW_READ_ADDR_ADDR_SET(x)             (((x) << WINDOW_READ_ADDR_ADDR_LSB) & WINDOW_READ_ADDR_ADDR_MASK)
+
+#define SPI_CONFIG_ADDRESS                       0x00000480
+#define SPI_CONFIG_OFFSET                        0x00000480
+#define SPI_CONFIG_SPI_RESET_MSB                 4
+#define SPI_CONFIG_SPI_RESET_LSB                 4
+#define SPI_CONFIG_SPI_RESET_MASK                0x00000010
+#define SPI_CONFIG_SPI_RESET_GET(x)              (((x) & SPI_CONFIG_SPI_RESET_MASK) >> SPI_CONFIG_SPI_RESET_LSB)
+#define SPI_CONFIG_SPI_RESET_SET(x)              (((x) << SPI_CONFIG_SPI_RESET_LSB) & SPI_CONFIG_SPI_RESET_MASK)
+#define SPI_CONFIG_INTERRUPT_ENABLE_MSB          3
+#define SPI_CONFIG_INTERRUPT_ENABLE_LSB          3
+#define SPI_CONFIG_INTERRUPT_ENABLE_MASK         0x00000008
+#define SPI_CONFIG_INTERRUPT_ENABLE_GET(x)       (((x) & SPI_CONFIG_INTERRUPT_ENABLE_MASK) >> SPI_CONFIG_INTERRUPT_ENABLE_LSB)
+#define SPI_CONFIG_INTERRUPT_ENABLE_SET(x)       (((x) << SPI_CONFIG_INTERRUPT_ENABLE_LSB) & SPI_CONFIG_INTERRUPT_ENABLE_MASK)
+#define SPI_CONFIG_TEST_MODE_MSB                 2
+#define SPI_CONFIG_TEST_MODE_LSB                 2
+#define SPI_CONFIG_TEST_MODE_MASK                0x00000004
+#define SPI_CONFIG_TEST_MODE_GET(x)              (((x) & SPI_CONFIG_TEST_MODE_MASK) >> SPI_CONFIG_TEST_MODE_LSB)
+#define SPI_CONFIG_TEST_MODE_SET(x)              (((x) << SPI_CONFIG_TEST_MODE_LSB) & SPI_CONFIG_TEST_MODE_MASK)
+#define SPI_CONFIG_DATA_SIZE_MSB                 1
+#define SPI_CONFIG_DATA_SIZE_LSB                 0
+#define SPI_CONFIG_DATA_SIZE_MASK                0x00000003
+#define SPI_CONFIG_DATA_SIZE_GET(x)              (((x) & SPI_CONFIG_DATA_SIZE_MASK) >> SPI_CONFIG_DATA_SIZE_LSB)
+#define SPI_CONFIG_DATA_SIZE_SET(x)              (((x) << SPI_CONFIG_DATA_SIZE_LSB) & SPI_CONFIG_DATA_SIZE_MASK)
+
+#define SPI_STATUS_ADDRESS                       0x00000481
+#define SPI_STATUS_OFFSET                        0x00000481
+#define SPI_STATUS_ADDR_ERR_MSB                  3
+#define SPI_STATUS_ADDR_ERR_LSB                  3
+#define SPI_STATUS_ADDR_ERR_MASK                 0x00000008
+#define SPI_STATUS_ADDR_ERR_GET(x)               (((x) & SPI_STATUS_ADDR_ERR_MASK) >> SPI_STATUS_ADDR_ERR_LSB)
+#define SPI_STATUS_ADDR_ERR_SET(x)               (((x) << SPI_STATUS_ADDR_ERR_LSB) & SPI_STATUS_ADDR_ERR_MASK)
+#define SPI_STATUS_RD_ERR_MSB                    2
+#define SPI_STATUS_RD_ERR_LSB                    2
+#define SPI_STATUS_RD_ERR_MASK                   0x00000004
+#define SPI_STATUS_RD_ERR_GET(x)                 (((x) & SPI_STATUS_RD_ERR_MASK) >> SPI_STATUS_RD_ERR_LSB)
+#define SPI_STATUS_RD_ERR_SET(x)                 (((x) << SPI_STATUS_RD_ERR_LSB) & SPI_STATUS_RD_ERR_MASK)
+#define SPI_STATUS_WR_ERR_MSB                    1
+#define SPI_STATUS_WR_ERR_LSB                    1
+#define SPI_STATUS_WR_ERR_MASK                   0x00000002
+#define SPI_STATUS_WR_ERR_GET(x)                 (((x) & SPI_STATUS_WR_ERR_MASK) >> SPI_STATUS_WR_ERR_LSB)
+#define SPI_STATUS_WR_ERR_SET(x)                 (((x) << SPI_STATUS_WR_ERR_LSB) & SPI_STATUS_WR_ERR_MASK)
+#define SPI_STATUS_READY_MSB                     0
+#define SPI_STATUS_READY_LSB                     0
+#define SPI_STATUS_READY_MASK                    0x00000001
+#define SPI_STATUS_READY_GET(x)                  (((x) & SPI_STATUS_READY_MASK) >> SPI_STATUS_READY_LSB)
+#define SPI_STATUS_READY_SET(x)                  (((x) << SPI_STATUS_READY_LSB) & SPI_STATUS_READY_MASK)
+
+#define NON_ASSOC_SLEEP_EN_ADDRESS               0x00000482
+#define NON_ASSOC_SLEEP_EN_OFFSET                0x00000482
+#define NON_ASSOC_SLEEP_EN_BIT_MSB               0
+#define NON_ASSOC_SLEEP_EN_BIT_LSB               0
+#define NON_ASSOC_SLEEP_EN_BIT_MASK              0x00000001
+#define NON_ASSOC_SLEEP_EN_BIT_GET(x)            (((x) & NON_ASSOC_SLEEP_EN_BIT_MASK) >> NON_ASSOC_SLEEP_EN_BIT_LSB)
+#define NON_ASSOC_SLEEP_EN_BIT_SET(x)            (((x) << NON_ASSOC_SLEEP_EN_BIT_LSB) & NON_ASSOC_SLEEP_EN_BIT_MASK)
+
+#define CIS_WINDOW_ADDRESS                       0x00000600
+#define CIS_WINDOW_OFFSET                        0x00000600
+#define CIS_WINDOW_DATA_MSB                      7
+#define CIS_WINDOW_DATA_LSB                      0
+#define CIS_WINDOW_DATA_MASK                     0x000000ff
+#define CIS_WINDOW_DATA_GET(x)                   (((x) & CIS_WINDOW_DATA_MASK) >> CIS_WINDOW_DATA_LSB)
+#define CIS_WINDOW_DATA_SET(x)                   (((x) << CIS_WINDOW_DATA_LSB) & CIS_WINDOW_DATA_MASK)
+
+
+#ifndef __ASSEMBLER__
+
+typedef struct mbox_host_reg_reg_s {
+  unsigned char pad0[1024]; /* pad to 0x400 */
+  volatile unsigned char host_int_status;
+  volatile unsigned char cpu_int_status;
+  volatile unsigned char error_int_status;
+  volatile unsigned char counter_int_status;
+  volatile unsigned char mbox_frame;
+  volatile unsigned char rx_lookahead_valid;
+  unsigned char pad1[2]; /* pad to 0x408 */
+  volatile unsigned char rx_lookahead0[4];
+  volatile unsigned char rx_lookahead1[4];
+  volatile unsigned char rx_lookahead2[4];
+  volatile unsigned char rx_lookahead3[4];
+  volatile unsigned char int_status_enable;
+  volatile unsigned char cpu_int_status_enable;
+  volatile unsigned char error_status_enable;
+  volatile unsigned char counter_int_status_enable;
+  unsigned char pad2[4]; /* pad to 0x420 */
+  volatile unsigned char count[8];
+  unsigned char pad3[24]; /* pad to 0x440 */
+  volatile unsigned char count_dec[32];
+  volatile unsigned char scratch[8];
+  volatile unsigned char fifo_timeout;
+  volatile unsigned char fifo_timeout_enable;
+  volatile unsigned char disable_sleep;
+  unsigned char pad4[5]; /* pad to 0x470 */
+  volatile unsigned char local_bus;
+  unsigned char pad5[1]; /* pad to 0x472 */
+  volatile unsigned char int_wlan;
+  unsigned char pad6[1]; /* pad to 0x474 */
+  volatile unsigned char window_data[4];
+  volatile unsigned char window_write_addr[4];
+  volatile unsigned char window_read_addr[4];
+  volatile unsigned char spi_config;
+  volatile unsigned char spi_status;
+  volatile unsigned char non_assoc_sleep_en;
+  unsigned char pad7[381]; /* pad to 0x600 */
+  volatile unsigned char cis_window[512];
+} mbox_host_reg_reg_t;
+
+#endif /* __ASSEMBLER__ */
+
+#endif /* _MBOX_HOST_REG_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/osapi.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/osapi.h
@@ -0,0 +1,329 @@
+/*
+ * This file contains the definitions of the basic atheros data types.
+ * It is used to map the data types in atheros files to a platform specific
+ * type.
+ *
+ * Copyright 2003-2005 Atheros Communications, Inc.,  All Rights Reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef _OSAPI_LINUX_H_
+#define _OSAPI_LINUX_H_
+
+#ifdef __KERNEL__
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <linux/jiffies.h>
+#endif
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#ifdef KERNEL_2_4
+#include <asm/arch/irq.h>
+#include <asm/irq.h>
+#endif
+
+#ifdef __GNUC__
+#define __ATTRIB_PACK           __attribute__ ((packed))
+#define __ATTRIB_PRINTF         __attribute__ ((format (printf, 1, 2)))
+#define __ATTRIB_NORETURN       __attribute__ ((noreturn))
+#ifndef INLINE
+#define INLINE                  __inline__
+#endif
+#else /* Not GCC */
+#define __ATTRIB_PACK
+#define __ATTRIB_PRINTF
+#define __ATTRIB_NORETURN
+#ifndef INLINE
+#define INLINE                  __inline
+#endif
+#endif /* End __GNUC__ */
+
+#define PREPACK
+#define POSTPACK                __ATTRIB_PACK
+
+/*
+ * Endianes macros
+ */
+#define A_BE2CPU8(x)       ntohb(x)
+#define A_BE2CPU16(x)      ntohs(x)
+#define A_BE2CPU32(x)      ntohl(x)
+
+#define A_LE2CPU8(x)       (x)
+#define A_LE2CPU16(x)      (x)
+#define A_LE2CPU32(x)      (x)
+
+#define A_CPU2BE8(x)       htonb(x)
+#define A_CPU2BE16(x)      htons(x)
+#define A_CPU2BE32(x)      htonl(x)
+
+#define A_MEMCPY(dst, src, len)         memcpy((A_UINT8 *)(dst), (src), (len))
+#define A_MEMZERO(addr, len)            memset(addr, 0, len)
+#define A_MEMCMP(addr1, addr2, len)     memcmp((addr1), (addr2), (len))
+#define A_MALLOC(size)                  kmalloc((size), GFP_KERNEL)
+#define A_MALLOC_NOWAIT(size)           kmalloc((size), GFP_ATOMIC)
+#define A_FREE(addr)                    kfree(addr)
+#define A_PRINTF(args...)               printk(args)
+#define A_SPRINTF(buf, args...)			sprintf (buf, args)
+
+/* Mutual Exclusion */
+typedef spinlock_t                      A_MUTEX_T;
+#define A_MUTEX_INIT(mutex)             spin_lock_init(mutex)
+#define A_MUTEX_LOCK(mutex)             spin_lock_bh(mutex)
+#define A_MUTEX_UNLOCK(mutex)           spin_unlock_bh(mutex)
+#define A_IS_MUTEX_VALID(mutex)         TRUE  /* okay to return true, since A_MUTEX_DELETE does nothing */
+#define A_MUTEX_DELETE(mutex)           /* spin locks are not kernel resources so nothing to free.. */
+
+/* Get current time in ms adding a constant offset (in ms) */
+#define A_GET_MS(offset)    \
+	(jiffies + ((offset) / 1000) * HZ)
+
+/*
+ * Timer Functions
+ */
+#define A_MDELAY(msecs)                 mdelay(msecs)
+/* A_MSLEEP can only be called from a context that is allowed to sleep */
+#define A_MSLEEP(msecs) msleep(msecs)
+typedef struct timer_list               A_TIMER;
+
+#define A_INIT_TIMER(pTimer, pFunction, pArg) do {              \
+    init_timer(pTimer);                                         \
+    (pTimer)->function = (pFunction);                           \
+    (pTimer)->data   = (unsigned long)(pArg);                   \
+} while (0)
+
+/*
+ * Start a Timer that elapses after 'periodMSec' milli-seconds
+ * Support is provided for a one-shot timer. The 'repeatFlag' is
+ * ignored.
+ */
+#define A_TIMEOUT_MS(pTimer, periodMSec, repeatFlag) do {                   \
+    if (repeatFlag) {                                                       \
+        printk("\n" __FILE__ ":%d: Timer Repeat requested\n",__LINE__);     \
+        panic("Timer Repeat");                                              \
+    }                                                                       \
+    mod_timer((pTimer), jiffies + HZ * (periodMSec) / 1000);                \
+} while (0)
+
+/*
+ * Cancel the Timer.
+ */
+#define A_UNTIMEOUT(pTimer) do {                                \
+    del_timer((pTimer));                                        \
+} while (0)
+
+#define A_DELETE_TIMER(pTimer) do {                             \
+} while (0)
+
+/*
+ * Wait Queue related functions
+ */
+typedef wait_queue_head_t               A_WAITQUEUE_HEAD;
+#define A_INIT_WAITQUEUE_HEAD(head)     init_waitqueue_head(head)
+#ifndef wait_event_interruptible_timeout
+#define __wait_event_interruptible_timeout(wq, condition, ret)          \
+do {                                                                    \
+        wait_queue_t __wait;                                            \
+        init_waitqueue_entry(&__wait, current);                         \
+                                                                        \
+        add_wait_queue(&wq, &__wait);                                   \
+        for (;;) {                                                      \
+                set_current_state(TASK_INTERRUPTIBLE);                  \
+                if (condition)                                          \
+                        break;                                          \
+                if (!signal_pending(current)) {                         \
+                        ret = schedule_timeout(ret);                    \
+                        if (!ret)                                       \
+                                break;                                  \
+                        continue;                                       \
+                }                                                       \
+                ret = -ERESTARTSYS;                                     \
+                break;                                                  \
+        }                                                               \
+        current->state = TASK_RUNNING;                                  \
+        remove_wait_queue(&wq, &__wait);                                \
+} while (0)
+
+#define wait_event_interruptible_timeout(wq, condition, timeout)        \
+({                                                                      \
+        long __ret = timeout;                                           \
+        if (!(condition))                                               \
+                __wait_event_interruptible_timeout(wq, condition, __ret); \
+        __ret;                                                          \
+})
+#endif /* wait_event_interruptible_timeout */
+
+#define A_WAIT_EVENT_INTERRUPTIBLE_TIMEOUT(head, condition, timeout) do { \
+    wait_event_interruptible_timeout(head, condition, timeout); \
+} while (0)
+
+#define A_WAKE_UP(head)                 wake_up(head)
+
+#ifdef DEBUG
+#define A_ASSERT(expr)  \
+    if (!(expr)) {   \
+        printk(KERN_ALERT "\n" __FILE__ ":%d: Assertion " #expr " failed!\n",__LINE__); \
+        panic(#expr); \
+    }
+
+#else
+#define A_ASSERT(expr)
+#endif /* DEBUG */
+
+/*
+ * Initialization of the network buffer subsystem
+ */
+#define A_NETBUF_INIT()
+
+/*
+ * Network buffer queue support
+ */
+typedef struct sk_buff_head A_NETBUF_QUEUE_T;
+
+#define A_NETBUF_QUEUE_INIT(q)  \
+    a_netbuf_queue_init(q)
+
+#define A_NETBUF_ENQUEUE(q, pkt) \
+    a_netbuf_enqueue((q), (pkt))
+#define A_NETBUF_PREQUEUE(q, pkt) \
+    a_netbuf_prequeue((q), (pkt))
+#define A_NETBUF_DEQUEUE(q) \
+    (a_netbuf_dequeue(q))
+#define A_NETBUF_QUEUE_SIZE(q)  \
+    a_netbuf_queue_size(q)
+#define A_NETBUF_QUEUE_EMPTY(q) \
+    a_netbuf_queue_empty(q)
+
+/*
+ * Network buffer support
+ */
+#define A_NETBUF_ALLOC(size) \
+    a_netbuf_alloc(size)
+#define A_NETBUF_ALLOC_RAW(size) \
+    a_netbuf_alloc_raw(size)
+#define A_NETBUF_FREE(bufPtr) \
+    a_netbuf_free(bufPtr)
+#define A_NETBUF_DATA(bufPtr) \
+    a_netbuf_to_data(bufPtr)
+#define A_NETBUF_LEN(bufPtr) \
+    a_netbuf_to_len(bufPtr)
+#define A_NETBUF_PUSH(bufPtr, len) \
+    a_netbuf_push(bufPtr, len)
+#define A_NETBUF_PUT(bufPtr, len) \
+    a_netbuf_put(bufPtr, len)
+#define A_NETBUF_TRIM(bufPtr,len) \
+    a_netbuf_trim(bufPtr, len)
+#define A_NETBUF_PULL(bufPtr, len) \
+    a_netbuf_pull(bufPtr, len)
+#define A_NETBUF_HEADROOM(bufPtr)\
+    a_netbuf_headroom(bufPtr)
+#define A_NETBUF_SETLEN(bufPtr,len) \
+    a_netbuf_setlen(bufPtr, len)
+
+/* Add data to end of a buffer  */
+#define A_NETBUF_PUT_DATA(bufPtr, srcPtr,  len) \
+    a_netbuf_put_data(bufPtr, srcPtr, len)
+
+/* Add data to start of the  buffer */
+#define A_NETBUF_PUSH_DATA(bufPtr, srcPtr,  len) \
+    a_netbuf_push_data(bufPtr, srcPtr, len)
+
+/* Remove data at start of the buffer */
+#define A_NETBUF_PULL_DATA(bufPtr, dstPtr, len) \
+    a_netbuf_pull_data(bufPtr, dstPtr, len)
+
+/* Remove data from the end of the buffer */
+#define A_NETBUF_TRIM_DATA(bufPtr, dstPtr, len) \
+    a_netbuf_trim_data(bufPtr, dstPtr, len)
+
+/* View data as "size" contiguous bytes of type "t" */
+#define A_NETBUF_VIEW_DATA(bufPtr, t, size) \
+    (t )( ((struct skbuf *)(bufPtr))->data)
+
+/* return the beginning of the headroom for the buffer */
+#define A_NETBUF_HEAD(bufPtr) \
+        ((((struct sk_buff *)(bufPtr))->head))
+
+/*
+ * OS specific network buffer access routines
+ */
+void *a_netbuf_alloc(int size);
+void *a_netbuf_alloc_raw(int size);
+void a_netbuf_free(void *bufPtr);
+void *a_netbuf_to_data(void *bufPtr);
+A_UINT32 a_netbuf_to_len(void *bufPtr);
+A_STATUS a_netbuf_push(void *bufPtr, A_INT32 len);
+A_STATUS a_netbuf_push_data(void *bufPtr, char *srcPtr, A_INT32 len);
+A_STATUS a_netbuf_put(void *bufPtr, A_INT32 len);
+A_STATUS a_netbuf_put_data(void *bufPtr, char *srcPtr, A_INT32 len);
+A_STATUS a_netbuf_pull(void *bufPtr, A_INT32 len);
+A_STATUS a_netbuf_pull_data(void *bufPtr, char *dstPtr, A_INT32 len);
+A_STATUS a_netbuf_trim(void *bufPtr, A_INT32 len);
+A_STATUS a_netbuf_trim_data(void *bufPtr, char *dstPtr, A_INT32 len);
+A_STATUS a_netbuf_setlen(void *bufPtr, A_INT32 len);
+A_INT32 a_netbuf_headroom(void *bufPtr);
+void a_netbuf_enqueue(A_NETBUF_QUEUE_T *q, void *pkt);
+void a_netbuf_prequeue(A_NETBUF_QUEUE_T *q, void *pkt);
+void *a_netbuf_dequeue(A_NETBUF_QUEUE_T *q);
+int a_netbuf_queue_size(A_NETBUF_QUEUE_T *q);
+int a_netbuf_queue_empty(A_NETBUF_QUEUE_T *q);
+int a_netbuf_queue_empty(A_NETBUF_QUEUE_T *q);
+void a_netbuf_queue_init(A_NETBUF_QUEUE_T *q);
+
+/*
+ * Kernel v.s User space functions
+ */
+A_UINT32 a_copy_to_user(void *to, const void *from, A_UINT32 n);
+A_UINT32 a_copy_from_user(void *to, const void *from, A_UINT32 n);
+
+/* In linux, WLAN Rx and Tx run in different contexts, so no need to check
+ * for any commands/data queued for WLAN */
+#define A_CHECK_DRV_TX()
+
+#else /* __KERNEL__ */
+
+#ifdef __GNUC__
+#define __ATTRIB_PACK           __attribute__ ((packed))
+#define __ATTRIB_PRINTF         __attribute__ ((format (printf, 1, 2)))
+#define __ATTRIB_NORETURN       __attribute__ ((noreturn))
+#ifndef INLINE
+#define INLINE                  __inline__
+#endif
+#else /* Not GCC */
+#define __ATTRIB_PACK
+#define __ATTRIB_PRINTF
+#define __ATTRIB_NORETURN
+#ifndef INLINE
+#define INLINE                  __inline
+#endif
+#endif /* End __GNUC__ */
+
+#define PREPACK
+#define POSTPACK                __ATTRIB_PACK
+
+#define A_MEMCPY(dst, src, len)         memcpy((dst), (src), (len))
+#define A_MEMZERO(addr, len)            memset((addr), 0, (len))
+#define A_MEMCMP(addr1, addr2, len)     memcmp((addr1), (addr2), (len))
+#define A_MALLOC(size)                  malloc(size)
+#define A_FREE(addr)                    free(addr)
+#endif /* __KERNEL__ */
+
+#endif /* _OSAPI_LINUX_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/roaming.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/roaming.h
@@ -0,0 +1,37 @@
+//------------------------------------------------------------------------------
+// <copyright file="roaming.h" company="Atheros">
+//    Copyright (c) 2004-2007 Atheros Corporation.  All rights reserved.
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 2 as
+// published by the Free Software Foundation;
+//
+// Software distributed under the License is distributed on an "AS
+// IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+// implied. See the License for the specific language governing
+// rights and limitations under the License.
+//
+//
+//------------------------------------------------------------------------------
+//==============================================================================
+// Author(s): ="Atheros"
+//==============================================================================
+
+#ifndef _ROAMING_H_
+#define _ROAMING_H_
+
+/*
+ * The signal quality could be in terms of either snr or rssi. We should
+ * have an enum for both of them. For the time being, we are going to move
+ * it to wmi.h that is shared by both host and the target, since we are
+ * repartitioning the code to the host
+ */
+#define SIGNAL_QUALITY_NOISE_FLOOR        -95
+#define SIGNAL_QUALITY_METRICS_NUM_MAX    2
+typedef enum {
+    SIGNAL_QUALITY_METRICS_SNR = 0,
+    SIGNAL_QUALITY_METRICS_RSSI,
+    SIGNAL_QUALITY_METRICS_ALL,
+} SIGNAL_QUALITY_METRICS_TYPE;
+
+#endif  /* _ROAMING_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/rtc_reg.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/rtc_reg.h
@@ -0,0 +1,1187 @@
+// ------------------------------------------------------------------
+// Copyright (c) 2004-2007 Atheros Corporation.  All rights reserved.
+//
+// The software source and binaries included in this development package are
+// licensed, not sold. You, or your company, received the package under one
+// or more license agreements. The rights granted to you are specifically
+// listed in these license agreement(s). All other rights remain with Atheros
+// Communications, Inc., its subsidiaries, or the respective owner including
+// those listed on the included copyright notices.  Distribution of any
+// portion of this package must be in strict compliance with the license
+// agreement(s) terms.
+// </copyright>
+//
+// <summary>
+// 	Wifi driver for AR6002
+// </summary>
+//
+// ------------------------------------------------------------------
+//===================================================================
+// Author(s): ="Atheros"
+//===================================================================
+
+/* These values only apply to the AR6002 */
+
+#ifndef _RTC_REG_REG_H_
+#define _RTC_REG_REG_H_
+
+#define RESET_CONTROL_ADDRESS                    0x00000000
+#define RESET_CONTROL_OFFSET                     0x00000000
+#define RESET_CONTROL_CPU_INIT_RESET_MSB         11
+#define RESET_CONTROL_CPU_INIT_RESET_LSB         11
+#define RESET_CONTROL_CPU_INIT_RESET_MASK        0x00000800
+#define RESET_CONTROL_CPU_INIT_RESET_GET(x)      (((x) & RESET_CONTROL_CPU_INIT_RESET_MASK) >> RESET_CONTROL_CPU_INIT_RESET_LSB)
+#define RESET_CONTROL_CPU_INIT_RESET_SET(x)      (((x) << RESET_CONTROL_CPU_INIT_RESET_LSB) & RESET_CONTROL_CPU_INIT_RESET_MASK)
+#define RESET_CONTROL_VMC_REMAP_RESET_MSB        10
+#define RESET_CONTROL_VMC_REMAP_RESET_LSB        10
+#define RESET_CONTROL_VMC_REMAP_RESET_MASK       0x00000400
+#define RESET_CONTROL_VMC_REMAP_RESET_GET(x)     (((x) & RESET_CONTROL_VMC_REMAP_RESET_MASK) >> RESET_CONTROL_VMC_REMAP_RESET_LSB)
+#define RESET_CONTROL_VMC_REMAP_RESET_SET(x)     (((x) << RESET_CONTROL_VMC_REMAP_RESET_LSB) & RESET_CONTROL_VMC_REMAP_RESET_MASK)
+#define RESET_CONTROL_RST_OUT_MSB                9
+#define RESET_CONTROL_RST_OUT_LSB                9
+#define RESET_CONTROL_RST_OUT_MASK               0x00000200
+#define RESET_CONTROL_RST_OUT_GET(x)             (((x) & RESET_CONTROL_RST_OUT_MASK) >> RESET_CONTROL_RST_OUT_LSB)
+#define RESET_CONTROL_RST_OUT_SET(x)             (((x) << RESET_CONTROL_RST_OUT_LSB) & RESET_CONTROL_RST_OUT_MASK)
+#define RESET_CONTROL_COLD_RST_MSB               8
+#define RESET_CONTROL_COLD_RST_LSB               8
+#define RESET_CONTROL_COLD_RST_MASK              0x00000100
+#define RESET_CONTROL_COLD_RST_GET(x)            (((x) & RESET_CONTROL_COLD_RST_MASK) >> RESET_CONTROL_COLD_RST_LSB)
+#define RESET_CONTROL_COLD_RST_SET(x)            (((x) << RESET_CONTROL_COLD_RST_LSB) & RESET_CONTROL_COLD_RST_MASK)
+#define RESET_CONTROL_WARM_RST_MSB               7
+#define RESET_CONTROL_WARM_RST_LSB               7
+#define RESET_CONTROL_WARM_RST_MASK              0x00000080
+#define RESET_CONTROL_WARM_RST_GET(x)            (((x) & RESET_CONTROL_WARM_RST_MASK) >> RESET_CONTROL_WARM_RST_LSB)
+#define RESET_CONTROL_WARM_RST_SET(x)            (((x) << RESET_CONTROL_WARM_RST_LSB) & RESET_CONTROL_WARM_RST_MASK)
+#define RESET_CONTROL_CPU_WARM_RST_MSB           6
+#define RESET_CONTROL_CPU_WARM_RST_LSB           6
+#define RESET_CONTROL_CPU_WARM_RST_MASK          0x00000040
+#define RESET_CONTROL_CPU_WARM_RST_GET(x)        (((x) & RESET_CONTROL_CPU_WARM_RST_MASK) >> RESET_CONTROL_CPU_WARM_RST_LSB)
+#define RESET_CONTROL_CPU_WARM_RST_SET(x)        (((x) << RESET_CONTROL_CPU_WARM_RST_LSB) & RESET_CONTROL_CPU_WARM_RST_MASK)
+#define RESET_CONTROL_MAC_COLD_RST_MSB           5
+#define RESET_CONTROL_MAC_COLD_RST_LSB           5
+#define RESET_CONTROL_MAC_COLD_RST_MASK          0x00000020
+#define RESET_CONTROL_MAC_COLD_RST_GET(x)        (((x) & RESET_CONTROL_MAC_COLD_RST_MASK) >> RESET_CONTROL_MAC_COLD_RST_LSB)
+#define RESET_CONTROL_MAC_COLD_RST_SET(x)        (((x) << RESET_CONTROL_MAC_COLD_RST_LSB) & RESET_CONTROL_MAC_COLD_RST_MASK)
+#define RESET_CONTROL_MAC_WARM_RST_MSB           4
+#define RESET_CONTROL_MAC_WARM_RST_LSB           4
+#define RESET_CONTROL_MAC_WARM_RST_MASK          0x00000010
+#define RESET_CONTROL_MAC_WARM_RST_GET(x)        (((x) & RESET_CONTROL_MAC_WARM_RST_MASK) >> RESET_CONTROL_MAC_WARM_RST_LSB)
+#define RESET_CONTROL_MAC_WARM_RST_SET(x)        (((x) << RESET_CONTROL_MAC_WARM_RST_LSB) & RESET_CONTROL_MAC_WARM_RST_MASK)
+#define RESET_CONTROL_MBOX_RST_MSB               2
+#define RESET_CONTROL_MBOX_RST_LSB               2
+#define RESET_CONTROL_MBOX_RST_MASK              0x00000004
+#define RESET_CONTROL_MBOX_RST_GET(x)            (((x) & RESET_CONTROL_MBOX_RST_MASK) >> RESET_CONTROL_MBOX_RST_LSB)
+#define RESET_CONTROL_MBOX_RST_SET(x)            (((x) << RESET_CONTROL_MBOX_RST_LSB) & RESET_CONTROL_MBOX_RST_MASK)
+#define RESET_CONTROL_UART_RST_MSB               1
+#define RESET_CONTROL_UART_RST_LSB               1
+#define RESET_CONTROL_UART_RST_MASK              0x00000002
+#define RESET_CONTROL_UART_RST_GET(x)            (((x) & RESET_CONTROL_UART_RST_MASK) >> RESET_CONTROL_UART_RST_LSB)
+#define RESET_CONTROL_UART_RST_SET(x)            (((x) << RESET_CONTROL_UART_RST_LSB) & RESET_CONTROL_UART_RST_MASK)
+#define RESET_CONTROL_SI0_RST_MSB                0
+#define RESET_CONTROL_SI0_RST_LSB                0
+#define RESET_CONTROL_SI0_RST_MASK               0x00000001
+#define RESET_CONTROL_SI0_RST_GET(x)             (((x) & RESET_CONTROL_SI0_RST_MASK) >> RESET_CONTROL_SI0_RST_LSB)
+#define RESET_CONTROL_SI0_RST_SET(x)             (((x) << RESET_CONTROL_SI0_RST_LSB) & RESET_CONTROL_SI0_RST_MASK)
+
+#define XTAL_CONTROL_ADDRESS                     0x00000004
+#define XTAL_CONTROL_OFFSET                      0x00000004
+#define XTAL_CONTROL_TCXO_MSB                    0
+#define XTAL_CONTROL_TCXO_LSB                    0
+#define XTAL_CONTROL_TCXO_MASK                   0x00000001
+#define XTAL_CONTROL_TCXO_GET(x)                 (((x) & XTAL_CONTROL_TCXO_MASK) >> XTAL_CONTROL_TCXO_LSB)
+#define XTAL_CONTROL_TCXO_SET(x)                 (((x) << XTAL_CONTROL_TCXO_LSB) & XTAL_CONTROL_TCXO_MASK)
+
+#define TCXO_DETECT_ADDRESS                      0x00000008
+#define TCXO_DETECT_OFFSET                       0x00000008
+#define TCXO_DETECT_PRESENT_MSB                  0
+#define TCXO_DETECT_PRESENT_LSB                  0
+#define TCXO_DETECT_PRESENT_MASK                 0x00000001
+#define TCXO_DETECT_PRESENT_GET(x)               (((x) & TCXO_DETECT_PRESENT_MASK) >> TCXO_DETECT_PRESENT_LSB)
+#define TCXO_DETECT_PRESENT_SET(x)               (((x) << TCXO_DETECT_PRESENT_LSB) & TCXO_DETECT_PRESENT_MASK)
+
+#define XTAL_TEST_ADDRESS                        0x0000000c
+#define XTAL_TEST_OFFSET                         0x0000000c
+#define XTAL_TEST_NOTCXODET_MSB                  0
+#define XTAL_TEST_NOTCXODET_LSB                  0
+#define XTAL_TEST_NOTCXODET_MASK                 0x00000001
+#define XTAL_TEST_NOTCXODET_GET(x)               (((x) & XTAL_TEST_NOTCXODET_MASK) >> XTAL_TEST_NOTCXODET_LSB)
+#define XTAL_TEST_NOTCXODET_SET(x)               (((x) << XTAL_TEST_NOTCXODET_LSB) & XTAL_TEST_NOTCXODET_MASK)
+
+#define QUADRATURE_ADDRESS                       0x00000010
+#define QUADRATURE_OFFSET                        0x00000010
+#define QUADRATURE_ADC_MSB                       5
+#define QUADRATURE_ADC_LSB                       4
+#define QUADRATURE_ADC_MASK                      0x00000030
+#define QUADRATURE_ADC_GET(x)                    (((x) & QUADRATURE_ADC_MASK) >> QUADRATURE_ADC_LSB)
+#define QUADRATURE_ADC_SET(x)                    (((x) << QUADRATURE_ADC_LSB) & QUADRATURE_ADC_MASK)
+#define QUADRATURE_SEL_MSB                       2
+#define QUADRATURE_SEL_LSB                       2
+#define QUADRATURE_SEL_MASK                      0x00000004
+#define QUADRATURE_SEL_GET(x)                    (((x) & QUADRATURE_SEL_MASK) >> QUADRATURE_SEL_LSB)
+#define QUADRATURE_SEL_SET(x)                    (((x) << QUADRATURE_SEL_LSB) & QUADRATURE_SEL_MASK)
+#define QUADRATURE_DAC_MSB                       1
+#define QUADRATURE_DAC_LSB                       0
+#define QUADRATURE_DAC_MASK                      0x00000003
+#define QUADRATURE_DAC_GET(x)                    (((x) & QUADRATURE_DAC_MASK) >> QUADRATURE_DAC_LSB)
+#define QUADRATURE_DAC_SET(x)                    (((x) << QUADRATURE_DAC_LSB) & QUADRATURE_DAC_MASK)
+
+#define PLL_CONTROL_ADDRESS                      0x00000014
+#define PLL_CONTROL_OFFSET                       0x00000014
+#define PLL_CONTROL_DIG_TEST_CLK_MSB             20
+#define PLL_CONTROL_DIG_TEST_CLK_LSB             20
+#define PLL_CONTROL_DIG_TEST_CLK_MASK            0x00100000
+#define PLL_CONTROL_DIG_TEST_CLK_GET(x)          (((x) & PLL_CONTROL_DIG_TEST_CLK_MASK) >> PLL_CONTROL_DIG_TEST_CLK_LSB)
+#define PLL_CONTROL_DIG_TEST_CLK_SET(x)          (((x) << PLL_CONTROL_DIG_TEST_CLK_LSB) & PLL_CONTROL_DIG_TEST_CLK_MASK)
+#define PLL_CONTROL_MAC_OVERRIDE_MSB             19
+#define PLL_CONTROL_MAC_OVERRIDE_LSB             19
+#define PLL_CONTROL_MAC_OVERRIDE_MASK            0x00080000
+#define PLL_CONTROL_MAC_OVERRIDE_GET(x)          (((x) & PLL_CONTROL_MAC_OVERRIDE_MASK) >> PLL_CONTROL_MAC_OVERRIDE_LSB)
+#define PLL_CONTROL_MAC_OVERRIDE_SET(x)          (((x) << PLL_CONTROL_MAC_OVERRIDE_LSB) & PLL_CONTROL_MAC_OVERRIDE_MASK)
+#define PLL_CONTROL_NOPWD_MSB                    18
+#define PLL_CONTROL_NOPWD_LSB                    18
+#define PLL_CONTROL_NOPWD_MASK                   0x00040000
+#define PLL_CONTROL_NOPWD_GET(x)                 (((x) & PLL_CONTROL_NOPWD_MASK) >> PLL_CONTROL_NOPWD_LSB)
+#define PLL_CONTROL_NOPWD_SET(x)                 (((x) << PLL_CONTROL_NOPWD_LSB) & PLL_CONTROL_NOPWD_MASK)
+#define PLL_CONTROL_UPDATING_MSB                 17
+#define PLL_CONTROL_UPDATING_LSB                 17
+#define PLL_CONTROL_UPDATING_MASK                0x00020000
+#define PLL_CONTROL_UPDATING_GET(x)              (((x) & PLL_CONTROL_UPDATING_MASK) >> PLL_CONTROL_UPDATING_LSB)
+#define PLL_CONTROL_UPDATING_SET(x)              (((x) << PLL_CONTROL_UPDATING_LSB) & PLL_CONTROL_UPDATING_MASK)
+#define PLL_CONTROL_BYPASS_MSB                   16
+#define PLL_CONTROL_BYPASS_LSB                   16
+#define PLL_CONTROL_BYPASS_MASK                  0x00010000
+#define PLL_CONTROL_BYPASS_GET(x)                (((x) & PLL_CONTROL_BYPASS_MASK) >> PLL_CONTROL_BYPASS_LSB)
+#define PLL_CONTROL_BYPASS_SET(x)                (((x) << PLL_CONTROL_BYPASS_LSB) & PLL_CONTROL_BYPASS_MASK)
+#define PLL_CONTROL_REFDIV_MSB                   15
+#define PLL_CONTROL_REFDIV_LSB                   12
+#define PLL_CONTROL_REFDIV_MASK                  0x0000f000
+#define PLL_CONTROL_REFDIV_GET(x)                (((x) & PLL_CONTROL_REFDIV_MASK) >> PLL_CONTROL_REFDIV_LSB)
+#define PLL_CONTROL_REFDIV_SET(x)                (((x) << PLL_CONTROL_REFDIV_LSB) & PLL_CONTROL_REFDIV_MASK)
+#define PLL_CONTROL_DIV_MSB                      9
+#define PLL_CONTROL_DIV_LSB                      0
+#define PLL_CONTROL_DIV_MASK                     0x000003ff
+#define PLL_CONTROL_DIV_GET(x)                   (((x) & PLL_CONTROL_DIV_MASK) >> PLL_CONTROL_DIV_LSB)
+#define PLL_CONTROL_DIV_SET(x)                   (((x) << PLL_CONTROL_DIV_LSB) & PLL_CONTROL_DIV_MASK)
+
+#define PLL_SETTLE_ADDRESS                       0x00000018
+#define PLL_SETTLE_OFFSET                        0x00000018
+#define PLL_SETTLE_TIME_MSB                      11
+#define PLL_SETTLE_TIME_LSB                      0
+#define PLL_SETTLE_TIME_MASK                     0x00000fff
+#define PLL_SETTLE_TIME_GET(x)                   (((x) & PLL_SETTLE_TIME_MASK) >> PLL_SETTLE_TIME_LSB)
+#define PLL_SETTLE_TIME_SET(x)                   (((x) << PLL_SETTLE_TIME_LSB) & PLL_SETTLE_TIME_MASK)
+
+#define XTAL_SETTLE_ADDRESS                      0x0000001c
+#define XTAL_SETTLE_OFFSET                       0x0000001c
+#define XTAL_SETTLE_TIME_MSB                     7
+#define XTAL_SETTLE_TIME_LSB                     0
+#define XTAL_SETTLE_TIME_MASK                    0x000000ff
+#define XTAL_SETTLE_TIME_GET(x)                  (((x) & XTAL_SETTLE_TIME_MASK) >> XTAL_SETTLE_TIME_LSB)
+#define XTAL_SETTLE_TIME_SET(x)                  (((x) << XTAL_SETTLE_TIME_LSB) & XTAL_SETTLE_TIME_MASK)
+
+#define CPU_CLOCK_ADDRESS                        0x00000020
+#define CPU_CLOCK_OFFSET                         0x00000020
+#define CPU_CLOCK_STANDARD_MSB                   1
+#define CPU_CLOCK_STANDARD_LSB                   0
+#define CPU_CLOCK_STANDARD_MASK                  0x00000003
+#define CPU_CLOCK_STANDARD_GET(x)                (((x) & CPU_CLOCK_STANDARD_MASK) >> CPU_CLOCK_STANDARD_LSB)
+#define CPU_CLOCK_STANDARD_SET(x)                (((x) << CPU_CLOCK_STANDARD_LSB) & CPU_CLOCK_STANDARD_MASK)
+
+#define CLOCK_OUT_ADDRESS                        0x00000024
+#define CLOCK_OUT_OFFSET                         0x00000024
+#define CLOCK_OUT_SELECT_MSB                     3
+#define CLOCK_OUT_SELECT_LSB                     0
+#define CLOCK_OUT_SELECT_MASK                    0x0000000f
+#define CLOCK_OUT_SELECT_GET(x)                  (((x) & CLOCK_OUT_SELECT_MASK) >> CLOCK_OUT_SELECT_LSB)
+#define CLOCK_OUT_SELECT_SET(x)                  (((x) << CLOCK_OUT_SELECT_LSB) & CLOCK_OUT_SELECT_MASK)
+
+#define CLOCK_CONTROL_ADDRESS                    0x00000028
+#define CLOCK_CONTROL_OFFSET                     0x00000028
+#define CLOCK_CONTROL_LF_CLK32_MSB               2
+#define CLOCK_CONTROL_LF_CLK32_LSB               2
+#define CLOCK_CONTROL_LF_CLK32_MASK              0x00000004
+#define CLOCK_CONTROL_LF_CLK32_GET(x)            (((x) & CLOCK_CONTROL_LF_CLK32_MASK) >> CLOCK_CONTROL_LF_CLK32_LSB)
+#define CLOCK_CONTROL_LF_CLK32_SET(x)            (((x) << CLOCK_CONTROL_LF_CLK32_LSB) & CLOCK_CONTROL_LF_CLK32_MASK)
+#define CLOCK_CONTROL_UART_CLK_MSB               1
+#define CLOCK_CONTROL_UART_CLK_LSB               1
+#define CLOCK_CONTROL_UART_CLK_MASK              0x00000002
+#define CLOCK_CONTROL_UART_CLK_GET(x)            (((x) & CLOCK_CONTROL_UART_CLK_MASK) >> CLOCK_CONTROL_UART_CLK_LSB)
+#define CLOCK_CONTROL_UART_CLK_SET(x)            (((x) << CLOCK_CONTROL_UART_CLK_LSB) & CLOCK_CONTROL_UART_CLK_MASK)
+#define CLOCK_CONTROL_SI0_CLK_MSB                0
+#define CLOCK_CONTROL_SI0_CLK_LSB                0
+#define CLOCK_CONTROL_SI0_CLK_MASK               0x00000001
+#define CLOCK_CONTROL_SI0_CLK_GET(x)             (((x) & CLOCK_CONTROL_SI0_CLK_MASK) >> CLOCK_CONTROL_SI0_CLK_LSB)
+#define CLOCK_CONTROL_SI0_CLK_SET(x)             (((x) << CLOCK_CONTROL_SI0_CLK_LSB) & CLOCK_CONTROL_SI0_CLK_MASK)
+
+#define BIAS_OVERRIDE_ADDRESS                    0x0000002c
+#define BIAS_OVERRIDE_OFFSET                     0x0000002c
+#define BIAS_OVERRIDE_ON_MSB                     0
+#define BIAS_OVERRIDE_ON_LSB                     0
+#define BIAS_OVERRIDE_ON_MASK                    0x00000001
+#define BIAS_OVERRIDE_ON_GET(x)                  (((x) & BIAS_OVERRIDE_ON_MASK) >> BIAS_OVERRIDE_ON_LSB)
+#define BIAS_OVERRIDE_ON_SET(x)                  (((x) << BIAS_OVERRIDE_ON_LSB) & BIAS_OVERRIDE_ON_MASK)
+
+#define WDT_CONTROL_ADDRESS                      0x00000030
+#define WDT_CONTROL_OFFSET                       0x00000030
+#define WDT_CONTROL_ACTION_MSB                   2
+#define WDT_CONTROL_ACTION_LSB                   0
+#define WDT_CONTROL_ACTION_MASK                  0x00000007
+#define WDT_CONTROL_ACTION_GET(x)                (((x) & WDT_CONTROL_ACTION_MASK) >> WDT_CONTROL_ACTION_LSB)
+#define WDT_CONTROL_ACTION_SET(x)                (((x) << WDT_CONTROL_ACTION_LSB) & WDT_CONTROL_ACTION_MASK)
+
+#define WDT_STATUS_ADDRESS                       0x00000034
+#define WDT_STATUS_OFFSET                        0x00000034
+#define WDT_STATUS_INTERRUPT_MSB                 0
+#define WDT_STATUS_INTERRUPT_LSB                 0
+#define WDT_STATUS_INTERRUPT_MASK                0x00000001
+#define WDT_STATUS_INTERRUPT_GET(x)              (((x) & WDT_STATUS_INTERRUPT_MASK) >> WDT_STATUS_INTERRUPT_LSB)
+#define WDT_STATUS_INTERRUPT_SET(x)              (((x) << WDT_STATUS_INTERRUPT_LSB) & WDT_STATUS_INTERRUPT_MASK)
+
+#define WDT_ADDRESS                              0x00000038
+#define WDT_OFFSET                               0x00000038
+#define WDT_TARGET_MSB                           21
+#define WDT_TARGET_LSB                           0
+#define WDT_TARGET_MASK                          0x003fffff
+#define WDT_TARGET_GET(x)                        (((x) & WDT_TARGET_MASK) >> WDT_TARGET_LSB)
+#define WDT_TARGET_SET(x)                        (((x) << WDT_TARGET_LSB) & WDT_TARGET_MASK)
+
+#define WDT_COUNT_ADDRESS                        0x0000003c
+#define WDT_COUNT_OFFSET                         0x0000003c
+#define WDT_COUNT_VALUE_MSB                      21
+#define WDT_COUNT_VALUE_LSB                      0
+#define WDT_COUNT_VALUE_MASK                     0x003fffff
+#define WDT_COUNT_VALUE_GET(x)                   (((x) & WDT_COUNT_VALUE_MASK) >> WDT_COUNT_VALUE_LSB)
+#define WDT_COUNT_VALUE_SET(x)                   (((x) << WDT_COUNT_VALUE_LSB) & WDT_COUNT_VALUE_MASK)
+
+#define WDT_RESET_ADDRESS                        0x00000040
+#define WDT_RESET_OFFSET                         0x00000040
+#define WDT_RESET_VALUE_MSB                      0
+#define WDT_RESET_VALUE_LSB                      0
+#define WDT_RESET_VALUE_MASK                     0x00000001
+#define WDT_RESET_VALUE_GET(x)                   (((x) & WDT_RESET_VALUE_MASK) >> WDT_RESET_VALUE_LSB)
+#define WDT_RESET_VALUE_SET(x)                   (((x) << WDT_RESET_VALUE_LSB) & WDT_RESET_VALUE_MASK)
+
+#define INT_STATUS_ADDRESS                       0x00000044
+#define INT_STATUS_OFFSET                        0x00000044
+#define INT_STATUS_RTC_POWER_MSB                 14
+#define INT_STATUS_RTC_POWER_LSB                 14
+#define INT_STATUS_RTC_POWER_MASK                0x00004000
+#define INT_STATUS_RTC_POWER_GET(x)              (((x) & INT_STATUS_RTC_POWER_MASK) >> INT_STATUS_RTC_POWER_LSB)
+#define INT_STATUS_RTC_POWER_SET(x)              (((x) << INT_STATUS_RTC_POWER_LSB) & INT_STATUS_RTC_POWER_MASK)
+#define INT_STATUS_MAC_MSB                       13
+#define INT_STATUS_MAC_LSB                       13
+#define INT_STATUS_MAC_MASK                      0x00002000
+#define INT_STATUS_MAC_GET(x)                    (((x) & INT_STATUS_MAC_MASK) >> INT_STATUS_MAC_LSB)
+#define INT_STATUS_MAC_SET(x)                    (((x) << INT_STATUS_MAC_LSB) & INT_STATUS_MAC_MASK)
+#define INT_STATUS_MAILBOX_MSB                   12
+#define INT_STATUS_MAILBOX_LSB                   12
+#define INT_STATUS_MAILBOX_MASK                  0x00001000
+#define INT_STATUS_MAILBOX_GET(x)                (((x) & INT_STATUS_MAILBOX_MASK) >> INT_STATUS_MAILBOX_LSB)
+#define INT_STATUS_MAILBOX_SET(x)                (((x) << INT_STATUS_MAILBOX_LSB) & INT_STATUS_MAILBOX_MASK)
+#define INT_STATUS_RTC_ALARM_MSB                 11
+#define INT_STATUS_RTC_ALARM_LSB                 11
+#define INT_STATUS_RTC_ALARM_MASK                0x00000800
+#define INT_STATUS_RTC_ALARM_GET(x)              (((x) & INT_STATUS_RTC_ALARM_MASK) >> INT_STATUS_RTC_ALARM_LSB)
+#define INT_STATUS_RTC_ALARM_SET(x)              (((x) << INT_STATUS_RTC_ALARM_LSB) & INT_STATUS_RTC_ALARM_MASK)
+#define INT_STATUS_HF_TIMER_MSB                  10
+#define INT_STATUS_HF_TIMER_LSB                  10
+#define INT_STATUS_HF_TIMER_MASK                 0x00000400
+#define INT_STATUS_HF_TIMER_GET(x)               (((x) & INT_STATUS_HF_TIMER_MASK) >> INT_STATUS_HF_TIMER_LSB)
+#define INT_STATUS_HF_TIMER_SET(x)               (((x) << INT_STATUS_HF_TIMER_LSB) & INT_STATUS_HF_TIMER_MASK)
+#define INT_STATUS_LF_TIMER3_MSB                 9
+#define INT_STATUS_LF_TIMER3_LSB                 9
+#define INT_STATUS_LF_TIMER3_MASK                0x00000200
+#define INT_STATUS_LF_TIMER3_GET(x)              (((x) & INT_STATUS_LF_TIMER3_MASK) >> INT_STATUS_LF_TIMER3_LSB)
+#define INT_STATUS_LF_TIMER3_SET(x)              (((x) << INT_STATUS_LF_TIMER3_LSB) & INT_STATUS_LF_TIMER3_MASK)
+#define INT_STATUS_LF_TIMER2_MSB                 8
+#define INT_STATUS_LF_TIMER2_LSB                 8
+#define INT_STATUS_LF_TIMER2_MASK                0x00000100
+#define INT_STATUS_LF_TIMER2_GET(x)              (((x) & INT_STATUS_LF_TIMER2_MASK) >> INT_STATUS_LF_TIMER2_LSB)
+#define INT_STATUS_LF_TIMER2_SET(x)              (((x) << INT_STATUS_LF_TIMER2_LSB) & INT_STATUS_LF_TIMER2_MASK)
+#define INT_STATUS_LF_TIMER1_MSB                 7
+#define INT_STATUS_LF_TIMER1_LSB                 7
+#define INT_STATUS_LF_TIMER1_MASK                0x00000080
+#define INT_STATUS_LF_TIMER1_GET(x)              (((x) & INT_STATUS_LF_TIMER1_MASK) >> INT_STATUS_LF_TIMER1_LSB)
+#define INT_STATUS_LF_TIMER1_SET(x)              (((x) << INT_STATUS_LF_TIMER1_LSB) & INT_STATUS_LF_TIMER1_MASK)
+#define INT_STATUS_LF_TIMER0_MSB                 6
+#define INT_STATUS_LF_TIMER0_LSB                 6
+#define INT_STATUS_LF_TIMER0_MASK                0x00000040
+#define INT_STATUS_LF_TIMER0_GET(x)              (((x) & INT_STATUS_LF_TIMER0_MASK) >> INT_STATUS_LF_TIMER0_LSB)
+#define INT_STATUS_LF_TIMER0_SET(x)              (((x) << INT_STATUS_LF_TIMER0_LSB) & INT_STATUS_LF_TIMER0_MASK)
+#define INT_STATUS_KEYPAD_MSB                    5
+#define INT_STATUS_KEYPAD_LSB                    5
+#define INT_STATUS_KEYPAD_MASK                   0x00000020
+#define INT_STATUS_KEYPAD_GET(x)                 (((x) & INT_STATUS_KEYPAD_MASK) >> INT_STATUS_KEYPAD_LSB)
+#define INT_STATUS_KEYPAD_SET(x)                 (((x) << INT_STATUS_KEYPAD_LSB) & INT_STATUS_KEYPAD_MASK)
+#define INT_STATUS_SI_MSB                        4
+#define INT_STATUS_SI_LSB                        4
+#define INT_STATUS_SI_MASK                       0x00000010
+#define INT_STATUS_SI_GET(x)                     (((x) & INT_STATUS_SI_MASK) >> INT_STATUS_SI_LSB)
+#define INT_STATUS_SI_SET(x)                     (((x) << INT_STATUS_SI_LSB) & INT_STATUS_SI_MASK)
+#define INT_STATUS_GPIO_MSB                      3
+#define INT_STATUS_GPIO_LSB                      3
+#define INT_STATUS_GPIO_MASK                     0x00000008
+#define INT_STATUS_GPIO_GET(x)                   (((x) & INT_STATUS_GPIO_MASK) >> INT_STATUS_GPIO_LSB)
+#define INT_STATUS_GPIO_SET(x)                   (((x) << INT_STATUS_GPIO_LSB) & INT_STATUS_GPIO_MASK)
+#define INT_STATUS_UART_MSB                      2
+#define INT_STATUS_UART_LSB                      2
+#define INT_STATUS_UART_MASK                     0x00000004
+#define INT_STATUS_UART_GET(x)                   (((x) & INT_STATUS_UART_MASK) >> INT_STATUS_UART_LSB)
+#define INT_STATUS_UART_SET(x)                   (((x) << INT_STATUS_UART_LSB) & INT_STATUS_UART_MASK)
+#define INT_STATUS_ERROR_MSB                     1
+#define INT_STATUS_ERROR_LSB                     1
+#define INT_STATUS_ERROR_MASK                    0x00000002
+#define INT_STATUS_ERROR_GET(x)                  (((x) & INT_STATUS_ERROR_MASK) >> INT_STATUS_ERROR_LSB)
+#define INT_STATUS_ERROR_SET(x)                  (((x) << INT_STATUS_ERROR_LSB) & INT_STATUS_ERROR_MASK)
+#define INT_STATUS_WDT_INT_MSB                   0
+#define INT_STATUS_WDT_INT_LSB                   0
+#define INT_STATUS_WDT_INT_MASK                  0x00000001
+#define INT_STATUS_WDT_INT_GET(x)                (((x) & INT_STATUS_WDT_INT_MASK) >> INT_STATUS_WDT_INT_LSB)
+#define INT_STATUS_WDT_INT_SET(x)                (((x) << INT_STATUS_WDT_INT_LSB) & INT_STATUS_WDT_INT_MASK)
+
+#define LF_TIMER0_ADDRESS                        0x00000048
+#define LF_TIMER0_OFFSET                         0x00000048
+#define LF_TIMER0_TARGET_MSB                     31
+#define LF_TIMER0_TARGET_LSB                     0
+#define LF_TIMER0_TARGET_MASK                    0xffffffff
+#define LF_TIMER0_TARGET_GET(x)                  (((x) & LF_TIMER0_TARGET_MASK) >> LF_TIMER0_TARGET_LSB)
+#define LF_TIMER0_TARGET_SET(x)                  (((x) << LF_TIMER0_TARGET_LSB) & LF_TIMER0_TARGET_MASK)
+
+#define LF_TIMER_COUNT0_ADDRESS                  0x0000004c
+#define LF_TIMER_COUNT0_OFFSET                   0x0000004c
+#define LF_TIMER_COUNT0_VALUE_MSB                31
+#define LF_TIMER_COUNT0_VALUE_LSB                0
+#define LF_TIMER_COUNT0_VALUE_MASK               0xffffffff
+#define LF_TIMER_COUNT0_VALUE_GET(x)             (((x) & LF_TIMER_COUNT0_VALUE_MASK) >> LF_TIMER_COUNT0_VALUE_LSB)
+#define LF_TIMER_COUNT0_VALUE_SET(x)             (((x) << LF_TIMER_COUNT0_VALUE_LSB) & LF_TIMER_COUNT0_VALUE_MASK)
+
+#define LF_TIMER_CONTROL0_ADDRESS                0x00000050
+#define LF_TIMER_CONTROL0_OFFSET                 0x00000050
+#define LF_TIMER_CONTROL0_ENABLE_MSB             2
+#define LF_TIMER_CONTROL0_ENABLE_LSB             2
+#define LF_TIMER_CONTROL0_ENABLE_MASK            0x00000004
+#define LF_TIMER_CONTROL0_ENABLE_GET(x)          (((x) & LF_TIMER_CONTROL0_ENABLE_MASK) >> LF_TIMER_CONTROL0_ENABLE_LSB)
+#define LF_TIMER_CONTROL0_ENABLE_SET(x)          (((x) << LF_TIMER_CONTROL0_ENABLE_LSB) & LF_TIMER_CONTROL0_ENABLE_MASK)
+#define LF_TIMER_CONTROL0_AUTO_RESTART_MSB       1
+#define LF_TIMER_CONTROL0_AUTO_RESTART_LSB       1
+#define LF_TIMER_CONTROL0_AUTO_RESTART_MASK      0x00000002
+#define LF_TIMER_CONTROL0_AUTO_RESTART_GET(x)    (((x) & LF_TIMER_CONTROL0_AUTO_RESTART_MASK) >> LF_TIMER_CONTROL0_AUTO_RESTART_LSB)
+#define LF_TIMER_CONTROL0_AUTO_RESTART_SET(x)    (((x) << LF_TIMER_CONTROL0_AUTO_RESTART_LSB) & LF_TIMER_CONTROL0_AUTO_RESTART_MASK)
+#define LF_TIMER_CONTROL0_RESET_MSB              0
+#define LF_TIMER_CONTROL0_RESET_LSB              0
+#define LF_TIMER_CONTROL0_RESET_MASK             0x00000001
+#define LF_TIMER_CONTROL0_RESET_GET(x)           (((x) & LF_TIMER_CONTROL0_RESET_MASK) >> LF_TIMER_CONTROL0_RESET_LSB)
+#define LF_TIMER_CONTROL0_RESET_SET(x)           (((x) << LF_TIMER_CONTROL0_RESET_LSB) & LF_TIMER_CONTROL0_RESET_MASK)
+
+#define LF_TIMER_STATUS0_ADDRESS                 0x00000054
+#define LF_TIMER_STATUS0_OFFSET                  0x00000054
+#define LF_TIMER_STATUS0_INTERRUPT_MSB           0
+#define LF_TIMER_STATUS0_INTERRUPT_LSB           0
+#define LF_TIMER_STATUS0_INTERRUPT_MASK          0x00000001
+#define LF_TIMER_STATUS0_INTERRUPT_GET(x)        (((x) & LF_TIMER_STATUS0_INTERRUPT_MASK) >> LF_TIMER_STATUS0_INTERRUPT_LSB)
+#define LF_TIMER_STATUS0_INTERRUPT_SET(x)        (((x) << LF_TIMER_STATUS0_INTERRUPT_LSB) & LF_TIMER_STATUS0_INTERRUPT_MASK)
+
+#define LF_TIMER1_ADDRESS                        0x00000058
+#define LF_TIMER1_OFFSET                         0x00000058
+#define LF_TIMER1_TARGET_MSB                     31
+#define LF_TIMER1_TARGET_LSB                     0
+#define LF_TIMER1_TARGET_MASK                    0xffffffff
+#define LF_TIMER1_TARGET_GET(x)                  (((x) & LF_TIMER1_TARGET_MASK) >> LF_TIMER1_TARGET_LSB)
+#define LF_TIMER1_TARGET_SET(x)                  (((x) << LF_TIMER1_TARGET_LSB) & LF_TIMER1_TARGET_MASK)
+
+#define LF_TIMER_COUNT1_ADDRESS                  0x0000005c
+#define LF_TIMER_COUNT1_OFFSET                   0x0000005c
+#define LF_TIMER_COUNT1_VALUE_MSB                31
+#define LF_TIMER_COUNT1_VALUE_LSB                0
+#define LF_TIMER_COUNT1_VALUE_MASK               0xffffffff
+#define LF_TIMER_COUNT1_VALUE_GET(x)             (((x) & LF_TIMER_COUNT1_VALUE_MASK) >> LF_TIMER_COUNT1_VALUE_LSB)
+#define LF_TIMER_COUNT1_VALUE_SET(x)             (((x) << LF_TIMER_COUNT1_VALUE_LSB) & LF_TIMER_COUNT1_VALUE_MASK)
+
+#define LF_TIMER_CONTROL1_ADDRESS                0x00000060
+#define LF_TIMER_CONTROL1_OFFSET                 0x00000060
+#define LF_TIMER_CONTROL1_ENABLE_MSB             2
+#define LF_TIMER_CONTROL1_ENABLE_LSB             2
+#define LF_TIMER_CONTROL1_ENABLE_MASK            0x00000004
+#define LF_TIMER_CONTROL1_ENABLE_GET(x)          (((x) & LF_TIMER_CONTROL1_ENABLE_MASK) >> LF_TIMER_CONTROL1_ENABLE_LSB)
+#define LF_TIMER_CONTROL1_ENABLE_SET(x)          (((x) << LF_TIMER_CONTROL1_ENABLE_LSB) & LF_TIMER_CONTROL1_ENABLE_MASK)
+#define LF_TIMER_CONTROL1_AUTO_RESTART_MSB       1
+#define LF_TIMER_CONTROL1_AUTO_RESTART_LSB       1
+#define LF_TIMER_CONTROL1_AUTO_RESTART_MASK      0x00000002
+#define LF_TIMER_CONTROL1_AUTO_RESTART_GET(x)    (((x) & LF_TIMER_CONTROL1_AUTO_RESTART_MASK) >> LF_TIMER_CONTROL1_AUTO_RESTART_LSB)
+#define LF_TIMER_CONTROL1_AUTO_RESTART_SET(x)    (((x) << LF_TIMER_CONTROL1_AUTO_RESTART_LSB) & LF_TIMER_CONTROL1_AUTO_RESTART_MASK)
+#define LF_TIMER_CONTROL1_RESET_MSB              0
+#define LF_TIMER_CONTROL1_RESET_LSB              0
+#define LF_TIMER_CONTROL1_RESET_MASK             0x00000001
+#define LF_TIMER_CONTROL1_RESET_GET(x)           (((x) & LF_TIMER_CONTROL1_RESET_MASK) >> LF_TIMER_CONTROL1_RESET_LSB)
+#define LF_TIMER_CONTROL1_RESET_SET(x)           (((x) << LF_TIMER_CONTROL1_RESET_LSB) & LF_TIMER_CONTROL1_RESET_MASK)
+
+#define LF_TIMER_STATUS1_ADDRESS                 0x00000064
+#define LF_TIMER_STATUS1_OFFSET                  0x00000064
+#define LF_TIMER_STATUS1_INTERRUPT_MSB           0
+#define LF_TIMER_STATUS1_INTERRUPT_LSB           0
+#define LF_TIMER_STATUS1_INTERRUPT_MASK          0x00000001
+#define LF_TIMER_STATUS1_INTERRUPT_GET(x)        (((x) & LF_TIMER_STATUS1_INTERRUPT_MASK) >> LF_TIMER_STATUS1_INTERRUPT_LSB)
+#define LF_TIMER_STATUS1_INTERRUPT_SET(x)        (((x) << LF_TIMER_STATUS1_INTERRUPT_LSB) & LF_TIMER_STATUS1_INTERRUPT_MASK)
+
+#define LF_TIMER2_ADDRESS                        0x00000068
+#define LF_TIMER2_OFFSET                         0x00000068
+#define LF_TIMER2_TARGET_MSB                     31
+#define LF_TIMER2_TARGET_LSB                     0
+#define LF_TIMER2_TARGET_MASK                    0xffffffff
+#define LF_TIMER2_TARGET_GET(x)                  (((x) & LF_TIMER2_TARGET_MASK) >> LF_TIMER2_TARGET_LSB)
+#define LF_TIMER2_TARGET_SET(x)                  (((x) << LF_TIMER2_TARGET_LSB) & LF_TIMER2_TARGET_MASK)
+
+#define LF_TIMER_COUNT2_ADDRESS                  0x0000006c
+#define LF_TIMER_COUNT2_OFFSET                   0x0000006c
+#define LF_TIMER_COUNT2_VALUE_MSB                31
+#define LF_TIMER_COUNT2_VALUE_LSB                0
+#define LF_TIMER_COUNT2_VALUE_MASK               0xffffffff
+#define LF_TIMER_COUNT2_VALUE_GET(x)             (((x) & LF_TIMER_COUNT2_VALUE_MASK) >> LF_TIMER_COUNT2_VALUE_LSB)
+#define LF_TIMER_COUNT2_VALUE_SET(x)             (((x) << LF_TIMER_COUNT2_VALUE_LSB) & LF_TIMER_COUNT2_VALUE_MASK)
+
+#define LF_TIMER_CONTROL2_ADDRESS                0x00000070
+#define LF_TIMER_CONTROL2_OFFSET                 0x00000070
+#define LF_TIMER_CONTROL2_ENABLE_MSB             2
+#define LF_TIMER_CONTROL2_ENABLE_LSB             2
+#define LF_TIMER_CONTROL2_ENABLE_MASK            0x00000004
+#define LF_TIMER_CONTROL2_ENABLE_GET(x)          (((x) & LF_TIMER_CONTROL2_ENABLE_MASK) >> LF_TIMER_CONTROL2_ENABLE_LSB)
+#define LF_TIMER_CONTROL2_ENABLE_SET(x)          (((x) << LF_TIMER_CONTROL2_ENABLE_LSB) & LF_TIMER_CONTROL2_ENABLE_MASK)
+#define LF_TIMER_CONTROL2_AUTO_RESTART_MSB       1
+#define LF_TIMER_CONTROL2_AUTO_RESTART_LSB       1
+#define LF_TIMER_CONTROL2_AUTO_RESTART_MASK      0x00000002
+#define LF_TIMER_CONTROL2_AUTO_RESTART_GET(x)    (((x) & LF_TIMER_CONTROL2_AUTO_RESTART_MASK) >> LF_TIMER_CONTROL2_AUTO_RESTART_LSB)
+#define LF_TIMER_CONTROL2_AUTO_RESTART_SET(x)    (((x) << LF_TIMER_CONTROL2_AUTO_RESTART_LSB) & LF_TIMER_CONTROL2_AUTO_RESTART_MASK)
+#define LF_TIMER_CONTROL2_RESET_MSB              0
+#define LF_TIMER_CONTROL2_RESET_LSB              0
+#define LF_TIMER_CONTROL2_RESET_MASK             0x00000001
+#define LF_TIMER_CONTROL2_RESET_GET(x)           (((x) & LF_TIMER_CONTROL2_RESET_MASK) >> LF_TIMER_CONTROL2_RESET_LSB)
+#define LF_TIMER_CONTROL2_RESET_SET(x)           (((x) << LF_TIMER_CONTROL2_RESET_LSB) & LF_TIMER_CONTROL2_RESET_MASK)
+
+#define LF_TIMER_STATUS2_ADDRESS                 0x00000074
+#define LF_TIMER_STATUS2_OFFSET                  0x00000074
+#define LF_TIMER_STATUS2_INTERRUPT_MSB           0
+#define LF_TIMER_STATUS2_INTERRUPT_LSB           0
+#define LF_TIMER_STATUS2_INTERRUPT_MASK          0x00000001
+#define LF_TIMER_STATUS2_INTERRUPT_GET(x)        (((x) & LF_TIMER_STATUS2_INTERRUPT_MASK) >> LF_TIMER_STATUS2_INTERRUPT_LSB)
+#define LF_TIMER_STATUS2_INTERRUPT_SET(x)        (((x) << LF_TIMER_STATUS2_INTERRUPT_LSB) & LF_TIMER_STATUS2_INTERRUPT_MASK)
+
+#define LF_TIMER3_ADDRESS                        0x00000078
+#define LF_TIMER3_OFFSET                         0x00000078
+#define LF_TIMER3_TARGET_MSB                     31
+#define LF_TIMER3_TARGET_LSB                     0
+#define LF_TIMER3_TARGET_MASK                    0xffffffff
+#define LF_TIMER3_TARGET_GET(x)                  (((x) & LF_TIMER3_TARGET_MASK) >> LF_TIMER3_TARGET_LSB)
+#define LF_TIMER3_TARGET_SET(x)                  (((x) << LF_TIMER3_TARGET_LSB) & LF_TIMER3_TARGET_MASK)
+
+#define LF_TIMER_COUNT3_ADDRESS                  0x0000007c
+#define LF_TIMER_COUNT3_OFFSET                   0x0000007c
+#define LF_TIMER_COUNT3_VALUE_MSB                31
+#define LF_TIMER_COUNT3_VALUE_LSB                0
+#define LF_TIMER_COUNT3_VALUE_MASK               0xffffffff
+#define LF_TIMER_COUNT3_VALUE_GET(x)             (((x) & LF_TIMER_COUNT3_VALUE_MASK) >> LF_TIMER_COUNT3_VALUE_LSB)
+#define LF_TIMER_COUNT3_VALUE_SET(x)             (((x) << LF_TIMER_COUNT3_VALUE_LSB) & LF_TIMER_COUNT3_VALUE_MASK)
+
+#define LF_TIMER_CONTROL3_ADDRESS                0x00000080
+#define LF_TIMER_CONTROL3_OFFSET                 0x00000080
+#define LF_TIMER_CONTROL3_ENABLE_MSB             2
+#define LF_TIMER_CONTROL3_ENABLE_LSB             2
+#define LF_TIMER_CONTROL3_ENABLE_MASK            0x00000004
+#define LF_TIMER_CONTROL3_ENABLE_GET(x)          (((x) & LF_TIMER_CONTROL3_ENABLE_MASK) >> LF_TIMER_CONTROL3_ENABLE_LSB)
+#define LF_TIMER_CONTROL3_ENABLE_SET(x)          (((x) << LF_TIMER_CONTROL3_ENABLE_LSB) & LF_TIMER_CONTROL3_ENABLE_MASK)
+#define LF_TIMER_CONTROL3_AUTO_RESTART_MSB       1
+#define LF_TIMER_CONTROL3_AUTO_RESTART_LSB       1
+#define LF_TIMER_CONTROL3_AUTO_RESTART_MASK      0x00000002
+#define LF_TIMER_CONTROL3_AUTO_RESTART_GET(x)    (((x) & LF_TIMER_CONTROL3_AUTO_RESTART_MASK) >> LF_TIMER_CONTROL3_AUTO_RESTART_LSB)
+#define LF_TIMER_CONTROL3_AUTO_RESTART_SET(x)    (((x) << LF_TIMER_CONTROL3_AUTO_RESTART_LSB) & LF_TIMER_CONTROL3_AUTO_RESTART_MASK)
+#define LF_TIMER_CONTROL3_RESET_MSB              0
+#define LF_TIMER_CONTROL3_RESET_LSB              0
+#define LF_TIMER_CONTROL3_RESET_MASK             0x00000001
+#define LF_TIMER_CONTROL3_RESET_GET(x)           (((x) & LF_TIMER_CONTROL3_RESET_MASK) >> LF_TIMER_CONTROL3_RESET_LSB)
+#define LF_TIMER_CONTROL3_RESET_SET(x)           (((x) << LF_TIMER_CONTROL3_RESET_LSB) & LF_TIMER_CONTROL3_RESET_MASK)
+
+#define LF_TIMER_STATUS3_ADDRESS                 0x00000084
+#define LF_TIMER_STATUS3_OFFSET                  0x00000084
+#define LF_TIMER_STATUS3_INTERRUPT_MSB           0
+#define LF_TIMER_STATUS3_INTERRUPT_LSB           0
+#define LF_TIMER_STATUS3_INTERRUPT_MASK          0x00000001
+#define LF_TIMER_STATUS3_INTERRUPT_GET(x)        (((x) & LF_TIMER_STATUS3_INTERRUPT_MASK) >> LF_TIMER_STATUS3_INTERRUPT_LSB)
+#define LF_TIMER_STATUS3_INTERRUPT_SET(x)        (((x) << LF_TIMER_STATUS3_INTERRUPT_LSB) & LF_TIMER_STATUS3_INTERRUPT_MASK)
+
+#define HF_TIMER_ADDRESS                         0x00000088
+#define HF_TIMER_OFFSET                          0x00000088
+#define HF_TIMER_TARGET_MSB                      31
+#define HF_TIMER_TARGET_LSB                      12
+#define HF_TIMER_TARGET_MASK                     0xfffff000
+#define HF_TIMER_TARGET_GET(x)                   (((x) & HF_TIMER_TARGET_MASK) >> HF_TIMER_TARGET_LSB)
+#define HF_TIMER_TARGET_SET(x)                   (((x) << HF_TIMER_TARGET_LSB) & HF_TIMER_TARGET_MASK)
+
+#define HF_TIMER_COUNT_ADDRESS                   0x0000008c
+#define HF_TIMER_COUNT_OFFSET                    0x0000008c
+#define HF_TIMER_COUNT_VALUE_MSB                 31
+#define HF_TIMER_COUNT_VALUE_LSB                 12
+#define HF_TIMER_COUNT_VALUE_MASK                0xfffff000
+#define HF_TIMER_COUNT_VALUE_GET(x)              (((x) & HF_TIMER_COUNT_VALUE_MASK) >> HF_TIMER_COUNT_VALUE_LSB)
+#define HF_TIMER_COUNT_VALUE_SET(x)              (((x) << HF_TIMER_COUNT_VALUE_LSB) & HF_TIMER_COUNT_VALUE_MASK)
+
+#define HF_LF_COUNT_ADDRESS                      0x00000090
+#define HF_LF_COUNT_OFFSET                       0x00000090
+#define HF_LF_COUNT_VALUE_MSB                    31
+#define HF_LF_COUNT_VALUE_LSB                    0
+#define HF_LF_COUNT_VALUE_MASK                   0xffffffff
+#define HF_LF_COUNT_VALUE_GET(x)                 (((x) & HF_LF_COUNT_VALUE_MASK) >> HF_LF_COUNT_VALUE_LSB)
+#define HF_LF_COUNT_VALUE_SET(x)                 (((x) << HF_LF_COUNT_VALUE_LSB) & HF_LF_COUNT_VALUE_MASK)
+
+#define HF_TIMER_CONTROL_ADDRESS                 0x00000094
+#define HF_TIMER_CONTROL_OFFSET                  0x00000094
+#define HF_TIMER_CONTROL_ENABLE_MSB              3
+#define HF_TIMER_CONTROL_ENABLE_LSB              3
+#define HF_TIMER_CONTROL_ENABLE_MASK             0x00000008
+#define HF_TIMER_CONTROL_ENABLE_GET(x)           (((x) & HF_TIMER_CONTROL_ENABLE_MASK) >> HF_TIMER_CONTROL_ENABLE_LSB)
+#define HF_TIMER_CONTROL_ENABLE_SET(x)           (((x) << HF_TIMER_CONTROL_ENABLE_LSB) & HF_TIMER_CONTROL_ENABLE_MASK)
+#define HF_TIMER_CONTROL_ON_MSB                  2
+#define HF_TIMER_CONTROL_ON_LSB                  2
+#define HF_TIMER_CONTROL_ON_MASK                 0x00000004
+#define HF_TIMER_CONTROL_ON_GET(x)               (((x) & HF_TIMER_CONTROL_ON_MASK) >> HF_TIMER_CONTROL_ON_LSB)
+#define HF_TIMER_CONTROL_ON_SET(x)               (((x) << HF_TIMER_CONTROL_ON_LSB) & HF_TIMER_CONTROL_ON_MASK)
+#define HF_TIMER_CONTROL_AUTO_RESTART_MSB        1
+#define HF_TIMER_CONTROL_AUTO_RESTART_LSB        1
+#define HF_TIMER_CONTROL_AUTO_RESTART_MASK       0x00000002
+#define HF_TIMER_CONTROL_AUTO_RESTART_GET(x)     (((x) & HF_TIMER_CONTROL_AUTO_RESTART_MASK) >> HF_TIMER_CONTROL_AUTO_RESTART_LSB)
+#define HF_TIMER_CONTROL_AUTO_RESTART_SET(x)     (((x) << HF_TIMER_CONTROL_AUTO_RESTART_LSB) & HF_TIMER_CONTROL_AUTO_RESTART_MASK)
+#define HF_TIMER_CONTROL_RESET_MSB               0
+#define HF_TIMER_CONTROL_RESET_LSB               0
+#define HF_TIMER_CONTROL_RESET_MASK              0x00000001
+#define HF_TIMER_CONTROL_RESET_GET(x)            (((x) & HF_TIMER_CONTROL_RESET_MASK) >> HF_TIMER_CONTROL_RESET_LSB)
+#define HF_TIMER_CONTROL_RESET_SET(x)            (((x) << HF_TIMER_CONTROL_RESET_LSB) & HF_TIMER_CONTROL_RESET_MASK)
+
+#define HF_TIMER_STATUS_ADDRESS                  0x00000098
+#define HF_TIMER_STATUS_OFFSET                   0x00000098
+#define HF_TIMER_STATUS_INTERRUPT_MSB            0
+#define HF_TIMER_STATUS_INTERRUPT_LSB            0
+#define HF_TIMER_STATUS_INTERRUPT_MASK           0x00000001
+#define HF_TIMER_STATUS_INTERRUPT_GET(x)         (((x) & HF_TIMER_STATUS_INTERRUPT_MASK) >> HF_TIMER_STATUS_INTERRUPT_LSB)
+#define HF_TIMER_STATUS_INTERRUPT_SET(x)         (((x) << HF_TIMER_STATUS_INTERRUPT_LSB) & HF_TIMER_STATUS_INTERRUPT_MASK)
+
+#define RTC_CONTROL_ADDRESS                      0x0000009c
+#define RTC_CONTROL_OFFSET                       0x0000009c
+#define RTC_CONTROL_ENABLE_MSB                   2
+#define RTC_CONTROL_ENABLE_LSB                   2
+#define RTC_CONTROL_ENABLE_MASK                  0x00000004
+#define RTC_CONTROL_ENABLE_GET(x)                (((x) & RTC_CONTROL_ENABLE_MASK) >> RTC_CONTROL_ENABLE_LSB)
+#define RTC_CONTROL_ENABLE_SET(x)                (((x) << RTC_CONTROL_ENABLE_LSB) & RTC_CONTROL_ENABLE_MASK)
+#define RTC_CONTROL_LOAD_RTC_MSB                 1
+#define RTC_CONTROL_LOAD_RTC_LSB                 1
+#define RTC_CONTROL_LOAD_RTC_MASK                0x00000002
+#define RTC_CONTROL_LOAD_RTC_GET(x)              (((x) & RTC_CONTROL_LOAD_RTC_MASK) >> RTC_CONTROL_LOAD_RTC_LSB)
+#define RTC_CONTROL_LOAD_RTC_SET(x)              (((x) << RTC_CONTROL_LOAD_RTC_LSB) & RTC_CONTROL_LOAD_RTC_MASK)
+#define RTC_CONTROL_LOAD_ALARM_MSB               0
+#define RTC_CONTROL_LOAD_ALARM_LSB               0
+#define RTC_CONTROL_LOAD_ALARM_MASK              0x00000001
+#define RTC_CONTROL_LOAD_ALARM_GET(x)            (((x) & RTC_CONTROL_LOAD_ALARM_MASK) >> RTC_CONTROL_LOAD_ALARM_LSB)
+#define RTC_CONTROL_LOAD_ALARM_SET(x)            (((x) << RTC_CONTROL_LOAD_ALARM_LSB) & RTC_CONTROL_LOAD_ALARM_MASK)
+
+#define RTC_TIME_ADDRESS                         0x000000a0
+#define RTC_TIME_OFFSET                          0x000000a0
+#define RTC_TIME_WEEK_DAY_MSB                    26
+#define RTC_TIME_WEEK_DAY_LSB                    24
+#define RTC_TIME_WEEK_DAY_MASK                   0x07000000
+#define RTC_TIME_WEEK_DAY_GET(x)                 (((x) & RTC_TIME_WEEK_DAY_MASK) >> RTC_TIME_WEEK_DAY_LSB)
+#define RTC_TIME_WEEK_DAY_SET(x)                 (((x) << RTC_TIME_WEEK_DAY_LSB) & RTC_TIME_WEEK_DAY_MASK)
+#define RTC_TIME_HOUR_MSB                        21
+#define RTC_TIME_HOUR_LSB                        16
+#define RTC_TIME_HOUR_MASK                       0x003f0000
+#define RTC_TIME_HOUR_GET(x)                     (((x) & RTC_TIME_HOUR_MASK) >> RTC_TIME_HOUR_LSB)
+#define RTC_TIME_HOUR_SET(x)                     (((x) << RTC_TIME_HOUR_LSB) & RTC_TIME_HOUR_MASK)
+#define RTC_TIME_MINUTE_MSB                      14
+#define RTC_TIME_MINUTE_LSB                      8
+#define RTC_TIME_MINUTE_MASK                     0x00007f00
+#define RTC_TIME_MINUTE_GET(x)                   (((x) & RTC_TIME_MINUTE_MASK) >> RTC_TIME_MINUTE_LSB)
+#define RTC_TIME_MINUTE_SET(x)                   (((x) << RTC_TIME_MINUTE_LSB) & RTC_TIME_MINUTE_MASK)
+#define RTC_TIME_SECOND_MSB                      6
+#define RTC_TIME_SECOND_LSB                      0
+#define RTC_TIME_SECOND_MASK                     0x0000007f
+#define RTC_TIME_SECOND_GET(x)                   (((x) & RTC_TIME_SECOND_MASK) >> RTC_TIME_SECOND_LSB)
+#define RTC_TIME_SECOND_SET(x)                   (((x) << RTC_TIME_SECOND_LSB) & RTC_TIME_SECOND_MASK)
+
+#define RTC_DATE_ADDRESS                         0x000000a4
+#define RTC_DATE_OFFSET                          0x000000a4
+#define RTC_DATE_YEAR_MSB                        23
+#define RTC_DATE_YEAR_LSB                        16
+#define RTC_DATE_YEAR_MASK                       0x00ff0000
+#define RTC_DATE_YEAR_GET(x)                     (((x) & RTC_DATE_YEAR_MASK) >> RTC_DATE_YEAR_LSB)
+#define RTC_DATE_YEAR_SET(x)                     (((x) << RTC_DATE_YEAR_LSB) & RTC_DATE_YEAR_MASK)
+#define RTC_DATE_MONTH_MSB                       12
+#define RTC_DATE_MONTH_LSB                       8
+#define RTC_DATE_MONTH_MASK                      0x00001f00
+#define RTC_DATE_MONTH_GET(x)                    (((x) & RTC_DATE_MONTH_MASK) >> RTC_DATE_MONTH_LSB)
+#define RTC_DATE_MONTH_SET(x)                    (((x) << RTC_DATE_MONTH_LSB) & RTC_DATE_MONTH_MASK)
+#define RTC_DATE_MONTH_DAY_MSB                   5
+#define RTC_DATE_MONTH_DAY_LSB                   0
+#define RTC_DATE_MONTH_DAY_MASK                  0x0000003f
+#define RTC_DATE_MONTH_DAY_GET(x)                (((x) & RTC_DATE_MONTH_DAY_MASK) >> RTC_DATE_MONTH_DAY_LSB)
+#define RTC_DATE_MONTH_DAY_SET(x)                (((x) << RTC_DATE_MONTH_DAY_LSB) & RTC_DATE_MONTH_DAY_MASK)
+
+#define RTC_SET_TIME_ADDRESS                     0x000000a8
+#define RTC_SET_TIME_OFFSET                      0x000000a8
+#define RTC_SET_TIME_WEEK_DAY_MSB                26
+#define RTC_SET_TIME_WEEK_DAY_LSB                24
+#define RTC_SET_TIME_WEEK_DAY_MASK               0x07000000
+#define RTC_SET_TIME_WEEK_DAY_GET(x)             (((x) & RTC_SET_TIME_WEEK_DAY_MASK) >> RTC_SET_TIME_WEEK_DAY_LSB)
+#define RTC_SET_TIME_WEEK_DAY_SET(x)             (((x) << RTC_SET_TIME_WEEK_DAY_LSB) & RTC_SET_TIME_WEEK_DAY_MASK)
+#define RTC_SET_TIME_HOUR_MSB                    21
+#define RTC_SET_TIME_HOUR_LSB                    16
+#define RTC_SET_TIME_HOUR_MASK                   0x003f0000
+#define RTC_SET_TIME_HOUR_GET(x)                 (((x) & RTC_SET_TIME_HOUR_MASK) >> RTC_SET_TIME_HOUR_LSB)
+#define RTC_SET_TIME_HOUR_SET(x)                 (((x) << RTC_SET_TIME_HOUR_LSB) & RTC_SET_TIME_HOUR_MASK)
+#define RTC_SET_TIME_MINUTE_MSB                  14
+#define RTC_SET_TIME_MINUTE_LSB                  8
+#define RTC_SET_TIME_MINUTE_MASK                 0x00007f00
+#define RTC_SET_TIME_MINUTE_GET(x)               (((x) & RTC_SET_TIME_MINUTE_MASK) >> RTC_SET_TIME_MINUTE_LSB)
+#define RTC_SET_TIME_MINUTE_SET(x)               (((x) << RTC_SET_TIME_MINUTE_LSB) & RTC_SET_TIME_MINUTE_MASK)
+#define RTC_SET_TIME_SECOND_MSB                  6
+#define RTC_SET_TIME_SECOND_LSB                  0
+#define RTC_SET_TIME_SECOND_MASK                 0x0000007f
+#define RTC_SET_TIME_SECOND_GET(x)               (((x) & RTC_SET_TIME_SECOND_MASK) >> RTC_SET_TIME_SECOND_LSB)
+#define RTC_SET_TIME_SECOND_SET(x)               (((x) << RTC_SET_TIME_SECOND_LSB) & RTC_SET_TIME_SECOND_MASK)
+
+#define RTC_SET_DATE_ADDRESS                     0x000000ac
+#define RTC_SET_DATE_OFFSET                      0x000000ac
+#define RTC_SET_DATE_YEAR_MSB                    23
+#define RTC_SET_DATE_YEAR_LSB                    16
+#define RTC_SET_DATE_YEAR_MASK                   0x00ff0000
+#define RTC_SET_DATE_YEAR_GET(x)                 (((x) & RTC_SET_DATE_YEAR_MASK) >> RTC_SET_DATE_YEAR_LSB)
+#define RTC_SET_DATE_YEAR_SET(x)                 (((x) << RTC_SET_DATE_YEAR_LSB) & RTC_SET_DATE_YEAR_MASK)
+#define RTC_SET_DATE_MONTH_MSB                   12
+#define RTC_SET_DATE_MONTH_LSB                   8
+#define RTC_SET_DATE_MONTH_MASK                  0x00001f00
+#define RTC_SET_DATE_MONTH_GET(x)                (((x) & RTC_SET_DATE_MONTH_MASK) >> RTC_SET_DATE_MONTH_LSB)
+#define RTC_SET_DATE_MONTH_SET(x)                (((x) << RTC_SET_DATE_MONTH_LSB) & RTC_SET_DATE_MONTH_MASK)
+#define RTC_SET_DATE_MONTH_DAY_MSB               5
+#define RTC_SET_DATE_MONTH_DAY_LSB               0
+#define RTC_SET_DATE_MONTH_DAY_MASK              0x0000003f
+#define RTC_SET_DATE_MONTH_DAY_GET(x)            (((x) & RTC_SET_DATE_MONTH_DAY_MASK) >> RTC_SET_DATE_MONTH_DAY_LSB)
+#define RTC_SET_DATE_MONTH_DAY_SET(x)            (((x) << RTC_SET_DATE_MONTH_DAY_LSB) & RTC_SET_DATE_MONTH_DAY_MASK)
+
+#define RTC_SET_ALARM_ADDRESS                    0x000000b0
+#define RTC_SET_ALARM_OFFSET                     0x000000b0
+#define RTC_SET_ALARM_HOUR_MSB                   21
+#define RTC_SET_ALARM_HOUR_LSB                   16
+#define RTC_SET_ALARM_HOUR_MASK                  0x003f0000
+#define RTC_SET_ALARM_HOUR_GET(x)                (((x) & RTC_SET_ALARM_HOUR_MASK) >> RTC_SET_ALARM_HOUR_LSB)
+#define RTC_SET_ALARM_HOUR_SET(x)                (((x) << RTC_SET_ALARM_HOUR_LSB) & RTC_SET_ALARM_HOUR_MASK)
+#define RTC_SET_ALARM_MINUTE_MSB                 14
+#define RTC_SET_ALARM_MINUTE_LSB                 8
+#define RTC_SET_ALARM_MINUTE_MASK                0x00007f00
+#define RTC_SET_ALARM_MINUTE_GET(x)              (((x) & RTC_SET_ALARM_MINUTE_MASK) >> RTC_SET_ALARM_MINUTE_LSB)
+#define RTC_SET_ALARM_MINUTE_SET(x)              (((x) << RTC_SET_ALARM_MINUTE_LSB) & RTC_SET_ALARM_MINUTE_MASK)
+#define RTC_SET_ALARM_SECOND_MSB                 6
+#define RTC_SET_ALARM_SECOND_LSB                 0
+#define RTC_SET_ALARM_SECOND_MASK                0x0000007f
+#define RTC_SET_ALARM_SECOND_GET(x)              (((x) & RTC_SET_ALARM_SECOND_MASK) >> RTC_SET_ALARM_SECOND_LSB)
+#define RTC_SET_ALARM_SECOND_SET(x)              (((x) << RTC_SET_ALARM_SECOND_LSB) & RTC_SET_ALARM_SECOND_MASK)
+
+#define RTC_CONFIG_ADDRESS                       0x000000b4
+#define RTC_CONFIG_OFFSET                        0x000000b4
+#define RTC_CONFIG_BCD_MSB                       2
+#define RTC_CONFIG_BCD_LSB                       2
+#define RTC_CONFIG_BCD_MASK                      0x00000004
+#define RTC_CONFIG_BCD_GET(x)                    (((x) & RTC_CONFIG_BCD_MASK) >> RTC_CONFIG_BCD_LSB)
+#define RTC_CONFIG_BCD_SET(x)                    (((x) << RTC_CONFIG_BCD_LSB) & RTC_CONFIG_BCD_MASK)
+#define RTC_CONFIG_TWELVE_HOUR_MSB               1
+#define RTC_CONFIG_TWELVE_HOUR_LSB               1
+#define RTC_CONFIG_TWELVE_HOUR_MASK              0x00000002
+#define RTC_CONFIG_TWELVE_HOUR_GET(x)            (((x) & RTC_CONFIG_TWELVE_HOUR_MASK) >> RTC_CONFIG_TWELVE_HOUR_LSB)
+#define RTC_CONFIG_TWELVE_HOUR_SET(x)            (((x) << RTC_CONFIG_TWELVE_HOUR_LSB) & RTC_CONFIG_TWELVE_HOUR_MASK)
+#define RTC_CONFIG_DSE_MSB                       0
+#define RTC_CONFIG_DSE_LSB                       0
+#define RTC_CONFIG_DSE_MASK                      0x00000001
+#define RTC_CONFIG_DSE_GET(x)                    (((x) & RTC_CONFIG_DSE_MASK) >> RTC_CONFIG_DSE_LSB)
+#define RTC_CONFIG_DSE_SET(x)                    (((x) << RTC_CONFIG_DSE_LSB) & RTC_CONFIG_DSE_MASK)
+
+#define RTC_ALARM_STATUS_ADDRESS                 0x000000b8
+#define RTC_ALARM_STATUS_OFFSET                  0x000000b8
+#define RTC_ALARM_STATUS_ENABLE_MSB              1
+#define RTC_ALARM_STATUS_ENABLE_LSB              1
+#define RTC_ALARM_STATUS_ENABLE_MASK             0x00000002
+#define RTC_ALARM_STATUS_ENABLE_GET(x)           (((x) & RTC_ALARM_STATUS_ENABLE_MASK) >> RTC_ALARM_STATUS_ENABLE_LSB)
+#define RTC_ALARM_STATUS_ENABLE_SET(x)           (((x) << RTC_ALARM_STATUS_ENABLE_LSB) & RTC_ALARM_STATUS_ENABLE_MASK)
+#define RTC_ALARM_STATUS_INTERRUPT_MSB           0
+#define RTC_ALARM_STATUS_INTERRUPT_LSB           0
+#define RTC_ALARM_STATUS_INTERRUPT_MASK          0x00000001
+#define RTC_ALARM_STATUS_INTERRUPT_GET(x)        (((x) & RTC_ALARM_STATUS_INTERRUPT_MASK) >> RTC_ALARM_STATUS_INTERRUPT_LSB)
+#define RTC_ALARM_STATUS_INTERRUPT_SET(x)        (((x) << RTC_ALARM_STATUS_INTERRUPT_LSB) & RTC_ALARM_STATUS_INTERRUPT_MASK)
+
+#define UART_WAKEUP_ADDRESS                      0x000000bc
+#define UART_WAKEUP_OFFSET                       0x000000bc
+#define UART_WAKEUP_ENABLE_MSB                   0
+#define UART_WAKEUP_ENABLE_LSB                   0
+#define UART_WAKEUP_ENABLE_MASK                  0x00000001
+#define UART_WAKEUP_ENABLE_GET(x)                (((x) & UART_WAKEUP_ENABLE_MASK) >> UART_WAKEUP_ENABLE_LSB)
+#define UART_WAKEUP_ENABLE_SET(x)                (((x) << UART_WAKEUP_ENABLE_LSB) & UART_WAKEUP_ENABLE_MASK)
+
+#define RESET_CAUSE_ADDRESS                      0x000000c0
+#define RESET_CAUSE_OFFSET                       0x000000c0
+#define RESET_CAUSE_LAST_MSB                     2
+#define RESET_CAUSE_LAST_LSB                     0
+#define RESET_CAUSE_LAST_MASK                    0x00000007
+#define RESET_CAUSE_LAST_GET(x)                  (((x) & RESET_CAUSE_LAST_MASK) >> RESET_CAUSE_LAST_LSB)
+#define RESET_CAUSE_LAST_SET(x)                  (((x) << RESET_CAUSE_LAST_LSB) & RESET_CAUSE_LAST_MASK)
+
+#define SYSTEM_SLEEP_ADDRESS                     0x000000c4
+#define SYSTEM_SLEEP_OFFSET                      0x000000c4
+#define SYSTEM_SLEEP_HOST_IF_MSB                 4
+#define SYSTEM_SLEEP_HOST_IF_LSB                 4
+#define SYSTEM_SLEEP_HOST_IF_MASK                0x00000010
+#define SYSTEM_SLEEP_HOST_IF_GET(x)              (((x) & SYSTEM_SLEEP_HOST_IF_MASK) >> SYSTEM_SLEEP_HOST_IF_LSB)
+#define SYSTEM_SLEEP_HOST_IF_SET(x)              (((x) << SYSTEM_SLEEP_HOST_IF_LSB) & SYSTEM_SLEEP_HOST_IF_MASK)
+#define SYSTEM_SLEEP_MBOX_MSB                    3
+#define SYSTEM_SLEEP_MBOX_LSB                    3
+#define SYSTEM_SLEEP_MBOX_MASK                   0x00000008
+#define SYSTEM_SLEEP_MBOX_GET(x)                 (((x) & SYSTEM_SLEEP_MBOX_MASK) >> SYSTEM_SLEEP_MBOX_LSB)
+#define SYSTEM_SLEEP_MBOX_SET(x)                 (((x) << SYSTEM_SLEEP_MBOX_LSB) & SYSTEM_SLEEP_MBOX_MASK)
+#define SYSTEM_SLEEP_MAC_IF_MSB                  2
+#define SYSTEM_SLEEP_MAC_IF_LSB                  2
+#define SYSTEM_SLEEP_MAC_IF_MASK                 0x00000004
+#define SYSTEM_SLEEP_MAC_IF_GET(x)               (((x) & SYSTEM_SLEEP_MAC_IF_MASK) >> SYSTEM_SLEEP_MAC_IF_LSB)
+#define SYSTEM_SLEEP_MAC_IF_SET(x)               (((x) << SYSTEM_SLEEP_MAC_IF_LSB) & SYSTEM_SLEEP_MAC_IF_MASK)
+#define SYSTEM_SLEEP_LIGHT_MSB                   1
+#define SYSTEM_SLEEP_LIGHT_LSB                   1
+#define SYSTEM_SLEEP_LIGHT_MASK                  0x00000002
+#define SYSTEM_SLEEP_LIGHT_GET(x)                (((x) & SYSTEM_SLEEP_LIGHT_MASK) >> SYSTEM_SLEEP_LIGHT_LSB)
+#define SYSTEM_SLEEP_LIGHT_SET(x)                (((x) << SYSTEM_SLEEP_LIGHT_LSB) & SYSTEM_SLEEP_LIGHT_MASK)
+#define SYSTEM_SLEEP_DISABLE_MSB                 0
+#define SYSTEM_SLEEP_DISABLE_LSB                 0
+#define SYSTEM_SLEEP_DISABLE_MASK                0x00000001
+#define SYSTEM_SLEEP_DISABLE_GET(x)              (((x) & SYSTEM_SLEEP_DISABLE_MASK) >> SYSTEM_SLEEP_DISABLE_LSB)
+#define SYSTEM_SLEEP_DISABLE_SET(x)              (((x) << SYSTEM_SLEEP_DISABLE_LSB) & SYSTEM_SLEEP_DISABLE_MASK)
+
+#define SDIO_WRAPPER_ADDRESS                     0x000000c8
+#define SDIO_WRAPPER_OFFSET                      0x000000c8
+#define SDIO_WRAPPER_SLEEP_MSB                   3
+#define SDIO_WRAPPER_SLEEP_LSB                   3
+#define SDIO_WRAPPER_SLEEP_MASK                  0x00000008
+#define SDIO_WRAPPER_SLEEP_GET(x)                (((x) & SDIO_WRAPPER_SLEEP_MASK) >> SDIO_WRAPPER_SLEEP_LSB)
+#define SDIO_WRAPPER_SLEEP_SET(x)                (((x) << SDIO_WRAPPER_SLEEP_LSB) & SDIO_WRAPPER_SLEEP_MASK)
+#define SDIO_WRAPPER_WAKEUP_MSB                  2
+#define SDIO_WRAPPER_WAKEUP_LSB                  2
+#define SDIO_WRAPPER_WAKEUP_MASK                 0x00000004
+#define SDIO_WRAPPER_WAKEUP_GET(x)               (((x) & SDIO_WRAPPER_WAKEUP_MASK) >> SDIO_WRAPPER_WAKEUP_LSB)
+#define SDIO_WRAPPER_WAKEUP_SET(x)               (((x) << SDIO_WRAPPER_WAKEUP_LSB) & SDIO_WRAPPER_WAKEUP_MASK)
+#define SDIO_WRAPPER_SOC_ON_MSB                  1
+#define SDIO_WRAPPER_SOC_ON_LSB                  1
+#define SDIO_WRAPPER_SOC_ON_MASK                 0x00000002
+#define SDIO_WRAPPER_SOC_ON_GET(x)               (((x) & SDIO_WRAPPER_SOC_ON_MASK) >> SDIO_WRAPPER_SOC_ON_LSB)
+#define SDIO_WRAPPER_SOC_ON_SET(x)               (((x) << SDIO_WRAPPER_SOC_ON_LSB) & SDIO_WRAPPER_SOC_ON_MASK)
+#define SDIO_WRAPPER_ON_MSB                      0
+#define SDIO_WRAPPER_ON_LSB                      0
+#define SDIO_WRAPPER_ON_MASK                     0x00000001
+#define SDIO_WRAPPER_ON_GET(x)                   (((x) & SDIO_WRAPPER_ON_MASK) >> SDIO_WRAPPER_ON_LSB)
+#define SDIO_WRAPPER_ON_SET(x)                   (((x) << SDIO_WRAPPER_ON_LSB) & SDIO_WRAPPER_ON_MASK)
+
+#define MAC_SLEEP_CONTROL_ADDRESS                0x000000cc
+#define MAC_SLEEP_CONTROL_OFFSET                 0x000000cc
+#define MAC_SLEEP_CONTROL_ENABLE_MSB             1
+#define MAC_SLEEP_CONTROL_ENABLE_LSB             0
+#define MAC_SLEEP_CONTROL_ENABLE_MASK            0x00000003
+#define MAC_SLEEP_CONTROL_ENABLE_GET(x)          (((x) & MAC_SLEEP_CONTROL_ENABLE_MASK) >> MAC_SLEEP_CONTROL_ENABLE_LSB)
+#define MAC_SLEEP_CONTROL_ENABLE_SET(x)          (((x) << MAC_SLEEP_CONTROL_ENABLE_LSB) & MAC_SLEEP_CONTROL_ENABLE_MASK)
+
+#define KEEP_AWAKE_ADDRESS                       0x000000d0
+#define KEEP_AWAKE_OFFSET                        0x000000d0
+#define KEEP_AWAKE_COUNT_MSB                     7
+#define KEEP_AWAKE_COUNT_LSB                     0
+#define KEEP_AWAKE_COUNT_MASK                    0x000000ff
+#define KEEP_AWAKE_COUNT_GET(x)                  (((x) & KEEP_AWAKE_COUNT_MASK) >> KEEP_AWAKE_COUNT_LSB)
+#define KEEP_AWAKE_COUNT_SET(x)                  (((x) << KEEP_AWAKE_COUNT_LSB) & KEEP_AWAKE_COUNT_MASK)
+
+#define LPO_CAL_TIME_ADDRESS                     0x000000d4
+#define LPO_CAL_TIME_OFFSET                      0x000000d4
+#define LPO_CAL_TIME_LENGTH_MSB                  13
+#define LPO_CAL_TIME_LENGTH_LSB                  0
+#define LPO_CAL_TIME_LENGTH_MASK                 0x00003fff
+#define LPO_CAL_TIME_LENGTH_GET(x)               (((x) & LPO_CAL_TIME_LENGTH_MASK) >> LPO_CAL_TIME_LENGTH_LSB)
+#define LPO_CAL_TIME_LENGTH_SET(x)               (((x) << LPO_CAL_TIME_LENGTH_LSB) & LPO_CAL_TIME_LENGTH_MASK)
+
+#define LPO_INIT_DIVIDEND_INT_ADDRESS            0x000000d8
+#define LPO_INIT_DIVIDEND_INT_OFFSET             0x000000d8
+#define LPO_INIT_DIVIDEND_INT_VALUE_MSB          23
+#define LPO_INIT_DIVIDEND_INT_VALUE_LSB          0
+#define LPO_INIT_DIVIDEND_INT_VALUE_MASK         0x00ffffff
+#define LPO_INIT_DIVIDEND_INT_VALUE_GET(x)       (((x) & LPO_INIT_DIVIDEND_INT_VALUE_MASK) >> LPO_INIT_DIVIDEND_INT_VALUE_LSB)
+#define LPO_INIT_DIVIDEND_INT_VALUE_SET(x)       (((x) << LPO_INIT_DIVIDEND_INT_VALUE_LSB) & LPO_INIT_DIVIDEND_INT_VALUE_MASK)
+
+#define LPO_INIT_DIVIDEND_FRACTION_ADDRESS       0x000000dc
+#define LPO_INIT_DIVIDEND_FRACTION_OFFSET        0x000000dc
+#define LPO_INIT_DIVIDEND_FRACTION_VALUE_MSB     10
+#define LPO_INIT_DIVIDEND_FRACTION_VALUE_LSB     0
+#define LPO_INIT_DIVIDEND_FRACTION_VALUE_MASK    0x000007ff
+#define LPO_INIT_DIVIDEND_FRACTION_VALUE_GET(x)  (((x) & LPO_INIT_DIVIDEND_FRACTION_VALUE_MASK) >> LPO_INIT_DIVIDEND_FRACTION_VALUE_LSB)
+#define LPO_INIT_DIVIDEND_FRACTION_VALUE_SET(x)  (((x) << LPO_INIT_DIVIDEND_FRACTION_VALUE_LSB) & LPO_INIT_DIVIDEND_FRACTION_VALUE_MASK)
+
+#define LPO_CAL_ADDRESS                          0x000000e0
+#define LPO_CAL_OFFSET                           0x000000e0
+#define LPO_CAL_ENABLE_MSB                       20
+#define LPO_CAL_ENABLE_LSB                       20
+#define LPO_CAL_ENABLE_MASK                      0x00100000
+#define LPO_CAL_ENABLE_GET(x)                    (((x) & LPO_CAL_ENABLE_MASK) >> LPO_CAL_ENABLE_LSB)
+#define LPO_CAL_ENABLE_SET(x)                    (((x) << LPO_CAL_ENABLE_LSB) & LPO_CAL_ENABLE_MASK)
+#define LPO_CAL_COUNT_MSB                        19
+#define LPO_CAL_COUNT_LSB                        0
+#define LPO_CAL_COUNT_MASK                       0x000fffff
+#define LPO_CAL_COUNT_GET(x)                     (((x) & LPO_CAL_COUNT_MASK) >> LPO_CAL_COUNT_LSB)
+#define LPO_CAL_COUNT_SET(x)                     (((x) << LPO_CAL_COUNT_LSB) & LPO_CAL_COUNT_MASK)
+
+#define LPO_CAL_TEST_CONTROL_ADDRESS             0x000000e4
+#define LPO_CAL_TEST_CONTROL_OFFSET              0x000000e4
+#define LPO_CAL_TEST_CONTROL_ENABLE_MSB          5
+#define LPO_CAL_TEST_CONTROL_ENABLE_LSB          5
+#define LPO_CAL_TEST_CONTROL_ENABLE_MASK         0x00000020
+#define LPO_CAL_TEST_CONTROL_ENABLE_GET(x)       (((x) & LPO_CAL_TEST_CONTROL_ENABLE_MASK) >> LPO_CAL_TEST_CONTROL_ENABLE_LSB)
+#define LPO_CAL_TEST_CONTROL_ENABLE_SET(x)       (((x) << LPO_CAL_TEST_CONTROL_ENABLE_LSB) & LPO_CAL_TEST_CONTROL_ENABLE_MASK)
+#define LPO_CAL_TEST_CONTROL_RTC_CYCLES_MSB      4
+#define LPO_CAL_TEST_CONTROL_RTC_CYCLES_LSB      0
+#define LPO_CAL_TEST_CONTROL_RTC_CYCLES_MASK     0x0000001f
+#define LPO_CAL_TEST_CONTROL_RTC_CYCLES_GET(x)   (((x) & LPO_CAL_TEST_CONTROL_RTC_CYCLES_MASK) >> LPO_CAL_TEST_CONTROL_RTC_CYCLES_LSB)
+#define LPO_CAL_TEST_CONTROL_RTC_CYCLES_SET(x)   (((x) << LPO_CAL_TEST_CONTROL_RTC_CYCLES_LSB) & LPO_CAL_TEST_CONTROL_RTC_CYCLES_MASK)
+
+#define LPO_CAL_TEST_STATUS_ADDRESS              0x000000e8
+#define LPO_CAL_TEST_STATUS_OFFSET               0x000000e8
+#define LPO_CAL_TEST_STATUS_READY_MSB            16
+#define LPO_CAL_TEST_STATUS_READY_LSB            16
+#define LPO_CAL_TEST_STATUS_READY_MASK           0x00010000
+#define LPO_CAL_TEST_STATUS_READY_GET(x)         (((x) & LPO_CAL_TEST_STATUS_READY_MASK) >> LPO_CAL_TEST_STATUS_READY_LSB)
+#define LPO_CAL_TEST_STATUS_READY_SET(x)         (((x) << LPO_CAL_TEST_STATUS_READY_LSB) & LPO_CAL_TEST_STATUS_READY_MASK)
+#define LPO_CAL_TEST_STATUS_COUNT_MSB            15
+#define LPO_CAL_TEST_STATUS_COUNT_LSB            0
+#define LPO_CAL_TEST_STATUS_COUNT_MASK           0x0000ffff
+#define LPO_CAL_TEST_STATUS_COUNT_GET(x)         (((x) & LPO_CAL_TEST_STATUS_COUNT_MASK) >> LPO_CAL_TEST_STATUS_COUNT_LSB)
+#define LPO_CAL_TEST_STATUS_COUNT_SET(x)         (((x) << LPO_CAL_TEST_STATUS_COUNT_LSB) & LPO_CAL_TEST_STATUS_COUNT_MASK)
+
+#define CHIP_ID_ADDRESS                          0x000000ec
+#define CHIP_ID_OFFSET                           0x000000ec
+#define CHIP_ID_DEVICE_ID_MSB                    31
+#define CHIP_ID_DEVICE_ID_LSB                    16
+#define CHIP_ID_DEVICE_ID_MASK                   0xffff0000
+#define CHIP_ID_DEVICE_ID_GET(x)                 (((x) & CHIP_ID_DEVICE_ID_MASK) >> CHIP_ID_DEVICE_ID_LSB)
+#define CHIP_ID_DEVICE_ID_SET(x)                 (((x) << CHIP_ID_DEVICE_ID_LSB) & CHIP_ID_DEVICE_ID_MASK)
+#define CHIP_ID_CONFIG_ID_MSB                    15
+#define CHIP_ID_CONFIG_ID_LSB                    4
+#define CHIP_ID_CONFIG_ID_MASK                   0x0000fff0
+#define CHIP_ID_CONFIG_ID_GET(x)                 (((x) & CHIP_ID_CONFIG_ID_MASK) >> CHIP_ID_CONFIG_ID_LSB)
+#define CHIP_ID_CONFIG_ID_SET(x)                 (((x) << CHIP_ID_CONFIG_ID_LSB) & CHIP_ID_CONFIG_ID_MASK)
+#define CHIP_ID_VERSION_ID_MSB                   3
+#define CHIP_ID_VERSION_ID_LSB                   0
+#define CHIP_ID_VERSION_ID_MASK                  0x0000000f
+#define CHIP_ID_VERSION_ID_GET(x)                (((x) & CHIP_ID_VERSION_ID_MASK) >> CHIP_ID_VERSION_ID_LSB)
+#define CHIP_ID_VERSION_ID_SET(x)                (((x) << CHIP_ID_VERSION_ID_LSB) & CHIP_ID_VERSION_ID_MASK)
+
+#define DERIVED_RTC_CLK_ADDRESS                  0x000000f0
+#define DERIVED_RTC_CLK_OFFSET                   0x000000f0
+#define DERIVED_RTC_CLK_EXTERNAL_DETECT_EN_MSB   20
+#define DERIVED_RTC_CLK_EXTERNAL_DETECT_EN_LSB   20
+#define DERIVED_RTC_CLK_EXTERNAL_DETECT_EN_MASK  0x00100000
+#define DERIVED_RTC_CLK_EXTERNAL_DETECT_EN_GET(x) (((x) & DERIVED_RTC_CLK_EXTERNAL_DETECT_EN_MASK) >> DERIVED_RTC_CLK_EXTERNAL_DETECT_EN_LSB)
+#define DERIVED_RTC_CLK_EXTERNAL_DETECT_EN_SET(x) (((x) << DERIVED_RTC_CLK_EXTERNAL_DETECT_EN_LSB) & DERIVED_RTC_CLK_EXTERNAL_DETECT_EN_MASK)
+#define DERIVED_RTC_CLK_EXTERNAL_DETECT_MSB      18
+#define DERIVED_RTC_CLK_EXTERNAL_DETECT_LSB      18
+#define DERIVED_RTC_CLK_EXTERNAL_DETECT_MASK     0x00040000
+#define DERIVED_RTC_CLK_EXTERNAL_DETECT_GET(x)   (((x) & DERIVED_RTC_CLK_EXTERNAL_DETECT_MASK) >> DERIVED_RTC_CLK_EXTERNAL_DETECT_LSB)
+#define DERIVED_RTC_CLK_EXTERNAL_DETECT_SET(x)   (((x) << DERIVED_RTC_CLK_EXTERNAL_DETECT_LSB) & DERIVED_RTC_CLK_EXTERNAL_DETECT_MASK)
+#define DERIVED_RTC_CLK_FORCE_MSB                17
+#define DERIVED_RTC_CLK_FORCE_LSB                16
+#define DERIVED_RTC_CLK_FORCE_MASK               0x00030000
+#define DERIVED_RTC_CLK_FORCE_GET(x)             (((x) & DERIVED_RTC_CLK_FORCE_MASK) >> DERIVED_RTC_CLK_FORCE_LSB)
+#define DERIVED_RTC_CLK_FORCE_SET(x)             (((x) << DERIVED_RTC_CLK_FORCE_LSB) & DERIVED_RTC_CLK_FORCE_MASK)
+#define DERIVED_RTC_CLK_PERIOD_MSB               15
+#define DERIVED_RTC_CLK_PERIOD_LSB               1
+#define DERIVED_RTC_CLK_PERIOD_MASK              0x0000fffe
+#define DERIVED_RTC_CLK_PERIOD_GET(x)            (((x) & DERIVED_RTC_CLK_PERIOD_MASK) >> DERIVED_RTC_CLK_PERIOD_LSB)
+#define DERIVED_RTC_CLK_PERIOD_SET(x)            (((x) << DERIVED_RTC_CLK_PERIOD_LSB) & DERIVED_RTC_CLK_PERIOD_MASK)
+
+#define MAC_PCU_SLP32_MODE_ADDRESS               0x000000f4
+#define MAC_PCU_SLP32_MODE_OFFSET                0x000000f4
+#define MAC_PCU_SLP32_MODE_TSF_WRITE_PENDING_MSB 21
+#define MAC_PCU_SLP32_MODE_TSF_WRITE_PENDING_LSB 21
+#define MAC_PCU_SLP32_MODE_TSF_WRITE_PENDING_MASK 0x00200000
+#define MAC_PCU_SLP32_MODE_TSF_WRITE_PENDING_GET(x) (((x) & MAC_PCU_SLP32_MODE_TSF_WRITE_PENDING_MASK) >> MAC_PCU_SLP32_MODE_TSF_WRITE_PENDING_LSB)
+#define MAC_PCU_SLP32_MODE_TSF_WRITE_PENDING_SET(x) (((x) << MAC_PCU_SLP32_MODE_TSF_WRITE_PENDING_LSB) & MAC_PCU_SLP32_MODE_TSF_WRITE_PENDING_MASK)
+#define MAC_PCU_SLP32_MODE_HALF_CLK_LATENCY_MSB  19
+#define MAC_PCU_SLP32_MODE_HALF_CLK_LATENCY_LSB  0
+#define MAC_PCU_SLP32_MODE_HALF_CLK_LATENCY_MASK 0x000fffff
+#define MAC_PCU_SLP32_MODE_HALF_CLK_LATENCY_GET(x) (((x) & MAC_PCU_SLP32_MODE_HALF_CLK_LATENCY_MASK) >> MAC_PCU_SLP32_MODE_HALF_CLK_LATENCY_LSB)
+#define MAC_PCU_SLP32_MODE_HALF_CLK_LATENCY_SET(x) (((x) << MAC_PCU_SLP32_MODE_HALF_CLK_LATENCY_LSB) & MAC_PCU_SLP32_MODE_HALF_CLK_LATENCY_MASK)
+
+#define MAC_PCU_SLP32_WAKE_ADDRESS               0x000000f8
+#define MAC_PCU_SLP32_WAKE_OFFSET                0x000000f8
+#define MAC_PCU_SLP32_WAKE_XTL_TIME_MSB          15
+#define MAC_PCU_SLP32_WAKE_XTL_TIME_LSB          0
+#define MAC_PCU_SLP32_WAKE_XTL_TIME_MASK         0x0000ffff
+#define MAC_PCU_SLP32_WAKE_XTL_TIME_GET(x)       (((x) & MAC_PCU_SLP32_WAKE_XTL_TIME_MASK) >> MAC_PCU_SLP32_WAKE_XTL_TIME_LSB)
+#define MAC_PCU_SLP32_WAKE_XTL_TIME_SET(x)       (((x) << MAC_PCU_SLP32_WAKE_XTL_TIME_LSB) & MAC_PCU_SLP32_WAKE_XTL_TIME_MASK)
+
+#define MAC_PCU_SLP32_INC_ADDRESS                0x000000fc
+#define MAC_PCU_SLP32_INC_OFFSET                 0x000000fc
+#define MAC_PCU_SLP32_INC_TSF_INC_MSB            19
+#define MAC_PCU_SLP32_INC_TSF_INC_LSB            0
+#define MAC_PCU_SLP32_INC_TSF_INC_MASK           0x000fffff
+#define MAC_PCU_SLP32_INC_TSF_INC_GET(x)         (((x) & MAC_PCU_SLP32_INC_TSF_INC_MASK) >> MAC_PCU_SLP32_INC_TSF_INC_LSB)
+#define MAC_PCU_SLP32_INC_TSF_INC_SET(x)         (((x) << MAC_PCU_SLP32_INC_TSF_INC_LSB) & MAC_PCU_SLP32_INC_TSF_INC_MASK)
+
+#define MAC_PCU_SLP_MIB1_ADDRESS                 0x00000100
+#define MAC_PCU_SLP_MIB1_OFFSET                  0x00000100
+#define MAC_PCU_SLP_MIB1_SLEEP_CNT_MSB           31
+#define MAC_PCU_SLP_MIB1_SLEEP_CNT_LSB           0
+#define MAC_PCU_SLP_MIB1_SLEEP_CNT_MASK          0xffffffff
+#define MAC_PCU_SLP_MIB1_SLEEP_CNT_GET(x)        (((x) & MAC_PCU_SLP_MIB1_SLEEP_CNT_MASK) >> MAC_PCU_SLP_MIB1_SLEEP_CNT_LSB)
+#define MAC_PCU_SLP_MIB1_SLEEP_CNT_SET(x)        (((x) << MAC_PCU_SLP_MIB1_SLEEP_CNT_LSB) & MAC_PCU_SLP_MIB1_SLEEP_CNT_MASK)
+
+#define MAC_PCU_SLP_MIB2_ADDRESS                 0x00000104
+#define MAC_PCU_SLP_MIB2_OFFSET                  0x00000104
+#define MAC_PCU_SLP_MIB2_CYCLE_CNT_MSB           31
+#define MAC_PCU_SLP_MIB2_CYCLE_CNT_LSB           0
+#define MAC_PCU_SLP_MIB2_CYCLE_CNT_MASK          0xffffffff
+#define MAC_PCU_SLP_MIB2_CYCLE_CNT_GET(x)        (((x) & MAC_PCU_SLP_MIB2_CYCLE_CNT_MASK) >> MAC_PCU_SLP_MIB2_CYCLE_CNT_LSB)
+#define MAC_PCU_SLP_MIB2_CYCLE_CNT_SET(x)        (((x) << MAC_PCU_SLP_MIB2_CYCLE_CNT_LSB) & MAC_PCU_SLP_MIB2_CYCLE_CNT_MASK)
+
+#define MAC_PCU_SLP_MIB3_ADDRESS                 0x00000108
+#define MAC_PCU_SLP_MIB3_OFFSET                  0x00000108
+#define MAC_PCU_SLP_MIB3_PENDING_MSB             1
+#define MAC_PCU_SLP_MIB3_PENDING_LSB             1
+#define MAC_PCU_SLP_MIB3_PENDING_MASK            0x00000002
+#define MAC_PCU_SLP_MIB3_PENDING_GET(x)          (((x) & MAC_PCU_SLP_MIB3_PENDING_MASK) >> MAC_PCU_SLP_MIB3_PENDING_LSB)
+#define MAC_PCU_SLP_MIB3_PENDING_SET(x)          (((x) << MAC_PCU_SLP_MIB3_PENDING_LSB) & MAC_PCU_SLP_MIB3_PENDING_MASK)
+#define MAC_PCU_SLP_MIB3_CLR_CNT_MSB             0
+#define MAC_PCU_SLP_MIB3_CLR_CNT_LSB             0
+#define MAC_PCU_SLP_MIB3_CLR_CNT_MASK            0x00000001
+#define MAC_PCU_SLP_MIB3_CLR_CNT_GET(x)          (((x) & MAC_PCU_SLP_MIB3_CLR_CNT_MASK) >> MAC_PCU_SLP_MIB3_CLR_CNT_LSB)
+#define MAC_PCU_SLP_MIB3_CLR_CNT_SET(x)          (((x) << MAC_PCU_SLP_MIB3_CLR_CNT_LSB) & MAC_PCU_SLP_MIB3_CLR_CNT_MASK)
+
+#define MAC_PCU_SLP_BEACON_ADDRESS               0x0000010c
+#define MAC_PCU_SLP_BEACON_OFFSET                0x0000010c
+#define MAC_PCU_SLP_BEACON_BMISS_TIMEOUT_ENABLE_MSB 24
+#define MAC_PCU_SLP_BEACON_BMISS_TIMEOUT_ENABLE_LSB 24
+#define MAC_PCU_SLP_BEACON_BMISS_TIMEOUT_ENABLE_MASK 0x01000000
+#define MAC_PCU_SLP_BEACON_BMISS_TIMEOUT_ENABLE_GET(x) (((x) & MAC_PCU_SLP_BEACON_BMISS_TIMEOUT_ENABLE_MASK) >> MAC_PCU_SLP_BEACON_BMISS_TIMEOUT_ENABLE_LSB)
+#define MAC_PCU_SLP_BEACON_BMISS_TIMEOUT_ENABLE_SET(x) (((x) << MAC_PCU_SLP_BEACON_BMISS_TIMEOUT_ENABLE_LSB) & MAC_PCU_SLP_BEACON_BMISS_TIMEOUT_ENABLE_MASK)
+#define MAC_PCU_SLP_BEACON_BMISS_TIMEOUT_MSB     23
+#define MAC_PCU_SLP_BEACON_BMISS_TIMEOUT_LSB     0
+#define MAC_PCU_SLP_BEACON_BMISS_TIMEOUT_MASK    0x00ffffff
+#define MAC_PCU_SLP_BEACON_BMISS_TIMEOUT_GET(x)  (((x) & MAC_PCU_SLP_BEACON_BMISS_TIMEOUT_MASK) >> MAC_PCU_SLP_BEACON_BMISS_TIMEOUT_LSB)
+#define MAC_PCU_SLP_BEACON_BMISS_TIMEOUT_SET(x)  (((x) << MAC_PCU_SLP_BEACON_BMISS_TIMEOUT_LSB) & MAC_PCU_SLP_BEACON_BMISS_TIMEOUT_MASK)
+
+#define POWER_REG_ADDRESS                        0x00000110
+#define POWER_REG_OFFSET                         0x00000110
+#define POWER_REG_VLVL_MSB                       11
+#define POWER_REG_VLVL_LSB                       8
+#define POWER_REG_VLVL_MASK                      0x00000f00
+#define POWER_REG_VLVL_GET(x)                    (((x) & POWER_REG_VLVL_MASK) >> POWER_REG_VLVL_LSB)
+#define POWER_REG_VLVL_SET(x)                    (((x) << POWER_REG_VLVL_LSB) & POWER_REG_VLVL_MASK)
+#define POWER_REG_CPU_INT_ENABLE_MSB             7
+#define POWER_REG_CPU_INT_ENABLE_LSB             7
+#define POWER_REG_CPU_INT_ENABLE_MASK            0x00000080
+#define POWER_REG_CPU_INT_ENABLE_GET(x)          (((x) & POWER_REG_CPU_INT_ENABLE_MASK) >> POWER_REG_CPU_INT_ENABLE_LSB)
+#define POWER_REG_CPU_INT_ENABLE_SET(x)          (((x) << POWER_REG_CPU_INT_ENABLE_LSB) & POWER_REG_CPU_INT_ENABLE_MASK)
+#define POWER_REG_WLAN_ISO_DIS_MSB               6
+#define POWER_REG_WLAN_ISO_DIS_LSB               6
+#define POWER_REG_WLAN_ISO_DIS_MASK              0x00000040
+#define POWER_REG_WLAN_ISO_DIS_GET(x)            (((x) & POWER_REG_WLAN_ISO_DIS_MASK) >> POWER_REG_WLAN_ISO_DIS_LSB)
+#define POWER_REG_WLAN_ISO_DIS_SET(x)            (((x) << POWER_REG_WLAN_ISO_DIS_LSB) & POWER_REG_WLAN_ISO_DIS_MASK)
+#define POWER_REG_WLAN_ISO_CNTL_MSB              5
+#define POWER_REG_WLAN_ISO_CNTL_LSB              5
+#define POWER_REG_WLAN_ISO_CNTL_MASK             0x00000020
+#define POWER_REG_WLAN_ISO_CNTL_GET(x)           (((x) & POWER_REG_WLAN_ISO_CNTL_MASK) >> POWER_REG_WLAN_ISO_CNTL_LSB)
+#define POWER_REG_WLAN_ISO_CNTL_SET(x)           (((x) << POWER_REG_WLAN_ISO_CNTL_LSB) & POWER_REG_WLAN_ISO_CNTL_MASK)
+#define POWER_REG_RADIO_PWD_EN_MSB               4
+#define POWER_REG_RADIO_PWD_EN_LSB               4
+#define POWER_REG_RADIO_PWD_EN_MASK              0x00000010
+#define POWER_REG_RADIO_PWD_EN_GET(x)            (((x) & POWER_REG_RADIO_PWD_EN_MASK) >> POWER_REG_RADIO_PWD_EN_LSB)
+#define POWER_REG_RADIO_PWD_EN_SET(x)            (((x) << POWER_REG_RADIO_PWD_EN_LSB) & POWER_REG_RADIO_PWD_EN_MASK)
+#define POWER_REG_SOC_SCALE_EN_MSB               3
+#define POWER_REG_SOC_SCALE_EN_LSB               3
+#define POWER_REG_SOC_SCALE_EN_MASK              0x00000008
+#define POWER_REG_SOC_SCALE_EN_GET(x)            (((x) & POWER_REG_SOC_SCALE_EN_MASK) >> POWER_REG_SOC_SCALE_EN_LSB)
+#define POWER_REG_SOC_SCALE_EN_SET(x)            (((x) << POWER_REG_SOC_SCALE_EN_LSB) & POWER_REG_SOC_SCALE_EN_MASK)
+#define POWER_REG_WLAN_SCALE_EN_MSB              2
+#define POWER_REG_WLAN_SCALE_EN_LSB              2
+#define POWER_REG_WLAN_SCALE_EN_MASK             0x00000004
+#define POWER_REG_WLAN_SCALE_EN_GET(x)           (((x) & POWER_REG_WLAN_SCALE_EN_MASK) >> POWER_REG_WLAN_SCALE_EN_LSB)
+#define POWER_REG_WLAN_SCALE_EN_SET(x)           (((x) << POWER_REG_WLAN_SCALE_EN_LSB) & POWER_REG_WLAN_SCALE_EN_MASK)
+#define POWER_REG_WLAN_PWD_EN_MSB                1
+#define POWER_REG_WLAN_PWD_EN_LSB                1
+#define POWER_REG_WLAN_PWD_EN_MASK               0x00000002
+#define POWER_REG_WLAN_PWD_EN_GET(x)             (((x) & POWER_REG_WLAN_PWD_EN_MASK) >> POWER_REG_WLAN_PWD_EN_LSB)
+#define POWER_REG_WLAN_PWD_EN_SET(x)             (((x) << POWER_REG_WLAN_PWD_EN_LSB) & POWER_REG_WLAN_PWD_EN_MASK)
+#define POWER_REG_POWER_EN_MSB                   0
+#define POWER_REG_POWER_EN_LSB                   0
+#define POWER_REG_POWER_EN_MASK                  0x00000001
+#define POWER_REG_POWER_EN_GET(x)                (((x) & POWER_REG_POWER_EN_MASK) >> POWER_REG_POWER_EN_LSB)
+#define POWER_REG_POWER_EN_SET(x)                (((x) << POWER_REG_POWER_EN_LSB) & POWER_REG_POWER_EN_MASK)
+
+#define CORE_CLK_CTRL_ADDRESS                    0x00000114
+#define CORE_CLK_CTRL_OFFSET                     0x00000114
+#define CORE_CLK_CTRL_DIV_MSB                    2
+#define CORE_CLK_CTRL_DIV_LSB                    0
+#define CORE_CLK_CTRL_DIV_MASK                   0x00000007
+#define CORE_CLK_CTRL_DIV_GET(x)                 (((x) & CORE_CLK_CTRL_DIV_MASK) >> CORE_CLK_CTRL_DIV_LSB)
+#define CORE_CLK_CTRL_DIV_SET(x)                 (((x) << CORE_CLK_CTRL_DIV_LSB) & CORE_CLK_CTRL_DIV_MASK)
+
+#define SDIO_SETUP_CIRCUIT_ADDRESS               0x00000120
+#define SDIO_SETUP_CIRCUIT_OFFSET                0x00000120
+#define SDIO_SETUP_CIRCUIT_VECTOR_MSB            7
+#define SDIO_SETUP_CIRCUIT_VECTOR_LSB            0
+#define SDIO_SETUP_CIRCUIT_VECTOR_MASK           0x000000ff
+#define SDIO_SETUP_CIRCUIT_VECTOR_GET(x)         (((x) & SDIO_SETUP_CIRCUIT_VECTOR_MASK) >> SDIO_SETUP_CIRCUIT_VECTOR_LSB)
+#define SDIO_SETUP_CIRCUIT_VECTOR_SET(x)         (((x) << SDIO_SETUP_CIRCUIT_VECTOR_LSB) & SDIO_SETUP_CIRCUIT_VECTOR_MASK)
+
+#define SDIO_SETUP_CONFIG_ADDRESS                0x00000140
+#define SDIO_SETUP_CONFIG_OFFSET                 0x00000140
+#define SDIO_SETUP_CONFIG_ENABLE_MSB             1
+#define SDIO_SETUP_CONFIG_ENABLE_LSB             1
+#define SDIO_SETUP_CONFIG_ENABLE_MASK            0x00000002
+#define SDIO_SETUP_CONFIG_ENABLE_GET(x)          (((x) & SDIO_SETUP_CONFIG_ENABLE_MASK) >> SDIO_SETUP_CONFIG_ENABLE_LSB)
+#define SDIO_SETUP_CONFIG_ENABLE_SET(x)          (((x) << SDIO_SETUP_CONFIG_ENABLE_LSB) & SDIO_SETUP_CONFIG_ENABLE_MASK)
+#define SDIO_SETUP_CONFIG_CLEAR_MSB              0
+#define SDIO_SETUP_CONFIG_CLEAR_LSB              0
+#define SDIO_SETUP_CONFIG_CLEAR_MASK             0x00000001
+#define SDIO_SETUP_CONFIG_CLEAR_GET(x)           (((x) & SDIO_SETUP_CONFIG_CLEAR_MASK) >> SDIO_SETUP_CONFIG_CLEAR_LSB)
+#define SDIO_SETUP_CONFIG_CLEAR_SET(x)           (((x) << SDIO_SETUP_CONFIG_CLEAR_LSB) & SDIO_SETUP_CONFIG_CLEAR_MASK)
+
+#define CPU_SETUP_CONFIG_ADDRESS                 0x00000144
+#define CPU_SETUP_CONFIG_OFFSET                  0x00000144
+#define CPU_SETUP_CONFIG_ENABLE_MSB              1
+#define CPU_SETUP_CONFIG_ENABLE_LSB              1
+#define CPU_SETUP_CONFIG_ENABLE_MASK             0x00000002
+#define CPU_SETUP_CONFIG_ENABLE_GET(x)           (((x) & CPU_SETUP_CONFIG_ENABLE_MASK) >> CPU_SETUP_CONFIG_ENABLE_LSB)
+#define CPU_SETUP_CONFIG_ENABLE_SET(x)           (((x) << CPU_SETUP_CONFIG_ENABLE_LSB) & CPU_SETUP_CONFIG_ENABLE_MASK)
+#define CPU_SETUP_CONFIG_CLEAR_MSB               0
+#define CPU_SETUP_CONFIG_CLEAR_LSB               0
+#define CPU_SETUP_CONFIG_CLEAR_MASK              0x00000001
+#define CPU_SETUP_CONFIG_CLEAR_GET(x)            (((x) & CPU_SETUP_CONFIG_CLEAR_MASK) >> CPU_SETUP_CONFIG_CLEAR_LSB)
+#define CPU_SETUP_CONFIG_CLEAR_SET(x)            (((x) << CPU_SETUP_CONFIG_CLEAR_LSB) & CPU_SETUP_CONFIG_CLEAR_MASK)
+
+#define CPU_SETUP_CIRCUIT_ADDRESS                0x00000160
+#define CPU_SETUP_CIRCUIT_OFFSET                 0x00000160
+#define CPU_SETUP_CIRCUIT_VECTOR_MSB             7
+#define CPU_SETUP_CIRCUIT_VECTOR_LSB             0
+#define CPU_SETUP_CIRCUIT_VECTOR_MASK            0x000000ff
+#define CPU_SETUP_CIRCUIT_VECTOR_GET(x)          (((x) & CPU_SETUP_CIRCUIT_VECTOR_MASK) >> CPU_SETUP_CIRCUIT_VECTOR_LSB)
+#define CPU_SETUP_CIRCUIT_VECTOR_SET(x)          (((x) << CPU_SETUP_CIRCUIT_VECTOR_LSB) & CPU_SETUP_CIRCUIT_VECTOR_MASK)
+
+#define BB_SETUP_CONFIG_ADDRESS                  0x00000180
+#define BB_SETUP_CONFIG_OFFSET                   0x00000180
+#define BB_SETUP_CONFIG_ENABLE_MSB               1
+#define BB_SETUP_CONFIG_ENABLE_LSB               1
+#define BB_SETUP_CONFIG_ENABLE_MASK              0x00000002
+#define BB_SETUP_CONFIG_ENABLE_GET(x)            (((x) & BB_SETUP_CONFIG_ENABLE_MASK) >> BB_SETUP_CONFIG_ENABLE_LSB)
+#define BB_SETUP_CONFIG_ENABLE_SET(x)            (((x) << BB_SETUP_CONFIG_ENABLE_LSB) & BB_SETUP_CONFIG_ENABLE_MASK)
+#define BB_SETUP_CONFIG_CLEAR_MSB                0
+#define BB_SETUP_CONFIG_CLEAR_LSB                0
+#define BB_SETUP_CONFIG_CLEAR_MASK               0x00000001
+#define BB_SETUP_CONFIG_CLEAR_GET(x)             (((x) & BB_SETUP_CONFIG_CLEAR_MASK) >> BB_SETUP_CONFIG_CLEAR_LSB)
+#define BB_SETUP_CONFIG_CLEAR_SET(x)             (((x) << BB_SETUP_CONFIG_CLEAR_LSB) & BB_SETUP_CONFIG_CLEAR_MASK)
+
+#define BB_SETUP_CIRCUIT_ADDRESS                 0x000001a0
+#define BB_SETUP_CIRCUIT_OFFSET                  0x000001a0
+#define BB_SETUP_CIRCUIT_VECTOR_MSB              7
+#define BB_SETUP_CIRCUIT_VECTOR_LSB              0
+#define BB_SETUP_CIRCUIT_VECTOR_MASK             0x000000ff
+#define BB_SETUP_CIRCUIT_VECTOR_GET(x)           (((x) & BB_SETUP_CIRCUIT_VECTOR_MASK) >> BB_SETUP_CIRCUIT_VECTOR_LSB)
+#define BB_SETUP_CIRCUIT_VECTOR_SET(x)           (((x) << BB_SETUP_CIRCUIT_VECTOR_LSB) & BB_SETUP_CIRCUIT_VECTOR_MASK)
+
+#define GPIO_WAKEUP_CONTROL_ADDRESS              0x000001c0
+#define GPIO_WAKEUP_CONTROL_OFFSET               0x000001c0
+#define GPIO_WAKEUP_CONTROL_ENABLE_MSB           0
+#define GPIO_WAKEUP_CONTROL_ENABLE_LSB           0
+#define GPIO_WAKEUP_CONTROL_ENABLE_MASK          0x00000001
+#define GPIO_WAKEUP_CONTROL_ENABLE_GET(x)        (((x) & GPIO_WAKEUP_CONTROL_ENABLE_MASK) >> GPIO_WAKEUP_CONTROL_ENABLE_LSB)
+#define GPIO_WAKEUP_CONTROL_ENABLE_SET(x)        (((x) << GPIO_WAKEUP_CONTROL_ENABLE_LSB) & GPIO_WAKEUP_CONTROL_ENABLE_MASK)
+
+
+#ifndef __ASSEMBLER__
+
+typedef struct rtc_reg_reg_s {
+  volatile unsigned int reset_control;
+  volatile unsigned int xtal_control;
+  volatile unsigned int tcxo_detect;
+  volatile unsigned int xtal_test;
+  volatile unsigned int quadrature;
+  volatile unsigned int pll_control;
+  volatile unsigned int pll_settle;
+  volatile unsigned int xtal_settle;
+  volatile unsigned int cpu_clock;
+  volatile unsigned int clock_out;
+  volatile unsigned int clock_control;
+  volatile unsigned int bias_override;
+  volatile unsigned int wdt_control;
+  volatile unsigned int wdt_status;
+  volatile unsigned int wdt;
+  volatile unsigned int wdt_count;
+  volatile unsigned int wdt_reset;
+  volatile unsigned int int_status;
+  volatile unsigned int lf_timer0;
+  volatile unsigned int lf_timer_count0;
+  volatile unsigned int lf_timer_control0;
+  volatile unsigned int lf_timer_status0;
+  volatile unsigned int lf_timer1;
+  volatile unsigned int lf_timer_count1;
+  volatile unsigned int lf_timer_control1;
+  volatile unsigned int lf_timer_status1;
+  volatile unsigned int lf_timer2;
+  volatile unsigned int lf_timer_count2;
+  volatile unsigned int lf_timer_control2;
+  volatile unsigned int lf_timer_status2;
+  volatile unsigned int lf_timer3;
+  volatile unsigned int lf_timer_count3;
+  volatile unsigned int lf_timer_control3;
+  volatile unsigned int lf_timer_status3;
+  volatile unsigned int hf_timer;
+  volatile unsigned int hf_timer_count;
+  volatile unsigned int hf_lf_count;
+  volatile unsigned int hf_timer_control;
+  volatile unsigned int hf_timer_status;
+  volatile unsigned int rtc_control;
+  volatile unsigned int rtc_time;
+  volatile unsigned int rtc_date;
+  volatile unsigned int rtc_set_time;
+  volatile unsigned int rtc_set_date;
+  volatile unsigned int rtc_set_alarm;
+  volatile unsigned int rtc_config;
+  volatile unsigned int rtc_alarm_status;
+  volatile unsigned int uart_wakeup;
+  volatile unsigned int reset_cause;
+  volatile unsigned int system_sleep;
+  volatile unsigned int sdio_wrapper;
+  volatile unsigned int mac_sleep_control;
+  volatile unsigned int keep_awake;
+  volatile unsigned int lpo_cal_time;
+  volatile unsigned int lpo_init_dividend_int;
+  volatile unsigned int lpo_init_dividend_fraction;
+  volatile unsigned int lpo_cal;
+  volatile unsigned int lpo_cal_test_control;
+  volatile unsigned int lpo_cal_test_status;
+  volatile unsigned int chip_id;
+  volatile unsigned int derived_rtc_clk;
+  volatile unsigned int mac_pcu_slp32_mode;
+  volatile unsigned int mac_pcu_slp32_wake;
+  volatile unsigned int mac_pcu_slp32_inc;
+  volatile unsigned int mac_pcu_slp_mib1;
+  volatile unsigned int mac_pcu_slp_mib2;
+  volatile unsigned int mac_pcu_slp_mib3;
+  volatile unsigned int mac_pcu_slp_beacon;
+  volatile unsigned int power_reg;
+  volatile unsigned int core_clk_ctrl;
+  unsigned char pad0[8]; /* pad to 0x120 */
+  volatile unsigned int sdio_setup_circuit[8];
+  volatile unsigned int sdio_setup_config;
+  volatile unsigned int cpu_setup_config;
+  unsigned char pad1[24]; /* pad to 0x160 */
+  volatile unsigned int cpu_setup_circuit[8];
+  volatile unsigned int bb_setup_config;
+  unsigned char pad2[28]; /* pad to 0x1a0 */
+  volatile unsigned int bb_setup_circuit[8];
+  volatile unsigned int gpio_wakeup_control;
+} rtc_reg_reg_t;
+
+#endif /* __ASSEMBLER__ */
+
+#endif /* _RTC_REG_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/si_reg.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/si_reg.h
@@ -0,0 +1,210 @@
+// ------------------------------------------------------------------
+// Copyright (c) 2004-2007 Atheros Corporation.  All rights reserved.
+//
+// The software source and binaries included in this development package are
+// licensed, not sold. You, or your company, received the package under one
+// or more license agreements. The rights granted to you are specifically
+// listed in these license agreement(s). All other rights remain with Atheros
+// Communications, Inc., its subsidiaries, or the respective owner including
+// those listed on the included copyright notices.  Distribution of any
+// portion of this package must be in strict compliance with the license
+// agreement(s) terms.
+// </copyright>
+//
+// <summary>
+// 	Wifi driver for AR6002
+// </summary>
+//
+// ------------------------------------------------------------------
+//===================================================================
+// Author(s): ="Atheros"
+//===================================================================
+
+/* These values only apply to the AR6002 */
+
+#ifndef _SI_REG_REG_H_
+#define _SI_REG_REG_H_
+
+#define SI_CONFIG_ADDRESS                        0x00000000
+#define SI_CONFIG_OFFSET                         0x00000000
+#define SI_CONFIG_ERR_INT_MSB                    19
+#define SI_CONFIG_ERR_INT_LSB                    19
+#define SI_CONFIG_ERR_INT_MASK                   0x00080000
+#define SI_CONFIG_ERR_INT_GET(x)                 (((x) & SI_CONFIG_ERR_INT_MASK) >> SI_CONFIG_ERR_INT_LSB)
+#define SI_CONFIG_ERR_INT_SET(x)                 (((x) << SI_CONFIG_ERR_INT_LSB) & SI_CONFIG_ERR_INT_MASK)
+#define SI_CONFIG_BIDIR_OD_DATA_MSB              18
+#define SI_CONFIG_BIDIR_OD_DATA_LSB              18
+#define SI_CONFIG_BIDIR_OD_DATA_MASK             0x00040000
+#define SI_CONFIG_BIDIR_OD_DATA_GET(x)           (((x) & SI_CONFIG_BIDIR_OD_DATA_MASK) >> SI_CONFIG_BIDIR_OD_DATA_LSB)
+#define SI_CONFIG_BIDIR_OD_DATA_SET(x)           (((x) << SI_CONFIG_BIDIR_OD_DATA_LSB) & SI_CONFIG_BIDIR_OD_DATA_MASK)
+#define SI_CONFIG_I2C_MSB                        16
+#define SI_CONFIG_I2C_LSB                        16
+#define SI_CONFIG_I2C_MASK                       0x00010000
+#define SI_CONFIG_I2C_GET(x)                     (((x) & SI_CONFIG_I2C_MASK) >> SI_CONFIG_I2C_LSB)
+#define SI_CONFIG_I2C_SET(x)                     (((x) << SI_CONFIG_I2C_LSB) & SI_CONFIG_I2C_MASK)
+#define SI_CONFIG_POS_SAMPLE_MSB                 7
+#define SI_CONFIG_POS_SAMPLE_LSB                 7
+#define SI_CONFIG_POS_SAMPLE_MASK                0x00000080
+#define SI_CONFIG_POS_SAMPLE_GET(x)              (((x) & SI_CONFIG_POS_SAMPLE_MASK) >> SI_CONFIG_POS_SAMPLE_LSB)
+#define SI_CONFIG_POS_SAMPLE_SET(x)              (((x) << SI_CONFIG_POS_SAMPLE_LSB) & SI_CONFIG_POS_SAMPLE_MASK)
+#define SI_CONFIG_POS_DRIVE_MSB                  6
+#define SI_CONFIG_POS_DRIVE_LSB                  6
+#define SI_CONFIG_POS_DRIVE_MASK                 0x00000040
+#define SI_CONFIG_POS_DRIVE_GET(x)               (((x) & SI_CONFIG_POS_DRIVE_MASK) >> SI_CONFIG_POS_DRIVE_LSB)
+#define SI_CONFIG_POS_DRIVE_SET(x)               (((x) << SI_CONFIG_POS_DRIVE_LSB) & SI_CONFIG_POS_DRIVE_MASK)
+#define SI_CONFIG_INACTIVE_DATA_MSB              5
+#define SI_CONFIG_INACTIVE_DATA_LSB              5
+#define SI_CONFIG_INACTIVE_DATA_MASK             0x00000020
+#define SI_CONFIG_INACTIVE_DATA_GET(x)           (((x) & SI_CONFIG_INACTIVE_DATA_MASK) >> SI_CONFIG_INACTIVE_DATA_LSB)
+#define SI_CONFIG_INACTIVE_DATA_SET(x)           (((x) << SI_CONFIG_INACTIVE_DATA_LSB) & SI_CONFIG_INACTIVE_DATA_MASK)
+#define SI_CONFIG_INACTIVE_CLK_MSB               4
+#define SI_CONFIG_INACTIVE_CLK_LSB               4
+#define SI_CONFIG_INACTIVE_CLK_MASK              0x00000010
+#define SI_CONFIG_INACTIVE_CLK_GET(x)            (((x) & SI_CONFIG_INACTIVE_CLK_MASK) >> SI_CONFIG_INACTIVE_CLK_LSB)
+#define SI_CONFIG_INACTIVE_CLK_SET(x)            (((x) << SI_CONFIG_INACTIVE_CLK_LSB) & SI_CONFIG_INACTIVE_CLK_MASK)
+#define SI_CONFIG_DIVIDER_MSB                    3
+#define SI_CONFIG_DIVIDER_LSB                    0
+#define SI_CONFIG_DIVIDER_MASK                   0x0000000f
+#define SI_CONFIG_DIVIDER_GET(x)                 (((x) & SI_CONFIG_DIVIDER_MASK) >> SI_CONFIG_DIVIDER_LSB)
+#define SI_CONFIG_DIVIDER_SET(x)                 (((x) << SI_CONFIG_DIVIDER_LSB) & SI_CONFIG_DIVIDER_MASK)
+
+#define SI_CS_ADDRESS                            0x00000004
+#define SI_CS_OFFSET                             0x00000004
+#define SI_CS_BIT_CNT_IN_LAST_BYTE_MSB           13
+#define SI_CS_BIT_CNT_IN_LAST_BYTE_LSB           11
+#define SI_CS_BIT_CNT_IN_LAST_BYTE_MASK          0x00003800
+#define SI_CS_BIT_CNT_IN_LAST_BYTE_GET(x)        (((x) & SI_CS_BIT_CNT_IN_LAST_BYTE_MASK) >> SI_CS_BIT_CNT_IN_LAST_BYTE_LSB)
+#define SI_CS_BIT_CNT_IN_LAST_BYTE_SET(x)        (((x) << SI_CS_BIT_CNT_IN_LAST_BYTE_LSB) & SI_CS_BIT_CNT_IN_LAST_BYTE_MASK)
+#define SI_CS_DONE_ERR_MSB                       10
+#define SI_CS_DONE_ERR_LSB                       10
+#define SI_CS_DONE_ERR_MASK                      0x00000400
+#define SI_CS_DONE_ERR_GET(x)                    (((x) & SI_CS_DONE_ERR_MASK) >> SI_CS_DONE_ERR_LSB)
+#define SI_CS_DONE_ERR_SET(x)                    (((x) << SI_CS_DONE_ERR_LSB) & SI_CS_DONE_ERR_MASK)
+#define SI_CS_DONE_INT_MSB                       9
+#define SI_CS_DONE_INT_LSB                       9
+#define SI_CS_DONE_INT_MASK                      0x00000200
+#define SI_CS_DONE_INT_GET(x)                    (((x) & SI_CS_DONE_INT_MASK) >> SI_CS_DONE_INT_LSB)
+#define SI_CS_DONE_INT_SET(x)                    (((x) << SI_CS_DONE_INT_LSB) & SI_CS_DONE_INT_MASK)
+#define SI_CS_START_MSB                          8
+#define SI_CS_START_LSB                          8
+#define SI_CS_START_MASK                         0x00000100
+#define SI_CS_START_GET(x)                       (((x) & SI_CS_START_MASK) >> SI_CS_START_LSB)
+#define SI_CS_START_SET(x)                       (((x) << SI_CS_START_LSB) & SI_CS_START_MASK)
+#define SI_CS_RX_CNT_MSB                         7
+#define SI_CS_RX_CNT_LSB                         4
+#define SI_CS_RX_CNT_MASK                        0x000000f0
+#define SI_CS_RX_CNT_GET(x)                      (((x) & SI_CS_RX_CNT_MASK) >> SI_CS_RX_CNT_LSB)
+#define SI_CS_RX_CNT_SET(x)                      (((x) << SI_CS_RX_CNT_LSB) & SI_CS_RX_CNT_MASK)
+#define SI_CS_TX_CNT_MSB                         3
+#define SI_CS_TX_CNT_LSB                         0
+#define SI_CS_TX_CNT_MASK                        0x0000000f
+#define SI_CS_TX_CNT_GET(x)                      (((x) & SI_CS_TX_CNT_MASK) >> SI_CS_TX_CNT_LSB)
+#define SI_CS_TX_CNT_SET(x)                      (((x) << SI_CS_TX_CNT_LSB) & SI_CS_TX_CNT_MASK)
+
+#define SI_TX_DATA0_ADDRESS                      0x00000008
+#define SI_TX_DATA0_OFFSET                       0x00000008
+#define SI_TX_DATA0_DATA3_MSB                    31
+#define SI_TX_DATA0_DATA3_LSB                    24
+#define SI_TX_DATA0_DATA3_MASK                   0xff000000
+#define SI_TX_DATA0_DATA3_GET(x)                 (((x) & SI_TX_DATA0_DATA3_MASK) >> SI_TX_DATA0_DATA3_LSB)
+#define SI_TX_DATA0_DATA3_SET(x)                 (((x) << SI_TX_DATA0_DATA3_LSB) & SI_TX_DATA0_DATA3_MASK)
+#define SI_TX_DATA0_DATA2_MSB                    23
+#define SI_TX_DATA0_DATA2_LSB                    16
+#define SI_TX_DATA0_DATA2_MASK                   0x00ff0000
+#define SI_TX_DATA0_DATA2_GET(x)                 (((x) & SI_TX_DATA0_DATA2_MASK) >> SI_TX_DATA0_DATA2_LSB)
+#define SI_TX_DATA0_DATA2_SET(x)                 (((x) << SI_TX_DATA0_DATA2_LSB) & SI_TX_DATA0_DATA2_MASK)
+#define SI_TX_DATA0_DATA1_MSB                    15
+#define SI_TX_DATA0_DATA1_LSB                    8
+#define SI_TX_DATA0_DATA1_MASK                   0x0000ff00
+#define SI_TX_DATA0_DATA1_GET(x)                 (((x) & SI_TX_DATA0_DATA1_MASK) >> SI_TX_DATA0_DATA1_LSB)
+#define SI_TX_DATA0_DATA1_SET(x)                 (((x) << SI_TX_DATA0_DATA1_LSB) & SI_TX_DATA0_DATA1_MASK)
+#define SI_TX_DATA0_DATA0_MSB                    7
+#define SI_TX_DATA0_DATA0_LSB                    0
+#define SI_TX_DATA0_DATA0_MASK                   0x000000ff
+#define SI_TX_DATA0_DATA0_GET(x)                 (((x) & SI_TX_DATA0_DATA0_MASK) >> SI_TX_DATA0_DATA0_LSB)
+#define SI_TX_DATA0_DATA0_SET(x)                 (((x) << SI_TX_DATA0_DATA0_LSB) & SI_TX_DATA0_DATA0_MASK)
+
+#define SI_TX_DATA1_ADDRESS                      0x0000000c
+#define SI_TX_DATA1_OFFSET                       0x0000000c
+#define SI_TX_DATA1_DATA7_MSB                    31
+#define SI_TX_DATA1_DATA7_LSB                    24
+#define SI_TX_DATA1_DATA7_MASK                   0xff000000
+#define SI_TX_DATA1_DATA7_GET(x)                 (((x) & SI_TX_DATA1_DATA7_MASK) >> SI_TX_DATA1_DATA7_LSB)
+#define SI_TX_DATA1_DATA7_SET(x)                 (((x) << SI_TX_DATA1_DATA7_LSB) & SI_TX_DATA1_DATA7_MASK)
+#define SI_TX_DATA1_DATA6_MSB                    23
+#define SI_TX_DATA1_DATA6_LSB                    16
+#define SI_TX_DATA1_DATA6_MASK                   0x00ff0000
+#define SI_TX_DATA1_DATA6_GET(x)                 (((x) & SI_TX_DATA1_DATA6_MASK) >> SI_TX_DATA1_DATA6_LSB)
+#define SI_TX_DATA1_DATA6_SET(x)                 (((x) << SI_TX_DATA1_DATA6_LSB) & SI_TX_DATA1_DATA6_MASK)
+#define SI_TX_DATA1_DATA5_MSB                    15
+#define SI_TX_DATA1_DATA5_LSB                    8
+#define SI_TX_DATA1_DATA5_MASK                   0x0000ff00
+#define SI_TX_DATA1_DATA5_GET(x)                 (((x) & SI_TX_DATA1_DATA5_MASK) >> SI_TX_DATA1_DATA5_LSB)
+#define SI_TX_DATA1_DATA5_SET(x)                 (((x) << SI_TX_DATA1_DATA5_LSB) & SI_TX_DATA1_DATA5_MASK)
+#define SI_TX_DATA1_DATA4_MSB                    7
+#define SI_TX_DATA1_DATA4_LSB                    0
+#define SI_TX_DATA1_DATA4_MASK                   0x000000ff
+#define SI_TX_DATA1_DATA4_GET(x)                 (((x) & SI_TX_DATA1_DATA4_MASK) >> SI_TX_DATA1_DATA4_LSB)
+#define SI_TX_DATA1_DATA4_SET(x)                 (((x) << SI_TX_DATA1_DATA4_LSB) & SI_TX_DATA1_DATA4_MASK)
+
+#define SI_RX_DATA0_ADDRESS                      0x00000010
+#define SI_RX_DATA0_OFFSET                       0x00000010
+#define SI_RX_DATA0_DATA3_MSB                    31
+#define SI_RX_DATA0_DATA3_LSB                    24
+#define SI_RX_DATA0_DATA3_MASK                   0xff000000
+#define SI_RX_DATA0_DATA3_GET(x)                 (((x) & SI_RX_DATA0_DATA3_MASK) >> SI_RX_DATA0_DATA3_LSB)
+#define SI_RX_DATA0_DATA3_SET(x)                 (((x) << SI_RX_DATA0_DATA3_LSB) & SI_RX_DATA0_DATA3_MASK)
+#define SI_RX_DATA0_DATA2_MSB                    23
+#define SI_RX_DATA0_DATA2_LSB                    16
+#define SI_RX_DATA0_DATA2_MASK                   0x00ff0000
+#define SI_RX_DATA0_DATA2_GET(x)                 (((x) & SI_RX_DATA0_DATA2_MASK) >> SI_RX_DATA0_DATA2_LSB)
+#define SI_RX_DATA0_DATA2_SET(x)                 (((x) << SI_RX_DATA0_DATA2_LSB) & SI_RX_DATA0_DATA2_MASK)
+#define SI_RX_DATA0_DATA1_MSB                    15
+#define SI_RX_DATA0_DATA1_LSB                    8
+#define SI_RX_DATA0_DATA1_MASK                   0x0000ff00
+#define SI_RX_DATA0_DATA1_GET(x)                 (((x) & SI_RX_DATA0_DATA1_MASK) >> SI_RX_DATA0_DATA1_LSB)
+#define SI_RX_DATA0_DATA1_SET(x)                 (((x) << SI_RX_DATA0_DATA1_LSB) & SI_RX_DATA0_DATA1_MASK)
+#define SI_RX_DATA0_DATA0_MSB                    7
+#define SI_RX_DATA0_DATA0_LSB                    0
+#define SI_RX_DATA0_DATA0_MASK                   0x000000ff
+#define SI_RX_DATA0_DATA0_GET(x)                 (((x) & SI_RX_DATA0_DATA0_MASK) >> SI_RX_DATA0_DATA0_LSB)
+#define SI_RX_DATA0_DATA0_SET(x)                 (((x) << SI_RX_DATA0_DATA0_LSB) & SI_RX_DATA0_DATA0_MASK)
+
+#define SI_RX_DATA1_ADDRESS                      0x00000014
+#define SI_RX_DATA1_OFFSET                       0x00000014
+#define SI_RX_DATA1_DATA7_MSB                    31
+#define SI_RX_DATA1_DATA7_LSB                    24
+#define SI_RX_DATA1_DATA7_MASK                   0xff000000
+#define SI_RX_DATA1_DATA7_GET(x)                 (((x) & SI_RX_DATA1_DATA7_MASK) >> SI_RX_DATA1_DATA7_LSB)
+#define SI_RX_DATA1_DATA7_SET(x)                 (((x) << SI_RX_DATA1_DATA7_LSB) & SI_RX_DATA1_DATA7_MASK)
+#define SI_RX_DATA1_DATA6_MSB                    23
+#define SI_RX_DATA1_DATA6_LSB                    16
+#define SI_RX_DATA1_DATA6_MASK                   0x00ff0000
+#define SI_RX_DATA1_DATA6_GET(x)                 (((x) & SI_RX_DATA1_DATA6_MASK) >> SI_RX_DATA1_DATA6_LSB)
+#define SI_RX_DATA1_DATA6_SET(x)                 (((x) << SI_RX_DATA1_DATA6_LSB) & SI_RX_DATA1_DATA6_MASK)
+#define SI_RX_DATA1_DATA5_MSB                    15
+#define SI_RX_DATA1_DATA5_LSB                    8
+#define SI_RX_DATA1_DATA5_MASK                   0x0000ff00
+#define SI_RX_DATA1_DATA5_GET(x)                 (((x) & SI_RX_DATA1_DATA5_MASK) >> SI_RX_DATA1_DATA5_LSB)
+#define SI_RX_DATA1_DATA5_SET(x)                 (((x) << SI_RX_DATA1_DATA5_LSB) & SI_RX_DATA1_DATA5_MASK)
+#define SI_RX_DATA1_DATA4_MSB                    7
+#define SI_RX_DATA1_DATA4_LSB                    0
+#define SI_RX_DATA1_DATA4_MASK                   0x000000ff
+#define SI_RX_DATA1_DATA4_GET(x)                 (((x) & SI_RX_DATA1_DATA4_MASK) >> SI_RX_DATA1_DATA4_LSB)
+#define SI_RX_DATA1_DATA4_SET(x)                 (((x) << SI_RX_DATA1_DATA4_LSB) & SI_RX_DATA1_DATA4_MASK)
+
+
+#ifndef __ASSEMBLER__
+
+typedef struct si_reg_reg_s {
+  volatile unsigned int si_config;
+  volatile unsigned int si_cs;
+  volatile unsigned int si_tx_data0;
+  volatile unsigned int si_tx_data1;
+  volatile unsigned int si_rx_data0;
+  volatile unsigned int si_rx_data1;
+} si_reg_reg_t;
+
+#endif /* __ASSEMBLER__ */
+
+#endif /* _SI_REG_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/targaddrs.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/targaddrs.h
@@ -0,0 +1,160 @@
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ */
+
+#ifndef __TARGADDRS_H__
+#define __TARGADDRS_H__
+#if defined(AR6001)
+#include "AR6001/addrs.h"
+#endif
+#if defined(AR6002)
+#include "AR6002/addrs.h"
+#endif
+
+/*
+ * AR6K option bits, to enable/disable various features.
+ * By default, all option bits are 0.
+ * These bits can be set in LOCAL_SCRATCH register 0.
+ */
+#define AR6K_OPTION_BMI_DISABLE      0x01 /* Disable BMI comm with Host */
+#define AR6K_OPTION_SERIAL_ENABLE    0x02 /* Enable serial port msgs */
+#define AR6K_OPTION_WDT_DISABLE      0x04 /* WatchDog Timer override */
+#define AR6K_OPTION_SLEEP_DISABLE    0x08 /* Disable system sleep */
+#define AR6K_OPTION_STOP_BOOT        0x10 /* Stop boot processes (for ATE) */
+#define AR6K_OPTION_ENABLE_NOANI     0x20 /* Operate without ANI */
+#define AR6K_OPTION_DSET_DISABLE     0x40 /* Ignore DataSets */
+#define AR6K_OPTION_IGNORE_FLASH     0x80 /* Ignore flash during bootup */
+
+/*
+ * xxx_HOST_INTEREST_ADDRESS is the address in Target RAM of the
+ * host_interest structure.  It must match the address of the _host_interest
+ * symbol (see linker script).
+ *
+ * Host Interest is shared between Host and Target in order to coordinate
+ * between the two, and is intended to remain constant (with additions only
+ * at the end) across software releases.
+ */
+#define AR6001_HOST_INTEREST_ADDRESS     0x80000600
+#define AR6002_HOST_INTEREST_ADDRESS     0x00500400
+
+#define HOST_INTEREST_MAX_SIZE          0x100
+
+#if !defined(__ASSEMBLER__)
+struct register_dump_s;
+struct dbglog_hdr_s;
+
+/*
+ * These are items that the Host may need to access
+ * via BMI or via the Diagnostic Window. The position
+ * of items in this structure must remain constant
+ * across firmware revisions!
+ *
+ * Types for each item must be fixed size across
+ * target and host platforms.
+ *
+ * More items may be added at the end.
+ */
+struct host_interest_s {
+    /*
+     * Pointer to application-defined area, if any.
+     * Set by Target application during startup.
+     */
+    A_UINT32               hi_app_host_interest;                      /* 0x00 */
+
+    /* Pointer to register dump area, valid after Target crash. */
+    A_UINT32               hi_failure_state;                          /* 0x04 */
+
+    /* Pointer to debug logging header */
+    A_UINT32               hi_dbglog_hdr;                             /* 0x08 */
+
+    /* Indicates whether or not flash is present on Target.
+     * NB: flash_is_present indicator is here not just
+     * because it might be of interest to the Host; but
+     * also because it's set early on by Target's startup
+     * asm code and we need it to have a special RAM address
+     * so that it doesn't get reinitialized with the rest
+     * of data.
+     */
+    A_UINT32               hi_flash_is_present;                       /* 0x0c */
+
+    /*
+     * General-purpose flag bits, similar to AR6000_OPTION_* flags.
+     * Can be used by application rather than by OS.
+     */
+    A_UINT32               hi_option_flag;                            /* 0x10 */
+
+    /*
+     * Boolean that determines whether or not to
+     * display messages on the serial port.
+     */
+    A_UINT32               hi_serial_enable;                          /* 0x14 */
+
+    /* Start address of Flash DataSet index, if any */
+    A_UINT32               hi_dset_list_head;                         /* 0x18 */
+
+    /* Override Target application start address */
+    A_UINT32               hi_app_start;                              /* 0x1c */
+
+    /* Clock and voltage tuning */
+    A_UINT32               hi_skip_clock_init;                        /* 0x20 */
+    A_UINT32               hi_core_clock_setting;                     /* 0x24 */
+    A_UINT32               hi_cpu_clock_setting;                      /* 0x28 */
+    A_UINT32               hi_system_sleep_setting;                   /* 0x2c */
+    A_UINT32               hi_xtal_control_setting;                   /* 0x30 */
+    A_UINT32               hi_pll_ctrl_setting_24ghz;                 /* 0x34 */
+    A_UINT32               hi_pll_ctrl_setting_5ghz;                  /* 0x38 */
+    A_UINT32               hi_ref_voltage_trim_setting;               /* 0x3c */
+    A_UINT32               hi_clock_info;                             /* 0x40 */
+
+    /*
+     * Flash configuration overrides, used only
+     * when firmware is not executing from flash.
+     * (When using flash, modify the global variables
+     * with equivalent names.)
+     */
+    A_UINT32               hi_bank0_addr_value;                       /* 0x44 */
+    A_UINT32               hi_bank0_read_value;                       /* 0x48 */
+    A_UINT32               hi_bank0_write_value;                      /* 0x4c */
+    A_UINT32               hi_bank0_config_value;                     /* 0x50 */
+
+    /* Pointer to Board Data  */
+    A_UINT32               hi_board_data;                             /* 0x54 */
+    A_UINT32               hi_board_data_initialized;                 /* 0x58 */
+
+    A_UINT32               hi_dset_RAM_index_table;                   /* 0x5c */
+
+    A_UINT32               hi_desired_baud_rate;                      /* 0x60 */
+    A_UINT32               hi_dbglog_config;                          /* 0x64 */
+    A_UINT32               hi_end_RAM_reserve_sz;                     /* 0x68 */
+    A_UINT32               hi_mbox_io_block_sz;                       /* 0x6c */
+
+    A_UINT32               hi_num_bpatch_streams;                     /* 0x70 -- unused */
+    A_UINT32               hi_mbox_isr_yield_limit;                   /* 0x74 */
+
+    A_UINT32               hi_refclk_hz;                              /* 0x78 */
+    A_UINT32               hi_ext_clk_detected;                       /* 0x7c */
+};
+
+/* Bits defined in hi_option_flag */
+#define HI_OPTION_TIMER_WAR      0x01 /* Enable timer workaround */
+#define HI_OPTION_BMI_CRED_LIMIT 0x02 /* Limit BMI command credits */
+
+/*
+ * Intended for use by Host software, this macro returns the Target RAM
+ * address of any item in the host_interest structure.
+ * Example: target_addr = AR6001_HOST_INTEREST_ITEM_ADDRESS(hi_board_data);
+ */
+#define AR6001_HOST_INTEREST_ITEM_ADDRESS(item) \
+    ((A_UINT32)&((((struct host_interest_s *)(AR6001_HOST_INTEREST_ADDRESS))->item)))
+
+#define AR6002_HOST_INTEREST_ITEM_ADDRESS(item) \
+    ((A_UINT32)&((((struct host_interest_s *)(AR6002_HOST_INTEREST_ADDRESS))->item)))
+
+
+#endif /* !__ASSEMBLER__ */
+
+#endif /* __TARGADDRS_H__ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/testcmd.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/testcmd.h
@@ -0,0 +1,151 @@
+/*
+ * Copyright (c) 2004-2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ */
+
+#ifndef  TESTCMD_H_
+#define  TESTCMD_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum {
+    ZEROES_PATTERN = 0,
+    ONES_PATTERN,
+    REPEATING_10,
+    PN7_PATTERN,
+    PN9_PATTERN,
+    PN15_PATTERN
+}TX_DATA_PATTERN;
+
+/* Continous tx
+   mode : TCMD_CONT_TX_OFF - Disabling continous tx
+          TCMD_CONT_TX_SINE - Enable continuous unmodulated tx
+          TCMD_CONT_TX_FRAME- Enable continuous modulated tx
+   freq : Channel freq in Mhz. (e.g 2412 for channel 1 in 11 g)
+dataRate: 0 - 1 Mbps
+          1 - 2 Mbps
+          2 - 5.5 Mbps
+          3 - 11 Mbps
+          4 - 6 Mbps
+          5 - 9 Mbps
+          6 - 12 Mbps
+          7 - 18 Mbps
+          8 - 24 Mbps
+          9 - 36 Mbps
+         10 - 28 Mbps
+         11 - 54 Mbps
+  txPwr: Tx power in dBm[5 -11] for unmod Tx, [5-14] for mod Tx
+antenna:  1 - one antenna
+          2 - two antenna
+Note : Enable/disable continuous tx test cmd works only when target is awake.
+*/
+
+typedef enum {
+    TCMD_CONT_TX_OFF = 0,
+    TCMD_CONT_TX_SINE,
+    TCMD_CONT_TX_FRAME,
+    TCMD_CONT_TX_TX99,
+    TCMD_CONT_TX_TX100
+} TCMD_CONT_TX_MODE;
+
+typedef PREPACK struct {
+    A_UINT32                 testCmdId;
+    A_UINT32                mode;
+    A_UINT32                freq;
+    A_UINT32                dataRate;
+    A_INT32                 txPwr;
+    A_UINT32                antenna;
+    A_UINT32                enANI;
+    A_UINT32                scramblerOff;
+    A_UINT32                aifsn;
+    A_UINT16                pktSz;
+    A_UINT16                txPattern;
+} POSTPACK TCMD_CONT_TX;
+
+#define TCMD_TXPATTERN_ZERONE                 0x1
+#define TCMD_TXPATTERN_ZERONE_DIS_SCRAMBLE    0x2
+
+/* Continuous Rx
+ act: TCMD_CONT_RX_PROMIS - promiscuous mode (accept all incoming frames)
+      TCMD_CONT_RX_FILTER - filter mode (accept only frames with dest
+                                             address equal specified
+                                             mac address (set via act =3)
+      TCMD_CONT_RX_REPORT  off mode  (disable cont rx mode and get the
+                                          report from the last cont
+                                          Rx test)
+
+     TCMD_CONT_RX_SETMAC - set MacAddr mode (sets the MAC address for the
+                                                 target. This Overrides
+                                                 the default MAC address.)
+
+*/
+typedef enum {
+    TCMD_CONT_RX_PROMIS =0,
+    TCMD_CONT_RX_FILTER,
+    TCMD_CONT_RX_REPORT,
+    TCMD_CONT_RX_SETMAC,
+    TCMD_CONT_RX_SET_ANT_SWITCH_TABLE
+} TCMD_CONT_RX_ACT;
+
+typedef PREPACK struct {
+    A_UINT32         testCmdId;
+    A_UINT32        act;
+    A_UINT32        enANI;
+    PREPACK union {
+        struct PREPACK TCMD_CONT_RX_PARA {
+            A_UINT32    freq;
+            A_UINT32    antenna;
+        } POSTPACK para;
+        struct PREPACK TCMD_CONT_RX_REPORT {
+            A_UINT32    totalPkt;
+            A_INT32    rssiInDBm;
+	    A_UINT32 crcErrPkt;
+	    A_UINT32 secErrPkt;
+        } POSTPACK report;
+        struct PREPACK TCMD_CONT_RX_MAC {
+            A_UCHAR    addr[ATH_MAC_LEN];
+        } POSTPACK mac;
+        struct PREPACK TCMD_CONT_RX_ANT_SWITCH_TABLE {
+            A_UINT32                antswitch1;
+            A_UINT32                antswitch2;
+        }POSTPACK antswitchtable;
+    } POSTPACK u;
+} POSTPACK TCMD_CONT_RX;
+
+/* Force sleep/wake  test cmd
+ mode: TCMD_PM_WAKEUP - Wakeup the target
+       TCMD_PM_SLEEP - Force the target to sleep.
+ */
+typedef enum {
+    TCMD_PM_WAKEUP = 1, /* be consistent with target */
+    TCMD_PM_SLEEP
+} TCMD_PM_MODE;
+
+typedef PREPACK struct {
+	A_UINT32  testCmdId;
+    A_UINT32  mode;
+} POSTPACK TCMD_PM;
+
+typedef enum {
+    TCMD_CONT_TX_ID,
+    TCMD_CONT_RX_ID,
+    TCMD_PM_ID
+} TCMD_ID;
+
+typedef PREPACK union {
+          TCMD_CONT_TX contTx;
+          TCMD_CONT_RX contRx;
+          TCMD_PM pm;
+} POSTPACK TEST_CMD;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* TESTCMD_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/vmc_reg.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/vmc_reg.h
@@ -0,0 +1,99 @@
+// ------------------------------------------------------------------
+// Copyright (c) 2004-2007 Atheros Corporation.  All rights reserved.
+//
+// The software source and binaries included in this development package are
+// licensed, not sold. You, or your company, received the package under one
+// or more license agreements. The rights granted to you are specifically
+// listed in these license agreement(s). All other rights remain with Atheros
+// Communications, Inc., its subsidiaries, or the respective owner including
+// those listed on the included copyright notices.  Distribution of any
+// portion of this package must be in strict compliance with the license
+// agreement(s) terms.
+// </copyright>
+//
+// <summary>
+// 	Wifi driver for AR6002
+// </summary>
+//
+// ------------------------------------------------------------------
+//===================================================================
+// Author(s): ="Atheros"
+//===================================================================
+
+
+#ifndef _VMC_REG_REG_H_
+#define _VMC_REG_REG_H_
+
+#define MC_TCAM_VALID_ADDRESS                    0x00000000
+#define MC_TCAM_VALID_OFFSET                     0x00000000
+#define MC_TCAM_VALID_BIT_MSB                    0
+#define MC_TCAM_VALID_BIT_LSB                    0
+#define MC_TCAM_VALID_BIT_MASK                   0x00000001
+#define MC_TCAM_VALID_BIT_GET(x)                 (((x) & MC_TCAM_VALID_BIT_MASK) >> MC_TCAM_VALID_BIT_LSB)
+#define MC_TCAM_VALID_BIT_SET(x)                 (((x) << MC_TCAM_VALID_BIT_LSB) & MC_TCAM_VALID_BIT_MASK)
+
+#define MC_TCAM_MASK_ADDRESS                     0x00000080
+#define MC_TCAM_MASK_OFFSET                      0x00000080
+#define MC_TCAM_MASK_SIZE_MSB                    2
+#define MC_TCAM_MASK_SIZE_LSB                    0
+#define MC_TCAM_MASK_SIZE_MASK                   0x00000007
+#define MC_TCAM_MASK_SIZE_GET(x)                 (((x) & MC_TCAM_MASK_SIZE_MASK) >> MC_TCAM_MASK_SIZE_LSB)
+#define MC_TCAM_MASK_SIZE_SET(x)                 (((x) << MC_TCAM_MASK_SIZE_LSB) & MC_TCAM_MASK_SIZE_MASK)
+
+#define MC_TCAM_COMPARE_ADDRESS                  0x00000100
+#define MC_TCAM_COMPARE_OFFSET                   0x00000100
+#define MC_TCAM_COMPARE_KEY_MSB                  21
+#define MC_TCAM_COMPARE_KEY_LSB                  5
+#define MC_TCAM_COMPARE_KEY_MASK                 0x003fffe0
+#define MC_TCAM_COMPARE_KEY_GET(x)               (((x) & MC_TCAM_COMPARE_KEY_MASK) >> MC_TCAM_COMPARE_KEY_LSB)
+#define MC_TCAM_COMPARE_KEY_SET(x)               (((x) << MC_TCAM_COMPARE_KEY_LSB) & MC_TCAM_COMPARE_KEY_MASK)
+
+#define MC_TCAM_TARGET_ADDRESS                   0x00000180
+#define MC_TCAM_TARGET_OFFSET                    0x00000180
+#define MC_TCAM_TARGET_ADDR_MSB                  21
+#define MC_TCAM_TARGET_ADDR_LSB                  5
+#define MC_TCAM_TARGET_ADDR_MASK                 0x003fffe0
+#define MC_TCAM_TARGET_ADDR_GET(x)               (((x) & MC_TCAM_TARGET_ADDR_MASK) >> MC_TCAM_TARGET_ADDR_LSB)
+#define MC_TCAM_TARGET_ADDR_SET(x)               (((x) << MC_TCAM_TARGET_ADDR_LSB) & MC_TCAM_TARGET_ADDR_MASK)
+
+#define ADDR_ERROR_CONTROL_ADDRESS               0x00000200
+#define ADDR_ERROR_CONTROL_OFFSET                0x00000200
+#define ADDR_ERROR_CONTROL_QUAL_ENABLE_MSB       1
+#define ADDR_ERROR_CONTROL_QUAL_ENABLE_LSB       1
+#define ADDR_ERROR_CONTROL_QUAL_ENABLE_MASK      0x00000002
+#define ADDR_ERROR_CONTROL_QUAL_ENABLE_GET(x)    (((x) & ADDR_ERROR_CONTROL_QUAL_ENABLE_MASK) >> ADDR_ERROR_CONTROL_QUAL_ENABLE_LSB)
+#define ADDR_ERROR_CONTROL_QUAL_ENABLE_SET(x)    (((x) << ADDR_ERROR_CONTROL_QUAL_ENABLE_LSB) & ADDR_ERROR_CONTROL_QUAL_ENABLE_MASK)
+#define ADDR_ERROR_CONTROL_ENABLE_MSB            0
+#define ADDR_ERROR_CONTROL_ENABLE_LSB            0
+#define ADDR_ERROR_CONTROL_ENABLE_MASK           0x00000001
+#define ADDR_ERROR_CONTROL_ENABLE_GET(x)         (((x) & ADDR_ERROR_CONTROL_ENABLE_MASK) >> ADDR_ERROR_CONTROL_ENABLE_LSB)
+#define ADDR_ERROR_CONTROL_ENABLE_SET(x)         (((x) << ADDR_ERROR_CONTROL_ENABLE_LSB) & ADDR_ERROR_CONTROL_ENABLE_MASK)
+
+#define ADDR_ERROR_STATUS_ADDRESS                0x00000204
+#define ADDR_ERROR_STATUS_OFFSET                 0x00000204
+#define ADDR_ERROR_STATUS_WRITE_MSB              25
+#define ADDR_ERROR_STATUS_WRITE_LSB              25
+#define ADDR_ERROR_STATUS_WRITE_MASK             0x02000000
+#define ADDR_ERROR_STATUS_WRITE_GET(x)           (((x) & ADDR_ERROR_STATUS_WRITE_MASK) >> ADDR_ERROR_STATUS_WRITE_LSB)
+#define ADDR_ERROR_STATUS_WRITE_SET(x)           (((x) << ADDR_ERROR_STATUS_WRITE_LSB) & ADDR_ERROR_STATUS_WRITE_MASK)
+#define ADDR_ERROR_STATUS_ADDRESS_MSB            24
+#define ADDR_ERROR_STATUS_ADDRESS_LSB            0
+#define ADDR_ERROR_STATUS_ADDRESS_MASK           0x01ffffff
+#define ADDR_ERROR_STATUS_ADDRESS_GET(x)         (((x) & ADDR_ERROR_STATUS_ADDRESS_MASK) >> ADDR_ERROR_STATUS_ADDRESS_LSB)
+#define ADDR_ERROR_STATUS_ADDRESS_SET(x)         (((x) << ADDR_ERROR_STATUS_ADDRESS_LSB) & ADDR_ERROR_STATUS_ADDRESS_MASK)
+
+
+#ifndef __ASSEMBLER__
+
+typedef struct vmc_reg_reg_s {
+  volatile unsigned int mc_tcam_valid[32];
+  volatile unsigned int mc_tcam_mask[32];
+  volatile unsigned int mc_tcam_compare[32];
+  volatile unsigned int mc_tcam_target[32];
+  volatile unsigned int addr_error_control;
+  volatile unsigned int addr_error_status;
+} vmc_reg_reg_t;
+
+#endif /* __ASSEMBLER__ */
+
+#endif /* _VMC_REG_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/wlan_api.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/wlan_api.h
@@ -0,0 +1,107 @@
+#ifndef _HOST_WLAN_API_H_
+#define _HOST_WLAN_API_H_
+/*
+ * Copyright (c) 2004-2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * This file contains the API for the host wlan module
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/include/wlan_api.h#1 $
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct ieee80211_node_table;
+struct ieee80211_frame;
+
+struct ieee80211_common_ie {
+    A_UINT16    ie_chan;
+    A_UINT8     *ie_tstamp;
+    A_UINT8     *ie_ssid;
+    A_UINT8     *ie_rates;
+    A_UINT8     *ie_xrates;
+    A_UINT8     *ie_country;
+    A_UINT8     *ie_wpa;
+    A_UINT8     *ie_rsn;
+    A_UINT8     *ie_wmm;
+    A_UINT8     *ie_ath;
+    A_UINT16    ie_capInfo;
+    A_UINT16    ie_beaconInt;
+    A_UINT8     *ie_tim;
+    A_UINT8     *ie_chswitch;
+    A_UINT8     ie_erp;
+    A_UINT8     *ie_wsc;
+};
+
+typedef struct bss {
+    A_UINT8                      ni_macaddr[6];
+    A_UINT8                      ni_snr;
+    A_INT16                      ni_rssi;
+    struct bss                   *ni_list_next;
+    struct bss                   *ni_list_prev;
+    struct bss                   *ni_hash_next;
+    struct bss                   *ni_hash_prev;
+    struct ieee80211_common_ie   ni_cie;
+    A_UINT8                     *ni_buf;
+    struct ieee80211_node_table *ni_table;
+    A_UINT32                     ni_refcnt;
+    int                          ni_scangen;
+    A_UINT32                     ni_tstamp;
+#ifdef OS_ROAM_MANAGEMENT
+    A_UINT32                     ni_si_gen;
+#endif
+} bss_t;
+
+typedef void wlan_node_iter_func(void *arg, bss_t *);
+
+bss_t *wlan_node_alloc(struct ieee80211_node_table *nt, int wh_size);
+void wlan_node_free(bss_t *ni);
+void wlan_setup_node(struct ieee80211_node_table *nt, bss_t *ni,
+                const A_UINT8 *macaddr);
+bss_t *wlan_find_node(struct ieee80211_node_table *nt, const A_UINT8 *macaddr);
+void wlan_node_reclaim(struct ieee80211_node_table *nt, bss_t *ni);
+void wlan_free_allnodes(struct ieee80211_node_table *nt);
+void wlan_iterate_nodes(struct ieee80211_node_table *nt, wlan_node_iter_func *f,
+                        void *arg);
+
+void wlan_node_table_init(void *wmip, struct ieee80211_node_table *nt);
+void wlan_node_table_reset(struct ieee80211_node_table *nt);
+void wlan_node_table_cleanup(struct ieee80211_node_table *nt);
+
+A_STATUS wlan_parse_beacon(A_UINT8 *buf, int framelen,
+                           struct ieee80211_common_ie *cie);
+
+A_UINT16 wlan_ieee2freq(int chan);
+A_UINT32 wlan_freq2ieee(A_UINT16 freq);
+
+void wlan_set_nodeage(struct ieee80211_node_table *nt, A_UINT32 nodeAge);
+
+bss_t *
+wlan_find_Ssidnode (struct ieee80211_node_table *nt, A_UCHAR *pSsid,
+                    A_UINT32 ssidLength, A_BOOL bIsWPA2, A_BOOL bMatchSSID);
+
+void
+wlan_node_return (struct ieee80211_node_table *nt, bss_t *ni);
+
+bss_t *wlan_node_remove(struct ieee80211_node_table *nt, A_UINT8 *bssid);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _HOST_WLAN_API_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/wmi.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/wmi.h
@@ -0,0 +1,1974 @@
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ * This file contains the definitions of the WMI protocol specified in the
+ * Wireless Module Interface (WMI).  It includes definitions of all the
+ * commands and events. Commands are messages from the host to the WM.
+ * Events and Replies are messages from the WM to the host.
+ *
+ * Ownership of correctness in regards to WMI commands
+ * belongs to the host driver and the WM is not required to validate
+ * parameters for value, proper range, or any other checking.
+ *
+ */
+
+#ifndef _WMI_H_
+#define _WMI_H_
+
+#include "wmix.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define HTC_PROTOCOL_VERSION    0x0002
+#define HTC_PROTOCOL_REVISION   0x0000
+
+#define WMI_PROTOCOL_VERSION    0x0002
+#define WMI_PROTOCOL_REVISION   0x0000
+
+#define ATH_MAC_LEN             6               /* length of mac in bytes */
+#define WMI_CMD_MAX_LEN         100
+#define WMI_CONTROL_MSG_MAX_LEN     256
+#define WMI_OPT_CONTROL_MSG_MAX_LEN 1536
+#define IS_ETHERTYPE(_typeOrLen)        ((_typeOrLen) >= 0x0600)
+#define RFC1042OUI      {0x00, 0x00, 0x00}
+
+#define IP_ETHERTYPE 0x0800
+
+#define WMI_IMPLICIT_PSTREAM 0xFF
+#define WMI_MAX_THINSTREAM 15
+
+struct host_app_area_s {
+    A_UINT32 wmi_protocol_ver;
+};
+
+/*
+ * Data Path
+ */
+typedef PREPACK struct {
+    A_UINT8     dstMac[ATH_MAC_LEN];
+    A_UINT8     srcMac[ATH_MAC_LEN];
+    A_UINT16    typeOrLen;
+} POSTPACK ATH_MAC_HDR;
+
+typedef PREPACK struct {
+    A_UINT8     dsap;
+    A_UINT8     ssap;
+    A_UINT8     cntl;
+    A_UINT8     orgCode[3];
+    A_UINT16    etherType;
+} POSTPACK ATH_LLC_SNAP_HDR;
+
+typedef enum {
+    DATA_MSGTYPE = 0x0,
+    CNTL_MSGTYPE,
+    SYNC_MSGTYPE,
+    OPT_MSGTYPE,
+} WMI_MSG_TYPE;
+
+
+typedef PREPACK struct {
+    A_INT8      rssi;
+    A_UINT8     info;            /* WMI_MSG_TYPE in lower 2 bits - b1b0 */
+                                 /* UP in next 3 bits - b4b3b2 */
+#define WMI_DATA_HDR_MSG_TYPE_MASK  0x03
+#define WMI_DATA_HDR_MSG_TYPE_SHIFT 0
+#define WMI_DATA_HDR_UP_MASK        0x07
+#define WMI_DATA_HDR_UP_SHIFT       2
+#define WMI_DATA_HDR_IS_MSG_TYPE(h, t)  (((h)->info & (WMI_DATA_HDR_MSG_TYPE_MASK)) == (t))
+} POSTPACK WMI_DATA_HDR;
+
+
+#define WMI_DATA_HDR_SET_MSG_TYPE(h, t) (h)->info = (((h)->info & ~(WMI_DATA_HDR_MSG_TYPE_MASK << WMI_DATA_HDR_MSG_TYPE_SHIFT)) | (t << WMI_DATA_HDR_MSG_TYPE_SHIFT))
+#define WMI_DATA_HDR_SET_UP(h, p) (h)->info = (((h)->info & ~(WMI_DATA_HDR_UP_MASK << WMI_DATA_HDR_UP_SHIFT)) | (p << WMI_DATA_HDR_UP_SHIFT))
+
+/*
+ * Control Path
+ */
+typedef PREPACK struct {
+    A_UINT16    commandId;
+} POSTPACK WMI_CMD_HDR;        /* used for commands and events */
+
+/*
+ * List of Commnands
+ */
+typedef enum {
+    WMI_CONNECT_CMDID           = 0x0001,
+    WMI_RECONNECT_CMDID,
+    WMI_DISCONNECT_CMDID,
+    WMI_SYNCHRONIZE_CMDID,
+    WMI_CREATE_PSTREAM_CMDID,
+    WMI_DELETE_PSTREAM_CMDID,
+    WMI_START_SCAN_CMDID,
+    WMI_SET_SCAN_PARAMS_CMDID,
+    WMI_SET_BSS_FILTER_CMDID,
+    WMI_SET_PROBED_SSID_CMDID,               /* 10 */
+    WMI_SET_LISTEN_INT_CMDID,
+    WMI_SET_BMISS_TIME_CMDID,
+    WMI_SET_DISC_TIMEOUT_CMDID,
+    WMI_GET_CHANNEL_LIST_CMDID,
+    WMI_SET_BEACON_INT_CMDID,
+    WMI_GET_STATISTICS_CMDID,
+    WMI_SET_CHANNEL_PARAMS_CMDID,
+    WMI_SET_POWER_MODE_CMDID,
+    WMI_SET_IBSS_PM_CAPS_CMDID,
+    WMI_SET_POWER_PARAMS_CMDID,              /* 20 */
+    WMI_SET_POWERSAVE_TIMERS_POLICY_CMDID,
+    WMI_ADD_CIPHER_KEY_CMDID,
+    WMI_DELETE_CIPHER_KEY_CMDID,
+    WMI_ADD_KRK_CMDID,
+    WMI_DELETE_KRK_CMDID,
+    WMI_SET_PMKID_CMDID,
+    WMI_SET_TX_PWR_CMDID,
+    WMI_GET_TX_PWR_CMDID,
+    WMI_SET_ASSOC_INFO_CMDID,
+    WMI_ADD_BAD_AP_CMDID,                    /* 30 */
+    WMI_DELETE_BAD_AP_CMDID,
+    WMI_SET_TKIP_COUNTERMEASURES_CMDID,
+    WMI_RSSI_THRESHOLD_PARAMS_CMDID,
+    WMI_TARGET_ERROR_REPORT_BITMASK_CMDID,
+    WMI_SET_ACCESS_PARAMS_CMDID,
+    WMI_SET_RETRY_LIMITS_CMDID,
+    WMI_SET_OPT_MODE_CMDID,
+    WMI_OPT_TX_FRAME_CMDID,
+    WMI_SET_VOICE_PKT_SIZE_CMDID,
+    WMI_SET_MAX_SP_LEN_CMDID,                /* 40 */
+    WMI_SET_ROAM_CTRL_CMDID,
+    WMI_GET_ROAM_TBL_CMDID,
+    WMI_GET_ROAM_DATA_CMDID,
+    WMI_ENABLE_RM_CMDID,
+    WMI_SET_MAX_OFFHOME_DURATION_CMDID,
+    WMI_EXTENSION_CMDID,                        /* Non-wireless extensions */
+    WMI_SNR_THRESHOLD_PARAMS_CMDID,
+    WMI_LQ_THRESHOLD_PARAMS_CMDID,
+    WMI_SET_LPREAMBLE_CMDID,
+    WMI_SET_RTS_CMDID,                       /* 50 */
+    WMI_CLR_RSSI_SNR_CMDID,
+    WMI_SET_FIXRATES_CMDID,
+    WMI_GET_FIXRATES_CMDID,
+    WMI_SET_AUTH_MODE_CMDID,
+    WMI_SET_REASSOC_MODE_CMDID,
+    WMI_SET_WMM_CMDID,
+    WMI_SET_WMM_TXOP_CMDID,
+    WMI_TEST_CMDID,
+    WMI_SET_BT_STATUS_CMDID,
+    WMI_SET_BT_PARAMS_CMDID,                 /* 60 */
+
+    WMI_SET_KEEPALIVE_CMDID,
+    WMI_GET_KEEPALIVE_CMDID,
+    WMI_SET_APPIE_CMDID,
+    WMI_GET_APPIE_CMDID,
+    WMI_SET_WSC_STATUS_CMDID,
+
+    /* Wake on Wireless */
+    WMI_SET_HOST_SLEEP_MODE_CMDID,
+    WMI_SET_WOW_MODE_CMDID,
+    WMI_GET_WOW_LIST_CMDID,
+    WMI_ADD_WOW_PATTERN_CMDID,
+    WMI_DEL_WOW_PATTERN_CMDID,               /* 70 */
+
+    /*
+     * Developer commands starts at 0xF000
+     */
+    WMI_SET_BITRATE_CMDID = 0xF000,
+    WMI_GET_BITRATE_CMDID,
+    WMI_SET_WHALPARAM_CMDID,
+
+
+    /*Should add the new command to the tail for compatible with
+     * etna.
+     */
+    WMI_SET_MAC_ADDRESS_CMDID,
+    WMI_SET_AKMP_PARAMS_CMDID,
+    WMI_SET_PMKID_LIST_CMDID,
+    WMI_GET_PMKID_LIST_CMDID,
+    WMI_ABORT_SCAN_CMDID,
+    WMI_SET_TARGET_EVENT_REPORT_CMDID,
+
+    WMI_SET_MCAST_FILTER_CMDID,
+    WMI_DEL_MCAST_FILTER_CMDID
+} WMI_COMMAND_ID;
+
+/*
+ * Frame Types
+ */
+typedef enum {
+    WMI_FRAME_BEACON        =   0,
+    WMI_FRAME_PROBE_REQ,
+    WMI_FRAME_PROBE_RESP,
+    WMI_FRAME_ASSOC_REQ,
+    WMI_FRAME_ASSOC_RESP,
+    WMI_NUM_MGMT_FRAME
+} WMI_MGMT_FRAME_TYPE;
+
+/*
+ * Connect Command
+ */
+typedef enum {
+    INFRA_NETWORK       = 0x01,
+    ADHOC_NETWORK       = 0x02,
+    ADHOC_CREATOR       = 0x04,
+    OPT_NETWORK         = 0x08,
+} NETWORK_TYPE;
+
+typedef enum {
+    OPEN_AUTH           = 0x01,
+    SHARED_AUTH         = 0x02,
+    LEAP_AUTH           = 0x04,  /* different from IEEE_AUTH_MODE definitions */
+} DOT11_AUTH_MODE;
+
+typedef enum {
+    NONE_AUTH           = 0x01,
+    WPA_AUTH            = 0x02,
+    WPA_PSK_AUTH        = 0x03,
+    WPA2_AUTH           = 0x04,
+    WPA2_PSK_AUTH       = 0x05,
+    WPA_AUTH_CCKM       = 0x06,
+    WPA2_AUTH_CCKM      = 0x07,
+} AUTH_MODE;
+
+typedef enum {
+    NONE_CRYPT          = 0x01,
+    WEP_CRYPT           = 0x02,
+    TKIP_CRYPT          = 0x03,
+    AES_CRYPT           = 0x04,
+#ifdef WAPI_ENABLE
+    WAPI_CRYPT          = 0x05,
+#endif /* WAPI_ENABLE */
+} CRYPTO_TYPE;
+
+#define WMI_MIN_CRYPTO_TYPE NONE_CRYPT
+#ifndef WAPI_ENABLE
+#define WMI_MAX_CRYPTO_TYPE (AES_CRYPT + 1)
+#else
+#define WMI_MAX_CRYPTO_TYPE (WAPI_CRYPT + 1)
+#endif /* WAPI_ENABLE */
+
+#define WMI_MIN_KEY_INDEX   0
+#ifndef WAPI_ENABLE
+#define WMI_MAX_KEY_INDEX   3
+#else
+#define WMI_MAX_KEY_INDEX   7 /* wapi grpKey 0-3, prwKey 4-7 */
+#endif
+
+#define WMI_MAX_KEY_LEN     32
+
+#define WMI_MAX_SSID_LEN    32
+
+typedef enum {
+    CONNECT_ASSOC_POLICY_USER = 0x0001,
+    CONNECT_SEND_REASSOC = 0x0002,
+    CONNECT_IGNORE_WPAx_GROUP_CIPHER = 0x0004,
+    CONNECT_PROFILE_MATCH_DONE = 0x0008,
+    CONNECT_IGNORE_AAC_BEACON = 0x0010,
+    CONNECT_CSA_FOLLOW_BSS = 0x0020,
+    CONNECT_CSA_IGNORE_FOLLOW_BSS = 0x0040,
+} WMI_CONNECT_CTRL_FLAGS_BITS;
+
+#define DEFAULT_CONNECT_CTRL_FLAGS         (CONNECT_CSA_FOLLOW_BSS)
+
+typedef PREPACK struct {
+    A_UINT8     networkType;
+    A_UINT8     dot11AuthMode;
+    A_UINT8     authMode;
+    A_UINT8     pairwiseCryptoType;
+    A_UINT8     pairwiseCryptoLen;
+    A_UINT8     groupCryptoType;
+    A_UINT8     groupCryptoLen;
+    A_UINT8     ssidLength;
+    A_UCHAR     ssid[WMI_MAX_SSID_LEN];
+    A_UINT16    channel;
+    A_UINT8     bssid[ATH_MAC_LEN];
+    A_UINT32    ctrl_flags;
+} POSTPACK WMI_CONNECT_CMD;
+
+/*
+ * WMI_RECONNECT_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT16    channel;                    /* hint */
+    A_UINT8     bssid[ATH_MAC_LEN];         /* mandatory if set */
+} POSTPACK WMI_RECONNECT_CMD;
+
+/*
+ * WMI_ADD_CIPHER_KEY_CMDID
+ */
+typedef enum {
+    PAIRWISE_USAGE      = 0x00,
+    GROUP_USAGE         = 0x01,
+    TX_USAGE            = 0x02,     /* default Tx Key - Static WEP only */
+} KEY_USAGE;
+
+/*
+ * Bit Flag
+ * Bit 0 - Initialise TSC - default is Initialize
+ */
+#define KEY_OP_INIT_TSC       0x01
+#define KEY_OP_INIT_RSC       0x02
+
+#define KEY_OP_INIT_VAL     0x03     /* Default Initialise the TSC & RSC */
+#define KEY_OP_VALID_MASK   0x03
+
+typedef PREPACK struct {
+    A_UINT8     keyIndex;
+    A_UINT8     keyType;
+    A_UINT8     keyUsage;           /* KEY_USAGE */
+    A_UINT8     keyLength;
+    A_UINT8     keyRSC[8];          /* key replay sequence counter */
+    A_UINT8     key[WMI_MAX_KEY_LEN];
+    A_UINT8     key_op_ctrl;       /* Additional Key Control information */
+} POSTPACK WMI_ADD_CIPHER_KEY_CMD;
+
+/*
+ * WMI_DELETE_CIPHER_KEY_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT8     keyIndex;
+} POSTPACK WMI_DELETE_CIPHER_KEY_CMD;
+
+#define WMI_KRK_LEN     16
+/*
+ * WMI_ADD_KRK_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT8     krk[WMI_KRK_LEN];
+} POSTPACK WMI_ADD_KRK_CMD;
+
+/*
+ * WMI_SET_TKIP_COUNTERMEASURES_CMDID
+ */
+typedef enum {
+    WMI_TKIP_CM_DISABLE = 0x0,
+    WMI_TKIP_CM_ENABLE  = 0x1,
+} WMI_TKIP_CM_CONTROL;
+
+typedef PREPACK struct {
+    A_UINT8  cm_en;                     /* WMI_TKIP_CM_CONTROL */
+} POSTPACK WMI_SET_TKIP_COUNTERMEASURES_CMD;
+
+/*
+ * WMI_SET_PMKID_CMDID
+ */
+
+#define WMI_PMKID_LEN 16
+
+typedef enum {
+   PMKID_DISABLE = 0,
+   PMKID_ENABLE  = 1,
+} PMKID_ENABLE_FLG;
+
+typedef PREPACK struct {
+    A_UINT8     bssid[ATH_MAC_LEN];
+    A_UINT8     enable;                 /* PMKID_ENABLE_FLG */
+    A_UINT8     pmkid[WMI_PMKID_LEN];
+} POSTPACK WMI_SET_PMKID_CMD;
+
+/*
+ * WMI_START_SCAN_CMD
+ */
+typedef enum {
+    WMI_LONG_SCAN  = 0,
+    WMI_SHORT_SCAN = 1,
+} WMI_SCAN_TYPE;
+
+typedef PREPACK struct {
+    A_BOOL   forceFgScan;
+    A_BOOL   isLegacy;        /* For Legacy Cisco AP compatibility */
+    A_UINT32 homeDwellTime;   /* Maximum duration in the home channel(milliseconds) */
+    A_UINT32 forceScanInterval;    /* Time interval between scans (milliseconds)*/
+    A_UINT8  scanType;           /* WMI_SCAN_TYPE */
+    A_UINT8  numChannels;            /* how many channels follow */
+    A_UINT16 channelList[1];         /* channels in Mhz */
+} POSTPACK WMI_START_SCAN_CMD;
+
+/*
+ * WMI_SET_SCAN_PARAMS_CMDID
+ */
+#define WMI_SHORTSCANRATIO_DEFAULT      3
+typedef enum {
+    CONNECT_SCAN_CTRL_FLAGS = 0x01,    /* set if can scan in the Connect cmd */
+    SCAN_CONNECTED_CTRL_FLAGS = 0x02,  /* set if scan for the SSID it is */
+                                       /* already connected to */
+    ACTIVE_SCAN_CTRL_FLAGS = 0x04,     /* set if enable active scan */
+    ROAM_SCAN_CTRL_FLAGS = 0x08,       /* set if enable roam scan when bmiss and lowrssi */
+    REPORT_BSSINFO_CTRL_FLAGS = 0x10,   /* set if follows customer BSSINFO reporting rule */
+    ENABLE_AUTO_CTRL_FLAGS = 0x20,      /* if disabled, target doesn't
+                                          scan after a disconnect event  */
+    ENABLE_SCAN_ABORT_EVENT = 0x40      /* Scan complete event with canceled status will be generated when a scan is prempted before it gets completed */
+
+} WMI_SCAN_CTRL_FLAGS_BITS;
+
+#define CAN_SCAN_IN_CONNECT(flags)      (flags & CONNECT_SCAN_CTRL_FLAGS)
+#define CAN_SCAN_CONNECTED(flags)       (flags & SCAN_CONNECTED_CTRL_FLAGS)
+#define ENABLE_ACTIVE_SCAN(flags)       (flags & ACTIVE_SCAN_CTRL_FLAGS)
+#define ENABLE_ROAM_SCAN(flags)         (flags & ROAM_SCAN_CTRL_FLAGS)
+#define CONFIG_REPORT_BSSINFO(flags)     (flags & REPORT_BSSINFO_CTRL_FLAGS)
+#define IS_AUTO_SCAN_ENABLED(flags)      (flags & ENABLE_AUTO_CTRL_FLAGS)
+#define SCAN_ABORT_EVENT_ENABLED(flags) (flags & ENABLE_SCAN_ABORT_EVENT)
+
+#define DEFAULT_SCAN_CTRL_FLAGS         (CONNECT_SCAN_CTRL_FLAGS| SCAN_CONNECTED_CTRL_FLAGS| ACTIVE_SCAN_CTRL_FLAGS| ROAM_SCAN_CTRL_FLAGS | ENABLE_AUTO_CTRL_FLAGS)
+
+
+/* for backwards compatibility with pre-2.1.x firmware */
+typedef PREPACK struct {
+    A_UINT16    fg_start_period;        /* seconds */
+    A_UINT16    fg_end_period;          /* seconds */
+    A_UINT16    bg_period;              /* seconds */
+    A_UINT16    maxact_chdwell_time;    /* msec */
+    A_UINT16    pas_chdwell_time;       /* msec */
+    A_UINT8     shortScanRatio;         /* how many shorts scan for one long */
+    A_UINT8     scanCtrlFlags;
+    A_UINT16    minact_chdwell_time;    /* msec */
+    A_UINT32    max_dfsch_act_time;     /* msecs */
+} POSTPACK WMI_SCAN_PARAMS_CMD_1;
+
+/* for version 2.1.x firmware */
+typedef PREPACK struct {
+    A_UINT16    fg_start_period;        /* seconds */
+    A_UINT16    fg_end_period;          /* seconds */
+    A_UINT16    bg_period;              /* seconds */
+    A_UINT16    maxact_chdwell_time;    /* msec */
+    A_UINT16    pas_chdwell_time;       /* msec */
+    A_UINT8     shortScanRatio;         /* how many shorts scan for one long */
+    A_UINT8     scanCtrlFlags;
+    A_UINT16    minact_chdwell_time;    /* msec */
+    A_UINT16    maxact_scan_per_ssid;   /* max active scans per ssid */
+    A_UINT32    max_dfsch_act_time;     /* msecs */
+} POSTPACK WMI_SCAN_PARAMS_CMD_2;
+
+#define WMI_SCAN_PARAMS_CMD WMI_SCAN_PARAMS_CMD_2
+
+/*
+ * WMI_SET_BSS_FILTER_CMDID
+ */
+typedef enum {
+    NONE_BSS_FILTER = 0x0,              /* no beacons forwarded */
+    ALL_BSS_FILTER,                     /* all beacons forwarded */
+    PROFILE_FILTER,                     /* only beacons matching profile */
+    ALL_BUT_PROFILE_FILTER,             /* all but beacons matching profile */
+    CURRENT_BSS_FILTER,                 /* only beacons matching current BSS */
+    ALL_BUT_BSS_FILTER,                 /* all but beacons matching BSS */
+    PROBED_SSID_FILTER,                 /* beacons matching probed ssid */
+    LAST_BSS_FILTER,                    /* marker only */
+} WMI_BSS_FILTER;
+
+/* for backwards compatibility with pre-2.1.x firmware */
+typedef PREPACK struct {
+    A_UINT8    bssFilter;                      /* see WMI_BSS_FILTER */
+    A_UINT32   ieMask;
+} POSTPACK WMI_BSS_FILTER_CMD_1;
+
+/* for version 2.1.x firmware */
+typedef PREPACK struct {
+    A_UINT8    bssFilter;                      /* see WMI_BSS_FILTER */
+    A_UINT8    reserved1;                      /* For alignment */
+    A_UINT16   reserved2;                      /* For alignment */
+    A_UINT32   ieMask;
+} POSTPACK WMI_BSS_FILTER_CMD_2;
+
+#define WMI_BSS_FILTER_CMD WMI_BSS_FILTER_CMD_2
+
+/*
+ * WMI_SET_PROBED_SSID_CMDID
+ */
+#define MAX_PROBED_SSID_INDEX   15
+
+typedef enum {
+    DISABLE_SSID_FLAG  = 0,                  /* disables entry */
+    SPECIFIC_SSID_FLAG = 0x01,               /* probes specified ssid */
+    ANY_SSID_FLAG      = 0x02,               /* probes for any ssid */
+} WMI_SSID_FLAG;
+
+typedef PREPACK struct {
+    A_UINT8     entryIndex;                     /* 0 to MAX_PROBED_SSID_INDEX */
+    A_UINT8     flag;                           /* WMI_SSID_FLG */
+    A_UINT8     ssidLength;
+    A_UINT8     ssid[32];
+} POSTPACK WMI_PROBED_SSID_CMD;
+
+/*
+ * WMI_SET_LISTEN_INT_CMDID
+ * The Listen interval is between 15 and 3000 TUs
+ */
+#define MIN_LISTEN_INTERVAL 15
+#define MAX_LISTEN_INTERVAL 5000
+#define MIN_LISTEN_BEACONS 1
+#define MAX_LISTEN_BEACONS 50
+
+typedef PREPACK struct {
+    A_UINT16     listenInterval;
+    A_UINT16     numBeacons;
+} POSTPACK WMI_LISTEN_INT_CMD;
+
+/*
+ * WMI_SET_BEACON_INT_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT16     beaconInterval;
+} POSTPACK WMI_BEACON_INT_CMD;
+
+/*
+ * WMI_SET_BMISS_TIME_CMDID
+ * valid values are between 1000 and 5000 TUs
+ */
+
+#define MIN_BMISS_TIME     1000
+#define MAX_BMISS_TIME     5000
+#define MIN_BMISS_BEACONS  1
+#define MAX_BMISS_BEACONS  50
+
+typedef PREPACK struct {
+    A_UINT16     bmissTime;
+    A_UINT16     numBeacons;
+} POSTPACK WMI_BMISS_TIME_CMD;
+
+/*
+ * WMI_SET_POWER_MODE_CMDID
+ */
+typedef enum {
+    REC_POWER = 0x01,
+    MAX_PERF_POWER,
+} WMI_POWER_MODE;
+
+typedef PREPACK struct {
+    A_UINT8     powerMode;      /* WMI_POWER_MODE */
+} POSTPACK WMI_POWER_MODE_CMD;
+
+/*
+ * WMI_SET_POWER_PARAMS_CMDID
+ */
+typedef enum {
+    IGNORE_DTIM = 0x01,
+    NORMAL_DTIM = 0x02,
+    STICK_DTIM  = 0x03,
+} WMI_DTIM_POLICY;
+
+typedef PREPACK struct {
+    A_UINT16    idle_period;             /* msec */
+    A_UINT16    pspoll_number;
+    A_UINT16    dtim_policy;
+} POSTPACK WMI_POWER_PARAMS_CMD;
+
+typedef PREPACK struct {
+    A_UINT8    power_saving;
+    A_UINT8    ttl; /* number of beacon periods */
+    A_UINT16   atim_windows;          /* msec */
+    A_UINT16   timeout_value;         /* msec */
+} POSTPACK WMI_IBSS_PM_CAPS_CMD;
+
+/*
+ * WMI_SET_POWERSAVE_TIMERS_POLICY_CMDID
+ */
+typedef enum {
+    IGNORE_TIM_ALL_QUEUES_APSD = 0,
+    PROCESS_TIM_ALL_QUEUES_APSD = 1,
+    IGNORE_TIM_SIMULATED_APSD = 2,
+    PROCESS_TIM_SIMULATED_APSD = 3,
+} APSD_TIM_POLICY;
+
+typedef PREPACK struct {
+    A_UINT16    psPollTimeout;          /* msec */
+    A_UINT16    triggerTimeout;         /* msec */
+    A_UINT32    apsdTimPolicy;      /* TIM behavior with  ques APSD enabled. Default is IGNORE_TIM_ALL_QUEUES_APSD */
+    A_UINT32    simulatedAPSDTimPolicy; /* TIM behavior with  simulated APSD enabled. Default is PROCESS_TIM_SIMULATED_APSD */
+} POSTPACK WMI_POWERSAVE_TIMERS_POLICY_CMD;
+
+/*
+ * WMI_SET_VOICE_PKT_SIZE_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT16    voicePktSize;
+} POSTPACK WMI_SET_VOICE_PKT_SIZE_CMD;
+
+/*
+ * WMI_SET_MAX_SP_LEN_CMDID
+ */
+typedef enum {
+    DELIVER_ALL_PKT = 0x0,
+    DELIVER_2_PKT = 0x1,
+    DELIVER_4_PKT = 0x2,
+    DELIVER_6_PKT = 0x3,
+} APSD_SP_LEN_TYPE;
+
+typedef PREPACK struct {
+    A_UINT8    maxSPLen;
+} POSTPACK WMI_SET_MAX_SP_LEN_CMD;
+
+/*
+ * WMI_SET_DISC_TIMEOUT_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT8     disconnectTimeout;          /* seconds */
+} POSTPACK WMI_DISC_TIMEOUT_CMD;
+
+typedef enum {
+    UPLINK_TRAFFIC = 0,
+    DNLINK_TRAFFIC = 1,
+    BIDIR_TRAFFIC = 2,
+} DIR_TYPE;
+
+typedef enum {
+    DISABLE_FOR_THIS_AC = 0,
+    ENABLE_FOR_THIS_AC  = 1,
+    ENABLE_FOR_ALL_AC   = 2,
+} VOICEPS_CAP_TYPE;
+
+typedef enum {
+    TRAFFIC_TYPE_APERIODIC = 0,
+    TRAFFIC_TYPE_PERIODIC = 1,
+}TRAFFIC_TYPE;
+
+/*
+ * WMI_SYNCHRONIZE_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT8 dataSyncMap;
+} POSTPACK WMI_SYNC_CMD;
+
+/*
+ * WMI_CREATE_PSTREAM_CMDID
+ */
+/* for backwards compatibility with pre-2.1.x firmware */
+typedef PREPACK struct {
+    A_UINT32        minServiceInt;           /* in milli-sec */
+    A_UINT32        maxServiceInt;           /* in milli-sec */
+    A_UINT32        inactivityInt;           /* in milli-sec */
+    A_UINT32        suspensionInt;           /* in milli-sec */
+    A_UINT32        serviceStartTime;
+    A_UINT32        minDataRate;             /* in bps */
+    A_UINT32        meanDataRate;            /* in bps */
+    A_UINT32        peakDataRate;            /* in bps */
+    A_UINT32        maxBurstSize;
+    A_UINT32        delayBound;
+    A_UINT32        minPhyRate;              /* in bps */
+    A_UINT32        sba;
+    A_UINT32        mediumTime;
+    A_UINT16        nominalMSDU;             /* in octects */
+    A_UINT16        maxMSDU;                 /* in octects */
+    A_UINT8         trafficClass;
+    A_UINT8         trafficType;             /* TRAFFIC_TYPE */
+    A_UINT8         trafficDirection;        /* TRAFFIC_DIR */
+    A_UINT8         voicePSCapability;       /* VOICEPS_CAP_TYPE */
+    A_UINT8         tsid;
+    A_UINT8         userPriority;            /* 802.1D user priority */
+} POSTPACK WMI_CREATE_PSTREAM_CMD_1;
+
+/* for version 2.1.x firmware */
+typedef PREPACK struct {
+    A_UINT32        minServiceInt;           /* in milli-sec */
+    A_UINT32        maxServiceInt;           /* in milli-sec */
+    A_UINT32        inactivityInt;           /* in milli-sec */
+    A_UINT32        suspensionInt;           /* in milli-sec */
+    A_UINT32        serviceStartTime;
+    A_UINT32        minDataRate;             /* in bps */
+    A_UINT32        meanDataRate;            /* in bps */
+    A_UINT32        peakDataRate;            /* in bps */
+    A_UINT32        maxBurstSize;
+    A_UINT32        delayBound;
+    A_UINT32        minPhyRate;              /* in bps */
+    A_UINT32        sba;
+    A_UINT32        mediumTime;
+    A_UINT16        nominalMSDU;             /* in octects */
+    A_UINT16        maxMSDU;                 /* in octects */
+    A_UINT8         trafficClass;
+    A_UINT8         trafficDirection;        /* DIR_TYPE */
+    A_UINT8         rxQueueNum;
+    A_UINT8         trafficType;             /* TRAFFIC_TYPE */
+    A_UINT8         voicePSCapability;       /* VOICEPS_CAP_TYPE */
+    A_UINT8         tsid;
+    A_UINT8         userPriority;            /* 802.1D user priority */
+} POSTPACK WMI_CREATE_PSTREAM_CMD_2;
+
+#define WMI_CREATE_PSTREAM_CMD WMI_CREATE_PSTREAM_CMD_2
+
+/*
+ * WMI_DELETE_PSTREAM_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT8     trafficClass;
+    A_UINT8     tsid;
+} POSTPACK WMI_DELETE_PSTREAM_CMD_1;
+
+typedef PREPACK struct {
+    A_UINT8     txQueueNumber;
+    A_UINT8     rxQueueNumber;
+    A_UINT8     trafficDirection;
+    A_UINT8     trafficClass;
+    A_UINT8     tsid;
+} POSTPACK WMI_DELETE_PSTREAM_CMD_2;
+
+#define WMI_DELETE_PSTREAM_CMD WMI_DELETE_PSTREAM_CMD_2
+
+/*
+ * WMI_SET_CHANNEL_PARAMS_CMDID
+ */
+typedef enum {
+    WMI_11A_MODE  = 0x1,
+    WMI_11G_MODE  = 0x2,
+    WMI_11AG_MODE = 0x3,
+    WMI_11B_MODE  = 0x4,
+    WMI_11GONLY_MODE = 0x5,
+} WMI_PHY_MODE;
+
+#define WMI_MAX_CHANNELS        32
+
+typedef PREPACK struct {
+    A_UINT8     reserved1;
+    A_UINT8     scanParam;              /* set if enable scan */
+    A_UINT8     phyMode;                /* see WMI_PHY_MODE */
+    A_UINT8     numChannels;            /* how many channels follow */
+    A_UINT16    channelList[1];         /* channels in Mhz */
+} POSTPACK WMI_CHANNEL_PARAMS_CMD;
+
+
+/*
+ *  WMI_RSSI_THRESHOLD_PARAMS_CMDID
+ *  Setting the polltime to 0 would disable polling.
+ *  Threshold values are in the ascending order, and should agree to:
+ *  (lowThreshold_lowerVal < lowThreshold_upperVal < highThreshold_lowerVal
+ *      < highThreshold_upperVal)
+ */
+
+typedef PREPACK struct WMI_RSSI_THRESHOLD_PARAMS{
+    A_UINT32    pollTime;               /* Polling time as a factor of LI */
+    A_INT16     thresholdAbove1_Val;          /* lowest of upper */
+    A_INT16     thresholdAbove2_Val;
+    A_INT16     thresholdAbove3_Val;
+    A_INT16     thresholdAbove4_Val;
+    A_INT16     thresholdAbove5_Val;
+    A_INT16     thresholdAbove6_Val;          /* highest of upper */
+    A_INT16     thresholdBelow1_Val;         /* lowest of bellow */
+    A_INT16     thresholdBelow2_Val;
+    A_INT16     thresholdBelow3_Val;
+    A_INT16     thresholdBelow4_Val;
+    A_INT16     thresholdBelow5_Val;
+    A_INT16     thresholdBelow6_Val;         /* highest of bellow */
+    A_UINT8     weight;                  /* "alpha" */
+    A_UINT8     reserved[3];
+} POSTPACK  WMI_RSSI_THRESHOLD_PARAMS_CMD;
+
+/*
+ *  WMI_SNR_THRESHOLD_PARAMS_CMDID
+ *  Setting the polltime to 0 would disable polling.
+ */
+
+typedef PREPACK struct WMI_SNR_THRESHOLD_PARAMS{
+    A_UINT32    pollTime;               /* Polling time as a factor of LI */
+    A_UINT8     weight;                  /* "alpha" */
+    A_UINT8     thresholdAbove1_Val;      /* lowest of uppper*/
+    A_UINT8     thresholdAbove2_Val;
+    A_UINT8     thresholdAbove3_Val;
+    A_UINT8     thresholdAbove4_Val;      /* highest of upper */
+    A_UINT8     thresholdBelow1_Val;     /* lowest of bellow */
+    A_UINT8     thresholdBelow2_Val;
+    A_UINT8     thresholdBelow3_Val;
+    A_UINT8     thresholdBelow4_Val;     /* highest of bellow */
+    A_UINT8     reserved[3];
+} POSTPACK WMI_SNR_THRESHOLD_PARAMS_CMD;
+
+/*
+ *  WMI_LQ_THRESHOLD_PARAMS_CMDID
+ */
+typedef PREPACK struct WMI_LQ_THRESHOLD_PARAMS {
+    A_UINT8     enable;
+    A_UINT8     thresholdAbove1_Val;
+    A_UINT8     thresholdAbove2_Val;
+    A_UINT8     thresholdAbove3_Val;
+    A_UINT8     thresholdAbove4_Val;
+    A_UINT8     thresholdBelow1_Val;
+    A_UINT8     thresholdBelow2_Val;
+    A_UINT8     thresholdBelow3_Val;
+    A_UINT8     thresholdBelow4_Val;
+    A_UINT8     reserved[3];
+} POSTPACK  WMI_LQ_THRESHOLD_PARAMS_CMD;
+
+typedef enum {
+    WMI_LPREAMBLE_DISABLED = 0,
+    WMI_LPREAMBLE_ENABLED
+} WMI_LPREAMBLE_STATUS;
+
+typedef PREPACK struct {
+    A_UINT8     status;
+}POSTPACK WMI_SET_LPREAMBLE_CMD;
+
+typedef PREPACK struct {
+    A_UINT16    threshold;
+}POSTPACK WMI_SET_RTS_CMD;
+
+/*
+ *  WMI_TARGET_ERROR_REPORT_BITMASK_CMDID
+ *  Sets the error reporting event bitmask in target. Target clears it
+ *  upon an error. Subsequent errors are counted, but not reported
+ *  via event, unless the bitmask is set again.
+ */
+typedef PREPACK struct {
+    A_UINT32    bitmask;
+} POSTPACK  WMI_TARGET_ERROR_REPORT_BITMASK;
+
+/*
+ * WMI_SET_TX_PWR_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT8     dbM;                  /* in dbM units */
+} POSTPACK WMI_SET_TX_PWR_CMD, WMI_TX_PWR_REPLY;
+
+/*
+ * WMI_SET_ASSOC_INFO_CMDID
+ *
+ * A maximum of 2 private IEs can be sent in the [Re]Assoc request.
+ * A 3rd one, the CCX version IE can also be set from the host.
+ */
+#define WMI_MAX_ASSOC_INFO_TYPE    2
+#define WMI_CCX_VER_IE             2 /* ieType to set CCX Version IE */
+
+#define WMI_MAX_ASSOC_INFO_LEN     240
+
+typedef PREPACK struct {
+    A_UINT8     ieType;
+    A_UINT8     bufferSize;
+    A_UINT8     assocInfo[1];       /* up to WMI_MAX_ASSOC_INFO_LEN */
+} POSTPACK WMI_SET_ASSOC_INFO_CMD;
+
+
+/*
+ * WMI_GET_TX_PWR_CMDID does not take any parameters
+ */
+
+/*
+ * WMI_ADD_BAD_AP_CMDID
+ */
+#define WMI_MAX_BAD_AP_INDEX      1
+
+typedef PREPACK struct {
+    A_UINT8     badApIndex;         /* 0 to WMI_MAX_BAD_AP_INDEX */
+    A_UINT8     bssid[ATH_MAC_LEN];
+} POSTPACK WMI_ADD_BAD_AP_CMD;
+
+/*
+ * WMI_DELETE_BAD_AP_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT8     badApIndex;         /* 0 to WMI_MAX_BAD_AP_INDEX */
+} POSTPACK WMI_DELETE_BAD_AP_CMD;
+
+/*
+ * WMI_SET_ACCESS_PARAMS_CMDID
+ */
+#define WMI_DEFAULT_TXOP_ACPARAM    0       /* implies one MSDU */
+#define WMI_DEFAULT_ECWMIN_ACPARAM  4       /* corresponds to CWmin of 15 */
+#define WMI_DEFAULT_ECWMAX_ACPARAM  10      /* corresponds to CWmax of 1023 */
+#define WMI_MAX_CW_ACPARAM          15      /* maximum eCWmin or eCWmax */
+#define WMI_DEFAULT_AIFSN_ACPARAM   2
+#define WMI_MAX_AIFSN_ACPARAM       15
+typedef PREPACK struct {
+    A_UINT16 txop;                      /* in units of 32 usec */
+    A_UINT8  eCWmin;
+    A_UINT8  eCWmax;
+    A_UINT8  aifsn;
+} POSTPACK WMI_SET_ACCESS_PARAMS_CMD;
+
+
+/*
+ * WMI_SET_RETRY_LIMITS_CMDID
+ *
+ * This command is used to customize the number of retries the
+ * wlan device will perform on a given frame.
+ */
+#define WMI_MIN_RETRIES 2
+#define WMI_MAX_RETRIES 13
+typedef enum {
+    MGMT_FRAMETYPE    = 0,
+    CONTROL_FRAMETYPE = 1,
+    DATA_FRAMETYPE    = 2
+} WMI_FRAMETYPE;
+
+typedef PREPACK struct {
+    A_UINT8 frameType;                      /* WMI_FRAMETYPE */
+    A_UINT8 trafficClass;                   /* applies only to DATA_FRAMETYPE */
+    A_UINT8 maxRetries;
+    A_UINT8 enableNotify;
+} POSTPACK WMI_SET_RETRY_LIMITS_CMD;
+
+/*
+ * WMI_SET_ROAM_CTRL_CMDID
+ *
+ * This command is used to influence the Roaming behaviour
+ * Set the host biases of the BSSs before setting the roam mode as bias
+ * based.
+ */
+
+/*
+ * Different types of Roam Control
+ */
+
+typedef enum {
+        WMI_FORCE_ROAM          = 1,      /* Roam to the specified BSSID */
+        WMI_SET_ROAM_MODE       = 2,      /* default ,progd bias, no roam */
+        WMI_SET_HOST_BIAS       = 3,     /* Set the Host Bias */
+        WMI_SET_LOWRSSI_SCAN_PARAMS = 4, /* Set lowrssi Scan parameters */
+} WMI_ROAM_CTRL_TYPE;
+
+#define WMI_MIN_ROAM_CTRL_TYPE WMI_FORCE_ROAM
+#define WMI_MAX_ROAM_CTRL_TYPE WMI_SET_LOWRSSI_SCAN_PARAMS
+
+/*
+ * ROAM MODES
+ */
+
+typedef enum {
+        WMI_DEFAULT_ROAM_MODE   = 1,  /* RSSI based ROAM */
+        WMI_HOST_BIAS_ROAM_MODE = 2, /* HOST BIAS based ROAM */
+        WMI_LOCK_BSS_MODE  = 3  /* Lock to the Current BSS - no Roam */
+} WMI_ROAM_MODE;
+
+/*
+ * BSS HOST BIAS INFO
+ */
+
+typedef PREPACK struct {
+        A_UINT8 bssid[ATH_MAC_LEN];
+        A_INT8  bias;
+} POSTPACK WMI_BSS_BIAS;
+
+typedef PREPACK struct {
+        A_UINT8 numBss;
+        WMI_BSS_BIAS bssBias[1];
+} POSTPACK WMI_BSS_BIAS_INFO;
+
+typedef PREPACK struct WMI_LOWRSSI_SCAN_PARAMS {
+        A_UINT16 lowrssi_scan_period;
+        A_INT16  lowrssi_scan_threshold;
+        A_INT16  lowrssi_roam_threshold;
+        A_UINT8  roam_rssi_floor;
+        A_UINT8  reserved[1];              /* For alignment */
+} POSTPACK WMI_LOWRSSI_SCAN_PARAMS;
+
+typedef PREPACK struct {
+    PREPACK union {
+        A_UINT8 bssid[ATH_MAC_LEN]; /* WMI_FORCE_ROAM */
+        A_UINT8 roamMode;           /* WMI_SET_ROAM_MODE  */
+        WMI_BSS_BIAS_INFO bssBiasInfo; /* WMI_SET_HOST_BIAS */
+        WMI_LOWRSSI_SCAN_PARAMS lrScanParams;
+    } POSTPACK info;
+    A_UINT8   roamCtrlType ;
+} POSTPACK WMI_SET_ROAM_CTRL_CMD;
+
+/*
+ * WMI_ENABLE_RM_CMDID
+ */
+typedef PREPACK struct {
+        A_BOOL enable_radio_measurements;
+} POSTPACK WMI_ENABLE_RM_CMD;
+
+/*
+ * WMI_SET_MAX_OFFHOME_DURATION_CMDID
+ */
+typedef PREPACK struct {
+        A_UINT8 max_offhome_duration;
+} POSTPACK WMI_SET_MAX_OFFHOME_DURATION_CMD;
+
+typedef PREPACK struct {
+    A_UINT32 frequency;
+    A_UINT8  threshold;
+} POSTPACK WMI_SET_HB_CHALLENGE_RESP_PARAMS_CMD;
+
+typedef enum {
+    BT_STREAM_UNDEF = 0,
+    BT_STREAM_SCO,             /* SCO stream */
+    BT_STREAM_A2DP,            /* A2DP stream */
+    BT_STREAM_SCAN,            /* BT Discovery or Page */
+    BT_STREAM_ESCO,
+    BT_STREAM_MAX
+} BT_STREAM_TYPE;
+
+typedef enum {
+    BT_PARAM_SCO = 1,         /* SCO stream parameters */
+    BT_PARAM_A2DP ,
+    BT_PARAM_ANTENNA_CONFIG,
+    BT_PARAM_COLOCATED_BT_DEVICE,
+    BT_PARAM_ACLCOEX,
+    BT_PARAM_11A_SEPARATE_ANT,
+    BT_PARAM_MAX
+} BT_PARAM_TYPE;
+
+typedef enum {
+    BT_PARAM_SCO_PSPOLL_LATENCY_ONE_FOURTH =1,
+    BT_PARAM_SCO_PSPOLL_LATENCY_HALF,
+    BT_PARAM_SCO_PSPOLL_LATENCY_THREE_FOURTH,
+} BT_PARAMS_SCO_PSPOLL_LATENCY;
+
+typedef enum {
+    BT_PARAMS_SCO_STOMP_SCO_NEVER =1,
+    BT_PARAMS_SCO_STOMP_SCO_ALWAYS,
+    BT_PARAMS_SCO_STOMP_SCO_IN_LOWRSSI,
+} BT_PARAMS_SCO_STOMP_RULES;
+
+typedef enum {
+    BT_STATUS_UNDEF = 0,
+    BT_STATUS_START,
+    BT_STATUS_STOP,
+    BT_STATUS_RESUME,
+    BT_STATUS_SUSPEND,
+    BT_STATUS_MAX
+} BT_STREAM_STATUS;
+
+typedef PREPACK struct {
+    A_UINT8 streamType;
+    A_UINT8 status;
+} POSTPACK WMI_SET_BT_STATUS_CMD;
+
+typedef enum {
+    BT_ANT_TYPE_UNDEF=0,
+    BT_ANT_TYPE_DUAL,
+    BT_ANT_TYPE_SPLITTER,
+    BT_ANT_TYPE_SWITCH
+} BT_ANT_FRONTEND_CONFIG;
+
+typedef enum {
+    BT_COLOCATED_DEV_BTS4020=0,
+    BT_COLCATED_DEV_CSR ,
+    BT_COLOCATED_DEV_VALKYRIE
+} BT_COLOCATED_DEV_TYPE;
+
+typedef PREPACK struct {
+    A_UINT32 numScoCyclesForceTrigger;  /* Number SCO cycles after which
+                                           force a pspoll. default = 10 */
+    A_UINT32 dataResponseTimeout;       /* Timeout Waiting for Downlink pkt
+                                           in response for ps-poll,
+                                           default = 10 msecs */
+    A_UINT32  stompScoRules;
+    A_UINT8 stompDutyCyleVal;           /* Sco cycles to limit ps-poll queuing
+                                           if stomped */
+    A_UINT8 psPollLatencyFraction;      /* Fraction of idle
+                                           period, within which
+                                           additional ps-polls
+                                           can be queued */
+    A_UINT8 noSCOSlots;                 /* Number of SCO Tx/Rx slots.
+                                           HVx, EV3, 2EV3 = 2 */
+    A_UINT8 noIdleSlots;                /* Number of Bluetooth idle slots between
+                                           consecutive SCO Tx/Rx slots
+                                           HVx, EV3 = 4
+                                           2EV3 = 10 */
+} POSTPACK BT_PARAMS_SCO;
+
+typedef PREPACK struct {
+    A_UINT32 a2dpWlanUsageLimit; /* MAX time firmware uses the medium for
+                                    wlan, after it identifies the idle time
+                                    default (30 msecs) */
+    A_UINT32 a2dpBurstCntMin;   /* Minimum number of bluetooth data frames
+                                   to replenish Wlan Usage  limit (default 3) */
+    A_UINT32 a2dpDataRespTimeout;
+    A_UINT32 isCoLocatedBtRoleMaster;
+}POSTPACK BT_PARAMS_A2DP;
+
+/* During BT ftp/ BT OPP or any another data based acl profile on bluetooth
+   (non a2dp).*/
+typedef PREPACK struct {
+    A_UINT32 aclWlanMediumUsageTime;  /* Wlan usage time during Acl (non-a2dp)
+                                       coexistence (default 30 msecs) */
+    A_UINT32 aclBtMediumUsageTime;   /* Bt usage time during acl coexistence
+                                       (default 30 msecs)*/
+    A_UINT32 aclDataRespTimeout;
+}POSTPACK BT_PARAMS_ACLCOEX;
+
+typedef PREPACK struct {
+    PREPACK union {
+        BT_PARAMS_SCO scoParams;
+        BT_PARAMS_A2DP a2dpParams;
+        BT_PARAMS_ACLCOEX  aclCoexParams;
+        A_UINT8 antType;         /* 0 -Disabled (default)
+                                     1 - BT_ANT_TYPE_DUAL
+                                     2 - BT_ANT_TYPE_SPLITTER
+                                     3 - BT_ANT_TYPE_SWITCH */
+        A_UINT8 coLocatedBtDev;  /* 0 - BT_COLOCATED_DEV_BTS4020 (default)
+                                     1 - BT_COLCATED_DEV_CSR
+                                     2 - BT_COLOCATED_DEV_VALKYRIe
+                                   */
+    } POSTPACK info;
+    A_UINT8 paramType ;
+} POSTPACK WMI_SET_BT_PARAMS_CMD;
+
+typedef enum {
+    DISCONN_EVT_IN_RECONN = 0,  /* default */
+    NO_DISCONN_EVT_IN_RECONN
+} TARGET_EVENT_REPORT_CONFIG;
+
+typedef PREPACK struct {
+    A_UINT32 evtConfig;
+} POSTPACK WMI_SET_TARGET_EVENT_REPORT_CMD;
+
+#define MAC_MAX_FILTERS_PER_LIST 4
+
+typedef PREPACK struct {
+    A_UINT8 multicast_mac[ATH_MAC_LEN];      /* WMI_SET_MCAST_FILTER */
+} POSTPACK WMI_SET_MCAST_FILTER_CMD;
+
+typedef PREPACK struct {
+    A_UINT8 valid_filter;
+    A_UINT8 mac_addr[ATH_MAC_LEN];
+} POSTPACK MAC_FILTER;
+
+typedef PREPACK struct {
+    A_UINT8 total_list_size;
+    MAC_FILTER list[MAC_MAX_FILTERS_PER_LIST];
+} POSTPACK MAC_FILTER_LIST;
+
+
+/*
+ * Command Replies
+ */
+
+/*
+ * WMI_GET_CHANNEL_LIST_CMDID reply
+ */
+typedef PREPACK struct {
+    A_UINT8     reserved1;
+    A_UINT8     numChannels;            /* number of channels in reply */
+    A_UINT16    channelList[1];         /* channel in Mhz */
+} POSTPACK WMI_CHANNEL_LIST_REPLY;
+
+typedef enum {
+    A_SUCCEEDED = A_OK,
+    A_FAILED_DELETE_STREAM_DOESNOT_EXIST=250,
+    A_SUCCEEDED_MODIFY_STREAM=251,
+    A_FAILED_INVALID_STREAM = 252,
+    A_FAILED_MAX_THINSTREAMS = 253,
+    A_FAILED_CREATE_REMOVE_PSTREAM_FIRST = 254,
+} PSTREAM_REPLY_STATUS;
+
+typedef PREPACK struct {
+    A_UINT8     status;                 /* PSTREAM_REPLY_STATUS */
+    A_UINT8     txQueueNumber;
+    A_UINT8     rxQueueNumber;
+    A_UINT8     trafficClass;
+    A_UINT8     trafficDirection;       /* DIR_TYPE */
+} POSTPACK WMI_CRE_PRIORITY_STREAM_REPLY;
+
+typedef PREPACK struct {
+    A_UINT8     status;                 /* PSTREAM_REPLY_STATUS */
+    A_UINT8     txQueueNumber;
+    A_UINT8     rxQueueNumber;
+    A_UINT8     trafficDirection;       /* DIR_TYPE */
+    A_UINT8     trafficClass;
+} POSTPACK WMI_DEL_PRIORITY_STREAM_REPLY;
+
+/*
+ * List of Events (target to host)
+ */
+typedef enum {
+    WMI_READY_EVENTID           = 0x1001,
+    WMI_CONNECT_EVENTID,
+    WMI_DISCONNECT_EVENTID,
+    WMI_BSSINFO_EVENTID,
+    WMI_CMDERROR_EVENTID,
+    WMI_REGDOMAIN_EVENTID,
+    WMI_PSTREAM_TIMEOUT_EVENTID,
+    WMI_NEIGHBOR_REPORT_EVENTID,
+    WMI_TKIP_MICERR_EVENTID,
+    WMI_SCAN_COMPLETE_EVENTID,           /* 0x100a */
+    WMI_REPORT_STATISTICS_EVENTID,
+    WMI_RSSI_THRESHOLD_EVENTID,
+    WMI_ERROR_REPORT_EVENTID,
+    WMI_OPT_RX_FRAME_EVENTID,
+    WMI_REPORT_ROAM_TBL_EVENTID,
+    WMI_EXTENSION_EVENTID,
+    WMI_CAC_EVENTID,
+    WMI_SNR_THRESHOLD_EVENTID,
+    WMI_LQ_THRESHOLD_EVENTID,
+    WMI_TX_RETRY_ERR_EVENTID,            /* 0x1014 */
+    WMI_REPORT_ROAM_DATA_EVENTID,
+    WMI_TEST_EVENTID,
+    WMI_APLIST_EVENTID,
+    WMI_GET_WOW_LIST_EVENTID,
+    WMI_GET_PMKID_LIST_EVENTID,
+    WMI_CHANNEL_CHANGE_EVENTID
+} WMI_EVENT_ID;
+
+typedef enum {
+    WMI_11A_CAPABILITY   = 1,
+    WMI_11G_CAPABILITY   = 2,
+    WMI_11AG_CAPABILITY  = 3,
+} WMI_PHY_CAPABILITY;
+
+/* for backwards compatibility with pre-2.1.x firmware */
+typedef PREPACK struct {
+    A_UINT8     macaddr[ATH_MAC_LEN];
+    A_UINT8     phyCapability;              /* WMI_PHY_CAPABILITY */
+} POSTPACK WMI_READY_EVENT_1;
+
+/* for version 2.1.x firmware */
+typedef PREPACK struct {
+    A_UINT32    version;
+    A_UINT8     macaddr[ATH_MAC_LEN];
+    A_UINT8     phyCapability;              /* WMI_PHY_CAPABILITY */
+} POSTPACK WMI_READY_EVENT_2;
+
+#if defined(ATH_TARGET)
+#define WMI_READY_EVENT WMI_READY_EVENT_1  /* AR6002_REV2 target code */
+#else
+#define WMI_READY_EVENT WMI_READY_EVENT_2 /* host code */
+#endif
+
+
+/*
+ * Connect Event
+ */
+typedef PREPACK struct {
+    A_UINT16    channel;
+    A_UINT8     bssid[ATH_MAC_LEN];
+    A_UINT16    listenInterval;
+    A_UINT16    beaconInterval;
+    A_UINT32    networkType;
+    A_UINT8     beaconIeLen;
+    A_UINT8     assocReqLen;
+    A_UINT8     assocRespLen;
+    A_UINT8     assocInfo[1];
+} POSTPACK WMI_CONNECT_EVENT;
+
+/*
+ * Disconnect Event
+ */
+typedef enum {
+    NO_NETWORK_AVAIL   = 0x01,
+    LOST_LINK          = 0x02,     /* bmiss */
+    DISCONNECT_CMD     = 0x03,
+    BSS_DISCONNECTED   = 0x04,
+    AUTH_FAILED        = 0x05,
+    ASSOC_FAILED       = 0x06,
+    NO_RESOURCES_AVAIL = 0x07,
+    CSERV_DISCONNECT   = 0x08,
+    INVALID_PROFILE    = 0x0a,
+    DOT11H_CHANNEL_SWITCH = 0x0b,
+    PROFILE_MISMATCH   = 0x0c,
+} WMI_DISCONNECT_REASON;
+
+typedef PREPACK struct {
+    A_UINT16    protocolReasonStatus;  /* reason code, see 802.11 spec. */
+    A_UINT8     bssid[ATH_MAC_LEN];    /* set if known */
+    A_UINT8     disconnectReason ;      /* see WMI_DISCONNECT_REASON */
+    A_UINT8     assocRespLen;
+    A_UINT8     assocInfo[1];
+} POSTPACK WMI_DISCONNECT_EVENT;
+
+/*
+ * BSS Info Event.
+ * Mechanism used to inform host of the presence and characteristic of
+ * wireless networks present.  Consists of bss info header followed by
+ * the beacon or probe-response frame body.  The 802.11 header is not included.
+ */
+typedef enum {
+    BEACON_FTYPE = 0x1,
+    PROBERESP_FTYPE,
+    ACTION_MGMT_FTYPE,
+} WMI_BI_FTYPE;
+
+enum {
+    BSS_ELEMID_CHANSWITCH = 0x01,
+    BSS_ELEMID_ATHEROS = 0x02,
+};
+
+typedef PREPACK struct {
+    A_UINT16    channel;
+    A_UINT8     frameType;          /* see WMI_BI_FTYPE */
+    A_UINT8     snr;
+    A_INT16     rssi;
+    A_UINT8     bssid[ATH_MAC_LEN];
+    A_UINT32    ieMask;
+} POSTPACK WMI_BSS_INFO_HDR;
+
+/*
+ * Command Error Event
+ */
+typedef enum {
+    INVALID_PARAM  = 0x01,
+    ILLEGAL_STATE  = 0x02,
+    INTERNAL_ERROR = 0x03,
+} WMI_ERROR_CODE;
+
+typedef PREPACK struct {
+    A_UINT16    commandId;
+    A_UINT8     errorCode;
+} POSTPACK WMI_CMD_ERROR_EVENT;
+
+/*
+ * New Regulatory Domain Event
+ */
+typedef PREPACK struct {
+    A_UINT32    regDomain;
+} POSTPACK WMI_REG_DOMAIN_EVENT;
+
+/* for backwards compatibility with pre-2.1.x firmware */
+typedef PREPACK struct {
+    A_UINT8     trafficClass;
+} POSTPACK WMI_PSTREAM_TIMEOUT_EVENT_1;
+
+/* for version 2.1.x firmware */
+typedef PREPACK struct {
+    A_UINT8     txQueueNumber;
+    A_UINT8     rxQueueNumber;
+    A_UINT8     trafficDirection;
+    A_UINT8     trafficClass;
+} POSTPACK WMI_PSTREAM_TIMEOUT_EVENT_2;
+
+#define WMI_PSTREAM_TIMEOUT_EVENT WMI_PSTREAM_TIMEOUT_EVENT_2
+
+/*
+ * The WMI_NEIGHBOR_REPORT Event is generated by the target to inform
+ * the host of BSS's it has found that matches the current profile.
+ * It can be used by the host to cache PMKs and/to initiate pre-authentication
+ * if the BSS supports it.  The first bssid is always the current associated
+ * BSS.
+ * The bssid and bssFlags information repeats according to the number
+ * or APs reported.
+ */
+typedef enum {
+    WMI_DEFAULT_BSS_FLAGS   = 0x00,
+    WMI_PREAUTH_CAPABLE_BSS = 0x01,
+    WMI_PMKID_VALID_BSS     = 0x02,
+} WMI_BSS_FLAGS;
+
+typedef PREPACK struct {
+    A_UINT8     bssid[ATH_MAC_LEN];
+    A_UINT8     bssFlags;            /* see WMI_BSS_FLAGS */
+} POSTPACK WMI_NEIGHBOR_INFO;
+
+typedef PREPACK struct {
+    A_INT8      numberOfAps;
+    WMI_NEIGHBOR_INFO neighbor[1];
+} POSTPACK WMI_NEIGHBOR_REPORT_EVENT;
+
+/*
+ * TKIP MIC Error Event
+ */
+typedef PREPACK struct {
+    A_UINT8 keyid;
+    A_UINT8 ismcast;
+} POSTPACK WMI_TKIP_MICERR_EVENT;
+
+/*
+ * WMI_SCAN_COMPLETE_EVENTID - no parameters (old), staus parameter (new)
+ */
+typedef PREPACK struct {
+    A_INT32 status;
+} POSTPACK WMI_SCAN_COMPLETE_EVENT;
+
+#define MAX_OPT_DATA_LEN 1400
+
+/*
+ * WMI_SET_ADHOC_BSSID_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT8     bssid[ATH_MAC_LEN];
+} POSTPACK WMI_SET_ADHOC_BSSID_CMD;
+
+/*
+ * WMI_SET_OPT_MODE_CMDID
+ */
+typedef enum {
+    SPECIAL_OFF,
+    SPECIAL_ON,
+} OPT_MODE_TYPE;
+
+typedef PREPACK struct {
+    A_UINT8     optMode;
+} POSTPACK WMI_SET_OPT_MODE_CMD;
+
+/*
+ * WMI_TX_OPT_FRAME_CMDID
+ */
+typedef enum {
+    OPT_PROBE_REQ   = 0x01,
+    OPT_PROBE_RESP  = 0x02,
+    OPT_CPPP_START  = 0x03,
+    OPT_CPPP_STOP   = 0x04,
+} WMI_OPT_FTYPE;
+
+typedef PREPACK struct {
+    A_UINT16    optIEDataLen;
+    A_UINT8     frmType;
+    A_UINT8     dstAddr[ATH_MAC_LEN];
+    A_UINT8     bssid[ATH_MAC_LEN];
+    A_UINT8     reserved;               /* For alignment */
+    A_UINT8     optIEData[1];
+} POSTPACK WMI_OPT_TX_FRAME_CMD;
+
+/*
+ * Special frame receive Event.
+ * Mechanism used to inform host of the receiption of the special frames.
+ * Consists of special frame info header followed by special frame body.
+ * The 802.11 header is not included.
+ */
+typedef PREPACK struct {
+    A_UINT16    channel;
+    A_UINT8     frameType;          /* see WMI_OPT_FTYPE */
+    A_INT8      snr;
+    A_UINT8     srcAddr[ATH_MAC_LEN];
+    A_UINT8     bssid[ATH_MAC_LEN];
+} POSTPACK WMI_OPT_RX_INFO_HDR;
+
+/*
+ * Reporting statistics.
+ */
+/* for backwards compatibility with pre-2.1.x firmware */
+typedef PREPACK struct {
+    A_UINT32   tx_packets;
+    A_UINT32   tx_bytes;
+    A_UINT32   tx_unicast_pkts;
+    A_UINT32   tx_unicast_bytes;
+    A_UINT32   tx_multicast_pkts;
+    A_UINT32   tx_multicast_bytes;
+    A_UINT32   tx_broadcast_pkts;
+    A_UINT32   tx_broadcast_bytes;
+    A_UINT32   tx_rts_success_cnt;
+    A_UINT32   tx_packet_per_ac[4];
+    A_UINT32   tx_errors_per_ac[4];
+
+    A_UINT32   tx_errors;
+    A_UINT32   tx_failed_cnt;
+    A_UINT32   tx_retry_cnt;
+    A_UINT32   tx_rts_fail_cnt;
+    A_INT32    tx_unicast_rate;
+}POSTPACK tx_stats_1_t;
+
+/* for version 2.1.x firmware */
+typedef PREPACK struct {
+    A_UINT32   tx_packets;
+    A_UINT32   tx_bytes;
+    A_UINT32   tx_unicast_pkts;
+    A_UINT32   tx_unicast_bytes;
+    A_UINT32   tx_multicast_pkts;
+    A_UINT32   tx_multicast_bytes;
+    A_UINT32   tx_broadcast_pkts;
+    A_UINT32   tx_broadcast_bytes;
+    A_UINT32   tx_rts_success_cnt;
+    A_UINT32   tx_packet_per_ac[4];
+    A_UINT32   tx_errors_per_ac[4];
+
+    A_UINT32   tx_errors;
+    A_UINT32   tx_failed_cnt;
+    A_UINT32   tx_retry_cnt;
+    A_UINT32   tx_mult_retry_cnt;
+    A_UINT32   tx_rts_fail_cnt;
+    A_INT32    tx_unicast_rate;
+}POSTPACK tx_stats_2_t;
+
+#define tx_stats_t tx_stats_2_t
+
+typedef PREPACK struct {
+    A_UINT32   rx_packets;
+    A_UINT32   rx_bytes;
+    A_UINT32   rx_unicast_pkts;
+    A_UINT32   rx_unicast_bytes;
+    A_UINT32   rx_multicast_pkts;
+    A_UINT32   rx_multicast_bytes;
+    A_UINT32   rx_broadcast_pkts;
+    A_UINT32   rx_broadcast_bytes;
+    A_UINT32   rx_fragment_pkt;
+
+    A_UINT32   rx_errors;
+    A_UINT32   rx_crcerr;
+    A_UINT32   rx_key_cache_miss;
+    A_UINT32   rx_decrypt_err;
+    A_UINT32   rx_duplicate_frames;
+    A_INT32    rx_unicast_rate;
+}POSTPACK rx_stats_t;
+
+typedef PREPACK struct {
+    A_UINT32   tkip_local_mic_failure;
+    A_UINT32   tkip_counter_measures_invoked;
+    A_UINT32   tkip_replays;
+    A_UINT32   tkip_format_errors;
+    A_UINT32   ccmp_format_errors;
+    A_UINT32   ccmp_replays;
+}POSTPACK tkip_ccmp_stats_t;
+
+typedef PREPACK struct {
+    A_UINT32   power_save_failure_cnt;
+}POSTPACK pm_stats_t;
+
+typedef PREPACK struct {
+    A_UINT32    cs_bmiss_cnt;
+    A_UINT32    cs_lowRssi_cnt;
+    A_UINT16    cs_connect_cnt;
+    A_UINT16    cs_disconnect_cnt;
+    A_INT16     cs_aveBeacon_rssi;
+    A_UINT16    cs_roam_count;
+    A_INT16     cs_rssi;
+    A_UINT8     cs_snr;
+    A_UINT8     cs_aveBeacon_snr;
+    A_UINT8     cs_lastRoam_msec;
+} POSTPACK cserv_stats_t;
+
+/* for backwards compatibility with pre-2.1.x firmware */
+typedef PREPACK struct {
+    tx_stats_1_t        tx_stats;
+    rx_stats_t          rx_stats;
+    tkip_ccmp_stats_t   tkipCcmpStats;
+}POSTPACK wlan_net_stats_1_t;
+
+/* for version 2.1.x firmware */
+typedef PREPACK struct {
+    tx_stats_2_t        tx_stats;
+    rx_stats_t          rx_stats;
+    tkip_ccmp_stats_t   tkipCcmpStats;
+}POSTPACK wlan_net_stats_2_t;
+
+#define wlan_net_stats_t wlan_net_stats_2_t
+
+typedef PREPACK struct {
+    A_UINT32    wow_num_pkts_dropped;
+    A_UINT16    wow_num_events_discarded;
+    A_UINT8     wow_num_host_pkt_wakeups;
+    A_UINT8     wow_num_host_event_wakeups;
+} POSTPACK wlan_wow_stats_t;
+
+/* for backwards compatibility with pre-2.1.x firmware */
+typedef PREPACK struct {
+    A_UINT32            lqVal;
+    A_INT32             noise_floor_calibation;
+    pm_stats_t          pmStats;
+    wlan_net_stats_1_t  txrxStats;
+    wlan_wow_stats_t    wowStats;
+    cserv_stats_t       cservStats;
+} POSTPACK WMI_TARGET_STATS_1;
+
+/* for version 2.1.x firmware */
+typedef PREPACK struct {
+    A_UINT32            lqVal;
+    A_INT32             noise_floor_calibation;
+    pm_stats_t          pmStats;
+    wlan_net_stats_2_t  txrxStats;
+    wlan_wow_stats_t    wowStats;
+    cserv_stats_t       cservStats;
+} POSTPACK WMI_TARGET_STATS_2;
+
+#define WMI_TARGET_STATS WMI_TARGET_STATS_2
+
+/*
+ * WMI_RSSI_THRESHOLD_EVENTID.
+ * Indicate the RSSI events to host. Events are indicated when we breach a
+ * thresold value.
+ */
+typedef enum{
+    WMI_RSSI_THRESHOLD1_ABOVE = 0,
+    WMI_RSSI_THRESHOLD2_ABOVE,
+    WMI_RSSI_THRESHOLD3_ABOVE,
+    WMI_RSSI_THRESHOLD4_ABOVE,
+    WMI_RSSI_THRESHOLD5_ABOVE,
+    WMI_RSSI_THRESHOLD6_ABOVE,
+    WMI_RSSI_THRESHOLD1_BELOW,
+    WMI_RSSI_THRESHOLD2_BELOW,
+    WMI_RSSI_THRESHOLD3_BELOW,
+    WMI_RSSI_THRESHOLD4_BELOW,
+    WMI_RSSI_THRESHOLD5_BELOW,
+    WMI_RSSI_THRESHOLD6_BELOW
+}WMI_RSSI_THRESHOLD_VAL;
+
+typedef PREPACK struct {
+    A_INT16 rssi;
+    A_UINT8 range;
+}POSTPACK WMI_RSSI_THRESHOLD_EVENT;
+
+/*
+ *  WMI_ERROR_REPORT_EVENTID
+ */
+typedef enum{
+    WMI_TARGET_PM_ERR_FAIL      = 0x00000001,
+    WMI_TARGET_KEY_NOT_FOUND    = 0x00000002,
+    WMI_TARGET_DECRYPTION_ERR   = 0x00000004,
+    WMI_TARGET_BMISS            = 0x00000008,
+    WMI_PSDISABLE_NODE_JOIN     = 0x00000010,
+    WMI_TARGET_COM_ERR          = 0x00000020,
+    WMI_TARGET_FATAL_ERR        = 0x00000040
+} WMI_TARGET_ERROR_VAL;
+
+typedef PREPACK struct {
+    A_UINT32 errorVal;
+}POSTPACK  WMI_TARGET_ERROR_REPORT_EVENT;
+
+typedef PREPACK struct {
+    A_UINT8 retrys;
+}POSTPACK  WMI_TX_RETRY_ERR_EVENT;
+
+typedef enum{
+    WMI_SNR_THRESHOLD1_ABOVE = 1,
+    WMI_SNR_THRESHOLD1_BELOW,
+    WMI_SNR_THRESHOLD2_ABOVE,
+    WMI_SNR_THRESHOLD2_BELOW,
+    WMI_SNR_THRESHOLD3_ABOVE,
+    WMI_SNR_THRESHOLD3_BELOW,
+    WMI_SNR_THRESHOLD4_ABOVE,
+    WMI_SNR_THRESHOLD4_BELOW
+} WMI_SNR_THRESHOLD_VAL;
+
+typedef PREPACK struct {
+    A_UINT8 range;  /* WMI_SNR_THRESHOLD_VAL */
+    A_UINT8 snr;
+}POSTPACK  WMI_SNR_THRESHOLD_EVENT;
+
+typedef enum{
+    WMI_LQ_THRESHOLD1_ABOVE = 1,
+    WMI_LQ_THRESHOLD1_BELOW,
+    WMI_LQ_THRESHOLD2_ABOVE,
+    WMI_LQ_THRESHOLD2_BELOW,
+    WMI_LQ_THRESHOLD3_ABOVE,
+    WMI_LQ_THRESHOLD3_BELOW,
+    WMI_LQ_THRESHOLD4_ABOVE,
+    WMI_LQ_THRESHOLD4_BELOW
+} WMI_LQ_THRESHOLD_VAL;
+
+typedef PREPACK struct {
+    A_INT32 lq;
+    A_UINT8 range;  /* WMI_LQ_THRESHOLD_VAL */
+}POSTPACK  WMI_LQ_THRESHOLD_EVENT;
+/*
+ * WMI_REPORT_ROAM_TBL_EVENTID
+ */
+#define MAX_ROAM_TBL_CAND   5
+
+typedef PREPACK struct {
+    A_INT32 roam_util;
+    A_UINT8 bssid[ATH_MAC_LEN];
+    A_INT8  rssi;
+    A_INT8  rssidt;
+    A_INT8  last_rssi;
+    A_INT8  util;
+    A_INT8  bias;
+    A_UINT8 reserved; /* For alignment */
+} POSTPACK WMI_BSS_ROAM_INFO;
+
+
+typedef PREPACK struct {
+    A_UINT16  roamMode;
+    A_UINT16  numEntries;
+    WMI_BSS_ROAM_INFO bssRoamInfo[1];
+} POSTPACK WMI_TARGET_ROAM_TBL;
+
+/*
+ *  WMI_CAC_EVENTID
+ */
+typedef enum {
+    CAC_INDICATION_ADMISSION = 0x00,
+    CAC_INDICATION_ADMISSION_RESP = 0x01,
+    CAC_INDICATION_DELETE = 0x02,
+    CAC_INDICATION_NO_RESP = 0x03,
+}CAC_INDICATION;
+
+#define WMM_TSPEC_IE_LEN   63
+
+typedef PREPACK struct {
+    A_UINT8 ac;
+    A_UINT8 cac_indication;
+    A_UINT8 statusCode;
+    A_UINT8 tspecSuggestion[WMM_TSPEC_IE_LEN];
+}POSTPACK  WMI_CAC_EVENT;
+
+/*
+ * WMI_APLIST_EVENTID
+ */
+
+typedef enum {
+    APLIST_VER1 = 1,
+} APLIST_VER;
+
+typedef PREPACK struct {
+    A_UINT8     bssid[ATH_MAC_LEN];
+    A_UINT16    channel;
+} POSTPACK  WMI_AP_INFO_V1;
+
+typedef PREPACK union {
+    WMI_AP_INFO_V1  apInfoV1;
+} POSTPACK WMI_AP_INFO;
+
+typedef PREPACK struct {
+    A_UINT8     apListVer;
+    A_UINT8     numAP;
+    WMI_AP_INFO apList[1];
+} POSTPACK WMI_APLIST_EVENT;
+
+/*
+ * developer commands
+ */
+
+/*
+ * WMI_SET_BITRATE_CMDID
+ *
+ * Get bit rate cmd uses same definition as set bit rate cmd
+ */
+typedef enum {
+    RATE_AUTO   = -1,
+    RATE_1Mb    = 0,
+    RATE_2Mb    = 1,
+    RATE_5_5Mb  = 2,
+    RATE_11Mb   = 3,
+    RATE_6Mb    = 4,
+    RATE_9Mb    = 5,
+    RATE_12Mb   = 6,
+    RATE_18Mb   = 7,
+    RATE_24Mb   = 8,
+    RATE_36Mb   = 9,
+    RATE_48Mb   = 10,
+    RATE_54Mb   = 11,
+} WMI_BIT_RATE;
+
+typedef PREPACK struct {
+    A_INT8      rateIndex;          /* see WMI_BIT_RATE */
+} POSTPACK WMI_BIT_RATE_CMD, WMI_BIT_RATE_REPLY;
+
+/*
+ * WMI_SET_FIXRATES_CMDID
+ *
+ * Get fix rates cmd uses same definition as set fix rates cmd
+ */
+typedef enum {
+    FIX_RATE_1Mb    = 0x1,
+    FIX_RATE_2Mb    = 0x2,
+    FIX_RATE_5_5Mb  = 0x4,
+    FIX_RATE_11Mb   = 0x8,
+    FIX_RATE_6Mb    = 0x10,
+    FIX_RATE_9Mb    = 0x20,
+    FIX_RATE_12Mb   = 0x40,
+    FIX_RATE_18Mb   = 0x80,
+    FIX_RATE_24Mb   = 0x100,
+    FIX_RATE_36Mb   = 0x200,
+    FIX_RATE_48Mb   = 0x400,
+    FIX_RATE_54Mb   = 0x800,
+} WMI_FIX_RATES_MASK;
+
+typedef PREPACK struct {
+    A_UINT16      fixRateMask;          /* see WMI_BIT_RATE */
+} POSTPACK WMI_FIX_RATES_CMD, WMI_FIX_RATES_REPLY;
+
+/*
+ * WMI_SET_RECONNECT_AUTH_MODE_CMDID
+ *
+ * Set authentication mode
+ */
+typedef enum {
+    RECONN_DO_AUTH = 0x00,
+    RECONN_NOT_AUTH = 0x01
+} WMI_AUTH_MODE;
+
+typedef PREPACK struct {
+    A_UINT8 mode;
+} POSTPACK WMI_SET_AUTH_MODE_CMD;
+
+/*
+ * WMI_SET_REASSOC_MODE_CMDID
+ *
+ * Set authentication mode
+ */
+typedef enum {
+    REASSOC_DO_DISASSOC = 0x00,
+    REASSOC_DONOT_DISASSOC = 0x01
+} WMI_REASSOC_MODE;
+
+typedef PREPACK struct {
+    A_UINT8 mode;
+}POSTPACK WMI_SET_REASSOC_MODE_CMD;
+
+typedef enum {
+    ROAM_DATA_TIME = 1,            /* Get The Roam Time Data */
+} ROAM_DATA_TYPE;
+
+typedef PREPACK struct {
+    A_UINT32        disassoc_time;
+    A_UINT32        no_txrx_time;
+    A_UINT32        assoc_time;
+    A_UINT32        allow_txrx_time;
+    A_UINT32        last_data_txrx_time;
+    A_UINT32        first_data_txrx_time;
+    A_UINT8         disassoc_bssid[ATH_MAC_LEN];
+    A_INT8          disassoc_bss_rssi;
+    A_UINT8         assoc_bssid[ATH_MAC_LEN];
+    A_INT8          assoc_bss_rssi;
+} POSTPACK WMI_TARGET_ROAM_TIME;
+
+typedef PREPACK struct {
+    PREPACK union {
+        WMI_TARGET_ROAM_TIME roamTime;
+    } POSTPACK u;
+    A_UINT8 roamDataType ;
+} POSTPACK WMI_TARGET_ROAM_DATA;
+
+typedef enum {
+    WMI_WMM_DISABLED = 0,
+    WMI_WMM_ENABLED
+} WMI_WMM_STATUS;
+
+typedef PREPACK struct {
+    A_UINT8    status;
+}POSTPACK WMI_SET_WMM_CMD;
+
+typedef enum {
+    WMI_TXOP_DISABLED = 0,
+    WMI_TXOP_ENABLED
+} WMI_TXOP_CFG;
+
+typedef PREPACK struct {
+    A_UINT8    txopEnable;
+}POSTPACK WMI_SET_WMM_TXOP_CMD;
+
+typedef PREPACK struct {
+    A_UINT8 keepaliveInterval;
+} POSTPACK WMI_SET_KEEPALIVE_CMD;
+
+typedef PREPACK struct {
+    A_BOOL configured;
+    A_UINT8 keepaliveInterval;
+} POSTPACK WMI_GET_KEEPALIVE_CMD;
+
+/*
+ * Add Application specified IE to a management frame
+ */
+#define WMI_MAX_IE_LEN  78
+
+typedef PREPACK struct {
+    A_UINT8 mgmtFrmType;  /* one of WMI_MGMT_FRAME_TYPE */
+    A_UINT8 ieLen;    /* Length  of the IE that should be added to the MGMT frame */
+    A_UINT8 ieInfo[1];
+} POSTPACK WMI_SET_APPIE_CMD;
+
+/*
+ * Notify the WSC registration status to the target
+ */
+#define WSC_REG_ACTIVE     1
+#define WSC_REG_INACTIVE   0
+/* Generic Hal Interface for setting hal paramters. */
+/* Add new Set HAL Param cmdIds here for newer params */
+typedef enum {
+   WHAL_SETCABTO_CMDID = 1,
+}WHAL_CMDID;
+
+typedef PREPACK struct {
+    A_UINT8 cabTimeOut;
+} POSTPACK WHAL_SETCABTO_PARAM;
+
+typedef PREPACK struct {
+    A_UINT8  whalCmdId;
+    A_UINT8 data[1];
+} POSTPACK WHAL_PARAMCMD;
+
+
+#define WOW_MAX_FILTER_LISTS 1 /*4*/
+#define WOW_MAX_FILTERS_PER_LIST 4
+#define WOW_PATTERN_SIZE 64
+#define WOW_MASK_SIZE 64
+
+typedef PREPACK struct {
+    A_UINT8 wow_valid_filter;
+    A_UINT8 wow_filter_id;
+    A_UINT8 wow_filter_size;
+    A_UINT8 wow_filter_offset;
+    A_UINT8 wow_filter_mask[WOW_MASK_SIZE];
+    A_UINT8 wow_filter_pattern[WOW_PATTERN_SIZE];
+} POSTPACK WOW_FILTER;
+
+
+typedef PREPACK struct {
+    A_UINT8 wow_valid_list;
+    A_UINT8 wow_list_id;
+    A_UINT8 wow_num_filters;
+    A_UINT8 wow_total_list_size;
+    WOW_FILTER list[WOW_MAX_FILTERS_PER_LIST];
+} POSTPACK WOW_FILTER_LIST;
+
+typedef PREPACK struct {
+    A_BOOL awake;
+    A_BOOL asleep;
+} POSTPACK WMI_SET_HOST_SLEEP_MODE_CMD;
+
+typedef PREPACK struct {
+    A_BOOL enable_wow;
+} POSTPACK WMI_SET_WOW_MODE_CMD;
+
+typedef PREPACK struct {
+    A_UINT8 filter_list_id;
+} POSTPACK WMI_GET_WOW_LIST_CMD;
+
+/*
+ * WMI_GET_WOW_LIST_CMD reply
+ */
+typedef PREPACK struct {
+    A_UINT8     num_filters;     /* number of patterns in reply */
+    A_UINT8     this_filter_num; /*  this is filter # x of total num_filters */
+    A_UINT8     wow_mode;
+    A_UINT8     host_mode;
+    WOW_FILTER  wow_filters[1];
+} POSTPACK WMI_GET_WOW_LIST_REPLY;
+
+typedef PREPACK struct {
+    A_UINT8 filter_list_id;
+    A_UINT8 filter_size;
+    A_UINT8 filter_offset;
+    A_UINT8 filter[1];
+} POSTPACK WMI_ADD_WOW_PATTERN_CMD;
+
+typedef PREPACK struct {
+    A_UINT16 filter_list_id;
+    A_UINT16 filter_id;
+} POSTPACK WMI_DEL_WOW_PATTERN_CMD;
+
+typedef PREPACK struct {
+    A_UINT8 macaddr[ATH_MAC_LEN];
+} POSTPACK WMI_SET_MAC_ADDRESS_CMD;
+
+/*
+ * WMI_SET_AKMP_PARAMS_CMD
+ */
+
+#define WMI_AKMP_MULTI_PMKID_EN   0x000001
+
+typedef PREPACK struct {
+    A_UINT32    akmpInfo;
+} POSTPACK WMI_SET_AKMP_PARAMS_CMD;
+
+typedef PREPACK struct {
+    A_UINT8 pmkid[WMI_PMKID_LEN];
+} POSTPACK WMI_PMKID;
+
+/*
+ * WMI_SET_PMKID_LIST_CMD
+ */
+#define WMI_MAX_PMKID_CACHE   8
+
+typedef PREPACK struct {
+    A_UINT32    numPMKID;
+    WMI_PMKID   pmkidList[WMI_MAX_PMKID_CACHE];
+} POSTPACK WMI_SET_PMKID_LIST_CMD;
+
+/*
+ * WMI_GET_PMKID_LIST_CMD  Reply
+ * Following the Number of PMKIDs is the list of PMKIDs
+ */
+/* for backwards compatibility with pre-2.1.x firmware */
+typedef PREPACK struct {
+    A_UINT32    numPMKID;
+    WMI_PMKID   pmkidList[1];
+} POSTPACK WMI_PMKID_LIST_REPLY_1;
+
+/* for version 2.1.x firmware */
+typedef PREPACK struct {
+    A_UINT32    numPMKID;
+    A_UINT8     bssidList[ATH_MAC_LEN][1];
+    WMI_PMKID   pmkidList[1];
+} POSTPACK WMI_PMKID_LIST_REPLY_2;
+
+#define WMI_PMKID_LIST_REPLY WMI_PMKID_LIST_REPLY_2
+
+typedef PREPACK struct {
+    A_UINT16 oldChannel;
+    A_UINT32 newChannel;
+} POSTPACK WMI_CHANNEL_CHANGE_EVENT;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _WMI_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/wmi_api.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/wmi_api.h
@@ -0,0 +1,287 @@
+
+#ifndef _WMI_API_H_
+#define _WMI_API_H_
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * This file contains the definitions for the Wireless Module Interface (WMI).
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/include/wmi_api.h#2 $
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * IP QoS Field definitions according to 802.1p
+ */
+#define BEST_EFFORT_PRI         0
+#define BACKGROUND_PRI          1
+#define EXCELLENT_EFFORT_PRI    3
+#define CONTROLLED_LOAD_PRI     4
+#define VIDEO_PRI               5
+#define VOICE_PRI               6
+#define NETWORK_CONTROL_PRI     7
+#define MAX_NUM_PRI             8
+
+#define UNDEFINED_PRI           (0xff)
+
+#define WMI_IMPLICIT_PSTREAM_INACTIVITY_INT 5000 /* 5 seconds */
+
+typedef enum {
+    ATHEROS_COMPLIANCE = 0x1,
+}TSPEC_PARAM_COMPLIANCE;
+
+struct wmi_t;
+
+void *wmi_init(void *devt);
+
+void wmi_qos_state_init(struct wmi_t *wmip);
+void wmi_shutdown(struct wmi_t *wmip);
+HTC_ENDPOINT_ID wmi_get_control_ep(struct wmi_t * wmip);
+void wmi_set_control_ep(struct wmi_t * wmip, HTC_ENDPOINT_ID eid);
+A_UINT16  wmi_get_mapped_qos_queue(struct wmi_t *, A_UINT8);
+A_STATUS wmi_dix_2_dot3(struct wmi_t *wmip, void *osbuf);
+A_STATUS wmi_data_hdr_add(struct wmi_t *wmip, void *osbuf, A_UINT8 msgType);
+A_STATUS wmi_dot3_2_dix(struct wmi_t *wmip, void *osbuf);
+A_STATUS wmi_data_hdr_remove(struct wmi_t *wmip, void *osbuf);
+A_STATUS wmi_syncpoint(struct wmi_t *wmip);
+A_STATUS wmi_syncpoint_reset(struct wmi_t *wmip);
+A_UINT8 wmi_implicit_create_pstream(struct wmi_t *wmip, void *osbuf, A_UINT32 layer2Priority, A_BOOL wmmEnabled);
+
+A_STATUS wmi_control_rx(struct wmi_t *wmip, void *osbuf);
+void wmi_iterate_nodes(struct wmi_t *wmip, wlan_node_iter_func *f, void *arg);
+void wmi_free_allnodes(struct wmi_t *wmip);
+bss_t *wmi_find_node(struct wmi_t *wmip, const A_UINT8 *macaddr);
+void wmi_free_node(struct wmi_t *wmip, const A_UINT8 *macaddr);
+
+
+typedef enum {
+    NO_SYNC_WMIFLAG = 0,
+    SYNC_BEFORE_WMIFLAG,            /* transmit all queued data before cmd */
+    SYNC_AFTER_WMIFLAG,             /* any new data waits until cmd execs */
+    SYNC_BOTH_WMIFLAG,
+    END_WMIFLAG                     /* end marker */
+} WMI_SYNC_FLAG;
+
+A_STATUS wmi_cmd_send(struct wmi_t *wmip, void *osbuf, WMI_COMMAND_ID cmdId,
+                      WMI_SYNC_FLAG flag);
+A_STATUS wmi_connect_cmd(struct wmi_t *wmip,
+                         NETWORK_TYPE netType,
+                         DOT11_AUTH_MODE dot11AuthMode,
+                         AUTH_MODE authMode,
+                         CRYPTO_TYPE pairwiseCrypto,
+                         A_UINT8 pairwiseCryptoLen,
+                         CRYPTO_TYPE groupCrypto,
+                         A_UINT8 groupCryptoLen,
+                         int ssidLength,
+                         A_UCHAR *ssid,
+                         A_UINT8 *bssid,
+                         A_UINT16 channel,
+                         A_UINT32 ctrl_flags);
+A_STATUS wmi_reconnect_cmd(struct wmi_t *wmip,
+                           A_UINT8 *bssid,
+                           A_UINT16 channel);
+A_STATUS wmi_disconnect_cmd(struct wmi_t *wmip);
+A_STATUS wmi_getrev_cmd(struct wmi_t *wmip);
+A_STATUS wmi_startscan_cmd(struct wmi_t *wmip, WMI_SCAN_TYPE scanType,
+                           A_BOOL forceFgScan, A_BOOL isLegacy,
+                           A_UINT32 homeDwellTime, A_UINT32 forceScanInterval,
+                           A_INT8 numChan, A_UINT16 *channelList);
+A_STATUS wmi_scanparams_cmd(struct wmi_t *wmip, A_UINT16 fg_start_sec,
+                            A_UINT16 fg_end_sec, A_UINT16 bg_sec,
+                            A_UINT16 minact_chdw_msec,
+                            A_UINT16 maxact_chdw_msec, A_UINT16 pas_chdw_msec,
+                            A_UINT8 shScanRatio, A_UINT8 scanCtrlFlags,
+                            A_UINT32 max_dfsch_act_time,
+                            A_UINT16 maxact_scan_per_ssid);
+A_STATUS wmi_bssfilter_cmd(struct wmi_t *wmip, A_UINT8 filter, A_UINT32 ieMask);
+A_STATUS wmi_probedSsid_cmd(struct wmi_t *wmip, A_UINT8 index, A_UINT8 flag,
+                            A_UINT8 ssidLength, A_UCHAR *ssid);
+A_STATUS wmi_listeninterval_cmd(struct wmi_t *wmip, A_UINT16 listenInterval, A_UINT16 listenBeacons);
+A_STATUS wmi_bmisstime_cmd(struct wmi_t *wmip, A_UINT16 bmisstime, A_UINT16 bmissbeacons);
+A_STATUS wmi_associnfo_cmd(struct wmi_t *wmip, A_UINT8 ieType,
+                           A_UINT8 ieLen, A_UINT8 *ieInfo);
+A_STATUS wmi_powermode_cmd(struct wmi_t *wmip, A_UINT8 powerMode);
+A_STATUS wmi_ibsspmcaps_cmd(struct wmi_t *wmip, A_UINT8 pmEnable, A_UINT8 ttl,
+                            A_UINT16 atim_windows, A_UINT16 timeout_value);
+A_STATUS wmi_pmparams_cmd(struct wmi_t *wmip, A_UINT16 idlePeriod,
+                           A_UINT16 psPollNum, A_UINT16 dtimPolicy);
+A_STATUS wmi_disctimeout_cmd(struct wmi_t *wmip, A_UINT8 timeout);
+A_STATUS wmi_sync_cmd(struct wmi_t *wmip, A_UINT8 syncNumber);
+A_STATUS wmi_create_pstream_cmd(struct wmi_t *wmip, WMI_CREATE_PSTREAM_CMD *pstream);
+A_STATUS wmi_delete_pstream_cmd(struct wmi_t *wmip, A_UINT8 trafficClass, A_UINT8 streamID);
+A_STATUS wmi_set_bitrate_cmd(struct wmi_t *wmip, A_INT32 rate);
+A_STATUS wmi_get_bitrate_cmd(struct wmi_t *wmip);
+A_INT8   wmi_validate_bitrate(struct wmi_t *wmip, A_INT32 rate);
+A_STATUS wmi_get_regDomain_cmd(struct wmi_t *wmip);
+A_STATUS wmi_get_channelList_cmd(struct wmi_t *wmip);
+A_STATUS wmi_set_channelParams_cmd(struct wmi_t *wmip, A_UINT8 scanParam,
+                                   WMI_PHY_MODE mode, A_INT8 numChan,
+                                   A_UINT16 *channelList);
+
+A_STATUS wmi_set_snr_threshold_params(struct wmi_t *wmip,
+                                       WMI_SNR_THRESHOLD_PARAMS_CMD *snrCmd);
+A_STATUS wmi_set_rssi_threshold_params(struct wmi_t *wmip,
+                                        WMI_RSSI_THRESHOLD_PARAMS_CMD *rssiCmd);
+A_STATUS wmi_clr_rssi_snr(struct wmi_t *wmip);
+A_STATUS wmi_set_lq_threshold_params(struct wmi_t *wmip,
+                                      WMI_LQ_THRESHOLD_PARAMS_CMD *lqCmd);
+A_STATUS wmi_set_rts_cmd(struct wmi_t *wmip, A_UINT16 threshold);
+A_STATUS wmi_set_lpreamble_cmd(struct wmi_t *wmip, A_UINT8 status);
+
+A_STATUS wmi_set_error_report_bitmask(struct wmi_t *wmip, A_UINT32 bitmask);
+
+A_STATUS wmi_get_challenge_resp_cmd(struct wmi_t *wmip, A_UINT32 cookie,
+                                    A_UINT32 source);
+A_STATUS wmi_config_debug_module_cmd(struct wmi_t *wmip, A_UINT16 mmask,
+                                     A_UINT16 tsr, A_BOOL rep, A_UINT16 size,
+                                     A_UINT32 valid);
+A_STATUS wmi_get_stats_cmd(struct wmi_t *wmip);
+A_STATUS wmi_addKey_cmd(struct wmi_t *wmip, A_UINT8 keyIndex,
+                        CRYPTO_TYPE keyType, A_UINT8 keyUsage,
+                        A_UINT8 keyLength,A_UINT8 *keyRSC,
+                        A_UINT8 *keyMaterial, A_UINT8 key_op_ctrl,
+                        WMI_SYNC_FLAG sync_flag);
+A_STATUS wmi_add_krk_cmd(struct wmi_t *wmip, A_UINT8 *krk);
+A_STATUS wmi_delete_krk_cmd(struct wmi_t *wmip);
+A_STATUS wmi_deleteKey_cmd(struct wmi_t *wmip, A_UINT8 keyIndex);
+A_STATUS wmi_set_akmp_params_cmd(struct wmi_t *wmip,
+                                 WMI_SET_AKMP_PARAMS_CMD *akmpParams);
+A_STATUS wmi_get_pmkid_list_cmd(struct wmi_t *wmip);
+A_STATUS wmi_set_pmkid_list_cmd(struct wmi_t *wmip,
+                                WMI_SET_PMKID_LIST_CMD *pmkInfo);
+A_STATUS wmi_abort_scan_cmd(struct wmi_t *wmip);
+A_STATUS wmi_set_txPwr_cmd(struct wmi_t *wmip, A_UINT8 dbM);
+A_STATUS wmi_get_txPwr_cmd(struct wmi_t *wmip);
+A_STATUS wmi_addBadAp_cmd(struct wmi_t *wmip, A_UINT8 apIndex, A_UINT8 *bssid);
+A_STATUS wmi_deleteBadAp_cmd(struct wmi_t *wmip, A_UINT8 apIndex);
+A_STATUS wmi_set_tkip_countermeasures_cmd(struct wmi_t *wmip, A_BOOL en);
+A_STATUS wmi_setPmkid_cmd(struct wmi_t *wmip, A_UINT8 *bssid, A_UINT8 *pmkId,
+                          A_BOOL set);
+A_STATUS wmi_set_access_params_cmd(struct wmi_t *wmip, A_UINT16 txop,
+                                   A_UINT8 eCWmin, A_UINT8 eCWmax,
+                                   A_UINT8 aifsn);
+A_STATUS wmi_set_retry_limits_cmd(struct wmi_t *wmip, A_UINT8 frameType,
+                                  A_UINT8 trafficClass, A_UINT8 maxRetries,
+                                  A_UINT8 enableNotify);
+
+void wmi_get_current_bssid(struct wmi_t *wmip, A_UINT8 *bssid);
+
+A_STATUS wmi_get_roam_tbl_cmd(struct wmi_t *wmip);
+A_STATUS wmi_get_roam_data_cmd(struct wmi_t *wmip, A_UINT8 roamDataType);
+A_STATUS wmi_set_roam_ctrl_cmd(struct wmi_t *wmip, WMI_SET_ROAM_CTRL_CMD *p,
+                               A_UINT8 size);
+A_STATUS wmi_set_powersave_timers_cmd(struct wmi_t *wmip,
+                            WMI_POWERSAVE_TIMERS_POLICY_CMD *pCmd,
+                            A_UINT8 size);
+
+A_STATUS wmi_set_opt_mode_cmd(struct wmi_t *wmip, A_UINT8 optMode);
+A_STATUS wmi_opt_tx_frame_cmd(struct wmi_t *wmip,
+                              A_UINT8 frmType,
+                              A_UINT8 *dstMacAddr,
+                              A_UINT8 *bssid,
+                              A_UINT16 optIEDataLen,
+                              A_UINT8 *optIEData);
+
+A_STATUS wmi_set_adhoc_bconIntvl_cmd(struct wmi_t *wmip, A_UINT16 intvl);
+A_STATUS wmi_set_voice_pkt_size_cmd(struct wmi_t *wmip, A_UINT16 voicePktSize);
+A_STATUS wmi_set_max_sp_len_cmd(struct wmi_t *wmip, A_UINT8 maxSpLen);
+A_UINT8  convert_userPriority_to_trafficClass(A_UINT8 userPriority);
+A_UINT8 wmi_get_power_mode_cmd(struct wmi_t *wmip);
+A_STATUS wmi_verify_tspec_params(WMI_CREATE_PSTREAM_CMD *pCmd, A_BOOL tspecCompliance);
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+A_STATUS wmi_test_cmd(struct wmi_t *wmip, A_UINT8 *buf, A_UINT32  len);
+#endif
+
+A_STATUS wmi_set_bt_status_cmd(struct wmi_t *wmip, A_UINT8 streamType, A_UINT8 status);
+A_STATUS wmi_set_bt_params_cmd(struct wmi_t *wmip, WMI_SET_BT_PARAMS_CMD* cmd);
+
+
+/*
+ *  This function is used to configure the fix rates mask to the target.
+ */
+A_STATUS wmi_set_fixrates_cmd(struct wmi_t *wmip, A_INT16 fixRatesMask);
+A_STATUS wmi_get_ratemask_cmd(struct wmi_t *wmip);
+
+A_STATUS wmi_set_authmode_cmd(struct wmi_t *wmip, A_UINT8 mode);
+
+A_STATUS wmi_set_reassocmode_cmd(struct wmi_t *wmip, A_UINT8 mode);
+
+A_STATUS wmi_set_wmm_cmd(struct wmi_t *wmip, WMI_WMM_STATUS status);
+A_STATUS wmi_set_wmm_txop(struct wmi_t *wmip, WMI_TXOP_CFG txEnable);
+
+A_STATUS wmi_get_keepalive_configured(struct wmi_t *wmip);
+A_UINT8 wmi_get_keepalive_cmd(struct wmi_t *wmip);
+A_STATUS wmi_set_keepalive_cmd(struct wmi_t *wmip, A_UINT8 keepaliveInterval);
+
+A_STATUS wmi_set_appie_cmd(struct wmi_t *wmip, A_UINT8 mgmtFrmType,
+                           A_UINT8 ieLen,A_UINT8 *ieInfo);
+
+A_STATUS wmi_set_halparam_cmd(struct wmi_t *wmip, A_UINT8 *cmd, A_UINT16 dataLen);
+A_INT32 wmi_get_rate(A_INT8 rateindex);
+
+/*Wake on Wireless WMI commands*/
+A_STATUS wmi_set_host_sleep_mode_cmd(struct wmi_t *wmip, WMI_SET_HOST_SLEEP_MODE_CMD *cmd);
+A_STATUS wmi_set_wow_mode_cmd(struct wmi_t *wmip, WMI_SET_WOW_MODE_CMD *cmd);
+A_STATUS wmi_get_wow_list_cmd(struct wmi_t *wmip, WMI_GET_WOW_LIST_CMD *cmd);
+A_STATUS wmi_add_wow_pattern_cmd(struct wmi_t *wmip,
+                                 WMI_ADD_WOW_PATTERN_CMD *cmd, A_UINT8* pattern, A_UINT8* mask, A_UINT8 pattern_size);
+A_STATUS wmi_del_wow_pattern_cmd(struct wmi_t *wmip,
+                                 WMI_DEL_WOW_PATTERN_CMD *cmd);
+A_STATUS wmi_set_wsc_status_cmd(struct wmi_t *wmip, A_UINT32 status);
+
+A_STATUS
+wmi_set_mcast_filter_cmd(struct wmi_t *wmip, A_UINT8 dot1, A_UINT8 dot2, A_UINT8 dot3, A_UINT8 dot4);
+
+A_STATUS
+wmi_del_mcast_filter_cmd(struct wmi_t *wmip, A_UINT8 dot1, A_UINT8 dot2, A_UINT8 dot3, A_UINT8 dot4);
+
+bss_t *
+wmi_find_Ssidnode (struct wmi_t *wmip, A_UCHAR *pSsid,
+                   A_UINT32 ssidLength, A_BOOL bIsWPA2, A_BOOL bMatchSSID);
+
+void
+wmi_node_return (struct wmi_t *wmip, bss_t *bss);
+
+void
+wmi_set_nodeage(struct wmi_t *wmip, A_UINT32 nodeAge);
+
+#if defined(CONFIG_TARGET_PROFILE_SUPPORT)
+A_STATUS wmi_prof_cfg_cmd(struct wmi_t *wmip, A_UINT32 period, A_UINT32 nbins);
+A_STATUS wmi_prof_addr_set_cmd(struct wmi_t *wmip, A_UINT32 addr);
+A_STATUS wmi_prof_start_cmd(struct wmi_t *wmip);
+A_STATUS wmi_prof_stop_cmd(struct wmi_t *wmip);
+A_STATUS wmi_prof_count_get_cmd(struct wmi_t *wmip);
+#endif /* CONFIG_TARGET_PROFILE_SUPPORT */
+#ifdef OS_ROAM_MANAGEMENT
+void wmi_scan_indication (struct wmi_t *wmip);
+#endif
+
+A_STATUS
+wmi_set_target_event_report_cmd(struct wmi_t *wmip, WMI_SET_TARGET_EVENT_REPORT_CMD* cmd);
+
+bss_t   *wmi_rm_current_bss (struct wmi_t *wmip, A_UINT8 *id);
+A_STATUS wmi_add_current_bss (struct wmi_t *wmip, A_UINT8 *id, bss_t *bss);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _WMI_API_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/wmi_host.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/wmi_host.h
@@ -0,0 +1,81 @@
+
+#ifndef _WMI_HOST_H_
+#define _WMI_HOST_H_
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * This file contains local definitios for the wmi host module.
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/wmi/wmi_host.h#1 $
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "../include/roaming.h"
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct wmi_stats {
+    A_UINT32    cmd_len_err;
+    A_UINT32    cmd_id_err;
+};
+
+/* Host side link management data structures */
+#define SIGNAL_QUALITY_THRESHOLD_LEVELS 6
+#define SIGNAL_QUALITY_UPPER_THRESHOLD_LEVELS SIGNAL_QUALITY_THRESHOLD_LEVELS
+#define SIGNAL_QUALITY_LOWER_THRESHOLD_LEVELS SIGNAL_QUALITY_THRESHOLD_LEVELS
+typedef struct sq_threshold_params_s {
+    A_INT16 upper_threshold[SIGNAL_QUALITY_UPPER_THRESHOLD_LEVELS];
+    A_INT16 lower_threshold[SIGNAL_QUALITY_LOWER_THRESHOLD_LEVELS];
+    A_UINT32 upper_threshold_valid_count;
+    A_UINT32 lower_threshold_valid_count;
+    A_UINT32 polling_interval;
+    A_UINT8 weight;
+    A_UINT8  last_rssi; //normally you would expect this to be bss specific but we keep only one instance because its only valid when the device is in a connected state. Not sure if it belongs to host or target.
+    A_UINT8  last_rssi_poll_event; //Not sure if it belongs to host or target
+} SQ_THRESHOLD_PARAMS;
+struct wmi_t {
+    A_BOOL                          wmi_ready;
+    A_BOOL                          wmi_numQoSStream;
+    A_UINT16                        wmi_streamExistsForAC[WMM_NUM_AC];
+    A_UINT8                         wmi_fatPipeExists;
+    void                           *wmi_devt;
+    struct wmi_stats                wmi_stats;
+    struct ieee80211_node_table     wmi_scan_table;
+    A_UINT8                         wmi_bssid[ATH_MAC_LEN];
+    A_UINT8                         wmi_powerMode;
+    A_UINT8                         wmi_phyMode;
+    A_UINT8                         wmi_keepaliveInterval;
+    A_MUTEX_T                       wmi_lock;
+    HTC_ENDPOINT_ID                wmi_endpoint_id;
+    SQ_THRESHOLD_PARAMS            wmi_SqThresholdParams[SIGNAL_QUALITY_METRICS_NUM_MAX];
+};
+
+
+#define LOCK_WMI(w)     A_MUTEX_LOCK(&(w)->wmi_lock);
+#define UNLOCK_WMI(w)   A_MUTEX_UNLOCK(&(w)->wmi_lock);
+
+#define WMI_TARGET_VERSION(wmip)	\
+	(((struct ar6_softc *) ((wmip)->wmi_devt))->arVersion.target_ver)
+
+#define WMI_TARGET_TYPE(wmip)		\
+	(((struct ar6_softc *) ((wmip)->wmi_devt))->arTargetType)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _WMI_HOST_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/include/wmix.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/include/wmix.h
@@ -0,0 +1,255 @@
+/*
+ * Copyright (c) 2004-2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ * This file contains extensions of the WMI protocol specified in the
+ * Wireless Module Interface (WMI).  It includes definitions of all
+ * extended commands and events.  Extensions include useful commands
+ * that are not directly related to wireless activities.  They may
+ * be hardware-specific, and they might not be supported on all
+ * implementations.
+ *
+ * Extended WMIX commands are encapsulated in a WMI message with
+ * cmd=WMI_EXTENSION_CMD.
+ */
+
+#ifndef _WMIX_H_
+#define _WMIX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#include "../include/dbglog.h"
+
+/*
+ * Extended WMI commands are those that are needed during wireless
+ * operation, but which are not really wireless commands.  This allows,
+ * for instance, platform-specific commands.  Extended WMI commands are
+ * embedded in a WMI command message with WMI_COMMAND_ID=WMI_EXTENSION_CMDID.
+ * Extended WMI events are similarly embedded in a WMI event message with
+ * WMI_EVENT_ID=WMI_EXTENSION_EVENTID.
+ */
+typedef PREPACK struct {
+    A_UINT32    commandId;
+} POSTPACK WMIX_CMD_HDR;
+
+typedef enum {
+    WMIX_DSETOPEN_REPLY_CMDID           = 0x2001,
+    WMIX_DSETDATA_REPLY_CMDID,
+    WMIX_GPIO_OUTPUT_SET_CMDID,
+    WMIX_GPIO_INPUT_GET_CMDID,
+    WMIX_GPIO_REGISTER_SET_CMDID,
+    WMIX_GPIO_REGISTER_GET_CMDID,
+    WMIX_GPIO_INTR_ACK_CMDID,
+    WMIX_HB_CHALLENGE_RESP_CMDID,
+    WMIX_DBGLOG_CFG_MODULE_CMDID,
+    WMIX_PROF_CFG_CMDID,                 /* 0x200a */
+    WMIX_PROF_ADDR_SET_CMDID,
+    WMIX_PROF_START_CMDID,
+    WMIX_PROF_STOP_CMDID,
+    WMIX_PROF_COUNT_GET_CMDID,
+} WMIX_COMMAND_ID;
+
+typedef enum {
+    WMIX_DSETOPENREQ_EVENTID            = 0x3001,
+    WMIX_DSETCLOSE_EVENTID,
+    WMIX_DSETDATAREQ_EVENTID,
+    WMIX_GPIO_INTR_EVENTID,
+    WMIX_GPIO_DATA_EVENTID,
+    WMIX_GPIO_ACK_EVENTID,
+    WMIX_HB_CHALLENGE_RESP_EVENTID,
+    WMIX_DBGLOG_EVENTID,
+    WMIX_PROF_COUNT_EVENTID,
+} WMIX_EVENT_ID;
+
+/*
+ * =============DataSet support=================
+ */
+
+/*
+ * WMIX_DSETOPENREQ_EVENTID
+ * DataSet Open Request Event
+ */
+typedef PREPACK struct {
+    A_UINT32 dset_id;
+    A_UINT32 targ_dset_handle;  /* echo'ed, not used by Host, */
+    A_UINT32 targ_reply_fn;     /* echo'ed, not used by Host, */
+    A_UINT32 targ_reply_arg;    /* echo'ed, not used by Host, */
+} POSTPACK WMIX_DSETOPENREQ_EVENT;
+
+/*
+ * WMIX_DSETCLOSE_EVENTID
+ * DataSet Close Event
+ */
+typedef PREPACK struct {
+    A_UINT32 access_cookie;
+} POSTPACK WMIX_DSETCLOSE_EVENT;
+
+/*
+ * WMIX_DSETDATAREQ_EVENTID
+ * DataSet Data Request Event
+ */
+typedef PREPACK struct {
+    A_UINT32 access_cookie;
+    A_UINT32 offset;
+    A_UINT32 length;
+    A_UINT32 targ_buf;         /* echo'ed, not used by Host, */
+    A_UINT32 targ_reply_fn;    /* echo'ed, not used by Host, */
+    A_UINT32 targ_reply_arg;   /* echo'ed, not used by Host, */
+} POSTPACK WMIX_DSETDATAREQ_EVENT;
+
+typedef PREPACK struct {
+    A_UINT32              status;
+    A_UINT32              targ_dset_handle;
+    A_UINT32              targ_reply_fn;
+    A_UINT32              targ_reply_arg;
+    A_UINT32              access_cookie;
+    A_UINT32              size;
+    A_UINT32              version;
+} POSTPACK WMIX_DSETOPEN_REPLY_CMD;
+
+typedef PREPACK struct {
+    A_UINT32              status;
+    A_UINT32              targ_buf;
+    A_UINT32              targ_reply_fn;
+    A_UINT32              targ_reply_arg;
+    A_UINT32              length;
+    A_UINT8               buf[1];
+} POSTPACK WMIX_DSETDATA_REPLY_CMD;
+
+
+/*
+ * =============GPIO support=================
+ * All masks are 18-bit masks with bit N operating on GPIO pin N.
+ */
+
+#include "../include/gpio.h"
+
+/*
+ * Set GPIO pin output state.
+ * In order for output to be driven, a pin must be enabled for output.
+ * This can be done during initialization through the GPIO Configuration
+ * DataSet, or during operation with the enable_mask.
+ *
+ * If a request is made to simultaneously set/clear or set/disable or
+ * clear/disable or disable/enable, results are undefined.
+ */
+typedef PREPACK struct {
+    A_UINT32              set_mask;             /* pins to set */
+    A_UINT32              clear_mask;           /* pins to clear */
+    A_UINT32              enable_mask;          /* pins to enable for output */
+    A_UINT32              disable_mask;         /* pins to disable/tristate */
+} POSTPACK WMIX_GPIO_OUTPUT_SET_CMD;
+
+/*
+ * Set a GPIO register.  For debug/exceptional cases.
+ * Values for gpioreg_id are GPIO_REGISTER_IDs, defined in a
+ * platform-dependent header.
+ */
+typedef PREPACK struct {
+    A_UINT32              gpioreg_id;           /* GPIO register ID */
+    A_UINT32              value;                /* value to write */
+} POSTPACK WMIX_GPIO_REGISTER_SET_CMD;
+
+/* Get a GPIO register.  For debug/exceptional cases. */
+typedef PREPACK struct {
+    A_UINT32              gpioreg_id;           /* GPIO register to read */
+} POSTPACK WMIX_GPIO_REGISTER_GET_CMD;
+
+/*
+ * Host acknowledges and re-arms GPIO interrupts.  A single
+ * message should be used to acknowledge all interrupts that
+ * were delivered in an earlier WMIX_GPIO_INTR_EVENT message.
+ */
+typedef PREPACK struct {
+    A_UINT32              ack_mask;             /* interrupts to acknowledge */
+} POSTPACK WMIX_GPIO_INTR_ACK_CMD;
+
+/*
+ * Target informs Host of GPIO interrupts that have ocurred since the
+ * last WMIX_GIPO_INTR_ACK_CMD was received.  Additional information --
+ * the current GPIO input values is provided -- in order to support
+ * use of a GPIO interrupt as a Data Valid signal for other GPIO pins.
+ */
+typedef PREPACK struct {
+    A_UINT32              intr_mask;            /* pending GPIO interrupts */
+    A_UINT32              input_values;         /* recent GPIO input values */
+} POSTPACK WMIX_GPIO_INTR_EVENT;
+
+/*
+ * Target responds to Host's earlier WMIX_GPIO_INPUT_GET_CMDID request
+ * using a GPIO_DATA_EVENT with
+ *   value set to the mask of GPIO pin inputs and
+ *   reg_id set to GPIO_ID_NONE
+ *
+ *
+ * Target responds to Hosts's earlier WMIX_GPIO_REGISTER_GET_CMDID request
+ * using a GPIO_DATA_EVENT with
+ *   value set to the value of the requested register and
+ *   reg_id identifying the register (reflects the original request)
+ * NB: reg_id supports the future possibility of unsolicited
+ * WMIX_GPIO_DATA_EVENTs (for polling GPIO input), and it may
+ * simplify Host GPIO support.
+ */
+typedef PREPACK struct {
+    A_UINT32              value;
+    A_UINT32              reg_id;
+} POSTPACK WMIX_GPIO_DATA_EVENT;
+
+/*
+ * =============Error Detection support=================
+ */
+
+/*
+ * WMIX_HB_CHALLENGE_RESP_CMDID
+ * Heartbeat Challenge Response command
+ */
+typedef PREPACK struct {
+    A_UINT32              cookie;
+    A_UINT32              source;
+} POSTPACK WMIX_HB_CHALLENGE_RESP_CMD;
+
+/*
+ * WMIX_HB_CHALLENGE_RESP_EVENTID
+ * Heartbeat Challenge Response Event
+ */
+#define WMIX_HB_CHALLENGE_RESP_EVENT WMIX_HB_CHALLENGE_RESP_CMD
+
+typedef PREPACK struct {
+    struct dbglog_config_s config;
+} POSTPACK WMIX_DBGLOG_CFG_MODULE_CMD;
+
+/*
+ * =============Target Profiling support=================
+ */
+
+typedef PREPACK struct {
+    A_UINT32 period; /* Time (in 30.5us ticks) between samples */
+    A_UINT32 nbins;
+} POSTPACK WMIX_PROF_CFG_CMD;
+
+typedef PREPACK struct {
+    A_UINT32 addr;
+} POSTPACK WMIX_PROF_ADDR_SET_CMD;
+
+/*
+ * Target responds to Hosts's earlier WMIX_PROF_COUNT_GET_CMDID request
+ * using a WMIX_PROF_COUNT_EVENT with
+ *   addr set to the next address
+ *   count set to the corresponding count
+ */
+typedef PREPACK struct {
+    A_UINT32              addr;
+    A_UINT32              count;
+} POSTPACK WMIX_PROF_COUNT_EVENT;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _WMIX_H_ */
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/wlan/Makefile
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/wlan/Makefile
@@ -0,0 +1,3 @@
+#
+obj-$(CONFIG_SDIO_AR6000_WLAN) += wlan_node.o  wlan_recv_beacon.o  wlan_utils.o
+
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/wlan/wlan_node.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/wlan/wlan_node.c
@@ -0,0 +1,568 @@
+/*-
+ * Copyright (c) 2001 Atsushi Onoe
+ * Copyright (c) 2002-2004 Sam Leffler, Errno Consulting
+ * Copyright (c) 2004-2005 Atheros Communications
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/wlan/src/wlan_node.c#1 $
+ */
+/*
+ * IEEE 802.11 node handling support.
+ */
+#include "../include/config.h"
+#include "../include/athdefs.h"
+#include "../include/athtypes.h"
+#include "../include/osapi.h"
+#include "../include/debug.h"
+#include "../include/ieee80211.h"
+#include "../include/wlan_api.h"
+#include "../include/ieee80211_node.h"
+#include "../include/htc_api.h"
+#include "../include/wmi.h"
+#include "../include/wmi_api.h"
+#include "../include/ar6000_api.h"
+
+static void wlan_node_timeout(A_ATH_TIMER arg);
+
+#undef WLAN_NODE_LEAK_CHECK
+#ifdef WLAN_NODE_LEAK_CHECK
+static int wlan_node_cnt = 0;
+#define wlan_node_cnt_inc() \
+	A_PRINTF("++wlan_node_cnt %d\n", ++wlan_node_cnt);
+#define wlan_node_cnt_dec() \
+	A_PRINTF("--wlan_node_cnt %d\n", --wlan_node_cnt);
+#else
+#define wlan_node_cnt_inc()
+#define wlan_node_cnt_dec()
+#endif
+
+bss_t *
+wlan_node_alloc(struct ieee80211_node_table *nt, int wh_size)
+{
+    bss_t *ni;
+
+    ni = A_MALLOC_NOWAIT(sizeof(bss_t));
+
+    if (ni != NULL) {
+        A_MEMZERO(ni, sizeof(bss_t));
+        if (wh_size) {
+            ni->ni_buf = A_MALLOC_NOWAIT(wh_size);
+            if (ni->ni_buf == NULL) {
+                A_FREE(ni);
+                ni = NULL;
+            }
+        }
+        wlan_node_cnt_inc();
+    }
+
+    return ni;
+}
+
+/*
+ * Free a node.  This should only be called when the refcnt for the node is
+ * known to be zero.  The node must be unlinked from the table prior to calling
+ * this routine.
+ */
+void
+wlan_node_free(bss_t *ni)
+{
+    if (ieee80211_node_refcnt(ni)) {
+        A_PRINTF("wlan_node_free:  Freeing node "
+            "%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x with refcnt %d\n",
+            ni->ni_macaddr[0], ni->ni_macaddr[1], ni->ni_macaddr[2],
+            ni->ni_macaddr[3], ni->ni_macaddr[4], ni->ni_macaddr[5],
+            ieee80211_node_refcnt(ni));
+    }
+    if (ni->ni_list_next || ni->ni_list_prev
+        || ni->ni_hash_next || ni->ni_hash_prev)
+    {
+        A_PRINTF("wlan_node_free:  Freeing linked node "
+            "%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\n",
+            ni->ni_macaddr[0], ni->ni_macaddr[1], ni->ni_macaddr[2],
+            ni->ni_macaddr[3], ni->ni_macaddr[4], ni->ni_macaddr[5]);
+    }
+
+    if (ni->ni_buf != NULL)
+        A_FREE(ni->ni_buf);
+
+    A_FREE(ni);
+    wlan_node_cnt_dec();
+}
+
+/*
+ * Add a node to the table and update the links.  Before calling this routine,
+ * the caller must verify that a node with the same mac address is not already
+ * present in the table.  On entry, the node being added must have a zero
+ * refcnt and must not be linked to the table.
+ * On exit, the node will have a refcnt of 2.  The caller must release one of
+ * the locks when it drops its reference to the node.  The second lock will be
+ * released when the node is unlinked from the table.
+ */
+void
+wlan_setup_node(struct ieee80211_node_table *nt, bss_t *ni,
+                const A_UINT8 *macaddr)
+{
+    int hash;
+    A_UINT32 timeoutValue = 0;
+    bss_t *dup_ni;
+
+    if (ieee80211_node_refcnt(ni)) {
+        A_PRINTF("wlan_setup_node:  Adding node "
+            "%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x with refcnt %d\n",
+            macaddr[0], macaddr[1], macaddr[2],
+            macaddr[3], macaddr[4], macaddr[5],
+            ieee80211_node_refcnt(ni));
+            ni->ni_refcnt = 0;
+    }
+    if (ni->ni_list_next || ni->ni_list_prev
+        || ni->ni_hash_next || ni->ni_hash_prev)
+    {
+        A_PRINTF("wlan_setup_node:  Adding linked node "
+            "%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\n",
+            macaddr[0], macaddr[1], macaddr[2],
+            macaddr[3], macaddr[4], macaddr[5]);
+        ni->ni_list_next = NULL;
+        ni->ni_list_prev = NULL;
+        ni->ni_hash_next = NULL;
+        ni->ni_hash_prev = NULL;
+    }
+    /* Check if a node with this macaddr is already present in the table. */
+    if ((dup_ni = wlan_find_node(nt, macaddr))) {
+        A_PRINTF("wlan_setup_node:  Adding duplicate node "
+            "%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\n",
+            macaddr[0], macaddr[1], macaddr[2],
+            macaddr[3], macaddr[4], macaddr[5]);
+        wlan_node_return(nt, dup_ni);
+    }
+
+    A_MEMCPY(ni->ni_macaddr, macaddr, IEEE80211_ADDR_LEN);
+    hash = IEEE80211_NODE_HASH(macaddr);
+    /* Increment node refcnt once to protect the table link. */
+    ieee80211_node_incref(ni);
+    /* Increment refcnt a second time for the caller's lock. */
+    ieee80211_node_incref(ni);
+
+    timeoutValue = nt->nt_nodeAge;
+    ni->ni_tstamp = A_GET_MS(timeoutValue);
+    IEEE80211_NODE_LOCK(nt);
+
+    /* Insert at the end of the node list */
+    ni->ni_list_next = NULL;
+    ni->ni_list_prev = nt->nt_node_last;
+    if(nt->nt_node_last != NULL)
+        nt->nt_node_last->ni_list_next = ni;
+    nt->nt_node_last = ni;
+    if(nt->nt_node_first == NULL)
+        nt->nt_node_first = ni;
+
+    /* Insert into the hash list i.e. the bucket */
+    if((ni->ni_hash_next = nt->nt_hash[hash]) != NULL)
+        nt->nt_hash[hash]->ni_hash_prev = ni;
+    ni->ni_hash_prev = NULL;
+    nt->nt_hash[hash] = ni;
+
+    if (!nt->isTimerArmed) {
+        A_TIMEOUT_MS(&nt->nt_inact_timer, timeoutValue, 0);
+        nt->isTimerArmed = TRUE;
+    }
+
+    IEEE80211_NODE_UNLOCK(nt);
+}
+
+/*
+ * Find a node with a given mac address.  The caller must hold the node table
+ * lock.  The node reference count is incremented.
+ */
+static bss_t *
+_ieee80211_find_node(struct ieee80211_node_table *nt,
+    const A_UINT8 *macaddr)
+{
+    bss_t *ni;
+    int hash;
+
+    IEEE80211_NODE_LOCK_ASSERT(nt);
+
+    hash = IEEE80211_NODE_HASH(macaddr);
+    for(ni = nt->nt_hash[hash]; ni; ni = ni->ni_hash_next) {
+        if (IEEE80211_ADDR_EQ(ni->ni_macaddr, macaddr)) {
+            ieee80211_node_incref(ni);  /* mark referenced */
+            return ni;
+        }
+    }
+    return NULL;
+}
+
+/*
+ * Decrement the reference count of a node and free it if the reference count
+ * goes to zero.  Ihe caller must hold the node table lock.
+ * It is an error to call this routine if it results in freeing a node that is
+ * linked to a table.  To avoid this, it must only be called to drop a node
+ * reference that was held by the caller.
+ */
+static void
+wlan_node_dec_free(bss_t *ni)
+{
+    if (ieee80211_node_dectestref(ni))
+        wlan_node_free(ni);
+}
+
+bss_t *
+wlan_find_node(struct ieee80211_node_table *nt, const A_UINT8 *macaddr)
+{
+    bss_t *ni;
+
+    IEEE80211_NODE_LOCK(nt);
+    ni = _ieee80211_find_node(nt, macaddr);
+    IEEE80211_NODE_UNLOCK(nt);
+    return ni;
+}
+
+/*
+ * Unlink a node from the table.  If the node is not linked to the table,
+ * then this routine does nothing.  If the node is linked to the table, then
+ * the node is unlinked and the node reference count is decremented.
+ * The caller must hold the node table lock.
+ * The caller must hold a reference to the node, so it is an error if the node
+ * reference count drops to zero when the node is unlinked by this routine.
+ * Returns 1 if the node is unlinked by this routine, or 0 if the node was
+ * unlinked on entry.
+ */
+static int
+_ieee80211_node_unlink(struct ieee80211_node_table *nt, bss_t *ni)
+{
+    int unlink = 0;
+
+    if(ni->ni_list_prev == NULL) {
+        if (nt->nt_node_first == ni) {
+            /* First in list so fix the list head */
+            nt->nt_node_first = ni->ni_list_next;
+            unlink = 1;
+        }
+    } else {
+        ni->ni_list_prev->ni_list_next = ni->ni_list_next;
+        unlink = 1;
+    }
+
+    if(ni->ni_list_next == NULL) {
+        if (nt->nt_node_last == ni) {
+            /* Last in list so fix list tail */
+            nt->nt_node_last = ni->ni_list_prev;
+            unlink = 1;
+        }
+    } else {
+        ni->ni_list_next->ni_list_prev = ni->ni_list_prev;
+        unlink = 1;
+    }
+
+    if(ni->ni_hash_prev == NULL) {
+        int hash = IEEE80211_NODE_HASH(ni->ni_macaddr);
+
+        if (nt->nt_hash[hash] == ni) {
+            /* First in list so fix the list head */
+            nt->nt_hash[hash] = ni->ni_hash_next;
+            unlink = 1;
+        }
+    } else {
+        ni->ni_hash_prev->ni_hash_next = ni->ni_hash_next;
+        unlink = 1;
+    }
+
+    if(ni->ni_hash_next != NULL) {
+        ni->ni_hash_next->ni_hash_prev = ni->ni_hash_prev;
+        unlink = 1;
+    }
+
+    if (unlink) {
+        ni->ni_list_prev = NULL;
+        ni->ni_list_next = NULL;
+        ni->ni_hash_prev = NULL;
+        ni->ni_hash_next = NULL;
+        if (ieee80211_node_dectestref(ni)) {
+            A_PRINTF("_ieee80211_node_unlink:  Unlinking unreferenced node "
+                "%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\n",
+                ni->ni_macaddr[0], ni->ni_macaddr[1], ni->ni_macaddr[2],
+                ni->ni_macaddr[3], ni->ni_macaddr[4], ni->ni_macaddr[5]);
+        }
+    }
+    return unlink;
+}
+
+/*
+ * Reclaim a node.
+ * Unlink the node from the table.  This routine always decrements the node
+ * referenct count by one to release the reference held by the caller.  The node
+ * reference count will be decremented an additional time if this routine
+ * unlinks the node from the table.  If the node reference count drops to zero,
+ * then this routine frees the node.
+ * It is not an error to call this routine with an unlinked node.
+ */
+void
+wlan_node_reclaim(struct ieee80211_node_table *nt, bss_t *ni)
+{
+    IEEE80211_NODE_LOCK(nt);
+
+    _ieee80211_node_unlink(nt, ni);
+
+    wlan_node_dec_free(ni);
+
+    IEEE80211_NODE_UNLOCK(nt);
+}
+
+/*
+ * Return the first node in the table after incrementing its reference count.
+ * Returns null if the table is empty.
+ */
+static bss_t *
+wlan_first_node(struct ieee80211_node_table *nt)
+{
+    bss_t *ni;
+
+    IEEE80211_NODE_LOCK(nt);
+    ni = nt->nt_node_first;
+    if (ni)
+        ieee80211_node_incref(ni);
+    IEEE80211_NODE_UNLOCK(nt);
+    return ni;
+}
+
+void
+wlan_free_allnodes(struct ieee80211_node_table *nt)
+{
+    bss_t *ni;
+
+    while ((ni = wlan_first_node(nt)) != NULL)
+        wlan_node_reclaim(nt, ni);
+}
+
+void
+wlan_iterate_nodes(struct ieee80211_node_table *nt, wlan_node_iter_func *f,
+                   void *arg)
+{
+    bss_t *ni;
+    A_UINT32 gen;
+
+    gen = ++nt->nt_scangen;
+
+    IEEE80211_NODE_LOCK(nt);
+    for (ni = nt->nt_node_first; ni; ni = ni->ni_list_next) {
+        if (ni->ni_scangen != gen) {
+            ni->ni_scangen = gen;
+            ieee80211_node_incref(ni);
+            (*f)(arg, ni);
+            ieee80211_node_decref(ni);
+        }
+    }
+    IEEE80211_NODE_UNLOCK(nt);
+}
+
+/*
+ * Node table support.
+ */
+void
+wlan_node_table_init(void *wmip, struct ieee80211_node_table *nt)
+{
+    int i;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN, ("node table = 0x%x\n", (A_UINT32)nt));
+    IEEE80211_NODE_LOCK_INIT(nt);
+
+    nt->nt_node_first = nt->nt_node_last = NULL;
+    for(i = 0; i < IEEE80211_NODE_HASHSIZE; i++)
+    {
+        nt->nt_hash[i] = NULL;
+    }
+    A_INIT_TIMER(&nt->nt_inact_timer, wlan_node_timeout, nt);
+    nt->isTimerArmed = FALSE;
+    nt->nt_wmip = wmip;
+    nt->nt_nodeAge = WLAN_NODE_INACT_TIMEOUT_MSEC;
+
+    //
+    // nt_scangen never initialized before and during suspend/resume of winmobile, customer (LG/SEMCO) identified
+    // that some junk has been stored in this, due to this scan list didn't properly updated
+    //
+    nt->nt_scangen   = 0;
+
+#ifdef OS_ROAM_MANAGEMENT
+    nt->nt_si_gen    = 0;
+#endif
+}
+
+void
+wlan_set_nodeage(struct ieee80211_node_table *nt, A_UINT32 nodeAge)
+{
+    nt->nt_nodeAge = nodeAge;
+    return;
+}
+
+static void
+wlan_node_timeout(A_ATH_TIMER arg)
+{
+    struct ieee80211_node_table *nt = (struct ieee80211_node_table *)arg;
+    bss_t *bss, *nextBss;
+    A_UINT8 myBssid[IEEE80211_ADDR_LEN], reArmTimer = FALSE;
+    A_UINT32 timeoutValue = 0;
+
+    timeoutValue = nt->nt_nodeAge;
+
+    wmi_get_current_bssid(nt->nt_wmip, myBssid);
+
+    bss = nt->nt_node_first;
+    while (bss != NULL)
+    {
+        nextBss = bss->ni_list_next;
+        if (A_MEMCMP(myBssid, bss->ni_macaddr, sizeof(myBssid)) != 0)
+        {
+
+            if (bss->ni_tstamp <= A_GET_MS(0))
+            {
+                 /*
+                  * We must hold a reference to the node when calling
+                  * wlan_node_reclaim().
+                  */
+                ieee80211_node_incref(bss);
+                /*
+                 * free up all but the current bss - if set
+                 */
+                wlan_node_reclaim(nt, bss);
+            }
+            else
+            {
+                /*
+                 * Re-arm timer, only when we have a bss other than
+                 * current bss AND it is not aged-out.
+                 */
+                reArmTimer = TRUE;
+            }
+        }
+        bss = nextBss;
+    }
+
+    if(reArmTimer)
+        A_TIMEOUT_MS(&nt->nt_inact_timer, timeoutValue, 0);
+
+    nt->isTimerArmed = reArmTimer;
+}
+
+void
+wlan_node_table_cleanup(struct ieee80211_node_table *nt)
+{
+    A_UNTIMEOUT(&nt->nt_inact_timer);
+    A_DELETE_TIMER(&nt->nt_inact_timer);
+    wlan_free_allnodes(nt);
+    IEEE80211_NODE_LOCK_DESTROY(nt);
+}
+
+bss_t *
+wlan_find_Ssidnode (struct ieee80211_node_table *nt, A_UCHAR *pSsid,
+                    A_UINT32 ssidLength, A_BOOL bIsWPA2, A_BOOL bMatchSSID)
+{
+    bss_t   *ni = NULL;
+    A_UCHAR *pIESsid = NULL;
+
+    IEEE80211_NODE_LOCK (nt);
+
+    for (ni = nt->nt_node_first; ni; ni = ni->ni_list_next) {
+        pIESsid = ni->ni_cie.ie_ssid;
+        if (pIESsid[1] <= 32) {
+
+            // Step 1 : Check SSID
+            if (0x00 == memcmp (pSsid, &pIESsid[2], ssidLength)) {
+
+                //
+                // Step 2.1 : Check MatchSSID is TRUE, if so, return Matched SSID
+                // Profile, otherwise check whether WPA2 or WPA
+                //
+                if (TRUE == bMatchSSID) {
+                    ieee80211_node_incref (ni);  /* mark referenced */
+                    IEEE80211_NODE_UNLOCK (nt);
+                    return ni;
+                }
+
+                // Step 2 : if SSID matches, check WPA or WPA2
+                if (TRUE == bIsWPA2 && NULL != ni->ni_cie.ie_rsn) {
+                    ieee80211_node_incref (ni);  /* mark referenced */
+                    IEEE80211_NODE_UNLOCK (nt);
+                    return ni;
+                }
+                if (FALSE == bIsWPA2 && NULL != ni->ni_cie.ie_wpa) {
+                    ieee80211_node_incref(ni);  /* mark referenced */
+                    IEEE80211_NODE_UNLOCK (nt);
+                    return ni;
+                }
+            }
+        }
+    }
+
+    IEEE80211_NODE_UNLOCK (nt);
+
+    return NULL;
+}
+
+void
+wlan_node_return (struct ieee80211_node_table *nt, bss_t *ni)
+{
+    IEEE80211_NODE_LOCK (nt);
+    wlan_node_dec_free (ni);
+    IEEE80211_NODE_UNLOCK (nt);
+}
+
+/*
+ * Unlink a node from the table, but do not free it.
+ * The caller must call wlan_node_return()
+ * to release the node when it is finished with it.
+ */
+bss_t *
+wlan_node_remove(struct ieee80211_node_table *nt, A_UINT8 *bssid)
+{
+    bss_t *bss, *nextBss;
+
+    IEEE80211_NODE_LOCK(nt);
+
+    bss = nt->nt_node_first;
+
+    while (bss != NULL)
+    {
+        nextBss = bss->ni_list_next;
+
+        if (A_MEMCMP(bssid, bss->ni_macaddr, 6) == 0)
+        {
+            /* increment the node reference count for the caller's reference */
+            ieee80211_node_incref(bss);
+            /* unlink the node from the table */
+            _ieee80211_node_unlink(nt, bss);
+            IEEE80211_NODE_UNLOCK(nt);
+            return bss;
+        }
+
+        bss = nextBss;
+    }
+
+    IEEE80211_NODE_UNLOCK(nt);
+    return NULL;
+}
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/wlan/wlan_recv_beacon.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/wlan/wlan_recv_beacon.c
@@ -0,0 +1,195 @@
+/*-
+ * Copyright (c) 2001 Atsushi Onoe
+ * Copyright (c) 2002-2004 Sam Leffler, Errno Consulting
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*
+ * IEEE 802.11 input handling.
+ */
+
+#include "../include/config.h"
+#include "../include/athdefs.h"
+#include "../include/athtypes.h"
+#include "../include/osapi.h"
+#include "../include/wmi.h"
+#include "../include/ieee80211.h"
+#include "../include/wlan_api.h"
+
+#define IEEE80211_VERIFY_LENGTH(_len, _minlen) do {         \
+    if ((_len) < (_minlen)) {                   \
+        return A_EINVAL;                         \
+    }                               \
+} while (0)
+
+#define IEEE80211_VERIFY_ELEMENT(__elem, __maxlen) do {         \
+    if ((__elem) == NULL) {                     \
+        return A_EINVAL;                         \
+    }                               \
+    if ((__elem)[1] > (__maxlen)) {                 \
+        return A_EINVAL;                         \
+    }                               \
+} while (0)
+
+
+/* unaligned little endian access */
+#define LE_READ_2(p)                            \
+    ((A_UINT16)                            \
+     ((((A_UINT8 *)(p))[0]      ) | (((A_UINT8 *)(p))[1] <<  8)))
+
+#define LE_READ_4(p)                            \
+    ((A_UINT32)                            \
+     ((((A_UINT8 *)(p))[0]      ) | (((A_UINT8 *)(p))[1] <<  8) | \
+      (((A_UINT8 *)(p))[2] << 16) | (((A_UINT8 *)(p))[3] << 24)))
+
+
+static int __inline
+iswpaoui(const A_UINT8 *frm)
+{
+    return frm[1] > 3 && LE_READ_4(frm+2) == ((WPA_OUI_TYPE<<24)|WPA_OUI);
+}
+
+static int __inline
+iswmmoui(const A_UINT8 *frm)
+{
+    return frm[1] > 3 && LE_READ_4(frm+2) == ((WMM_OUI_TYPE<<24)|WMM_OUI);
+}
+
+/* unused functions for now */
+#if 0
+static int __inline
+iswmmparam(const A_UINT8 *frm)
+{
+    return frm[1] > 5 && frm[6] == WMM_PARAM_OUI_SUBTYPE;
+}
+
+static int __inline
+iswmminfo(const A_UINT8 *frm)
+{
+    return frm[1] > 5 && frm[6] == WMM_INFO_OUI_SUBTYPE;
+}
+#endif
+
+static int __inline
+isatherosoui(const A_UINT8 *frm)
+{
+    return frm[1] > 3 && LE_READ_4(frm+2) == ((ATH_OUI_TYPE<<24)|ATH_OUI);
+}
+
+static int __inline
+iswscoui(const A_UINT8 *frm)
+{
+    return frm[1] > 3 && LE_READ_4(frm+2) == ((0x04<<24)|WPA_OUI);
+}
+
+A_STATUS
+wlan_parse_beacon(A_UINT8 *buf, int framelen, struct ieee80211_common_ie *cie)
+{
+    A_UINT8 *frm, *efrm;
+
+    frm = buf;
+    efrm = (A_UINT8 *) (frm + framelen);
+
+    /*
+     * beacon/probe response frame format
+     *  [8] time stamp
+     *  [2] beacon interval
+     *  [2] capability information
+     *  [tlv] ssid
+     *  [tlv] supported rates
+     *  [tlv] country information
+     *  [tlv] parameter set (FH/DS)
+     *  [tlv] erp information
+     *  [tlv] extended supported rates
+     *  [tlv] WMM
+     *  [tlv] WPA or RSN
+     *  [tlv] Atheros Advanced Capabilities
+     */
+    IEEE80211_VERIFY_LENGTH(efrm - frm, 12);
+    A_MEMZERO(cie, sizeof(*cie));
+
+    cie->ie_tstamp = frm; frm += 8;
+    cie->ie_beaconInt = A_LE2CPU16(*(A_UINT16 *)frm);  frm += 2;
+    cie->ie_capInfo = A_LE2CPU16(*(A_UINT16 *)frm);  frm += 2;
+    cie->ie_chan = 0;
+
+    while (frm < efrm) {
+        switch (*frm) {
+        case IEEE80211_ELEMID_SSID:
+            cie->ie_ssid = frm;
+            break;
+        case IEEE80211_ELEMID_RATES:
+            cie->ie_rates = frm;
+            break;
+        case IEEE80211_ELEMID_COUNTRY:
+            cie->ie_country = frm;
+            break;
+        case IEEE80211_ELEMID_FHPARMS:
+            break;
+        case IEEE80211_ELEMID_DSPARMS:
+            cie->ie_chan = frm[2];
+            break;
+        case IEEE80211_ELEMID_TIM:
+            cie->ie_tim = frm;
+            break;
+        case IEEE80211_ELEMID_IBSSPARMS:
+            break;
+        case IEEE80211_ELEMID_XRATES:
+            cie->ie_xrates = frm;
+            break;
+        case IEEE80211_ELEMID_ERP:
+            if (frm[1] != 1) {
+                //A_PRINTF("Discarding ERP Element - Bad Len\n");
+                return A_EINVAL;
+            }
+            cie->ie_erp = frm[2];
+            break;
+        case IEEE80211_ELEMID_RSN:
+            cie->ie_rsn = frm;
+            break;
+        case IEEE80211_ELEMID_VENDOR:
+            if (iswpaoui(frm)) {
+                cie->ie_wpa = frm;
+            } else if (iswmmoui(frm)) {
+                cie->ie_wmm = frm;
+            } else if (isatherosoui(frm)) {
+                cie->ie_ath = frm;
+            } else if(iswscoui(frm)) {
+                cie->ie_wsc = frm;
+            }
+            break;
+        default:
+            break;
+        }
+        frm += frm[1] + 2;
+    }
+    IEEE80211_VERIFY_ELEMENT(cie->ie_rates, IEEE80211_RATE_MAXSIZE);
+    IEEE80211_VERIFY_ELEMENT(cie->ie_ssid, IEEE80211_NWID_LEN);
+
+    return A_OK;
+}
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/wlan/wlan_utils.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/wlan/wlan_utils.c
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2004-2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * This module implements frequently used wlan utilies
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/wlan/src/wlan_utils.c#1 $
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "../include/config.h"
+#include "../include/athdefs.h"
+#include "../include/athtypes.h"
+#include "../include/osapi.h"
+
+/*
+ * converts ieee channel number to frequency
+ */
+A_UINT16
+wlan_ieee2freq(int chan)
+{
+    if (chan == 14) {
+        return 2484;
+    }
+    if (chan < 14) {    /* 0-13 */
+        return (2407 + (chan*5));
+    }
+    if (chan < 27) {    /* 15-26 */
+        return (2512 + ((chan-15)*20));
+    }
+    return (5000 + (chan*5));
+}
+
+/*
+ * Converts MHz frequency to IEEE channel number.
+ */
+A_UINT32
+wlan_freq2ieee(A_UINT16 freq)
+{
+    if (freq == 2484)
+        return 14;
+    if (freq < 2484)
+        return (freq - 2407) / 5;
+    if (freq < 5000)
+        return 15 + ((freq - 2512) / 20);
+    return (freq - 5000) / 5;
+}
Index: linux-2.6/drivers/sdio/functions/wlan/ar6000/wmi/wmi.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/functions/wlan/ar6000/wmi/wmi.c
@@ -0,0 +1,5199 @@
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * This module implements the hardware independent layer of the
+ * Wireless Module Interface (WMI) protocol.
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/wmi/wmi.c#4 $
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "../include/config.h"
+#include "../include/athdefs.h"
+#include "../include/athtypes.h"
+#include "../include/osapi.h"
+#include "../include/htc.h"
+#include "../include/htc_api.h"
+#include "../include/wmi.h"
+#include "../include/ieee80211.h"
+#include "../include/ieee80211_node.h"
+#include "../include/wlan_api.h"
+#include "../include/wmi_api.h"
+#include "../include/dset_api.h"
+#include "../include/gpio_api.h"
+#include "../include/wmi_host.h"
+#include "../include/athdrv.h"
+#include "../include/a_drv_api.h"
+#include "../include/AR6K_version.h"
+#include "../include/ar6000_drv.h"
+#undef AR_DEBUG_PRINTF
+#include "../include/debug.h"
+#include "../include/dbglog_api.h"
+#include "../include/roaming.h"
+
+static A_STATUS wmi_ready_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+
+static A_STATUS wmi_connect_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                     int len);
+static A_STATUS wmi_disconnect_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                        int len);
+static A_STATUS wmi_tkip_micerr_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                        int len);
+static A_STATUS wmi_bssInfo_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                     int len);
+static A_STATUS wmi_opt_frame_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                       int len);
+static A_STATUS wmi_pstream_timeout_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                     int len);
+static A_STATUS wmi_sync_point(struct wmi_t *wmip);
+
+static A_STATUS wmi_bitrate_reply_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                     int len);
+static A_STATUS wmi_ratemask_reply_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                     int len);
+static A_STATUS wmi_channelList_reply_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                         int len);
+static A_STATUS wmi_regDomain_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                       int len);
+static A_STATUS wmi_txPwr_reply_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_neighborReport_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                             int len);
+
+static A_STATUS wmi_dset_open_req_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                     int len);
+#ifdef CONFIG_HOST_DSET_SUPPORT
+static A_STATUS wmi_dset_close_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_dset_data_req_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                     int len);
+#endif /* CONFIG_HOST_DSET_SUPPORT */
+
+
+static A_STATUS wmi_scanComplete_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                     int len);
+static A_STATUS wmi_errorEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_statsEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_rssiThresholdEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_hbChallengeResp_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_reportErrorEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_cac_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_channel_change_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_roam_tbl_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                      int len);
+static A_STATUS wmi_roam_data_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                      int len);
+static A_STATUS wmi_get_wow_list_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                      int len);
+static A_STATUS
+wmi_get_pmkid_list_event_rx(struct wmi_t *wmip, A_UINT8 *datap, A_UINT32 len);
+
+#ifdef CONFIG_HOST_GPIO_SUPPORT
+static A_STATUS wmi_gpio_intr_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_gpio_data_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_gpio_ack_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+#endif /* CONFIG_HOST_GPIO_SUPPORT */
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+static A_STATUS
+wmi_tcmd_test_report_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+#endif
+
+static A_STATUS
+wmi_txRetryErrEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+
+static A_STATUS
+wmi_snrThresholdEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+
+static A_STATUS
+wmi_lqThresholdEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+
+static A_BOOL
+wmi_is_bitrate_index_valid(struct wmi_t *wmip, A_INT32 rateIndex);
+
+static A_STATUS
+wmi_aplistEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+
+static A_STATUS
+wmi_dbglog_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+
+static A_STATUS wmi_keepalive_reply_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+
+A_STATUS wmi_cmd_send_xtnd(struct wmi_t *wmip, void *osbuf, WMIX_COMMAND_ID cmdId,
+                  WMI_SYNC_FLAG syncflag);
+
+static A_UINT8 ar6000_determine_userPriority( A_UINT8 *pkt, A_UINT32 layer2Pri);
+
+A_UINT8 ar6000_get_upper_threshold(A_INT16 rssi, SQ_THRESHOLD_PARAMS *sq_thresh, A_UINT32 size);
+A_UINT8 ar6000_get_lower_threshold(A_INT16 rssi, SQ_THRESHOLD_PARAMS *sq_thresh, A_UINT32 size);
+
+void wmi_cache_configure_rssithreshold(struct wmi_t *wmip, WMI_RSSI_THRESHOLD_PARAMS_CMD *rssiCmd);
+void wmi_cache_configure_snrthreshold(struct wmi_t *wmip, WMI_SNR_THRESHOLD_PARAMS_CMD *snrCmd);
+static A_STATUS wmi_send_rssi_threshold_params(struct wmi_t *wmip,
+                              WMI_RSSI_THRESHOLD_PARAMS_CMD *rssiCmd);
+static A_STATUS wmi_send_snr_threshold_params(struct wmi_t *wmip,
+                             WMI_SNR_THRESHOLD_PARAMS_CMD *snrCmd);
+#if defined(CONFIG_TARGET_PROFILE_SUPPORT)
+static A_STATUS
+wmi_prof_count_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+#endif /* CONFIG_TARGET_PROFILE_SUPPORT */
+
+int wps_enable;
+static const A_INT32 wmi_rateTable[] = {
+    1000,
+    2000,
+    5500,
+    11000,
+    6000,
+    9000,
+    12000,
+    18000,
+    24000,
+    36000,
+    48000,
+    54000,
+    0};
+
+#define MODE_A_SUPPORT_RATE_START       ((A_INT32) 4)
+#define MODE_A_SUPPORT_RATE_STOP        ((A_INT32) 11)
+
+#define MODE_GONLY_SUPPORT_RATE_START   MODE_A_SUPPORT_RATE_START
+#define MODE_GONLY_SUPPORT_RATE_STOP    MODE_A_SUPPORT_RATE_STOP
+
+#define MODE_B_SUPPORT_RATE_START       ((A_INT32) 0)
+#define MODE_B_SUPPORT_RATE_STOP        ((A_INT32) 3)
+
+#define MODE_G_SUPPORT_RATE_START       ((A_INT32) 0)
+#define MODE_G_SUPPORT_RATE_STOP        ((A_INT32) 11)
+
+#define MAX_NUMBER_OF_SUPPORT_RATES     (MODE_G_SUPPORT_RATE_STOP + 1)
+
+/* 802.1d to AC mapping. Refer pg 57 of WMM-test-plan-v1.2 */
+const A_UINT8 up_to_ac[]= {
+                WMM_AC_BE,
+                WMM_AC_BK,
+                WMM_AC_BK,
+                WMM_AC_BE,
+                WMM_AC_VI,
+                WMM_AC_VI,
+                WMM_AC_VO,
+                WMM_AC_VO,
+            };
+
+/* This stuff is used when we want a simple layer-3 visibility */
+typedef PREPACK struct _iphdr {
+    A_UINT8     ip_ver_hdrlen;          /* version and hdr length */
+    A_UINT8     ip_tos;                 /* type of service */
+    A_UINT16    ip_len;                 /* total length */
+    A_UINT16    ip_id;                  /* identification */
+    A_INT16     ip_off;                 /* fragment offset field */
+#define IP_DF 0x4000                    /* dont fragment flag */
+#define IP_MF 0x2000                    /* more fragments flag */
+#define IP_OFFMASK 0x1fff               /* mask for fragmenting bits */
+    A_UINT8     ip_ttl;                 /* time to live */
+    A_UINT8     ip_p;                   /* protocol */
+    A_UINT16    ip_sum;                 /* checksum */
+    A_UINT8     ip_src[4];              /* source and dest address */
+    A_UINT8     ip_dst[4];
+} POSTPACK iphdr;
+
+
+void *
+wmi_init(void *devt)
+{
+    struct wmi_t *wmip;
+
+    wmip = A_MALLOC(sizeof(struct wmi_t));
+    if (wmip == NULL) {
+        return (NULL);
+    }
+    A_MEMZERO(wmip, sizeof(*wmip));
+    A_MUTEX_INIT(&wmip->wmi_lock);
+    wmip->wmi_devt = devt;
+    wlan_node_table_init(wmip, &wmip->wmi_scan_table);
+    wmi_qos_state_init(wmip);
+    wmip->wmi_powerMode = REC_POWER;
+    wmip->wmi_phyMode = WMI_11G_MODE;
+
+    return (wmip);
+}
+
+void
+wmi_qos_state_init(struct wmi_t *wmip)
+{
+    A_UINT8 i;
+
+    if (wmip == NULL) {
+        return;
+    }
+    LOCK_WMI(wmip);
+
+    /* Initialize QoS States */
+    wmip->wmi_numQoSStream = 0;
+
+    wmip->wmi_fatPipeExists = 0;
+
+    for (i=0; i < WMM_NUM_AC; i++) {
+        wmip->wmi_streamExistsForAC[i]=0;
+    }
+
+    UNLOCK_WMI(wmip);
+
+    A_WMI_SET_NUMDATAENDPTS(wmip->wmi_devt, 1);
+}
+
+void
+wmi_set_control_ep(struct wmi_t * wmip, HTC_ENDPOINT_ID eid)
+{
+    A_ASSERT( eid != ENDPOINT_UNUSED);
+    wmip->wmi_endpoint_id = eid;
+}
+
+HTC_ENDPOINT_ID
+wmi_get_control_ep(struct wmi_t * wmip)
+{
+    return(wmip->wmi_endpoint_id);
+}
+
+void
+wmi_shutdown(struct wmi_t *wmip)
+{
+    if (wmip != NULL) {
+        wlan_node_table_cleanup(&wmip->wmi_scan_table);
+        if (A_IS_MUTEX_VALID(&wmip->wmi_lock)) {
+            A_MUTEX_DELETE(&wmip->wmi_lock);
+        }
+        A_FREE(wmip);
+    }
+}
+
+/*
+ *  performs DIX to 802.3 encapsulation for transmit packets.
+ *  uses passed in buffer.  Returns buffer or NULL if failed.
+ *  Assumes the entire DIX header is contigous and that there is
+ *  enough room in the buffer for a 802.3 mac header and LLC+SNAP headers.
+ */
+A_STATUS
+wmi_dix_2_dot3(struct wmi_t *wmip, void *osbuf)
+{
+    A_UINT8          *datap;
+    A_UINT16         typeorlen;
+    ATH_MAC_HDR      macHdr;
+    ATH_LLC_SNAP_HDR *llcHdr;
+
+    A_ASSERT(osbuf != NULL);
+
+    if (A_NETBUF_HEADROOM(osbuf) <
+        (sizeof(ATH_LLC_SNAP_HDR) + sizeof(WMI_DATA_HDR)))
+    {
+        return A_NO_MEMORY;
+    }
+
+    datap = A_NETBUF_DATA(osbuf);
+
+    typeorlen = *(A_UINT16 *)(datap + ATH_MAC_LEN + ATH_MAC_LEN);
+
+    if (!IS_ETHERTYPE(A_BE2CPU16(typeorlen))) {
+        /*
+         * packet is already in 802.3 format - return success
+         */
+        A_DPRINTF(DBG_WMI, (DBGFMT "packet already 802.3\n", DBGARG));
+        return (A_OK);
+    }
+
+    /*
+     * Save mac fields and length to be inserted later
+     */
+    A_MEMCPY(macHdr.dstMac, datap, ATH_MAC_LEN);
+    A_MEMCPY(macHdr.srcMac, datap + ATH_MAC_LEN, ATH_MAC_LEN);
+    macHdr.typeOrLen = A_CPU2BE16(A_NETBUF_LEN(osbuf) - sizeof(ATH_MAC_HDR) +
+                                  sizeof(ATH_LLC_SNAP_HDR));
+
+    /*
+     * Make room for LLC+SNAP headers
+     */
+    if (A_NETBUF_PUSH(osbuf, sizeof(ATH_LLC_SNAP_HDR)) != A_OK) {
+        return A_NO_MEMORY;
+    }
+
+    datap = A_NETBUF_DATA(osbuf);
+
+    A_MEMCPY(datap, &macHdr, sizeof (ATH_MAC_HDR));
+
+    llcHdr = (ATH_LLC_SNAP_HDR *)(datap + sizeof(ATH_MAC_HDR));
+    llcHdr->dsap      = 0xAA;
+    llcHdr->ssap      = 0xAA;
+    llcHdr->cntl      = 0x03;
+    llcHdr->orgCode[0] = 0x0;
+    llcHdr->orgCode[1] = 0x0;
+    llcHdr->orgCode[2] = 0x0;
+    llcHdr->etherType = typeorlen;
+
+    return (A_OK);
+}
+
+/*
+ * Adds a WMI data header
+ * Assumes there is enough room in the buffer to add header.
+ */
+A_STATUS
+wmi_data_hdr_add(struct wmi_t *wmip, void *osbuf, A_UINT8 msgType)
+{
+    WMI_DATA_HDR     *dtHdr;
+
+    A_ASSERT(osbuf != NULL);
+
+    if (A_NETBUF_PUSH(osbuf, sizeof(WMI_DATA_HDR)) != A_OK) {
+        return A_NO_MEMORY;
+    }
+
+    dtHdr = (WMI_DATA_HDR *)A_NETBUF_DATA(osbuf);
+    dtHdr->info = msgType;
+    dtHdr->rssi = 0;
+
+    return (A_OK);
+}
+
+A_UINT8 wmi_implicit_create_pstream(struct wmi_t *wmip, void *osbuf, A_UINT32 layer2Priority, A_BOOL wmmEnabled)
+{
+    A_UINT8         *datap;
+    A_UINT8         trafficClass = WMM_AC_BE;
+    ATH_LLC_SNAP_HDR *llcHdr;
+    A_UINT16        ipType = IP_ETHERTYPE;
+    WMI_DATA_HDR     *dtHdr;
+    WMI_CREATE_PSTREAM_CMD  cmd;
+    A_BOOL           streamExists = FALSE;
+    A_UINT8        userPriority;
+
+    A_ASSERT(osbuf != NULL);
+
+    datap = A_NETBUF_DATA(osbuf);
+
+    if (!wmmEnabled) {
+            /* If WMM is disabled all traffic goes as BE traffic */
+        userPriority = 0;
+    } else {
+    llcHdr = (ATH_LLC_SNAP_HDR *)(datap + sizeof(WMI_DATA_HDR) +
+                                  sizeof(ATH_MAC_HDR));
+
+        if (llcHdr->etherType == A_CPU2BE16(ipType)) {
+        /* Extract the endpoint info from the TOS field in the IP header */
+
+            userPriority = ar6000_determine_userPriority(((A_UINT8 *)llcHdr) + sizeof(ATH_LLC_SNAP_HDR),layer2Priority);
+        } else {
+            userPriority = layer2Priority & 0x7;
+        }
+    }
+
+        trafficClass = convert_userPriority_to_trafficClass(userPriority);
+
+    dtHdr = (WMI_DATA_HDR *)datap;
+        dtHdr->info |= (userPriority & WMI_DATA_HDR_UP_MASK) << WMI_DATA_HDR_UP_SHIFT;  /* lower 3-bits are 802.1d priority */
+
+    LOCK_WMI(wmip);
+    streamExists = wmip->wmi_fatPipeExists;
+    UNLOCK_WMI(wmip);
+
+    if (!(streamExists & (1 << trafficClass))) {
+
+        A_MEMZERO(&cmd, sizeof(cmd));
+	    cmd.trafficClass = trafficClass;
+	    cmd.userPriority = userPriority;
+		cmd.inactivityInt = WMI_IMPLICIT_PSTREAM_INACTIVITY_INT;
+            /* Implicit streams are created with TSID 0xFF */
+        cmd.tsid = WMI_IMPLICIT_PSTREAM;
+        wmi_create_pstream_cmd(wmip, &cmd);
+    }
+
+    return trafficClass;
+}
+
+/*
+ *  performs 802.3 to DIX encapsulation for received packets.
+ *  Assumes the entire 802.3 header is contigous.
+ */
+A_STATUS
+wmi_dot3_2_dix(struct wmi_t *wmip, void *osbuf)
+{
+    A_UINT8          *datap;
+    ATH_MAC_HDR      macHdr;
+    ATH_LLC_SNAP_HDR *llcHdr;
+
+    A_ASSERT(osbuf != NULL);
+    datap = A_NETBUF_DATA(osbuf);
+
+    A_MEMCPY(&macHdr, datap, sizeof(ATH_MAC_HDR));
+    llcHdr = (ATH_LLC_SNAP_HDR *)(datap + sizeof(ATH_MAC_HDR));
+    macHdr.typeOrLen = llcHdr->etherType;
+
+    if (A_NETBUF_PULL(osbuf, sizeof(ATH_LLC_SNAP_HDR)) != A_OK) {
+        return A_NO_MEMORY;
+    }
+
+    datap = A_NETBUF_DATA(osbuf);
+
+    A_MEMCPY(datap, &macHdr, sizeof (ATH_MAC_HDR));
+
+    return (A_OK);
+}
+
+/*
+ * Removes a WMI data header
+ */
+A_STATUS
+wmi_data_hdr_remove(struct wmi_t *wmip, void *osbuf)
+{
+    A_ASSERT(osbuf != NULL);
+
+    return (A_NETBUF_PULL(osbuf, sizeof(WMI_DATA_HDR)));
+}
+
+void
+wmi_iterate_nodes(struct wmi_t *wmip, wlan_node_iter_func *f, void *arg)
+{
+    wlan_iterate_nodes(&wmip->wmi_scan_table, f, arg);
+}
+
+/*
+ * WMI Extended Event received from Target.
+ */
+A_STATUS
+wmi_control_rx_xtnd(struct wmi_t *wmip, void *osbuf)
+{
+    WMIX_CMD_HDR *cmd;
+    A_UINT16 id;
+    A_UINT8 *datap;
+    A_UINT32 len;
+    A_STATUS status = A_OK;
+
+    if (A_NETBUF_LEN(osbuf) < sizeof(WMIX_CMD_HDR)) {
+        A_DPRINTF(DBG_WMI, (DBGFMT "bad packet 1\n", DBGARG));
+        wmip->wmi_stats.cmd_len_err++;
+        A_NETBUF_FREE(osbuf);
+        return A_ERROR;
+    }
+
+    cmd = (WMIX_CMD_HDR *)A_NETBUF_DATA(osbuf);
+    id = cmd->commandId;
+
+    if (A_NETBUF_PULL(osbuf, sizeof(WMIX_CMD_HDR)) != A_OK) {
+        A_DPRINTF(DBG_WMI, (DBGFMT "bad packet 2\n", DBGARG));
+        wmip->wmi_stats.cmd_len_err++;
+        A_NETBUF_FREE(osbuf);
+        return A_ERROR;
+    }
+
+    datap = A_NETBUF_DATA(osbuf);
+    len = A_NETBUF_LEN(osbuf);
+
+    switch (id) {
+    case (WMIX_DSETOPENREQ_EVENTID):
+        status = wmi_dset_open_req_rx(wmip, datap, len);
+        break;
+#ifdef CONFIG_HOST_DSET_SUPPORT
+    case (WMIX_DSETCLOSE_EVENTID):
+        status = wmi_dset_close_rx(wmip, datap, len);
+        break;
+    case (WMIX_DSETDATAREQ_EVENTID):
+        status = wmi_dset_data_req_rx(wmip, datap, len);
+        break;
+#endif /* CONFIG_HOST_DSET_SUPPORT */
+#ifdef CONFIG_HOST_GPIO_SUPPORT
+    case (WMIX_GPIO_INTR_EVENTID):
+        wmi_gpio_intr_rx(wmip, datap, len);
+        break;
+    case (WMIX_GPIO_DATA_EVENTID):
+        wmi_gpio_data_rx(wmip, datap, len);
+        break;
+    case (WMIX_GPIO_ACK_EVENTID):
+        wmi_gpio_ack_rx(wmip, datap, len);
+        break;
+#endif /* CONFIG_HOST_GPIO_SUPPORT */
+    case (WMIX_HB_CHALLENGE_RESP_EVENTID):
+        wmi_hbChallengeResp_rx(wmip, datap, len);
+        break;
+    case (WMIX_DBGLOG_EVENTID):
+        wmi_dbglog_event_rx(wmip, datap, len);
+        break;
+#if defined(CONFIG_TARGET_PROFILE_SUPPORT)
+    case (WMIX_PROF_COUNT_EVENTID):
+        wmi_prof_count_rx(wmip, datap, len);
+        break;
+#endif /* CONFIG_TARGET_PROFILE_SUPPORT */
+    default:
+        A_DPRINTF(DBG_WMI|DBG_ERROR,
+            (DBGFMT "Unknown id 0x%x\n", DBGARG, id));
+        wmip->wmi_stats.cmd_id_err++;
+        status = A_ERROR;
+        break;
+    }
+
+    return status;
+}
+
+/*
+ * Control Path
+ */
+A_UINT32 cmdRecvNum;
+
+A_STATUS
+wmi_control_rx(struct wmi_t *wmip, void *osbuf)
+{
+    WMI_CMD_HDR *cmd;
+    A_UINT16 id;
+    A_UINT8 *datap;
+    A_UINT32 len, i, loggingReq;
+    A_STATUS status = A_OK;
+
+    A_ASSERT(osbuf != NULL);
+    if (A_NETBUF_LEN(osbuf) < sizeof(WMI_CMD_HDR)) {
+        A_DPRINTF(DBG_WMI, (DBGFMT "bad packet 1\n", DBGARG));
+        wmip->wmi_stats.cmd_len_err++;
+        A_NETBUF_FREE(osbuf);
+        return A_ERROR;
+    }
+
+    cmd = (WMI_CMD_HDR *)A_NETBUF_DATA(osbuf);
+    id = cmd->commandId;
+
+    if (A_NETBUF_PULL(osbuf, sizeof(WMI_CMD_HDR)) != A_OK) {
+        A_DPRINTF(DBG_WMI, (DBGFMT "bad packet 2\n", DBGARG));
+        wmip->wmi_stats.cmd_len_err++;
+        A_NETBUF_FREE(osbuf);
+        return A_ERROR;
+    }
+
+    datap = A_NETBUF_DATA(osbuf);
+    len = A_NETBUF_LEN(osbuf);
+
+    loggingReq = 0;
+
+    ar6000_get_driver_cfg(wmip->wmi_devt,
+                    AR6000_DRIVER_CFG_LOG_RAW_WMI_MSGS,
+                    &loggingReq);
+
+    if(loggingReq) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("WMI %d \n",id));
+        AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("WMI recv, MsgNo %d : ", cmdRecvNum));
+        for(i = 0; i < len; i++)
+            AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("%x ", datap[i]));
+        AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("\n"));
+    }
+
+    LOCK_WMI(wmip);
+    cmdRecvNum++;
+    UNLOCK_WMI(wmip);
+
+    switch (id) {
+    case (WMI_GET_BITRATE_CMDID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_GET_BITRATE_CMDID\n", DBGARG));
+        status = wmi_bitrate_reply_rx(wmip, datap, len);
+        break;
+    case (WMI_GET_CHANNEL_LIST_CMDID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_GET_CHANNEL_LIST_CMDID\n", DBGARG));
+        status = wmi_channelList_reply_rx(wmip, datap, len);
+        break;
+    case (WMI_GET_TX_PWR_CMDID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_GET_TX_PWR_CMDID\n", DBGARG));
+        status = wmi_txPwr_reply_rx(wmip, datap, len);
+        break;
+    case (WMI_READY_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_READY_EVENTID\n", DBGARG));
+        status = wmi_ready_event_rx(wmip, datap, len);
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        A_WMI_DBGLOG_INIT_DONE(wmip->wmi_devt);
+        break;
+    case (WMI_CONNECT_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_CONNECT_EVENTID\n", DBGARG));
+        status = wmi_connect_event_rx(wmip, datap, len);
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        break;
+    case (WMI_DISCONNECT_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_DISCONNECT_EVENTID\n", DBGARG));
+        status = wmi_disconnect_event_rx(wmip, datap, len);
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        break;
+    case (WMI_TKIP_MICERR_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_TKIP_MICERR_EVENTID\n", DBGARG));
+        status = wmi_tkip_micerr_event_rx(wmip, datap, len);
+        break;
+    case (WMI_BSSINFO_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_BSSINFO_EVENTID\n", DBGARG));
+        status = wmi_bssInfo_event_rx(wmip, datap, len);
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        break;
+    case (WMI_REGDOMAIN_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_REGDOMAIN_EVENTID\n", DBGARG));
+        status = wmi_regDomain_event_rx(wmip, datap, len);
+        break;
+    case (WMI_PSTREAM_TIMEOUT_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_PSTREAM_TIMEOUT_EVENTID\n", DBGARG));
+        status = wmi_pstream_timeout_event_rx(wmip, datap, len);
+            /* pstreams are fatpipe abstractions that get implicitly created.
+             * User apps only deal with thinstreams. creation of a thinstream
+             * by the user or data traffic flow in an AC triggers implicit
+             * pstream creation. Do we need to send this event to App..?
+             * no harm in sending it.
+             */
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        break;
+    case (WMI_NEIGHBOR_REPORT_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_NEIGHBOR_REPORT_EVENTID\n", DBGARG));
+        status = wmi_neighborReport_event_rx(wmip, datap, len);
+        break;
+    case (WMI_SCAN_COMPLETE_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_SCAN_COMPLETE_EVENTID\n", DBGARG));
+        status = wmi_scanComplete_rx(wmip, datap, len);
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        break;
+    case (WMI_CMDERROR_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_CMDERROR_EVENTID\n", DBGARG));
+        status = wmi_errorEvent_rx(wmip, datap, len);
+        break;
+    case (WMI_REPORT_STATISTICS_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_REPORT_STATISTICS_EVENTID\n", DBGARG));
+        status = wmi_statsEvent_rx(wmip, datap, len);
+        break;
+    case (WMI_RSSI_THRESHOLD_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_RSSI_THRESHOLD_EVENTID\n", DBGARG));
+        status = wmi_rssiThresholdEvent_rx(wmip, datap, len);
+        break;
+    case (WMI_ERROR_REPORT_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_ERROR_REPORT_EVENTID\n", DBGARG));
+        status = wmi_reportErrorEvent_rx(wmip, datap, len);
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        break;
+    case (WMI_OPT_RX_FRAME_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_OPT_RX_FRAME_EVENTID\n", DBGARG));
+        status = wmi_opt_frame_event_rx(wmip, datap, len);
+        break;
+    case (WMI_REPORT_ROAM_TBL_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_REPORT_ROAM_TBL_EVENTID\n", DBGARG));
+        status = wmi_roam_tbl_event_rx(wmip, datap, len);
+        break;
+    case (WMI_EXTENSION_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_EXTENSION_EVENTID\n", DBGARG));
+        status = wmi_control_rx_xtnd(wmip, osbuf);
+        break;
+    case (WMI_CAC_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_CAC_EVENTID\n", DBGARG));
+        status = wmi_cac_event_rx(wmip, datap, len);
+        break;
+    case (WMI_CHANNEL_CHANGE_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_CHANNEL_CHANGE_EVENTID\n", DBGARG));
+        status = wmi_channel_change_event_rx(wmip, datap, len);
+        break;
+    case (WMI_REPORT_ROAM_DATA_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_REPORT_ROAM_DATA_EVENTID\n", DBGARG));
+        status = wmi_roam_data_event_rx(wmip, datap, len);
+        break;
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+    case (WMI_TEST_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_TEST_EVENTID\n", DBGARG));
+        status = wmi_tcmd_test_report_rx(wmip, datap, len);
+        break;
+#endif
+    case (WMI_GET_FIXRATES_CMDID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_GET_FIXRATES_CMDID\n", DBGARG));
+        status = wmi_ratemask_reply_rx(wmip, datap, len);
+        break;
+    case (WMI_TX_RETRY_ERR_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_TX_RETRY_ERR_EVENTID\n", DBGARG));
+        status = wmi_txRetryErrEvent_rx(wmip, datap, len);
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        break;
+    case (WMI_SNR_THRESHOLD_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_SNR_THRESHOLD_EVENTID\n", DBGARG));
+        status = wmi_snrThresholdEvent_rx(wmip, datap, len);
+        break;
+    case (WMI_LQ_THRESHOLD_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_LQ_THRESHOLD_EVENTID\n", DBGARG));
+        status = wmi_lqThresholdEvent_rx(wmip, datap, len);
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        break;
+    case (WMI_APLIST_EVENTID):
+        AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("Received APLIST Event\n"));
+        status = wmi_aplistEvent_rx(wmip, datap, len);
+        break;
+    case (WMI_GET_KEEPALIVE_CMDID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_GET_KEEPALIVE_CMDID\n", DBGARG));
+        status = wmi_keepalive_reply_rx(wmip, datap, len);
+        break;
+    case (WMI_GET_WOW_LIST_EVENTID):
+        status = wmi_get_wow_list_event_rx(wmip, datap, len);
+        break;
+    case (WMI_GET_PMKID_LIST_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_GET_PMKID_LIST Event\n", DBGARG));
+        status = wmi_get_pmkid_list_event_rx(wmip, datap, len);
+        break;
+    default:
+        A_DPRINTF(DBG_WMI|DBG_ERROR,
+            (DBGFMT "Unknown id 0x%x\n", DBGARG, id));
+        wmip->wmi_stats.cmd_id_err++;
+        status = A_ERROR;
+        break;
+    }
+
+    A_NETBUF_FREE(osbuf);
+
+    return status;
+}
+
+/* Send a "simple" wmi command -- one with no arguments */
+static A_STATUS
+wmi_simple_cmd(struct wmi_t *wmip, WMI_COMMAND_ID cmdid)
+{
+    void *osbuf;
+
+    osbuf = A_NETBUF_ALLOC(0);
+
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, cmdid, NO_SYNC_WMIFLAG));
+}
+
+/* Send a "simple" extended wmi command -- one with no arguments.
+   Enabling this command only if GPIO or profiling support is enabled.
+   This is to suppress warnings on some platforms */
+#if defined(CONFIG_HOST_GPIO_SUPPORT) || defined(CONFIG_TARGET_PROFILE_SUPPORT)
+static A_STATUS
+wmi_simple_cmd_xtnd(struct wmi_t *wmip, WMIX_COMMAND_ID cmdid)
+{
+    void *osbuf;
+
+    osbuf = A_NETBUF_ALLOC(0);
+
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, cmdid, NO_SYNC_WMIFLAG));
+}
+#endif
+
+/* for backwards compatibility with pre-2.1.x firmware */
+static A_STATUS
+wmi_ready_event_rx_1(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_READY_EVENT_1 *ev = (WMI_READY_EVENT_1 *)datap;
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+    if (len < sizeof(WMI_READY_EVENT_1)) {
+        return A_EINVAL;
+    }
+    wmip->wmi_ready = TRUE;
+    A_WMI_READY_EVENT(wmip->wmi_devt, ev->macaddr, ev->phyCapability, 0);
+
+    return A_OK;
+}
+
+/* for version 2.1.x firmware */
+static A_STATUS
+wmi_ready_event_rx_2(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_READY_EVENT_2 *ev = (WMI_READY_EVENT_2 *)datap;
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+    if (len < sizeof(WMI_READY_EVENT_2)) {
+        return A_EINVAL;
+    }
+    wmip->wmi_ready = TRUE;
+    A_WMI_READY_EVENT(wmip->wmi_devt, ev->macaddr, ev->phyCapability,
+                      ev->version);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_ready_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    A_STATUS status;
+
+    if ((WMI_TARGET_TYPE(wmip) == TARGET_TYPE_AR6001)
+        && (WMI_TARGET_VERSION(wmip) < AR6K_VERSION(2, 1, 0, 0)))
+    {
+        status = wmi_ready_event_rx_1(wmip, datap, len);
+    } else
+        status = wmi_ready_event_rx_2(wmip, datap, len);
+
+    return status;
+}
+
+static A_STATUS
+wmi_connect_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_CONNECT_EVENT *ev;
+
+    if (len < sizeof(WMI_CONNECT_EVENT)) {
+        return A_EINVAL;
+    }
+    ev = (WMI_CONNECT_EVENT *)datap;
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "freq %d bssid %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\n",
+        DBGARG, ev->channel,
+        ev->bssid[0], ev->bssid[1], ev->bssid[2],
+        ev->bssid[3], ev->bssid[4], ev->bssid[5]));
+
+    A_MEMCPY(wmip->wmi_bssid, ev->bssid, ATH_MAC_LEN);
+
+    A_WMI_CONNECT_EVENT(wmip->wmi_devt, ev->channel, ev->bssid,
+                         ev->listenInterval, ev->beaconInterval,
+                         (NETWORK_TYPE) ev->networkType, ev->beaconIeLen,
+                         ev->assocReqLen, ev->assocRespLen,
+                         ev->assocInfo);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_regDomain_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_REG_DOMAIN_EVENT *ev;
+
+    if (len < sizeof(*ev)) {
+        return A_EINVAL;
+    }
+    ev = (WMI_REG_DOMAIN_EVENT *)datap;
+
+    A_WMI_REGDOMAIN_EVENT(wmip->wmi_devt, ev->regDomain);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_neighborReport_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_NEIGHBOR_REPORT_EVENT *ev;
+    int numAps;
+
+    if (len < sizeof(*ev)) {
+        return A_EINVAL;
+    }
+    ev = (WMI_NEIGHBOR_REPORT_EVENT *)datap;
+    numAps = ev->numberOfAps;
+
+    if (len < (int)(sizeof(*ev) + ((numAps - 1) * sizeof(WMI_NEIGHBOR_INFO)))) {
+        return A_EINVAL;
+    }
+
+    A_WMI_NEIGHBORREPORT_EVENT(wmip->wmi_devt, numAps, ev->neighbor);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_disconnect_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_DISCONNECT_EVENT *ev;
+
+    if (len < sizeof(WMI_DISCONNECT_EVENT)) {
+        return A_EINVAL;
+    }
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    ev = (WMI_DISCONNECT_EVENT *)datap;
+
+    A_MEMZERO(wmip->wmi_bssid, sizeof(wmip->wmi_bssid));
+
+    A_WMI_DISCONNECT_EVENT(wmip->wmi_devt, ev->disconnectReason, ev->bssid,
+                            ev->assocRespLen, ev->assocInfo, ev->protocolReasonStatus);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_tkip_micerr_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_TKIP_MICERR_EVENT *ev;
+
+    if (len < sizeof(*ev)) {
+        return A_EINVAL;
+    }
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    ev = (WMI_TKIP_MICERR_EVENT *)datap;
+    A_WMI_TKIP_MICERR_EVENT(wmip->wmi_devt, ev->keyid, ev->ismcast);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_bssInfo_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    bss_t *bss = NULL;
+    WMI_BSS_INFO_HDR *bih;
+    A_UINT8 *buf;
+    A_UINT32 nodeCachingAllowed = 1;
+
+    if (len <= sizeof(WMI_BSS_INFO_HDR)) {
+        return A_EINVAL;
+    }
+
+    bih = (WMI_BSS_INFO_HDR *)datap;
+    bss = wlan_find_node(&wmip->wmi_scan_table, bih->bssid);
+
+    if (bih->rssi > 0) {
+        if (NULL == bss)
+            return A_OK;  //no node found in the table, just drop the node with incorrect RSSI
+        else
+            bih->rssi = bss->ni_rssi; //Adjust RSSI in datap in case it is used in A_WMI_BSSINFO_EVENT_RX
+    }
+
+    A_WMI_BSSINFO_EVENT_RX(wmip->wmi_devt, datap, len);
+    /* What is driver config for wlan node caching? */
+    if(ar6000_get_driver_cfg(wmip->wmi_devt,
+                    AR6000_DRIVER_CFG_GET_WLANNODECACHING,
+                    &nodeCachingAllowed) != A_OK)
+    {
+        if (bss)
+            wlan_node_return(&wmip->wmi_scan_table, bss);
+        return A_EINVAL;
+    }
+
+    if(!nodeCachingAllowed) {
+        if (bss)
+            wlan_node_return(&wmip->wmi_scan_table, bss);
+        return A_OK;
+    }
+
+    buf = datap + sizeof(WMI_BSS_INFO_HDR);
+    len -= sizeof(WMI_BSS_INFO_HDR);
+
+    A_DPRINTF(DBG_WMI2, (DBGFMT "bssInfo event - ch %u, rssi %02x, "
+              "bssid \"%02x:%02x:%02x:%02x:%02x:%02x\"\n", DBGARG,
+              bih->channel, (unsigned char) bih->rssi, bih->bssid[0],
+              bih->bssid[1], bih->bssid[2], bih->bssid[3], bih->bssid[4],
+              bih->bssid[5]));
+
+    if(wps_enable && (bih->frameType == PROBERESP_FTYPE) ) {
+        if (bss)
+            wlan_node_return(&wmip->wmi_scan_table, bss);
+        return A_OK;
+    }
+
+    if (bss != NULL) {
+        /*
+         * Free up the node.  Not the most efficient process given
+         * we are about to allocate a new node but it is simple and should be
+         * adequate.
+         */
+        wlan_node_reclaim(&wmip->wmi_scan_table, bss);
+    }
+
+    bss = wlan_node_alloc(&wmip->wmi_scan_table, len);
+    if (bss == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    bss->ni_snr        = bih->snr;
+    bss->ni_rssi       = bih->rssi;
+    A_ASSERT(bss->ni_buf != NULL);
+    A_MEMCPY(bss->ni_buf, buf, len);
+
+    if (wlan_parse_beacon(bss->ni_buf, len, &bss->ni_cie) != A_OK) {
+        wlan_node_free(bss);
+        return A_EINVAL;
+    }
+
+    /*
+     * Update the frequency in ie_chan, overwriting of channel number
+     * which is done in wlan_parse_beacon
+     */
+    bss->ni_cie.ie_chan = bih->channel;
+    wlan_setup_node(&wmip->wmi_scan_table, bss, bih->bssid);
+    wlan_node_return(&wmip->wmi_scan_table, bss);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_opt_frame_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    bss_t *bss;
+    WMI_OPT_RX_INFO_HDR *bih;
+    A_UINT8 *buf;
+
+    if (len <= sizeof(WMI_OPT_RX_INFO_HDR)) {
+        return A_EINVAL;
+    }
+
+    bih = (WMI_OPT_RX_INFO_HDR *)datap;
+    buf = datap + sizeof(WMI_OPT_RX_INFO_HDR);
+    len -= sizeof(WMI_OPT_RX_INFO_HDR);
+
+    A_DPRINTF(DBG_WMI2, (DBGFMT "opt frame event %2.2x:%2.2x\n", DBGARG,
+        bih->bssid[4], bih->bssid[5]));
+
+    bss = wlan_find_node(&wmip->wmi_scan_table, bih->bssid);
+    if (bss != NULL) {
+        /*
+         * Free up the node.  Not the most efficient process given
+         * we are about to allocate a new node but it is simple and should be
+         * adequate.
+         */
+        wlan_node_reclaim(&wmip->wmi_scan_table, bss);
+    }
+
+    bss = wlan_node_alloc(&wmip->wmi_scan_table, len);
+    if (bss == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    bss->ni_snr        = bih->snr;
+    bss->ni_cie.ie_chan = bih->channel;
+    A_ASSERT(bss->ni_buf != NULL);
+    A_MEMCPY(bss->ni_buf, buf, len);
+    wlan_setup_node(&wmip->wmi_scan_table, bss, bih->bssid);
+    wlan_node_return(&wmip->wmi_scan_table, bss);
+
+    return A_OK;
+}
+
+/* for backwards compatibility with pre-2.1.x firmware */
+static A_STATUS
+wmi_pstream_timeout_event_rx_1(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_PSTREAM_TIMEOUT_EVENT_1 *ev;
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "wmi_pstream_timeout_event_rx_1\n", DBGARG));
+
+    if (len < sizeof(WMI_PSTREAM_TIMEOUT_EVENT_1)) {
+        return A_EINVAL;
+    }
+
+    ev = (WMI_PSTREAM_TIMEOUT_EVENT_1 *)datap;
+
+        /* When the pstream (fat pipe == AC) timesout, it means there were no
+         * thinStreams within this pstream & it got implicitly created due to
+         * data flow on this AC. We start the inactivity timer only for
+         * implicitly created pstream. Just reset the host state.
+         */
+        /* Set the activeTsids for this AC to 0 */
+    LOCK_WMI(wmip);
+    wmip->wmi_streamExistsForAC[ev->trafficClass]=0;
+    wmip->wmi_fatPipeExists &= ~(1 << ev->trafficClass);
+    UNLOCK_WMI(wmip);
+
+        /*Indicate inactivity to driver layer for this fatpipe (pstream)*/
+    A_WMI_STREAM_TX_INACTIVE(wmip->wmi_devt, ev->trafficClass);
+
+    return A_OK;
+}
+
+/* for version 2.1.x firmware */
+static A_STATUS
+wmi_pstream_timeout_event_rx_2(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_PSTREAM_TIMEOUT_EVENT_2 *ev;
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "wmi_pstream_timeout_event_rx_2\n", DBGARG));
+
+    if (len < sizeof(WMI_PSTREAM_TIMEOUT_EVENT_2)) {
+        return A_EINVAL;
+    }
+
+    ev = (WMI_PSTREAM_TIMEOUT_EVENT_2 *)datap;
+
+        /* When the pstream (fat pipe == AC) timesout, it means there were no
+         * thinStreams within this pstream & it got implicitly created due to
+         * data flow on this AC. We start the inactivity timer only for
+         * implicitly created pstream. Just reset the host state.
+         */
+        /* Set the activeTsids for this AC to 0 */
+    LOCK_WMI(wmip);
+    wmip->wmi_streamExistsForAC[ev->trafficClass]=0;
+    wmip->wmi_fatPipeExists &= ~(1 << ev->trafficClass);
+    UNLOCK_WMI(wmip);
+
+        /*Indicate inactivity to driver layer for this fatpipe (pstream)*/
+    A_WMI_STREAM_TX_INACTIVE(wmip->wmi_devt, ev->trafficClass);
+
+    return A_OK;
+}
+
+    /* This event indicates inactivity timeout of a fatpipe(pstream)
+     * at the target
+     */
+static A_STATUS
+wmi_pstream_timeout_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    A_STATUS status;
+
+    if ((WMI_TARGET_TYPE(wmip) == TARGET_TYPE_AR6001)
+        && (WMI_TARGET_VERSION(wmip) < AR6K_VERSION(2, 1, 0, 0)))
+    {
+        status = wmi_pstream_timeout_event_rx_1(wmip, datap, len);
+    } else
+        status = wmi_pstream_timeout_event_rx_2(wmip, datap, len);
+
+    return status;
+}
+
+static A_STATUS
+wmi_bitrate_reply_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_BIT_RATE_CMD *reply;
+    A_INT32 rate;
+
+    if (len < sizeof(WMI_BIT_RATE_CMD)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_BIT_RATE_CMD *)datap;
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Enter - rateindex %d\n", DBGARG, reply->rateIndex));
+
+    if (reply->rateIndex == (A_INT8) RATE_AUTO) {
+        rate = RATE_AUTO;
+    } else {
+        rate = wmi_rateTable[(A_UINT32) reply->rateIndex];
+    }
+
+    A_WMI_BITRATE_RX(wmip->wmi_devt, rate);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_ratemask_reply_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_FIX_RATES_CMD *reply;
+
+    if (len < sizeof(WMI_BIT_RATE_CMD)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_FIX_RATES_CMD *)datap;
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Enter - fixed rate mask %x\n", DBGARG, reply->fixRateMask));
+
+    A_WMI_RATEMASK_RX(wmip->wmi_devt, reply->fixRateMask);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_channelList_reply_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_CHANNEL_LIST_REPLY *reply;
+
+    if (len < sizeof(WMI_CHANNEL_LIST_REPLY)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_CHANNEL_LIST_REPLY *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_CHANNELLIST_RX(wmip->wmi_devt, reply->numChannels,
+                          reply->channelList);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_txPwr_reply_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_TX_PWR_REPLY *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_TX_PWR_REPLY *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_TXPWR_RX(wmip->wmi_devt, reply->dbM);
+
+    return A_OK;
+}
+static A_STATUS
+wmi_keepalive_reply_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_GET_KEEPALIVE_CMD *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_GET_KEEPALIVE_CMD *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_KEEPALIVE_RX(wmip->wmi_devt, reply->configured);
+
+    return A_OK;
+}
+
+
+static A_STATUS
+wmi_dset_open_req_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMIX_DSETOPENREQ_EVENT *dsetopenreq;
+
+    if (len < sizeof(WMIX_DSETOPENREQ_EVENT)) {
+        return A_EINVAL;
+    }
+    dsetopenreq = (WMIX_DSETOPENREQ_EVENT *)datap;
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Enter - dset_id=0x%x\n", DBGARG, dsetopenreq->dset_id));
+    A_WMI_DSET_OPEN_REQ(wmip->wmi_devt,
+                        dsetopenreq->dset_id,
+                        dsetopenreq->targ_dset_handle,
+                        dsetopenreq->targ_reply_fn,
+                        dsetopenreq->targ_reply_arg);
+
+    return A_OK;
+}
+
+#ifdef CONFIG_HOST_DSET_SUPPORT
+static A_STATUS
+wmi_dset_close_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMIX_DSETCLOSE_EVENT *dsetclose;
+
+    if (len < sizeof(WMIX_DSETCLOSE_EVENT)) {
+        return A_EINVAL;
+    }
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    dsetclose = (WMIX_DSETCLOSE_EVENT *)datap;
+    A_WMI_DSET_CLOSE(wmip->wmi_devt, dsetclose->access_cookie);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_dset_data_req_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMIX_DSETDATAREQ_EVENT *dsetdatareq;
+
+    if (len < sizeof(WMIX_DSETDATAREQ_EVENT)) {
+        return A_EINVAL;
+    }
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    dsetdatareq = (WMIX_DSETDATAREQ_EVENT *)datap;
+    A_WMI_DSET_DATA_REQ(wmip->wmi_devt,
+                         dsetdatareq->access_cookie,
+                         dsetdatareq->offset,
+                         dsetdatareq->length,
+                         dsetdatareq->targ_buf,
+                         dsetdatareq->targ_reply_fn,
+                         dsetdatareq->targ_reply_arg);
+
+    return A_OK;
+}
+#endif /* CONFIG_HOST_DSET_SUPPORT */
+
+static A_STATUS
+wmi_scanComplete_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_SCAN_COMPLETE_EVENT *ev;
+
+    ev = (WMI_SCAN_COMPLETE_EVENT *)datap;
+    A_WMI_SCANCOMPLETE_EVENT(wmip->wmi_devt, (A_STATUS) ev->status);
+
+    return A_OK;
+}
+
+/*
+ * Target is reporting a programming error.  This is for
+ * developer aid only.  Target only checks a few common violations
+ * and it is responsibility of host to do all error checking.
+ * Behavior of target after wmi error event is undefined.
+ * A reset is recommended.
+ */
+static A_STATUS
+wmi_errorEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_CMD_ERROR_EVENT *ev;
+
+    ev = (WMI_CMD_ERROR_EVENT *)datap;
+    AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("Programming Error: cmd=%d ", ev->commandId));
+    switch (ev->errorCode) {
+    case (INVALID_PARAM):
+        AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("Illegal Parameter\n"));
+        break;
+    case (ILLEGAL_STATE):
+        AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("Illegal State\n"));
+        break;
+    case (INTERNAL_ERROR):
+        AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("Internal Error\n"));
+        break;
+    }
+
+    return A_OK;
+}
+
+/* for backwards compatibility with pre-2.1.x firmware */
+static A_STATUS
+wmi_statsEvent_rx_1(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_TARGET_STATS_1 *reply1;
+    WMI_TARGET_STATS_2 *reply2;
+    static WMI_TARGET_STATS_2 sreply2;
+    int i;
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    if (len < sizeof(*reply1)) {
+        return A_EINVAL;
+    }
+    reply1 = (WMI_TARGET_STATS_1 *)datap;
+
+    reply2 = &sreply2;
+    A_MEMZERO(reply2, sizeof(*reply2));
+
+    reply2->lqVal = reply1->lqVal;
+    reply2->noise_floor_calibation = reply1->noise_floor_calibation;
+    reply2->pmStats = reply1->pmStats;
+    reply2->txrxStats.tx_stats.tx_packets = reply1->txrxStats.tx_stats.tx_packets;
+    reply2->txrxStats.tx_stats.tx_bytes = reply1->txrxStats.tx_stats.tx_bytes;
+    reply2->txrxStats.tx_stats.tx_unicast_pkts = reply1->txrxStats.tx_stats.tx_unicast_pkts;
+    reply2->txrxStats.tx_stats.tx_unicast_bytes = reply1->txrxStats.tx_stats.tx_unicast_bytes;
+    reply2->txrxStats.tx_stats.tx_multicast_pkts = reply1->txrxStats.tx_stats.tx_multicast_pkts;
+    reply2->txrxStats.tx_stats.tx_multicast_bytes = reply1->txrxStats.tx_stats.tx_multicast_bytes;
+    reply2->txrxStats.tx_stats.tx_broadcast_pkts = reply1->txrxStats.tx_stats.tx_broadcast_pkts;
+    reply2->txrxStats.tx_stats.tx_broadcast_bytes = reply1->txrxStats.tx_stats.tx_broadcast_bytes;
+    reply2->txrxStats.tx_stats.tx_rts_success_cnt = reply1->txrxStats.tx_stats.tx_rts_success_cnt;
+    for (i = 0; i < 4; i++) {
+        reply2->txrxStats.tx_stats.tx_packet_per_ac[i] = reply1->txrxStats.tx_stats.tx_packet_per_ac[i];
+        reply2->txrxStats.tx_stats.tx_errors_per_ac[i] = reply1->txrxStats.tx_stats.tx_errors_per_ac[i];
+    }
+    reply2->txrxStats.tx_stats.tx_errors = reply1->txrxStats.tx_stats.tx_errors;
+    reply2->txrxStats.tx_stats.tx_failed_cnt = reply1->txrxStats.tx_stats.tx_failed_cnt;
+    reply2->txrxStats.tx_stats.tx_retry_cnt = reply1->txrxStats.tx_stats.tx_retry_cnt;
+    reply2->txrxStats.tx_stats.tx_mult_retry_cnt = 0;
+    reply2->txrxStats.tx_stats.tx_rts_fail_cnt = reply1->txrxStats.tx_stats.tx_rts_fail_cnt;
+    reply2->txrxStats.tx_stats.tx_unicast_rate = reply1->txrxStats.tx_stats.tx_unicast_rate;
+    reply2->txrxStats.rx_stats = reply1->txrxStats.rx_stats;
+    reply2->txrxStats.tkipCcmpStats = reply1->txrxStats.tkipCcmpStats;
+    reply2->wowStats = reply1->wowStats;
+    reply2->cservStats = reply1->cservStats;
+
+    A_WMI_TARGETSTATS_EVENT(wmip->wmi_devt, reply2);
+
+    return A_OK;
+}
+
+/* for version 2.1.x firmware */
+static A_STATUS
+wmi_statsEvent_rx_2(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_TARGET_STATS_2 *reply;
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_TARGET_STATS_2 *)datap;
+
+    A_WMI_TARGETSTATS_EVENT(wmip->wmi_devt, reply);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_statsEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    A_STATUS status;
+
+    if ((WMI_TARGET_TYPE(wmip) == TARGET_TYPE_AR6001)
+        && (WMI_TARGET_VERSION(wmip) < AR6K_VERSION(2, 1, 0, 0)))
+    {
+        status = wmi_statsEvent_rx_1(wmip, datap, len);
+    } else
+        status = wmi_statsEvent_rx_2(wmip, datap, len);
+
+    return status;
+}
+
+static A_STATUS
+wmi_rssiThresholdEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_RSSI_THRESHOLD_EVENT *reply;
+    WMI_RSSI_THRESHOLD_VAL newThreshold;
+    WMI_RSSI_THRESHOLD_PARAMS_CMD cmd;
+    SQ_THRESHOLD_PARAMS *sq_thresh =
+           &wmip->wmi_SqThresholdParams[SIGNAL_QUALITY_METRICS_RSSI];
+    A_UINT8 upper_rssi_threshold, lower_rssi_threshold;
+    A_INT16 rssi;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_RSSI_THRESHOLD_EVENT *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+    newThreshold = (WMI_RSSI_THRESHOLD_VAL) reply->range;
+    rssi = reply->rssi;
+
+    /*
+     * Identify the threshold breached and communicate that to the app. After
+     * that install a new set of thresholds based on the signal quality
+     * reported by the target
+     */
+    if (newThreshold) {
+        /* Upper threshold breached */
+        if (rssi < sq_thresh->upper_threshold[0]) {
+            A_DPRINTF(DBG_WMI, (DBGFMT "Spurious upper RSSI threshold event: "
+                      " %d\n", DBGARG, rssi));
+        } else if ((rssi < sq_thresh->upper_threshold[1]) &&
+                   (rssi >= sq_thresh->upper_threshold[0]))
+        {
+            newThreshold = WMI_RSSI_THRESHOLD1_ABOVE;
+        } else if ((rssi < sq_thresh->upper_threshold[2]) &&
+                   (rssi >= sq_thresh->upper_threshold[1]))
+        {
+            newThreshold = WMI_RSSI_THRESHOLD2_ABOVE;
+        } else if ((rssi < sq_thresh->upper_threshold[3]) &&
+                   (rssi >= sq_thresh->upper_threshold[2]))
+        {
+            newThreshold = WMI_RSSI_THRESHOLD3_ABOVE;
+        } else if ((rssi < sq_thresh->upper_threshold[4]) &&
+                   (rssi >= sq_thresh->upper_threshold[3]))
+        {
+            newThreshold = WMI_RSSI_THRESHOLD4_ABOVE;
+        } else if ((rssi < sq_thresh->upper_threshold[5]) &&
+                   (rssi >= sq_thresh->upper_threshold[4]))
+        {
+            newThreshold = WMI_RSSI_THRESHOLD5_ABOVE;
+        } else if (rssi >= sq_thresh->upper_threshold[5]) {
+            newThreshold = WMI_RSSI_THRESHOLD6_ABOVE;
+        }
+    } else {
+        /* Lower threshold breached */
+        if (rssi > sq_thresh->lower_threshold[0]) {
+            A_DPRINTF(DBG_WMI, (DBGFMT "Spurious lower RSSI threshold event: "
+                      "%d %d\n", DBGARG, rssi, sq_thresh->lower_threshold[0]));
+        } else if ((rssi > sq_thresh->lower_threshold[1]) &&
+                   (rssi <= sq_thresh->lower_threshold[0]))
+        {
+            newThreshold = WMI_RSSI_THRESHOLD6_BELOW;
+        } else if ((rssi > sq_thresh->lower_threshold[2]) &&
+                   (rssi <= sq_thresh->lower_threshold[1]))
+        {
+            newThreshold = WMI_RSSI_THRESHOLD5_BELOW;
+        } else if ((rssi > sq_thresh->lower_threshold[3]) &&
+                   (rssi <= sq_thresh->lower_threshold[2]))
+        {
+            newThreshold = WMI_RSSI_THRESHOLD4_BELOW;
+        } else if ((rssi > sq_thresh->lower_threshold[4]) &&
+                   (rssi <= sq_thresh->lower_threshold[3]))
+        {
+            newThreshold = WMI_RSSI_THRESHOLD3_BELOW;
+        } else if ((rssi > sq_thresh->lower_threshold[5]) &&
+                   (rssi <= sq_thresh->lower_threshold[4]))
+        {
+            newThreshold = WMI_RSSI_THRESHOLD2_BELOW;
+        } else if (rssi <= sq_thresh->lower_threshold[5]) {
+            newThreshold = WMI_RSSI_THRESHOLD1_BELOW;
+        }
+    }
+    /* Calculate and install the next set of thresholds */
+    lower_rssi_threshold = ar6000_get_lower_threshold(rssi, sq_thresh,
+                                      sq_thresh->lower_threshold_valid_count);
+    upper_rssi_threshold = ar6000_get_upper_threshold(rssi, sq_thresh,
+                                      sq_thresh->upper_threshold_valid_count);
+    /* Issue a wmi command to install the thresholds */
+    cmd.thresholdAbove1_Val = upper_rssi_threshold;
+    cmd.thresholdBelow1_Val = lower_rssi_threshold;
+    cmd.weight = sq_thresh->weight;
+    cmd.pollTime = sq_thresh->polling_interval;
+
+    if (wmi_send_rssi_threshold_params(wmip, &cmd) != A_OK) {
+        A_DPRINTF(DBG_WMI, (DBGFMT "Unable to configure the RSSI thresholds\n",
+                  DBGARG));
+    }
+
+    A_WMI_RSSI_THRESHOLD_EVENT(wmip->wmi_devt, newThreshold, reply->rssi);
+
+    return A_OK;
+}
+
+
+static A_STATUS
+wmi_reportErrorEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_TARGET_ERROR_REPORT_EVENT *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_TARGET_ERROR_REPORT_EVENT *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_REPORT_ERROR_EVENT(wmip->wmi_devt, (WMI_TARGET_ERROR_VAL) reply->errorVal);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_cac_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_CAC_EVENT *reply;
+    WMM_TSPEC_IE *tspec_ie;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_CAC_EVENT *)datap;
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    if ((reply->cac_indication == CAC_INDICATION_ADMISSION_RESP) &&
+    	(reply->statusCode != TSPEC_STATUS_CODE_ADMISSION_ACCEPTED)) {
+        tspec_ie = (WMM_TSPEC_IE *) &(reply->tspecSuggestion);
+
+        wmi_delete_pstream_cmd(wmip, reply->ac,
+        		(tspec_ie->tsInfo_info >> TSPEC_TSID_S) & TSPEC_TSID_MASK);
+    }
+    else if (reply->cac_indication == CAC_INDICATION_NO_RESP) {
+    	A_UINT16 activeTsids;
+        A_UINT8 i;
+
+        /* following assumes that there is only one outstanding ADDTS request
+           when this event is received */
+        LOCK_WMI(wmip);
+        activeTsids = wmip->wmi_streamExistsForAC[reply->ac];
+        UNLOCK_WMI(wmip);
+
+        for (i = 0; i < sizeof(activeTsids) * 8; i++) {
+            if ((activeTsids >> i) & 1) {
+                break;
+            }
+        }
+        if (i < (sizeof(activeTsids) * 8)) {
+            wmi_delete_pstream_cmd(wmip, reply->ac, i);
+        }
+    }
+
+    A_WMI_CAC_EVENT(wmip->wmi_devt, reply->ac,
+                reply->cac_indication, reply->statusCode,
+                reply->tspecSuggestion);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_channel_change_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_CHANNEL_CHANGE_EVENT *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_CHANNEL_CHANGE_EVENT *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_CHANNEL_CHANGE_EVENT(wmip->wmi_devt, reply->oldChannel,
+                               reply->newChannel);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_hbChallengeResp_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMIX_HB_CHALLENGE_RESP_EVENT *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMIX_HB_CHALLENGE_RESP_EVENT *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "wmi: challenge response event\n", DBGARG));
+
+    A_WMI_HBCHALLENGERESP_EVENT(wmip->wmi_devt, reply->cookie, reply->source);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_roam_tbl_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_TARGET_ROAM_TBL *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_TARGET_ROAM_TBL *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_ROAM_TABLE_EVENT(wmip->wmi_devt, reply);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_roam_data_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_TARGET_ROAM_DATA *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_TARGET_ROAM_DATA *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_ROAM_DATA_EVENT(wmip->wmi_devt, reply);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_txRetryErrEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    if (len < sizeof(WMI_TX_RETRY_ERR_EVENT)) {
+        return A_EINVAL;
+    }
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_TX_RETRY_ERR_EVENT(wmip->wmi_devt);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_snrThresholdEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_SNR_THRESHOLD_EVENT *reply;
+    SQ_THRESHOLD_PARAMS *sq_thresh =
+           &wmip->wmi_SqThresholdParams[SIGNAL_QUALITY_METRICS_SNR];
+    WMI_SNR_THRESHOLD_VAL newThreshold;
+    WMI_SNR_THRESHOLD_PARAMS_CMD cmd;
+    A_UINT8 upper_snr_threshold, lower_snr_threshold;
+    A_INT16 snr;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_SNR_THRESHOLD_EVENT *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    newThreshold = (WMI_SNR_THRESHOLD_VAL) reply->range;
+    snr = reply->snr;
+    /*
+     * Identify the threshold breached and communicate that to the app. After
+     * that install a new set of thresholds based on the signal quality
+     * reported by the target
+     */
+    if (newThreshold) {
+        /* Upper threshold breached */
+        if (snr < sq_thresh->upper_threshold[0]) {
+            A_DPRINTF(DBG_WMI, (DBGFMT "Spurious upper SNR threshold event: "
+                     "%d\n", DBGARG, snr));
+        } else if ((snr < sq_thresh->upper_threshold[1]) &&
+                   (snr >= sq_thresh->upper_threshold[0]))
+        {
+            newThreshold = WMI_SNR_THRESHOLD1_ABOVE;
+        } else if ((snr < sq_thresh->upper_threshold[2]) &&
+                   (snr >= sq_thresh->upper_threshold[1]))
+        {
+            newThreshold = WMI_SNR_THRESHOLD2_ABOVE;
+        } else if ((snr < sq_thresh->upper_threshold[3]) &&
+                   (snr >= sq_thresh->upper_threshold[2]))
+        {
+            newThreshold = WMI_SNR_THRESHOLD3_ABOVE;
+        } else if (snr >= sq_thresh->upper_threshold[3]) {
+            newThreshold = WMI_SNR_THRESHOLD4_ABOVE;
+        }
+    } else {
+        /* Lower threshold breached */
+        if (snr > sq_thresh->lower_threshold[0]) {
+            A_DPRINTF(DBG_WMI, (DBGFMT "Spurious lower SNR threshold event: "
+                      "%d %d\n", DBGARG, snr, sq_thresh->lower_threshold[0]));
+        } else if ((snr > sq_thresh->lower_threshold[1]) &&
+                   (snr <= sq_thresh->lower_threshold[0]))
+        {
+            newThreshold = WMI_SNR_THRESHOLD4_BELOW;
+        } else if ((snr > sq_thresh->lower_threshold[2]) &&
+                   (snr <= sq_thresh->lower_threshold[1]))
+        {
+            newThreshold = WMI_SNR_THRESHOLD3_BELOW;
+        } else if ((snr > sq_thresh->lower_threshold[3]) &&
+                   (snr <= sq_thresh->lower_threshold[2]))
+        {
+            newThreshold = WMI_SNR_THRESHOLD2_BELOW;
+        } else if (snr <= sq_thresh->lower_threshold[3]) {
+            newThreshold = WMI_SNR_THRESHOLD1_BELOW;
+        }
+    }
+
+    /* Calculate and install the next set of thresholds */
+    lower_snr_threshold = ar6000_get_lower_threshold(snr, sq_thresh,
+                                      sq_thresh->lower_threshold_valid_count);
+    upper_snr_threshold = ar6000_get_upper_threshold(snr, sq_thresh,
+                                      sq_thresh->upper_threshold_valid_count);
+
+    /* Issue a wmi command to install the thresholds */
+    cmd.thresholdAbove1_Val = upper_snr_threshold;
+    cmd.thresholdBelow1_Val = lower_snr_threshold;
+    cmd.weight = sq_thresh->weight;
+    cmd.pollTime = sq_thresh->polling_interval;
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "snr: %d, threshold: %d, lower: %d, upper: %d\n"
+              ,DBGARG, snr, newThreshold, lower_snr_threshold,
+              upper_snr_threshold));
+
+    if (wmi_send_snr_threshold_params(wmip, &cmd) != A_OK) {
+        A_DPRINTF(DBG_WMI, (DBGFMT "Unable to configure the SNR thresholds\n",
+                  DBGARG));
+    }
+    A_WMI_SNR_THRESHOLD_EVENT_RX(wmip->wmi_devt, newThreshold, reply->snr);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_lqThresholdEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_LQ_THRESHOLD_EVENT *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_LQ_THRESHOLD_EVENT *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_LQ_THRESHOLD_EVENT_RX(wmip->wmi_devt,
+                                (WMI_LQ_THRESHOLD_VAL) reply->range,
+                                reply->lq);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_aplistEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    A_UINT16 ap_info_entry_size;
+    WMI_APLIST_EVENT *ev = (WMI_APLIST_EVENT *)datap;
+    WMI_AP_INFO_V1 *ap_info_v1;
+    A_UINT8 i;
+
+    if (len < sizeof(WMI_APLIST_EVENT)) {
+        return A_EINVAL;
+    }
+
+    if (ev->apListVer == APLIST_VER1) {
+        ap_info_entry_size = sizeof(WMI_AP_INFO_V1);
+        ap_info_v1 = (WMI_AP_INFO_V1 *)ev->apList;
+    } else {
+        return A_EINVAL;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("Number of APs in APLIST Event is %d\n", ev->numAP));
+    if (len < (int)(sizeof(WMI_APLIST_EVENT) +
+              (ev->numAP - 1) * ap_info_entry_size))
+    {
+        return A_EINVAL;
+    }
+
+    /*
+     * AP List Ver1 Contents
+     */
+    for (i = 0; i < ev->numAP; i++) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("AP#%d BSSID %2.2x %2.2x %2.2x %2.2x %2.2x %2.2x "\
+                    "Channel %d\n", i,
+                   ap_info_v1->bssid[0], ap_info_v1->bssid[1],
+                   ap_info_v1->bssid[2], ap_info_v1->bssid[3],
+                   ap_info_v1->bssid[4], ap_info_v1->bssid[5],
+                   ap_info_v1->channel));
+        ap_info_v1++;
+    }
+    return A_OK;
+}
+
+static A_STATUS
+wmi_dbglog_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    A_UINT32 dropped;
+
+    dropped = *((A_UINT32 *)datap);
+    datap += sizeof(dropped);
+    len -= sizeof(dropped);
+    A_WMI_DBGLOG_EVENT(wmip->wmi_devt, dropped, datap, len);
+    return A_OK;
+}
+
+#ifdef CONFIG_HOST_GPIO_SUPPORT
+static A_STATUS
+wmi_gpio_intr_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMIX_GPIO_INTR_EVENT *gpio_intr = (WMIX_GPIO_INTR_EVENT *)datap;
+
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Enter - intrmask=0x%x input=0x%x.\n", DBGARG,
+        gpio_intr->intr_mask, gpio_intr->input_values));
+
+    A_WMI_GPIO_INTR_RX(gpio_intr->intr_mask, gpio_intr->input_values);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_gpio_data_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMIX_GPIO_DATA_EVENT *gpio_data = (WMIX_GPIO_DATA_EVENT *)datap;
+
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Enter - reg=%d value=0x%x\n", DBGARG,
+        gpio_data->reg_id, gpio_data->value));
+
+    A_WMI_GPIO_DATA_RX(gpio_data->reg_id, gpio_data->value);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_gpio_ack_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_GPIO_ACK_RX();
+
+    return A_OK;
+}
+#endif /* CONFIG_HOST_GPIO_SUPPORT */
+
+/*
+ * Called to send a wmi command. Command specific data is already built
+ * on osbuf and current osbuf->data points to it.
+ */
+A_STATUS
+wmi_cmd_send(struct wmi_t *wmip, void *osbuf, WMI_COMMAND_ID cmdId,
+               WMI_SYNC_FLAG syncflag)
+{
+#define IS_OPT_TX_CMD(cmdId) ((cmdId == WMI_OPT_TX_FRAME_CMDID))
+    WMI_CMD_HDR         *cHdr;
+    HTC_ENDPOINT_ID     eid  = wmip->wmi_endpoint_id;
+
+    A_ASSERT(osbuf != NULL);
+
+    if (syncflag >= END_WMIFLAG) {
+        return A_EINVAL;
+    }
+
+    if ((syncflag == SYNC_BEFORE_WMIFLAG) || (syncflag == SYNC_BOTH_WMIFLAG)) {
+        /*
+         * We want to make sure all data currently queued is transmitted before
+         * the cmd execution.  Establish a new sync point.
+         */
+        wmi_sync_point(wmip);
+    }
+
+    if (A_NETBUF_PUSH(osbuf, sizeof(WMI_CMD_HDR)) != A_OK) {
+        return A_NO_MEMORY;
+    }
+
+    cHdr = (WMI_CMD_HDR *)A_NETBUF_DATA(osbuf);
+    cHdr->commandId = (A_UINT16) cmdId;
+
+    /*
+     * Only for OPT_TX_CMD, use BE endpoint.
+     */
+    if (IS_OPT_TX_CMD(cmdId)) {
+        wmi_data_hdr_add(wmip, osbuf, OPT_MSGTYPE);
+        eid = A_WMI_Ac2EndpointID(wmip->wmi_devt, WMM_AC_BE);
+    }
+    A_WMI_CONTROL_TX(wmip->wmi_devt, osbuf, eid);
+
+    if ((syncflag == SYNC_AFTER_WMIFLAG) || (syncflag == SYNC_BOTH_WMIFLAG)) {
+        /*
+         * We want to make sure all new data queued waits for the command to
+         * execute. Establish a new sync point.
+         */
+        wmi_sync_point(wmip);
+    }
+    return (A_OK);
+#undef IS_OPT_TX_CMD
+}
+
+A_STATUS
+wmi_cmd_send_xtnd(struct wmi_t *wmip, void *osbuf, WMIX_COMMAND_ID cmdId,
+                  WMI_SYNC_FLAG syncflag)
+{
+    WMIX_CMD_HDR     *cHdr;
+
+    if (A_NETBUF_PUSH(osbuf, sizeof(WMIX_CMD_HDR)) != A_OK) {
+        return A_NO_MEMORY;
+    }
+
+    cHdr = (WMIX_CMD_HDR *)A_NETBUF_DATA(osbuf);
+    cHdr->commandId = (A_UINT32) cmdId;
+
+    return wmi_cmd_send(wmip, osbuf, WMI_EXTENSION_CMDID, syncflag);
+}
+
+A_STATUS
+wmi_connect_cmd(struct wmi_t *wmip, NETWORK_TYPE netType,
+                DOT11_AUTH_MODE dot11AuthMode, AUTH_MODE authMode,
+                CRYPTO_TYPE pairwiseCrypto, A_UINT8 pairwiseCryptoLen,
+                CRYPTO_TYPE groupCrypto, A_UINT8 groupCryptoLen,
+                int ssidLength, A_UCHAR *ssid,
+                A_UINT8 *bssid, A_UINT16 channel, A_UINT32 ctrl_flags)
+{
+    void *osbuf;
+    WMI_CONNECT_CMD *cc;
+
+    if ((pairwiseCrypto == NONE_CRYPT) && (groupCrypto != NONE_CRYPT)) {
+        return A_EINVAL;
+    }
+    if ((pairwiseCrypto != NONE_CRYPT) && (groupCrypto == NONE_CRYPT)) {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(WMI_CONNECT_CMD));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(WMI_CONNECT_CMD));
+
+    cc = (WMI_CONNECT_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cc, sizeof(*cc));
+
+    if (ssidLength)
+    {
+    A_MEMCPY(cc->ssid, ssid, ssidLength);
+    }
+
+    cc->ssidLength          = ssidLength;
+    cc->networkType         = netType;
+    cc->dot11AuthMode       = dot11AuthMode;
+    cc->authMode            = authMode;
+    cc->pairwiseCryptoType  = pairwiseCrypto;
+    cc->pairwiseCryptoLen   = pairwiseCryptoLen;
+    cc->groupCryptoType     = groupCrypto;
+    cc->groupCryptoLen      = groupCryptoLen;
+    cc->channel             = channel;
+    cc->ctrl_flags          = ctrl_flags;
+
+    if (bssid != NULL) {
+        A_MEMCPY(cc->bssid, bssid, ATH_MAC_LEN);
+    }
+    if (wmi_set_keepalive_cmd(wmip, wmip->wmi_keepaliveInterval) != A_OK) {
+        return(A_ERROR);
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_CONNECT_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_reconnect_cmd(struct wmi_t *wmip, A_UINT8 *bssid, A_UINT16 channel)
+{
+    void *osbuf;
+    WMI_RECONNECT_CMD *cc;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(WMI_RECONNECT_CMD));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(WMI_RECONNECT_CMD));
+
+    cc = (WMI_RECONNECT_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cc, sizeof(*cc));
+
+    cc->channel = channel;
+
+    if (bssid != NULL) {
+        A_MEMCPY(cc->bssid, bssid, ATH_MAC_LEN);
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_RECONNECT_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_disconnect_cmd(struct wmi_t *wmip)
+{
+    A_STATUS status;
+
+    /* Bug fix for 24817(elevator bug) - the disconnect command does not
+       need to do a SYNC before.*/
+    status = wmi_simple_cmd(wmip, WMI_DISCONNECT_CMDID);
+
+    return status;
+}
+
+A_STATUS
+wmi_startscan_cmd(struct wmi_t *wmip, WMI_SCAN_TYPE scanType,
+                  A_BOOL forceFgScan, A_BOOL isLegacy,
+                  A_UINT32 homeDwellTime, A_UINT32 forceScanInterval,
+                  A_INT8 numChan, A_UINT16 *channelList)
+{
+    void *osbuf;
+    WMI_START_SCAN_CMD *sc;
+    A_INT8 size;
+
+    size = sizeof (*sc);
+
+    if ((scanType != WMI_LONG_SCAN) && (scanType != WMI_SHORT_SCAN)) {
+        return A_EINVAL;
+    }
+
+    if (numChan) {
+        if (numChan > WMI_MAX_CHANNELS) {
+            return A_EINVAL;
+        }
+        size += sizeof(A_UINT16) * (numChan - 1);
+    }
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    sc = (WMI_START_SCAN_CMD *)(A_NETBUF_DATA(osbuf));
+    sc->scanType = scanType;
+    sc->forceFgScan = forceFgScan;
+    sc->isLegacy = isLegacy;
+    sc->homeDwellTime = homeDwellTime;
+    sc->forceScanInterval = forceScanInterval;
+    sc->numChannels = numChan;
+    if (numChan) {
+        A_MEMCPY(sc->channelList, channelList, numChan * sizeof(A_UINT16));
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_START_SCAN_CMDID, NO_SYNC_WMIFLAG));
+}
+
+/* for backwards compatibility with pre-2.1.x firmware */
+A_STATUS
+wmi_scanparams_cmd_1(struct wmi_t *wmip, A_UINT16 fg_start_sec,
+                   A_UINT16 fg_end_sec, A_UINT16 bg_sec,
+                   A_UINT16 minact_chdw_msec, A_UINT16 maxact_chdw_msec,
+                   A_UINT16 pas_chdw_msec,
+                   A_UINT8 shScanRatio, A_UINT8 scanCtrlFlags,
+                   A_UINT32 max_dfsch_act_time)
+{
+    void *osbuf;
+    WMI_SCAN_PARAMS_CMD_1 *sc;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*sc));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*sc));
+
+    sc = (WMI_SCAN_PARAMS_CMD_1 *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(sc, sizeof(*sc));
+    sc->fg_start_period  = fg_start_sec;
+    sc->fg_end_period    = fg_end_sec;
+    sc->bg_period        = bg_sec;
+    sc->minact_chdwell_time = minact_chdw_msec;
+    sc->maxact_chdwell_time = maxact_chdw_msec;
+    sc->pas_chdwell_time = pas_chdw_msec;
+    sc->shortScanRatio   = shScanRatio;
+    sc->scanCtrlFlags    = scanCtrlFlags;
+    sc->max_dfsch_act_time = max_dfsch_act_time;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_SCAN_PARAMS_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+/* for version 2.1.x firmware */
+A_STATUS
+wmi_scanparams_cmd_2(struct wmi_t *wmip, A_UINT16 fg_start_sec,
+                   A_UINT16 fg_end_sec, A_UINT16 bg_sec,
+                   A_UINT16 minact_chdw_msec, A_UINT16 maxact_chdw_msec,
+                   A_UINT16 pas_chdw_msec,
+                   A_UINT8 shScanRatio, A_UINT8 scanCtrlFlags,
+                   A_UINT32 max_dfsch_act_time, A_UINT16 maxact_scan_per_ssid)
+{
+    void *osbuf;
+    WMI_SCAN_PARAMS_CMD_2 *sc;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*sc));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*sc));
+
+    sc = (WMI_SCAN_PARAMS_CMD_2 *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(sc, sizeof(*sc));
+    sc->fg_start_period  = fg_start_sec;
+    sc->fg_end_period    = fg_end_sec;
+    sc->bg_period        = bg_sec;
+    sc->minact_chdwell_time = minact_chdw_msec;
+    sc->maxact_chdwell_time = maxact_chdw_msec;
+    sc->pas_chdwell_time = pas_chdw_msec;
+    sc->shortScanRatio   = shScanRatio;
+    sc->scanCtrlFlags    = scanCtrlFlags;
+    sc->max_dfsch_act_time = max_dfsch_act_time;
+    sc->maxact_scan_per_ssid = maxact_scan_per_ssid;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_SCAN_PARAMS_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_scanparams_cmd(struct wmi_t *wmip, A_UINT16 fg_start_sec,
+                   A_UINT16 fg_end_sec, A_UINT16 bg_sec,
+                   A_UINT16 minact_chdw_msec, A_UINT16 maxact_chdw_msec,
+                   A_UINT16 pas_chdw_msec,
+                   A_UINT8 shScanRatio, A_UINT8 scanCtrlFlags,
+                   A_UINT32 max_dfsch_act_time, A_UINT16 maxact_scan_per_ssid)
+{
+    A_STATUS status;
+
+    if ((WMI_TARGET_TYPE(wmip) == TARGET_TYPE_AR6001)
+        && (WMI_TARGET_VERSION(wmip) < AR6K_VERSION(2, 1, 0, 0)))
+    {
+        status = wmi_scanparams_cmd_1(wmip, fg_start_sec, fg_end_sec, bg_sec,
+                                      minact_chdw_msec, maxact_chdw_msec,
+                                      pas_chdw_msec, shScanRatio, scanCtrlFlags,
+                                      max_dfsch_act_time);
+    } else
+        status = wmi_scanparams_cmd_2(wmip, fg_start_sec, fg_end_sec, bg_sec,
+                                      minact_chdw_msec, maxact_chdw_msec,
+                                      pas_chdw_msec, shScanRatio, scanCtrlFlags,
+                                      max_dfsch_act_time, maxact_scan_per_ssid);
+
+    return status;
+}
+
+/* for backwards compatibility with pre-2.1.x firmware */
+A_STATUS
+wmi_bssfilter_cmd_1(struct wmi_t *wmip, A_UINT8 filter, A_UINT32 ieMask)
+{
+    void *osbuf;
+    WMI_BSS_FILTER_CMD_1 *cmd;
+
+    if (filter >= LAST_BSS_FILTER) {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_BSS_FILTER_CMD_1 *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->bssFilter = filter;
+    cmd->ieMask = ieMask;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_BSS_FILTER_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+/* for version 2.1.x firmware */
+A_STATUS
+wmi_bssfilter_cmd_2(struct wmi_t *wmip, A_UINT8 filter, A_UINT32 ieMask)
+{
+    void *osbuf;
+    WMI_BSS_FILTER_CMD_2 *cmd;
+
+    if (filter >= LAST_BSS_FILTER) {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_BSS_FILTER_CMD_2 *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->bssFilter = filter;
+    cmd->ieMask = ieMask;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_BSS_FILTER_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_bssfilter_cmd(struct wmi_t *wmip, A_UINT8 filter, A_UINT32 ieMask)
+{
+    A_STATUS status;
+
+    if ((WMI_TARGET_TYPE(wmip) == TARGET_TYPE_AR6001)
+        && (WMI_TARGET_VERSION(wmip) < AR6K_VERSION(2, 1, 0, 0)))
+    {
+        status = wmi_bssfilter_cmd_1(wmip, filter, ieMask);
+    } else
+        status = wmi_bssfilter_cmd_2(wmip, filter, ieMask);
+
+    return status;
+}
+
+A_STATUS
+wmi_probedSsid_cmd(struct wmi_t *wmip, A_UINT8 index, A_UINT8 flag,
+                   A_UINT8 ssidLength, A_UCHAR *ssid)
+{
+    void *osbuf;
+    WMI_PROBED_SSID_CMD *cmd;
+
+    if (index > MAX_PROBED_SSID_INDEX) {
+        return A_EINVAL;
+    }
+    if (ssidLength > sizeof(cmd->ssid)) {
+        return A_EINVAL;
+    }
+    if ((flag & (DISABLE_SSID_FLAG | ANY_SSID_FLAG)) && (ssidLength > 0)) {
+        return A_EINVAL;
+    }
+    if ((flag & SPECIFIC_SSID_FLAG) && !ssidLength) {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_PROBED_SSID_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->entryIndex = index;
+    cmd->flag       = flag;
+    cmd->ssidLength = ssidLength;
+    A_MEMCPY(cmd->ssid, ssid, ssidLength);
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_PROBED_SSID_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_listeninterval_cmd(struct wmi_t *wmip, A_UINT16 listenInterval, A_UINT16 listenBeacons)
+{
+    void *osbuf;
+    WMI_LISTEN_INT_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_LISTEN_INT_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->listenInterval = listenInterval;
+    cmd->numBeacons = listenBeacons;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_LISTEN_INT_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_bmisstime_cmd(struct wmi_t *wmip, A_UINT16 bmissTime, A_UINT16 bmissBeacons)
+{
+    void *osbuf;
+    WMI_BMISS_TIME_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_BMISS_TIME_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->bmissTime = bmissTime;
+    cmd->numBeacons =  bmissBeacons;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_BMISS_TIME_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_associnfo_cmd(struct wmi_t *wmip, A_UINT8 ieType,
+                     A_UINT8 ieLen, A_UINT8 *ieInfo)
+{
+    void *osbuf;
+    WMI_SET_ASSOC_INFO_CMD *cmd;
+    A_UINT16 cmdLen;
+
+    cmdLen = sizeof(*cmd) + ieLen - 1;
+    osbuf = A_NETBUF_ALLOC(cmdLen);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, cmdLen);
+
+    cmd = (WMI_SET_ASSOC_INFO_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, cmdLen);
+    cmd->ieType = ieType;
+    cmd->bufferSize = ieLen;
+    A_MEMCPY(cmd->assocInfo, ieInfo, ieLen);
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_ASSOC_INFO_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_powermode_cmd(struct wmi_t *wmip, A_UINT8 powerMode)
+{
+    void *osbuf;
+    WMI_POWER_MODE_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_POWER_MODE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->powerMode = powerMode;
+    wmip->wmi_powerMode = powerMode;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_POWER_MODE_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_ibsspmcaps_cmd(struct wmi_t *wmip, A_UINT8 pmEnable, A_UINT8 ttl,
+                   A_UINT16 atim_windows, A_UINT16 timeout_value)
+{
+    void *osbuf;
+    WMI_IBSS_PM_CAPS_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_IBSS_PM_CAPS_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->power_saving = pmEnable;
+    cmd->ttl = ttl;
+    cmd->atim_windows = atim_windows;
+    cmd->timeout_value = timeout_value;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_IBSS_PM_CAPS_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_pmparams_cmd(struct wmi_t *wmip, A_UINT16 idlePeriod,
+                 A_UINT16 psPollNum, A_UINT16 dtimPolicy)
+{
+    void *osbuf;
+    WMI_POWER_PARAMS_CMD *pm;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*pm));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*pm));
+
+    pm = (WMI_POWER_PARAMS_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(pm, sizeof(*pm));
+    pm->idle_period   = idlePeriod;
+    pm->pspoll_number = psPollNum;
+    pm->dtim_policy   = dtimPolicy;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_POWER_PARAMS_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_disctimeout_cmd(struct wmi_t *wmip, A_UINT8 timeout)
+{
+    void *osbuf;
+    WMI_DISC_TIMEOUT_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_DISC_TIMEOUT_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->disconnectTimeout = timeout;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_DISC_TIMEOUT_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_addKey_cmd(struct wmi_t *wmip, A_UINT8 keyIndex, CRYPTO_TYPE keyType,
+               A_UINT8 keyUsage, A_UINT8 keyLength, A_UINT8 *keyRSC,
+               A_UINT8 *keyMaterial, A_UINT8 key_op_ctrl,
+               WMI_SYNC_FLAG sync_flag)
+{
+    void *osbuf;
+    WMI_ADD_CIPHER_KEY_CMD *cmd;
+
+    if ((keyIndex > WMI_MAX_KEY_INDEX) || (keyLength > WMI_MAX_KEY_LEN) ||
+        (keyMaterial == NULL))
+    {
+        return A_EINVAL;
+    }
+
+    if ((WEP_CRYPT != keyType) && (NULL == keyRSC)) {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_ADD_CIPHER_KEY_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->keyIndex = keyIndex;
+    cmd->keyType  = keyType;
+    cmd->keyUsage = keyUsage;
+    cmd->keyLength = keyLength;
+    A_MEMCPY(cmd->key, keyMaterial, keyLength);
+    if (NULL != keyRSC) {
+        A_MEMCPY(cmd->keyRSC, keyRSC, sizeof(cmd->keyRSC));
+    }
+    cmd->key_op_ctrl = key_op_ctrl;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_ADD_CIPHER_KEY_CMDID, sync_flag));
+}
+
+A_STATUS
+wmi_add_krk_cmd(struct wmi_t *wmip, A_UINT8 *krk)
+{
+    void *osbuf;
+    WMI_ADD_KRK_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_ADD_KRK_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    A_MEMCPY(cmd->krk, krk, WMI_KRK_LEN);
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_ADD_KRK_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_delete_krk_cmd(struct wmi_t *wmip)
+{
+    return wmi_simple_cmd(wmip, WMI_DELETE_KRK_CMDID);
+}
+
+A_STATUS
+wmi_deleteKey_cmd(struct wmi_t *wmip, A_UINT8 keyIndex)
+{
+    void *osbuf;
+    WMI_DELETE_CIPHER_KEY_CMD *cmd;
+
+    if (keyIndex > WMI_MAX_KEY_INDEX) {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_DELETE_CIPHER_KEY_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->keyIndex = keyIndex;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_DELETE_CIPHER_KEY_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_setPmkid_cmd(struct wmi_t *wmip, A_UINT8 *bssid, A_UINT8 *pmkId,
+                 A_BOOL set)
+{
+    void *osbuf;
+    WMI_SET_PMKID_CMD *cmd;
+
+    if (bssid == NULL) {
+        return A_EINVAL;
+    }
+
+    if ((set == TRUE) && (pmkId == NULL)) {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_PMKID_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMCPY(cmd->bssid, bssid, sizeof(cmd->bssid));
+    if (set == TRUE) {
+        A_MEMCPY(cmd->pmkid, pmkId, sizeof(cmd->pmkid));
+        cmd->enable = PMKID_ENABLE;
+    } else {
+        A_MEMZERO(cmd->pmkid, sizeof(cmd->pmkid));
+        cmd->enable = PMKID_DISABLE;
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_PMKID_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_tkip_countermeasures_cmd(struct wmi_t *wmip, A_BOOL en)
+{
+    void *osbuf;
+    WMI_SET_TKIP_COUNTERMEASURES_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_TKIP_COUNTERMEASURES_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->cm_en = (en == TRUE)? WMI_TKIP_CM_ENABLE : WMI_TKIP_CM_DISABLE;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_TKIP_COUNTERMEASURES_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_akmp_params_cmd(struct wmi_t *wmip,
+                        WMI_SET_AKMP_PARAMS_CMD *akmpParams)
+{
+    void *osbuf;
+    WMI_SET_AKMP_PARAMS_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+    cmd = (WMI_SET_AKMP_PARAMS_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->akmpInfo = akmpParams->akmpInfo;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_AKMP_PARAMS_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_pmkid_list_cmd(struct wmi_t *wmip,
+                       WMI_SET_PMKID_LIST_CMD *pmkInfo)
+{
+    void *osbuf;
+    WMI_SET_PMKID_LIST_CMD *cmd;
+    A_UINT16 cmdLen;
+    A_UINT8 i;
+
+    cmdLen = sizeof(pmkInfo->numPMKID) +
+             pmkInfo->numPMKID * sizeof(WMI_PMKID);
+
+    osbuf = A_NETBUF_ALLOC(cmdLen);
+
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, cmdLen);
+    cmd = (WMI_SET_PMKID_LIST_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->numPMKID = pmkInfo->numPMKID;
+
+    for (i = 0; i < cmd->numPMKID; i++) {
+        A_MEMCPY(&cmd->pmkidList[i], &pmkInfo->pmkidList[i],
+                 WMI_PMKID_LEN);
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_PMKID_LIST_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_get_pmkid_list_cmd(struct wmi_t *wmip)
+{
+    return wmi_simple_cmd(wmip, WMI_GET_PMKID_LIST_CMDID);
+}
+
+A_STATUS
+wmi_dataSync_send(struct wmi_t *wmip, void *osbuf, HTC_ENDPOINT_ID eid)
+{
+    WMI_DATA_HDR     *dtHdr;
+
+    A_ASSERT( eid != wmip->wmi_endpoint_id);
+    A_ASSERT(osbuf != NULL);
+
+    if (A_NETBUF_PUSH(osbuf, sizeof(WMI_DATA_HDR)) != A_OK) {
+        return A_NO_MEMORY;
+    }
+
+    dtHdr = (WMI_DATA_HDR *)A_NETBUF_DATA(osbuf);
+    dtHdr->info =
+      (SYNC_MSGTYPE & WMI_DATA_HDR_MSG_TYPE_MASK) << WMI_DATA_HDR_MSG_TYPE_SHIFT;
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter - eid %d\n", DBGARG, eid));
+
+    return (A_WMI_CONTROL_TX(wmip->wmi_devt, osbuf, eid));
+}
+
+typedef struct _WMI_DATA_SYNC_BUFS {
+    A_UINT8            trafficClass;
+    void               *osbuf;
+}WMI_DATA_SYNC_BUFS;
+
+static A_STATUS
+wmi_sync_point(struct wmi_t *wmip)
+{
+	void *cmd_osbuf;
+    WMI_SYNC_CMD *cmd;
+    WMI_DATA_SYNC_BUFS dataSyncBufs[WMM_NUM_AC];
+	A_UINT8 i,numPriStreams=0;
+	A_STATUS status = A_OK;
+
+	A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    memset(dataSyncBufs,0,sizeof(dataSyncBufs));
+
+    /* lock out while we walk through the priority list and assemble our local array */
+    LOCK_WMI(wmip);
+
+    for (i=0; i < WMM_NUM_AC ; i++) {
+		if (wmip->wmi_fatPipeExists & (1 << i)) {
+            numPriStreams++;
+            dataSyncBufs[numPriStreams-1].trafficClass = i;
+        }
+    }
+
+    UNLOCK_WMI(wmip);
+
+    /* dataSyncBufs is now filled with entries (starting at index 0) containing valid streamIDs */
+
+    do {
+	    /*
+	     * We allocate all network buffers needed so we will be able to
+	     * send all required frames.
+	     */
+	    cmd_osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+	    if (cmd_osbuf == NULL) {
+		    status = A_NO_MEMORY;
+            break;
+	    }
+
+        A_NETBUF_PUT(cmd_osbuf, sizeof(*cmd));
+
+        cmd = (WMI_SYNC_CMD *)(A_NETBUF_DATA(cmd_osbuf));
+        A_MEMZERO(cmd, sizeof(*cmd));
+
+        /* In the SYNC cmd sent on the control Ep, send a bitmap of the data
+         * eps on which the Data Sync will be sent
+         */
+        cmd->dataSyncMap = wmip->wmi_fatPipeExists;
+
+	    for (i=0; i < numPriStreams ; i++) {
+	        dataSyncBufs[i].osbuf = A_NETBUF_ALLOC(0);
+            if (dataSyncBufs[i].osbuf == NULL) {
+                status = A_NO_MEMORY;
+                break;
+            }
+	    } //end for
+
+        /* if Buffer allocation for any of the dataSync fails, then do not
+         * send the Synchronize cmd on the control ep
+         */
+        if (A_FAILED(status)) {
+            break;
+        }
+
+	    /*
+	     * Send sync cmd followed by sync data messages on all endpoints being
+	     * used
+	     */
+	    status = wmi_cmd_send(wmip, cmd_osbuf, WMI_SYNCHRONIZE_CMDID,
+						  NO_SYNC_WMIFLAG);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+            /* cmd buffer sent, we no longer own it */
+        cmd_osbuf = NULL;
+
+		for(i=0; i < numPriStreams; i++) {
+            A_ASSERT(dataSyncBufs[i].osbuf != NULL);
+
+            status = wmi_dataSync_send(wmip,
+                                       dataSyncBufs[i].osbuf,
+                                       A_WMI_Ac2EndpointID(wmip->wmi_devt,
+                                                            dataSyncBufs[i].
+                                                            trafficClass)
+                                      );
+
+            if (A_FAILED(status)) {
+                break;
+            }
+            /* we don't own this buffer anymore, NULL it out of the array so it
+             * won't get cleaned up */
+            dataSyncBufs[i].osbuf = NULL;
+		} //end for
+
+    } while(FALSE);
+
+    /* free up any resources left over (possibly due to an error) */
+
+    if (cmd_osbuf != NULL) {
+        A_NETBUF_FREE(cmd_osbuf);
+    }
+
+    for (i = 0; i < numPriStreams; i++) {
+        if (dataSyncBufs[i].osbuf != NULL) {
+            A_NETBUF_FREE(dataSyncBufs[i].osbuf);
+        }
+    }
+
+	return (status);
+}
+
+A_STATUS
+wmi_create_pstream_cmd(struct wmi_t *wmip, WMI_CREATE_PSTREAM_CMD *params)
+{
+    void *osbuf;
+    WMI_CREATE_PSTREAM_CMD_1 *cmd1;
+    WMI_CREATE_PSTREAM_CMD_2 *cmd2;
+    A_UINT8 fatPipeExistsForAC=0;
+
+    /* Validate all the parameters. */
+    if( !((params->userPriority < 8) &&
+         (params->userPriority <= 0x7) &&
+         (convert_userPriority_to_trafficClass(params->userPriority) == params->trafficClass)  &&
+         (params->trafficDirection == UPLINK_TRAFFIC ||
+            params->trafficDirection == DNLINK_TRAFFIC ||
+            params->trafficDirection == BIDIR_TRAFFIC) &&
+         (params->trafficType == TRAFFIC_TYPE_APERIODIC ||
+            params->trafficType == TRAFFIC_TYPE_PERIODIC ) &&
+         (params->voicePSCapability == DISABLE_FOR_THIS_AC  ||
+            params->voicePSCapability == ENABLE_FOR_THIS_AC ||
+            params->voicePSCapability == ENABLE_FOR_ALL_AC) &&
+         (params->tsid == WMI_IMPLICIT_PSTREAM || params->tsid <= WMI_MAX_THINSTREAM)) )
+    {
+        return  A_EINVAL;
+    }
+
+    if ((WMI_TARGET_TYPE(wmip) == TARGET_TYPE_AR6001)
+        && (WMI_TARGET_VERSION(wmip) < AR6K_VERSION(2, 1, 0, 0)))
+    {
+        /* for backwards compatibility with pre-2.1.x firmware */
+        osbuf = A_NETBUF_ALLOC(sizeof(*cmd1));
+        if (osbuf == NULL) {
+            return A_NO_MEMORY;
+        }
+
+        A_NETBUF_PUT(osbuf, sizeof(*cmd1));
+
+        cmd1 = (WMI_CREATE_PSTREAM_CMD_1 *)(A_NETBUF_DATA(osbuf));
+        A_MEMZERO(cmd1, sizeof(*cmd1));
+        cmd1->minServiceInt = params->minServiceInt;
+        cmd1->maxServiceInt = params->maxServiceInt;
+        cmd1->inactivityInt = params->inactivityInt;
+        cmd1->suspensionInt = params->suspensionInt;
+        cmd1->serviceStartTime = params->serviceStartTime;
+        cmd1->minDataRate = params->minDataRate;
+        cmd1->meanDataRate = params->meanDataRate;
+        cmd1->peakDataRate = params->peakDataRate;
+        cmd1->maxBurstSize = params->maxBurstSize;
+        cmd1->delayBound = params->delayBound;
+        cmd1->minPhyRate = params->minPhyRate;
+        cmd1->sba = params->sba;
+        cmd1->mediumTime = params->mediumTime;
+        cmd1->nominalMSDU = params->nominalMSDU;
+        cmd1->maxMSDU = params->maxMSDU;
+        cmd1->trafficClass = params->trafficClass;
+        cmd1->trafficType = params->trafficType;
+        cmd1->trafficDirection = params->trafficDirection;
+        cmd1->voicePSCapability = params->voicePSCapability;
+        cmd1->tsid = params->tsid;
+        cmd1->userPriority = params->userPriority;
+   } else {
+        /* for version 2.1.x firmware */
+        osbuf = A_NETBUF_ALLOC(sizeof(*cmd2));
+        if (osbuf == NULL) {
+            return A_NO_MEMORY;
+        }
+
+        A_NETBUF_PUT(osbuf, sizeof(*cmd2));
+
+        cmd2 = (WMI_CREATE_PSTREAM_CMD_2 *)(A_NETBUF_DATA(osbuf));
+        A_MEMZERO(cmd2, sizeof(*cmd2));
+        A_MEMCPY(cmd2, params, sizeof(*cmd2));
+    }
+
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Sending create_pstream_cmd: ac=%d    tsid:%d\n", DBGARG,
+        params->trafficClass, params->tsid));
+
+        /* this is an implicitly created Fat pipe */
+    if (params->tsid == WMI_IMPLICIT_PSTREAM) {
+        LOCK_WMI(wmip);
+        fatPipeExistsForAC = (wmip->wmi_fatPipeExists & (1 << params->trafficClass));
+        wmip->wmi_fatPipeExists |= (1<<params->trafficClass);
+        UNLOCK_WMI(wmip);
+    } else {
+            /* this is an explicitly created thin stream within a fat pipe */
+        LOCK_WMI(wmip);
+        fatPipeExistsForAC = (wmip->wmi_fatPipeExists & (1 << params->trafficClass));
+        wmip->wmi_streamExistsForAC[params->trafficClass] |= (1<<params->tsid);
+            /* if a thinstream becomes active, the fat pipe automatically
+            * becomes active
+            */
+        wmip->wmi_fatPipeExists |= (1<<params->trafficClass);
+        UNLOCK_WMI(wmip);
+    }
+
+        /* Indicate activty change to driver layer only if this is the
+         * first TSID to get created in this AC explicitly or an implicit
+         * fat pipe is getting created.
+         */
+    if (!fatPipeExistsForAC) {
+        A_WMI_STREAM_TX_ACTIVE(wmip->wmi_devt, params->trafficClass);
+    }
+
+    /* mike: should be SYNC_BEFORE_WMIFLAG */
+    return (wmi_cmd_send(wmip, osbuf, WMI_CREATE_PSTREAM_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_delete_pstream_cmd(struct wmi_t *wmip, A_UINT8 trafficClass, A_UINT8 tsid)
+{
+    void *osbuf;
+    WMI_DELETE_PSTREAM_CMD_1 *cmd1;
+    WMI_DELETE_PSTREAM_CMD_2 *cmd2;
+    A_STATUS status;
+	A_UINT16 activeTsids=0;
+
+    /* validate the parameters */
+    if (trafficClass > 3) {
+        A_DPRINTF(DBG_WMI, (DBGFMT "Invalid trafficClass: %d\n", DBGARG, trafficClass));
+        return A_EINVAL;
+    }
+
+    if ((WMI_TARGET_TYPE(wmip) == TARGET_TYPE_AR6001)
+        && (WMI_TARGET_VERSION(wmip) < AR6K_VERSION(2, 1, 0, 0)))
+    {
+        /* for backwards compatibility with pre-2.1.x firmware */
+        osbuf = A_NETBUF_ALLOC(sizeof(*cmd1));
+        if (osbuf == NULL) {
+            return A_NO_MEMORY;
+        }
+
+        A_NETBUF_PUT(osbuf, sizeof(*cmd1));
+
+        cmd1 = (WMI_DELETE_PSTREAM_CMD_1 *)(A_NETBUF_DATA(osbuf));
+        A_MEMZERO(cmd1, sizeof(*cmd1));
+
+        cmd1->trafficClass = trafficClass;
+        cmd1->tsid = tsid;
+    } else {
+        /* for version 2.1.x firmware */
+        osbuf = A_NETBUF_ALLOC(sizeof(*cmd2));
+        if (osbuf == NULL) {
+            return A_NO_MEMORY;
+        }
+
+        A_NETBUF_PUT(osbuf, sizeof(*cmd2));
+
+        cmd2 = (WMI_DELETE_PSTREAM_CMD_2 *)(A_NETBUF_DATA(osbuf));
+        A_MEMZERO(cmd2, sizeof(*cmd2));
+
+        cmd2->trafficClass = trafficClass;
+        cmd2->tsid = tsid;
+    }
+
+    LOCK_WMI(wmip);
+    activeTsids = wmip->wmi_streamExistsForAC[trafficClass];
+    UNLOCK_WMI(wmip);
+
+        /* Check if the tsid was created & exists */
+    if (!(activeTsids & (1<<tsid))) {
+
+        A_DPRINTF(DBG_WMI,
+        (DBGFMT "TSID %d does'nt exist for trafficClass: %d\n", DBGARG, tsid, trafficClass));
+            /* TODO: return a more appropriate err code */
+        return A_ERROR;
+    }
+
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Sending delete_pstream_cmd: trafficClass: %d tsid=%d\n", DBGARG, trafficClass, tsid));
+
+    status = (wmi_cmd_send(wmip, osbuf, WMI_DELETE_PSTREAM_CMDID,
+                         SYNC_BEFORE_WMIFLAG));
+
+    LOCK_WMI(wmip);
+    wmip->wmi_streamExistsForAC[trafficClass] &= ~(1<<tsid);
+    activeTsids = wmip->wmi_streamExistsForAC[trafficClass];
+    UNLOCK_WMI(wmip);
+
+
+        /* Indicate stream inactivity to driver layer only if all tsids
+         * within this AC are deleted.
+         */
+    if(!activeTsids) {
+        A_WMI_STREAM_TX_INACTIVE(wmip->wmi_devt, trafficClass);
+        LOCK_WMI(wmip);
+        wmip->wmi_fatPipeExists &= ~(1<<trafficClass);
+        UNLOCK_WMI(wmip);
+    }
+
+    return status;
+}
+
+/*
+ * used to set the bit rate.  rate is in Kbps.  If rate == -1
+ * then auto selection is used.
+ */
+A_STATUS
+wmi_set_bitrate_cmd(struct wmi_t *wmip, A_INT32 rate)
+{
+    void *osbuf;
+    WMI_BIT_RATE_CMD *cmd;
+    A_INT8 index;
+
+    if (rate != -1) {
+        index = wmi_validate_bitrate(wmip, rate);
+        if(index == A_EINVAL){
+            return A_EINVAL;
+        }
+    } else {
+        index = -1;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_BIT_RATE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+
+    cmd->rateIndex = index;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_BITRATE_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_get_bitrate_cmd(struct wmi_t *wmip)
+{
+    return wmi_simple_cmd(wmip, WMI_GET_BITRATE_CMDID);
+}
+
+/*
+ * Returns TRUE iff the given rate index is legal in the current PHY mode.
+ */
+A_BOOL
+wmi_is_bitrate_index_valid(struct wmi_t *wmip, A_INT32 rateIndex)
+{
+    WMI_PHY_MODE phyMode = (WMI_PHY_MODE) wmip->wmi_phyMode;
+    A_BOOL isValid = TRUE;
+    switch(phyMode) {
+        case WMI_11A_MODE:
+            if ((rateIndex < MODE_A_SUPPORT_RATE_START) || (rateIndex > MODE_A_SUPPORT_RATE_STOP)) {
+                isValid = FALSE;
+            }
+            break;
+
+        case WMI_11B_MODE:
+            if ((rateIndex < MODE_B_SUPPORT_RATE_START) || (rateIndex > MODE_B_SUPPORT_RATE_STOP)) {
+                isValid = FALSE;
+            }
+            break;
+
+        case WMI_11GONLY_MODE:
+            if ((rateIndex < MODE_GONLY_SUPPORT_RATE_START) || (rateIndex > MODE_GONLY_SUPPORT_RATE_STOP)) {
+                isValid = FALSE;
+            }
+            break;
+
+        case WMI_11G_MODE:
+        case WMI_11AG_MODE:
+            if ((rateIndex < MODE_G_SUPPORT_RATE_START) || (rateIndex > MODE_G_SUPPORT_RATE_STOP)) {
+                isValid = FALSE;
+            }
+            break;
+
+        default:
+            A_ASSERT(FALSE);
+            break;
+    }
+
+    return isValid;
+}
+
+A_INT8
+wmi_validate_bitrate(struct wmi_t *wmip, A_INT32 rate)
+{
+    A_INT8 i;
+    if (rate != -1)
+    {
+        for (i=0;;i++)
+        {
+            if (wmi_rateTable[(A_UINT32) i] == 0) {
+                return A_EINVAL;
+            }
+            if (wmi_rateTable[(A_UINT32) i] == rate) {
+                break;
+            }
+        }
+    }
+    else{
+     i = -1;
+    }
+
+    if(wmi_is_bitrate_index_valid(wmip, (A_INT32) i) != TRUE) {
+        return A_EINVAL;
+    }
+
+    return i;
+}
+
+A_STATUS
+wmi_set_fixrates_cmd(struct wmi_t *wmip, A_INT16 fixRatesMask)
+{
+    void *osbuf;
+    WMI_FIX_RATES_CMD *cmd;
+    A_INT32 rateIndex;
+
+    /* Make sure all rates in the mask are valid in the current PHY mode */
+    for(rateIndex = 0; rateIndex < MAX_NUMBER_OF_SUPPORT_RATES; rateIndex++) {
+       if((1 << rateIndex) & (A_UINT32)fixRatesMask) {
+            if(wmi_is_bitrate_index_valid(wmip, rateIndex) != TRUE) {
+                A_DPRINTF(DBG_WMI, (DBGFMT "Set Fix Rates command failed: Given rate is illegal in current PHY mode\n", DBGARG));
+                return A_EINVAL;
+            }
+       }
+    }
+
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_FIX_RATES_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+
+    cmd->fixRateMask = fixRatesMask;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_FIXRATES_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_get_ratemask_cmd(struct wmi_t *wmip)
+{
+    return wmi_simple_cmd(wmip, WMI_GET_FIXRATES_CMDID);
+}
+
+A_STATUS
+wmi_get_channelList_cmd(struct wmi_t *wmip)
+{
+    return wmi_simple_cmd(wmip, WMI_GET_CHANNEL_LIST_CMDID);
+}
+
+/*
+ * used to generate a wmi sey channel Parameters cmd.
+ * mode should always be specified and corresponds to the phy mode of the
+ * wlan.
+ * numChan should alway sbe specified. If zero indicates that all available
+ * channels should be used.
+ * channelList is an array of channel frequencies (in Mhz) which the radio
+ * should limit its operation to.  It should be NULL if numChan == 0.  Size of
+ * array should correspond to numChan entries.
+ */
+A_STATUS
+wmi_set_channelParams_cmd(struct wmi_t *wmip, A_UINT8 scanParam,
+                          WMI_PHY_MODE mode, A_INT8 numChan,
+                          A_UINT16 *channelList)
+{
+    void *osbuf;
+    WMI_CHANNEL_PARAMS_CMD *cmd;
+    A_INT8 size;
+
+    size = sizeof (*cmd);
+
+    if (numChan) {
+        if (numChan > WMI_MAX_CHANNELS) {
+            return A_EINVAL;
+        }
+        size += sizeof(A_UINT16) * (numChan - 1);
+    }
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_CHANNEL_PARAMS_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+
+    wmip->wmi_phyMode = mode;
+    cmd->scanParam   = scanParam;
+    cmd->phyMode     = mode;
+    cmd->numChannels = numChan;
+    A_MEMCPY(cmd->channelList, channelList, numChan * sizeof(A_UINT16));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_CHANNEL_PARAMS_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+void
+wmi_cache_configure_rssithreshold(struct wmi_t *wmip, WMI_RSSI_THRESHOLD_PARAMS_CMD *rssiCmd)
+{
+    SQ_THRESHOLD_PARAMS *sq_thresh =
+           &wmip->wmi_SqThresholdParams[SIGNAL_QUALITY_METRICS_RSSI];
+    /*
+     * Parse the command and store the threshold values here. The checks
+     * for valid values can be put here
+     */
+    sq_thresh->weight = rssiCmd->weight;
+    sq_thresh->polling_interval = rssiCmd->pollTime;
+
+    sq_thresh->upper_threshold[0] = rssiCmd->thresholdAbove1_Val - SIGNAL_QUALITY_NOISE_FLOOR;
+    sq_thresh->upper_threshold[1] = rssiCmd->thresholdAbove2_Val - SIGNAL_QUALITY_NOISE_FLOOR;
+    sq_thresh->upper_threshold[2] = rssiCmd->thresholdAbove3_Val - SIGNAL_QUALITY_NOISE_FLOOR;
+    sq_thresh->upper_threshold[3] = rssiCmd->thresholdAbove4_Val - SIGNAL_QUALITY_NOISE_FLOOR;
+    sq_thresh->upper_threshold[4] = rssiCmd->thresholdAbove5_Val - SIGNAL_QUALITY_NOISE_FLOOR;
+    sq_thresh->upper_threshold[5] = rssiCmd->thresholdAbove6_Val - SIGNAL_QUALITY_NOISE_FLOOR;
+    sq_thresh->upper_threshold_valid_count = 6;
+
+    /* List sorted in descending order */
+    sq_thresh->lower_threshold[0] = rssiCmd->thresholdBelow6_Val - SIGNAL_QUALITY_NOISE_FLOOR;
+    sq_thresh->lower_threshold[1] = rssiCmd->thresholdBelow5_Val - SIGNAL_QUALITY_NOISE_FLOOR;
+    sq_thresh->lower_threshold[2] = rssiCmd->thresholdBelow4_Val - SIGNAL_QUALITY_NOISE_FLOOR;
+    sq_thresh->lower_threshold[3] = rssiCmd->thresholdBelow3_Val - SIGNAL_QUALITY_NOISE_FLOOR;
+    sq_thresh->lower_threshold[4] = rssiCmd->thresholdBelow2_Val - SIGNAL_QUALITY_NOISE_FLOOR;
+    sq_thresh->lower_threshold[5] = rssiCmd->thresholdBelow1_Val - SIGNAL_QUALITY_NOISE_FLOOR;
+    sq_thresh->lower_threshold_valid_count = 6;
+
+    /*
+     * Configuring the thresholds to their extremes allows the host to get an
+     * event from the target which is used for the configuring the correct
+     * thresholds
+     */
+    rssiCmd->thresholdAbove1_Val = sq_thresh->upper_threshold[0];
+    rssiCmd->thresholdBelow1_Val = sq_thresh->lower_threshold[0];
+}
+
+A_STATUS
+wmi_set_rssi_threshold_params(struct wmi_t *wmip,
+                              WMI_RSSI_THRESHOLD_PARAMS_CMD *rssiCmd)
+{
+     /* Check these values are in ascending order */
+    if( rssiCmd->thresholdAbove6_Val <= rssiCmd->thresholdAbove5_Val ||
+        rssiCmd->thresholdAbove5_Val <= rssiCmd->thresholdAbove4_Val ||
+        rssiCmd->thresholdAbove4_Val <= rssiCmd->thresholdAbove3_Val ||
+        rssiCmd->thresholdAbove3_Val <= rssiCmd->thresholdAbove2_Val ||
+        rssiCmd->thresholdAbove2_Val <= rssiCmd->thresholdAbove1_Val ||
+        rssiCmd->thresholdBelow6_Val <= rssiCmd->thresholdBelow5_Val ||
+        rssiCmd->thresholdBelow5_Val <= rssiCmd->thresholdBelow4_Val ||
+        rssiCmd->thresholdBelow4_Val <= rssiCmd->thresholdBelow3_Val ||
+        rssiCmd->thresholdBelow3_Val <= rssiCmd->thresholdBelow2_Val ||
+        rssiCmd->thresholdBelow2_Val <= rssiCmd->thresholdBelow1_Val)
+    {
+        return A_EINVAL;
+    }
+
+    wmi_cache_configure_rssithreshold(wmip, rssiCmd);
+
+    return (wmi_send_rssi_threshold_params(wmip, rssiCmd));
+}
+
+A_STATUS
+wmi_set_host_sleep_mode_cmd(struct wmi_t *wmip,
+                              WMI_SET_HOST_SLEEP_MODE_CMD *hostModeCmd)
+{
+    void    *osbuf;
+    A_INT8  size;
+    WMI_SET_HOST_SLEEP_MODE_CMD *cmd;
+    A_UINT16 activeTsids=0;
+    A_UINT8 streamExists=0;
+    A_UINT8 i;
+
+    if( hostModeCmd->awake == hostModeCmd->asleep) {
+        return A_EINVAL;
+    }
+
+    size = sizeof (*cmd);
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_SET_HOST_SLEEP_MODE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+    A_MEMCPY(cmd, hostModeCmd, sizeof(WMI_SET_HOST_SLEEP_MODE_CMD));
+
+    if(hostModeCmd->asleep) {
+        /*
+         * Relinquish credits from all implicitly created pstreams since when we
+         * go to sleep. If user created explicit thinstreams exists with in a
+         * fatpipe leave them intact for the user to delete
+         */
+        LOCK_WMI(wmip);
+        streamExists = wmip->wmi_fatPipeExists;
+        UNLOCK_WMI(wmip);
+
+        for(i=0;i< WMM_NUM_AC;i++) {
+            if (streamExists & (1<<i)) {
+                LOCK_WMI(wmip);
+                activeTsids = wmip->wmi_streamExistsForAC[i];
+                UNLOCK_WMI(wmip);
+                /* If there are no user created thin streams delete the fatpipe */
+                if(!activeTsids) {
+                    streamExists &= ~(1<<i);
+                    /*Indicate inactivity to drv layer for this fatpipe(pstream)*/
+                    A_WMI_STREAM_TX_INACTIVE(wmip->wmi_devt,i);
+                }
+            }
+        }
+
+        /* Update the fatpipes that exists*/
+        LOCK_WMI(wmip);
+        wmip->wmi_fatPipeExists = streamExists;
+        UNLOCK_WMI(wmip);
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_HOST_SLEEP_MODE_CMDID,
+                            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_wow_mode_cmd(struct wmi_t *wmip,
+                              WMI_SET_WOW_MODE_CMD *wowModeCmd)
+{
+    void    *osbuf;
+    A_INT8  size;
+    WMI_SET_WOW_MODE_CMD *cmd;
+
+    size = sizeof (*cmd);
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_SET_WOW_MODE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+    A_MEMCPY(cmd, wowModeCmd, sizeof(WMI_SET_WOW_MODE_CMD));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_WOW_MODE_CMDID,
+                            NO_SYNC_WMIFLAG));
+
+}
+
+A_STATUS
+wmi_get_wow_list_cmd(struct wmi_t *wmip,
+                              WMI_GET_WOW_LIST_CMD *wowListCmd)
+{
+    void    *osbuf;
+    A_INT8  size;
+    WMI_GET_WOW_LIST_CMD *cmd;
+
+    size = sizeof (*cmd);
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_GET_WOW_LIST_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+    A_MEMCPY(cmd, wowListCmd, sizeof(WMI_GET_WOW_LIST_CMD));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_GET_WOW_LIST_CMDID,
+                            NO_SYNC_WMIFLAG));
+
+}
+
+static A_STATUS
+wmi_get_wow_list_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_GET_WOW_LIST_REPLY *reply;
+
+    if (len < sizeof(WMI_GET_WOW_LIST_REPLY)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_GET_WOW_LIST_REPLY *)datap;
+
+    A_WMI_WOW_LIST_EVENT(wmip->wmi_devt, reply->num_filters,
+                          reply);
+
+    return A_OK;
+}
+
+A_STATUS wmi_add_wow_pattern_cmd(struct wmi_t *wmip,
+                                 WMI_ADD_WOW_PATTERN_CMD *addWowCmd,
+                                 A_UINT8* pattern, A_UINT8* mask,
+                                 A_UINT8 pattern_size)
+{
+    void    *osbuf;
+    A_INT8  size;
+    WMI_ADD_WOW_PATTERN_CMD *cmd;
+    A_UINT8 *filter_mask = NULL;
+
+    size = sizeof (*cmd);
+
+    size += ((2 * addWowCmd->filter_size)* sizeof(A_UINT8));
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_ADD_WOW_PATTERN_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->filter_list_id = addWowCmd->filter_list_id;
+    cmd->filter_offset = addWowCmd->filter_offset;
+    cmd->filter_size = addWowCmd->filter_size;
+
+    A_MEMCPY(cmd->filter, pattern, addWowCmd->filter_size);
+
+    filter_mask = (A_UINT8*)(cmd->filter + cmd->filter_size);
+    A_MEMCPY(filter_mask, mask, addWowCmd->filter_size);
+
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_ADD_WOW_PATTERN_CMDID,
+                            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_del_wow_pattern_cmd(struct wmi_t *wmip,
+                              WMI_DEL_WOW_PATTERN_CMD *delWowCmd)
+{
+    void    *osbuf;
+    A_INT8  size;
+    WMI_DEL_WOW_PATTERN_CMD *cmd;
+
+    size = sizeof (*cmd);
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_DEL_WOW_PATTERN_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+    A_MEMCPY(cmd, delWowCmd, sizeof(WMI_DEL_WOW_PATTERN_CMD));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_DEL_WOW_PATTERN_CMDID,
+                            NO_SYNC_WMIFLAG));
+
+}
+
+void
+wmi_cache_configure_snrthreshold(struct wmi_t *wmip, WMI_SNR_THRESHOLD_PARAMS_CMD *snrCmd)
+{
+    SQ_THRESHOLD_PARAMS *sq_thresh =
+           &wmip->wmi_SqThresholdParams[SIGNAL_QUALITY_METRICS_SNR];
+    /*
+     * Parse the command and store the threshold values here. The checks
+     * for valid values can be put here
+     */
+    sq_thresh->weight = snrCmd->weight;
+    sq_thresh->polling_interval = snrCmd->pollTime;
+
+    sq_thresh->upper_threshold[0] = snrCmd->thresholdAbove1_Val;
+    sq_thresh->upper_threshold[1] = snrCmd->thresholdAbove2_Val;
+    sq_thresh->upper_threshold[2] = snrCmd->thresholdAbove3_Val;
+    sq_thresh->upper_threshold[3] = snrCmd->thresholdAbove4_Val;
+    sq_thresh->upper_threshold_valid_count = 4;
+
+    /* List sorted in descending order */
+    sq_thresh->lower_threshold[0] = snrCmd->thresholdBelow4_Val;
+    sq_thresh->lower_threshold[1] = snrCmd->thresholdBelow3_Val;
+    sq_thresh->lower_threshold[2] = snrCmd->thresholdBelow2_Val;
+    sq_thresh->lower_threshold[3] = snrCmd->thresholdBelow1_Val;
+    sq_thresh->lower_threshold_valid_count = 4;
+
+    /*
+     * Configuring the thresholds to their extremes allows the host to get an
+     * event from the target which is used for the configuring the correct
+     * thresholds
+     */
+    snrCmd->thresholdAbove1_Val = (A_UINT8)sq_thresh->upper_threshold[0];
+    snrCmd->thresholdBelow1_Val = (A_UINT8)sq_thresh->lower_threshold[0];
+}
+A_STATUS
+wmi_set_snr_threshold_params(struct wmi_t *wmip,
+                             WMI_SNR_THRESHOLD_PARAMS_CMD *snrCmd)
+{
+    if( snrCmd->thresholdAbove4_Val <= snrCmd->thresholdAbove3_Val ||
+        snrCmd->thresholdAbove3_Val <= snrCmd->thresholdAbove2_Val ||
+        snrCmd->thresholdAbove2_Val <= snrCmd->thresholdAbove1_Val ||
+        snrCmd->thresholdBelow4_Val <= snrCmd->thresholdBelow3_Val ||
+        snrCmd->thresholdBelow3_Val <= snrCmd->thresholdBelow2_Val ||
+        snrCmd->thresholdBelow2_Val <= snrCmd->thresholdBelow1_Val)
+    {
+        return A_EINVAL;
+    }
+    wmi_cache_configure_snrthreshold(wmip, snrCmd);
+    return (wmi_send_snr_threshold_params(wmip, snrCmd));
+}
+
+A_STATUS
+wmi_clr_rssi_snr(struct wmi_t *wmip)
+{
+    void    *osbuf;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(int));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_CLR_RSSI_SNR_CMDID,
+                            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_lq_threshold_params(struct wmi_t *wmip,
+                             WMI_LQ_THRESHOLD_PARAMS_CMD *lqCmd)
+{
+    void    *osbuf;
+    A_INT8  size;
+    WMI_LQ_THRESHOLD_PARAMS_CMD *cmd;
+    /* These values are in ascending order */
+    if( lqCmd->thresholdAbove4_Val <= lqCmd->thresholdAbove3_Val ||
+        lqCmd->thresholdAbove3_Val <= lqCmd->thresholdAbove2_Val ||
+        lqCmd->thresholdAbove2_Val <= lqCmd->thresholdAbove1_Val ||
+        lqCmd->thresholdBelow4_Val <= lqCmd->thresholdBelow3_Val ||
+        lqCmd->thresholdBelow3_Val <= lqCmd->thresholdBelow2_Val ||
+        lqCmd->thresholdBelow2_Val <= lqCmd->thresholdBelow1_Val ) {
+
+        return A_EINVAL;
+    }
+
+    size = sizeof (*cmd);
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_LQ_THRESHOLD_PARAMS_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+    A_MEMCPY(cmd, lqCmd, sizeof(WMI_LQ_THRESHOLD_PARAMS_CMD));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_LQ_THRESHOLD_PARAMS_CMDID,
+                            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_error_report_bitmask(struct wmi_t *wmip, A_UINT32 mask)
+{
+    void    *osbuf;
+    A_INT8  size;
+    WMI_TARGET_ERROR_REPORT_BITMASK *cmd;
+
+    size = sizeof (*cmd);
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_TARGET_ERROR_REPORT_BITMASK *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+
+    cmd->bitmask = mask;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_TARGET_ERROR_REPORT_BITMASK_CMDID,
+                            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_get_challenge_resp_cmd(struct wmi_t *wmip, A_UINT32 cookie, A_UINT32 source)
+{
+    void *osbuf;
+    WMIX_HB_CHALLENGE_RESP_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMIX_HB_CHALLENGE_RESP_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->cookie = cookie;
+    cmd->source = source;
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_HB_CHALLENGE_RESP_CMDID,
+                              NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_config_debug_module_cmd(struct wmi_t *wmip, A_UINT16 mmask,
+                            A_UINT16 tsr, A_BOOL rep, A_UINT16 size,
+                            A_UINT32 valid)
+{
+    void *osbuf;
+    WMIX_DBGLOG_CFG_MODULE_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMIX_DBGLOG_CFG_MODULE_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->config.cfgmmask = mmask;
+    cmd->config.cfgtsr = tsr;
+    cmd->config.cfgrep = rep;
+    cmd->config.cfgsize = size;
+    cmd->config.cfgvalid = valid;
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_DBGLOG_CFG_MODULE_CMDID,
+                              NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_get_stats_cmd(struct wmi_t *wmip)
+{
+    return wmi_simple_cmd(wmip, WMI_GET_STATISTICS_CMDID);
+}
+
+A_STATUS
+wmi_addBadAp_cmd(struct wmi_t *wmip, A_UINT8 apIndex, A_UINT8 *bssid)
+{
+    void *osbuf;
+    WMI_ADD_BAD_AP_CMD *cmd;
+
+    if ((bssid == NULL) || (apIndex > WMI_MAX_BAD_AP_INDEX)) {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_ADD_BAD_AP_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->badApIndex = apIndex;
+    A_MEMCPY(cmd->bssid, bssid, sizeof(cmd->bssid));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_ADD_BAD_AP_CMDID, SYNC_BEFORE_WMIFLAG));
+}
+
+A_STATUS
+wmi_deleteBadAp_cmd(struct wmi_t *wmip, A_UINT8 apIndex)
+{
+    void *osbuf;
+    WMI_DELETE_BAD_AP_CMD *cmd;
+
+    if (apIndex > WMI_MAX_BAD_AP_INDEX) {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_DELETE_BAD_AP_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->badApIndex = apIndex;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_DELETE_BAD_AP_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_abort_scan_cmd(struct wmi_t *wmip)
+{
+    return wmi_simple_cmd(wmip, WMI_ABORT_SCAN_CMDID);
+}
+
+A_STATUS
+wmi_set_txPwr_cmd(struct wmi_t *wmip, A_UINT8 dbM)
+{
+    void *osbuf;
+    WMI_SET_TX_PWR_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_TX_PWR_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->dbM = dbM;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_TX_PWR_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_get_txPwr_cmd(struct wmi_t *wmip)
+{
+    return wmi_simple_cmd(wmip, WMI_GET_TX_PWR_CMDID);
+}
+
+A_UINT16
+wmi_get_mapped_qos_queue(struct wmi_t *wmip, A_UINT8 trafficClass)
+{
+	A_UINT16 activeTsids=0;
+
+    LOCK_WMI(wmip);
+    activeTsids = wmip->wmi_streamExistsForAC[trafficClass];
+    UNLOCK_WMI(wmip);
+
+    return activeTsids;
+}
+
+A_STATUS
+wmi_get_roam_tbl_cmd(struct wmi_t *wmip)
+{
+    return wmi_simple_cmd(wmip, WMI_GET_ROAM_TBL_CMDID);
+}
+
+A_STATUS
+wmi_get_roam_data_cmd(struct wmi_t *wmip, A_UINT8 roamDataType)
+{
+    void *osbuf;
+    A_UINT32 size = sizeof(A_UINT8);
+    WMI_TARGET_ROAM_DATA *cmd;
+
+    osbuf = A_NETBUF_ALLOC(size);      /* no payload */
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_TARGET_ROAM_DATA *)(A_NETBUF_DATA(osbuf));
+    cmd->roamDataType = roamDataType;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_GET_ROAM_DATA_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_roam_ctrl_cmd(struct wmi_t *wmip, WMI_SET_ROAM_CTRL_CMD *p,
+                      A_UINT8 size)
+{
+    void *osbuf;
+    WMI_SET_ROAM_CTRL_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_SET_ROAM_CTRL_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+
+    A_MEMCPY(cmd, p, size);
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_ROAM_CTRL_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_powersave_timers_cmd(struct wmi_t *wmip,
+                            WMI_POWERSAVE_TIMERS_POLICY_CMD *pCmd,
+                            A_UINT8 size)
+{
+    void *osbuf;
+    WMI_POWERSAVE_TIMERS_POLICY_CMD *cmd;
+
+    /* These timers can't be zero */
+    if(!pCmd->psPollTimeout || !pCmd->triggerTimeout ||
+       !(pCmd->apsdTimPolicy == IGNORE_TIM_ALL_QUEUES_APSD ||
+         pCmd->apsdTimPolicy == PROCESS_TIM_ALL_QUEUES_APSD) ||
+       !(pCmd->simulatedAPSDTimPolicy == IGNORE_TIM_SIMULATED_APSD ||
+         pCmd->simulatedAPSDTimPolicy == PROCESS_TIM_SIMULATED_APSD))
+        return A_EINVAL;
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_POWERSAVE_TIMERS_POLICY_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+
+    A_MEMCPY(cmd, pCmd, size);
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_POWERSAVE_TIMERS_POLICY_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+#ifdef CONFIG_HOST_GPIO_SUPPORT
+/* Send a command to Target to change GPIO output pins. */
+A_STATUS
+wmi_gpio_output_set(struct wmi_t *wmip,
+                    A_UINT32 set_mask,
+                    A_UINT32 clear_mask,
+                    A_UINT32 enable_mask,
+                    A_UINT32 disable_mask)
+{
+    void *osbuf;
+    WMIX_GPIO_OUTPUT_SET_CMD *output_set;
+    int size;
+
+    size = sizeof(*output_set);
+
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Enter - set=0x%x clear=0x%x enb=0x%x dis=0x%x\n", DBGARG,
+        set_mask, clear_mask, enable_mask, disable_mask));
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+    A_NETBUF_PUT(osbuf, size);
+    output_set = (WMIX_GPIO_OUTPUT_SET_CMD *)(A_NETBUF_DATA(osbuf));
+
+    output_set->set_mask                   = set_mask;
+    output_set->clear_mask                 = clear_mask;
+    output_set->enable_mask                = enable_mask;
+    output_set->disable_mask               = disable_mask;
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_GPIO_OUTPUT_SET_CMDID,
+                             NO_SYNC_WMIFLAG));
+}
+
+/* Send a command to the Target requesting state of the GPIO input pins */
+A_STATUS
+wmi_gpio_input_get(struct wmi_t *wmip)
+{
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    return wmi_simple_cmd_xtnd(wmip, WMIX_GPIO_INPUT_GET_CMDID);
+}
+
+/* Send a command to the Target that changes the value of a GPIO register. */
+A_STATUS
+wmi_gpio_register_set(struct wmi_t *wmip,
+                      A_UINT32 gpioreg_id,
+                      A_UINT32 value)
+{
+    void *osbuf;
+    WMIX_GPIO_REGISTER_SET_CMD *register_set;
+    int size;
+
+    size = sizeof(*register_set);
+
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Enter - reg=%d value=0x%x\n", DBGARG, gpioreg_id, value));
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+    A_NETBUF_PUT(osbuf, size);
+    register_set = (WMIX_GPIO_REGISTER_SET_CMD *)(A_NETBUF_DATA(osbuf));
+
+    register_set->gpioreg_id               = gpioreg_id;
+    register_set->value                    = value;
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_GPIO_REGISTER_SET_CMDID,
+                             NO_SYNC_WMIFLAG));
+}
+
+/* Send a command to the Target to fetch the value of a GPIO register. */
+A_STATUS
+wmi_gpio_register_get(struct wmi_t *wmip,
+                      A_UINT32 gpioreg_id)
+{
+    void *osbuf;
+    WMIX_GPIO_REGISTER_GET_CMD *register_get;
+    int size;
+
+    size = sizeof(*register_get);
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter - reg=%d\n", DBGARG, gpioreg_id));
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+    A_NETBUF_PUT(osbuf, size);
+    register_get = (WMIX_GPIO_REGISTER_GET_CMD *)(A_NETBUF_DATA(osbuf));
+
+    register_get->gpioreg_id               = gpioreg_id;
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_GPIO_REGISTER_GET_CMDID,
+                             NO_SYNC_WMIFLAG));
+}
+
+/* Send a command to the Target acknowledging some GPIO interrupts. */
+A_STATUS
+wmi_gpio_intr_ack(struct wmi_t *wmip,
+                  A_UINT32 ack_mask)
+{
+    void *osbuf;
+    WMIX_GPIO_INTR_ACK_CMD *intr_ack;
+    int size;
+
+    size = sizeof(*intr_ack);
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter ack_mask=0x%x\n", DBGARG, ack_mask));
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+    A_NETBUF_PUT(osbuf, size);
+    intr_ack = (WMIX_GPIO_INTR_ACK_CMD *)(A_NETBUF_DATA(osbuf));
+
+    intr_ack->ack_mask               = ack_mask;
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_GPIO_INTR_ACK_CMDID,
+                             NO_SYNC_WMIFLAG));
+}
+#endif /* CONFIG_HOST_GPIO_SUPPORT */
+
+A_STATUS
+wmi_set_access_params_cmd(struct wmi_t *wmip, A_UINT16 txop, A_UINT8 eCWmin,
+                          A_UINT8 eCWmax, A_UINT8 aifsn)
+{
+    void *osbuf;
+    WMI_SET_ACCESS_PARAMS_CMD *cmd;
+
+    if ((eCWmin > WMI_MAX_CW_ACPARAM) || (eCWmax > WMI_MAX_CW_ACPARAM) ||
+        (aifsn > WMI_MAX_AIFSN_ACPARAM))
+    {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_ACCESS_PARAMS_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->txop   = txop;
+    cmd->eCWmin = eCWmin;
+    cmd->eCWmax = eCWmax;
+    cmd->aifsn  = aifsn;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_ACCESS_PARAMS_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_retry_limits_cmd(struct wmi_t *wmip, A_UINT8 frameType,
+                         A_UINT8 trafficClass, A_UINT8 maxRetries,
+                         A_UINT8 enableNotify)
+{
+    void *osbuf;
+    WMI_SET_RETRY_LIMITS_CMD *cmd;
+
+    if ((frameType != MGMT_FRAMETYPE) && (frameType != CONTROL_FRAMETYPE) &&
+        (frameType != DATA_FRAMETYPE))
+    {
+        return A_EINVAL;
+    }
+
+    if (maxRetries > WMI_MAX_RETRIES) {
+        return A_EINVAL;
+    }
+
+    if (frameType != DATA_FRAMETYPE) {
+        trafficClass = 0;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_RETRY_LIMITS_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->frameType    = frameType;
+    cmd->trafficClass = trafficClass;
+    cmd->maxRetries   = maxRetries;
+    cmd->enableNotify = enableNotify;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_RETRY_LIMITS_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+void
+wmi_get_current_bssid(struct wmi_t *wmip, A_UINT8 *bssid)
+{
+    if (bssid != NULL) {
+        A_MEMCPY(bssid, wmip->wmi_bssid, ATH_MAC_LEN);
+    }
+}
+
+A_STATUS
+wmi_set_opt_mode_cmd(struct wmi_t *wmip, A_UINT8 optMode)
+{
+    void *osbuf;
+    WMI_SET_OPT_MODE_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_OPT_MODE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->optMode = optMode;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_OPT_MODE_CMDID,
+                         SYNC_BOTH_WMIFLAG));
+}
+
+A_STATUS
+wmi_opt_tx_frame_cmd(struct wmi_t *wmip,
+                      A_UINT8 frmType,
+                      A_UINT8 *dstMacAddr,
+                      A_UINT8 *bssid,
+                      A_UINT16 optIEDataLen,
+                      A_UINT8 *optIEData)
+{
+    void *osbuf;
+    WMI_OPT_TX_FRAME_CMD *cmd;
+    osbuf = A_NETBUF_ALLOC(optIEDataLen + sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, (optIEDataLen + sizeof(*cmd)));
+
+    cmd = (WMI_OPT_TX_FRAME_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, (optIEDataLen + sizeof(*cmd)-1));
+
+    cmd->frmType    = frmType;
+    cmd->optIEDataLen   = optIEDataLen;
+    //cmd->optIEData     = (A_UINT8 *)((int)cmd + sizeof(*cmd));
+    A_MEMCPY(cmd->bssid, bssid, sizeof(cmd->bssid));
+    A_MEMCPY(cmd->dstAddr, dstMacAddr, sizeof(cmd->dstAddr));
+    A_MEMCPY(&cmd->optIEData[0], optIEData, optIEDataLen);
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_OPT_TX_FRAME_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_adhoc_bconIntvl_cmd(struct wmi_t *wmip, A_UINT16 intvl)
+{
+    void *osbuf;
+    WMI_BEACON_INT_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_BEACON_INT_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->beaconInterval = intvl;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_BEACON_INT_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+
+A_STATUS
+wmi_set_voice_pkt_size_cmd(struct wmi_t *wmip, A_UINT16 voicePktSize)
+{
+    void *osbuf;
+    WMI_SET_VOICE_PKT_SIZE_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_VOICE_PKT_SIZE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->voicePktSize = voicePktSize;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_VOICE_PKT_SIZE_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+
+A_STATUS
+wmi_set_max_sp_len_cmd(struct wmi_t *wmip, A_UINT8 maxSPLen)
+{
+    void *osbuf;
+    WMI_SET_MAX_SP_LEN_CMD *cmd;
+
+    /* maxSPLen is a two-bit value. If user trys to set anything
+     * other than this, then its invalid
+     */
+    if(maxSPLen & ~0x03)
+        return  A_EINVAL;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_MAX_SP_LEN_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->maxSPLen = maxSPLen;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_MAX_SP_LEN_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+static A_UINT8
+ar6000_determine_userPriority(
+    A_UINT8 *pkt,
+    A_UINT32 layer2Pri)
+{
+    A_UINT8 ipPri;
+    iphdr *ipHdr = (iphdr *)pkt;
+
+    /* Determine IPTOS priority */
+    /*
+     * IP Tos format :
+     *      (Refer Pg 57 WMM-test-plan-v1.2)
+     * IP-TOS - 8bits
+     *          : DSCP(6-bits) ECN(2-bits)
+     *          : DSCP - P2 P1 P0 X X X
+     *              where (P2 P1 P0) form 802.1D
+     */
+    ipPri = ipHdr->ip_tos >> 5;
+    ipPri &= 0x7;
+
+    if ((layer2Pri & 0x7) > ipPri)
+        return ((A_UINT8)layer2Pri & 0x7);
+    else
+        return ipPri;
+}
+
+A_UINT8
+convert_userPriority_to_trafficClass(A_UINT8 userPriority)
+{
+        return  (up_to_ac[userPriority & 0x7]);
+}
+
+A_UINT8
+wmi_get_power_mode_cmd(struct wmi_t *wmip)
+{
+    return wmip->wmi_powerMode;
+}
+
+A_STATUS
+wmi_verify_tspec_params(WMI_CREATE_PSTREAM_CMD *pCmd, A_BOOL tspecCompliance)
+{
+    A_STATUS ret = A_OK;
+
+#define TSPEC_SUSPENSION_INTERVAL_ATHEROS_DEF (~0)
+#define TSPEC_SERVICE_START_TIME_ATHEROS_DEF  0
+#define TSPEC_MAX_BURST_SIZE_ATHEROS_DEF      0
+#define TSPEC_DELAY_BOUND_ATHEROS_DEF         0
+#define TSPEC_MEDIUM_TIME_ATHEROS_DEF         0
+#define TSPEC_SBA_ATHEROS_DEF                 0x2000  /* factor is 1 */
+
+    /* Verify TSPEC params for ATHEROS compliance */
+    if(tspecCompliance == ATHEROS_COMPLIANCE) {
+        if ((pCmd->suspensionInt != TSPEC_SUSPENSION_INTERVAL_ATHEROS_DEF) ||
+            (pCmd->serviceStartTime != TSPEC_SERVICE_START_TIME_ATHEROS_DEF) ||
+            (pCmd->minDataRate != pCmd->meanDataRate) ||
+            (pCmd->minDataRate != pCmd->peakDataRate) ||
+            (pCmd->maxBurstSize != TSPEC_MAX_BURST_SIZE_ATHEROS_DEF) ||
+            (pCmd->delayBound != TSPEC_DELAY_BOUND_ATHEROS_DEF) ||
+            (pCmd->sba != TSPEC_SBA_ATHEROS_DEF) ||
+            (pCmd->mediumTime != TSPEC_MEDIUM_TIME_ATHEROS_DEF)) {
+
+            A_DPRINTF(DBG_WMI, (DBGFMT "Invalid TSPEC params\n", DBGARG));
+            //A_PRINTF("%s: Invalid TSPEC params\n", __func__);
+            ret = A_EINVAL;
+        }
+    }
+
+    return ret;
+}
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+static A_STATUS
+wmi_tcmd_test_report_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+
+   A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+   A_WMI_TCMD_RX_REPORT_EVENT(wmip->wmi_devt, datap, len);
+
+   return A_OK;
+}
+
+#endif /* CONFIG_HOST_TCMD_SUPPORT*/
+
+A_STATUS
+wmi_set_authmode_cmd(struct wmi_t *wmip, A_UINT8 mode)
+{
+    void *osbuf;
+    WMI_SET_AUTH_MODE_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_AUTH_MODE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->mode = mode;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_AUTH_MODE_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_reassocmode_cmd(struct wmi_t *wmip, A_UINT8 mode)
+{
+    void *osbuf;
+    WMI_SET_REASSOC_MODE_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_REASSOC_MODE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->mode = mode;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_REASSOC_MODE_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_lpreamble_cmd(struct wmi_t *wmip, A_UINT8 status)
+{
+    void *osbuf;
+    WMI_SET_LPREAMBLE_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_LPREAMBLE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->status = status;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_LPREAMBLE_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_rts_cmd(struct wmi_t *wmip, A_UINT16 threshold)
+{
+    void *osbuf;
+    WMI_SET_RTS_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_RTS_CMD*)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->threshold = threshold;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_RTS_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_wmm_cmd(struct wmi_t *wmip, WMI_WMM_STATUS status)
+{
+    void *osbuf;
+    WMI_SET_WMM_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_WMM_CMD*)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->status = status;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_WMM_CMDID,
+            NO_SYNC_WMIFLAG));
+
+}
+
+A_STATUS
+wmi_set_wmm_txop(struct wmi_t *wmip, WMI_TXOP_CFG cfg)
+{
+    void *osbuf;
+    WMI_SET_WMM_TXOP_CMD *cmd;
+
+    if( !((cfg == WMI_TXOP_DISABLED) || (cfg == WMI_TXOP_ENABLED)) )
+        return A_EINVAL;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_WMM_TXOP_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->txopEnable = cfg;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_WMM_TXOP_CMDID,
+            NO_SYNC_WMIFLAG));
+
+}
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+/* WMI  layer doesn't need to know the data type of the test cmd.
+   This would be beneficial for customers like Qualcomm, who might
+   have different test command requirements from differnt manufacturers
+ */
+A_STATUS
+wmi_test_cmd(struct wmi_t *wmip, A_UINT8 *buf, A_UINT32  len)
+{
+    void *osbuf;
+    char *data;
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    osbuf= A_NETBUF_ALLOC(len);
+    if(osbuf == NULL)
+    {
+        return A_NO_MEMORY;
+    }
+    A_NETBUF_PUT(osbuf, len);
+    data = A_NETBUF_DATA(osbuf);
+    A_MEMCPY(data, buf, len);
+
+    return(wmi_cmd_send(wmip, osbuf, WMI_TEST_CMDID,
+         NO_SYNC_WMIFLAG));
+}
+
+#endif
+
+A_STATUS
+wmi_set_bt_status_cmd(struct wmi_t *wmip, A_UINT8 streamType, A_UINT8 status)
+{
+    void *osbuf;
+    WMI_SET_BT_STATUS_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_BT_STATUS_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->streamType = streamType;
+    cmd->status = status;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_BT_STATUS_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_bt_params_cmd(struct wmi_t *wmip, WMI_SET_BT_PARAMS_CMD* cmd)
+{
+    void *osbuf;
+    WMI_SET_BT_PARAMS_CMD* alloc_cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    alloc_cmd = (WMI_SET_BT_PARAMS_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(alloc_cmd, sizeof(*cmd));
+    A_MEMCPY(alloc_cmd, cmd, sizeof(*cmd));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_BT_PARAMS_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_get_keepalive_configured(struct wmi_t *wmip)
+{
+    void *osbuf;
+    WMI_GET_KEEPALIVE_CMD *cmd;
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+    cmd = (WMI_GET_KEEPALIVE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    return (wmi_cmd_send(wmip, osbuf, WMI_GET_KEEPALIVE_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_UINT8
+wmi_get_keepalive_cmd(struct wmi_t *wmip)
+{
+    return wmip->wmi_keepaliveInterval;
+}
+
+A_STATUS
+wmi_set_keepalive_cmd(struct wmi_t *wmip, A_UINT8 keepaliveInterval)
+{
+    void *osbuf;
+    WMI_SET_KEEPALIVE_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_KEEPALIVE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->keepaliveInterval = keepaliveInterval;
+    wmip->wmi_keepaliveInterval = keepaliveInterval;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_KEEPALIVE_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_appie_cmd(struct wmi_t *wmip, A_UINT8 mgmtFrmType, A_UINT8 ieLen,
+                  A_UINT8 *ieInfo)
+{
+    void *osbuf;
+    WMI_SET_APPIE_CMD *cmd;
+    A_UINT16 cmdLen;
+
+    cmdLen = sizeof(*cmd) + ieLen - 1;
+    osbuf = A_NETBUF_ALLOC(cmdLen);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, cmdLen);
+
+    cmd = (WMI_SET_APPIE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, cmdLen);
+
+    cmd->mgmtFrmType = mgmtFrmType;
+    cmd->ieLen = ieLen;
+    A_MEMCPY(cmd->ieInfo, ieInfo, ieLen);
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_APPIE_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_halparam_cmd(struct wmi_t *wmip, A_UINT8 *cmd, A_UINT16 dataLen)
+{
+    void *osbuf;
+    A_UINT8 *data;
+
+    osbuf = A_NETBUF_ALLOC(dataLen);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, dataLen);
+
+    data = A_NETBUF_DATA(osbuf);
+
+    A_MEMCPY(data, cmd, dataLen);
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_WHALPARAM_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_INT32
+wmi_get_rate(A_INT8 rateindex)
+{
+    if (rateindex == RATE_AUTO) {
+        return 0;
+    } else {
+        return(wmi_rateTable[(A_UINT32) rateindex]);
+    }
+}
+
+void
+wmi_node_return (struct wmi_t *wmip, bss_t *bss)
+{
+	if (NULL != bss)
+	{
+		wlan_node_return (&wmip->wmi_scan_table, bss);
+	}
+}
+
+void
+wmi_set_nodeage(struct wmi_t *wmip, A_UINT32 nodeAge)
+{
+    wlan_set_nodeage(&wmip->wmi_scan_table,nodeAge);
+}
+
+bss_t *
+wmi_find_Ssidnode (struct wmi_t *wmip, A_UCHAR *pSsid,
+                   A_UINT32 ssidLength, A_BOOL bIsWPA2, A_BOOL bMatchSSID)
+{
+	bss_t *node = NULL;
+    node = wlan_find_Ssidnode (&wmip->wmi_scan_table, pSsid,
+                               ssidLength, bIsWPA2, bMatchSSID);
+	return node;
+}
+
+void
+wmi_free_allnodes(struct wmi_t *wmip)
+{
+	wlan_free_allnodes(&wmip->wmi_scan_table);
+}
+
+bss_t *
+wmi_find_node(struct wmi_t *wmip, const A_UINT8 *macaddr)
+{
+	bss_t *ni=NULL;
+	ni=wlan_find_node(&wmip->wmi_scan_table,macaddr);
+	return ni;
+}
+
+void
+wmi_free_node(struct wmi_t *wmip, const A_UINT8 *macaddr)
+{
+    bss_t *ni=NULL;
+
+    ni=wlan_find_node(&wmip->wmi_scan_table,macaddr);
+    if (ni != NULL) {
+        wlan_node_reclaim(&wmip->wmi_scan_table, ni);
+    }
+
+    return;
+}
+
+A_STATUS
+wmi_dset_open_reply(struct wmi_t *wmip,
+                    A_UINT32 status,
+                    A_UINT32 access_cookie,
+                    A_UINT32 dset_size,
+                    A_UINT32 dset_version,
+                    A_UINT32 targ_handle,
+                    A_UINT32 targ_reply_fn,
+                    A_UINT32 targ_reply_arg)
+{
+    void *osbuf;
+    WMIX_DSETOPEN_REPLY_CMD *open_reply;
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter - wmip=0x%x\n", DBGARG, (int)wmip));
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*open_reply));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*open_reply));
+    open_reply = (WMIX_DSETOPEN_REPLY_CMD *)(A_NETBUF_DATA(osbuf));
+
+    open_reply->status                   = status;
+    open_reply->targ_dset_handle         = targ_handle;
+    open_reply->targ_reply_fn            = targ_reply_fn;
+    open_reply->targ_reply_arg           = targ_reply_arg;
+    open_reply->access_cookie            = access_cookie;
+    open_reply->size                     = dset_size;
+    open_reply->version                  = dset_version;
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_DSETOPEN_REPLY_CMDID,
+                             NO_SYNC_WMIFLAG));
+}
+
+/* for backwards compatibility with pre-2.1.x firmware */
+static A_STATUS
+wmi_get_pmkid_list_event_rx_1(struct wmi_t *wmip, A_UINT8 *datap, A_UINT32 len)
+{
+    WMI_PMKID_LIST_REPLY_1 *reply1;
+    WMI_PMKID_LIST_REPLY_2 *reply2;
+    A_UINT32 expected_len, new_len;
+    WMI_PMKID *pmkidList1, *pmkidList2;
+    int i;
+
+    if (len < sizeof(WMI_PMKID_LIST_REPLY_1)) {
+        return A_EINVAL;
+    }
+    reply1 = (WMI_PMKID_LIST_REPLY_1 *)datap;
+    expected_len = sizeof(reply1->numPMKID) + reply1->numPMKID * WMI_PMKID_LEN;
+
+    if (len < expected_len) {
+        return A_EINVAL;
+    }
+
+    new_len = sizeof(reply1->numPMKID)
+                   + reply1->numPMKID * (ATH_MAC_LEN + WMI_PMKID_LEN);
+
+    reply2 = A_MALLOC(new_len);
+    if (!reply2)
+        return A_ERROR;
+    A_MEMZERO(reply2, new_len);
+
+    reply2->numPMKID = reply1->numPMKID;
+    pmkidList1 = reply1->pmkidList;
+    pmkidList2 = reply2->pmkidList;
+    for (i = 0; i < reply1->numPMKID; i++) {
+        *pmkidList2 = *pmkidList1;
+        pmkidList1 = (WMI_PMKID *)
+            (((unsigned char *) pmkidList1) + WMI_PMKID_LEN);
+        pmkidList2 = (WMI_PMKID *)
+            (((unsigned char *) pmkidList2) + WMI_PMKID_LEN + ATH_MAC_LEN);
+    }
+
+    /*
+     * Since the pre-2.1.x firmware doesn't return the bssidList information,
+     * we are passing zeros for every bssidList entry.
+     */
+    A_WMI_PMKID_LIST_EVENT(wmip->wmi_devt, reply2->numPMKID,
+                           reply2->pmkidList, reply2->bssidList[0]);
+
+    A_FREE(reply2);
+
+    return A_OK;
+}
+
+/* for version 2.1.x firmware */
+static A_STATUS
+wmi_get_pmkid_list_event_rx_2(struct wmi_t *wmip, A_UINT8 *datap, A_UINT32 len)
+{
+    WMI_PMKID_LIST_REPLY_2 *reply;
+    A_UINT32 expected_len;
+
+    if (len < sizeof(WMI_PMKID_LIST_REPLY_2)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_PMKID_LIST_REPLY_2 *)datap;
+    expected_len = sizeof(reply->numPMKID)
+                   + reply->numPMKID * (ATH_MAC_LEN + WMI_PMKID_LEN);
+
+    if (len < expected_len) {
+        return A_EINVAL;
+    }
+
+    A_WMI_PMKID_LIST_EVENT(wmip->wmi_devt, reply->numPMKID,
+                           reply->pmkidList, reply->bssidList[0]);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_get_pmkid_list_event_rx(struct wmi_t *wmip, A_UINT8 *datap, A_UINT32 len)
+{
+    A_STATUS status;
+
+    if ((WMI_TARGET_TYPE(wmip) == TARGET_TYPE_AR6001)
+        && (WMI_TARGET_VERSION(wmip) < AR6K_VERSION(2, 1, 0, 0)))
+    {
+        status = wmi_get_pmkid_list_event_rx_1(wmip, datap, len);
+    } else
+        status = wmi_get_pmkid_list_event_rx_2(wmip, datap, len);
+
+    return status;
+}
+
+#ifdef CONFIG_HOST_DSET_SUPPORT
+A_STATUS
+wmi_dset_data_reply(struct wmi_t *wmip,
+                    A_UINT32 status,
+                    A_UINT8 *user_buf,
+                    A_UINT32 length,
+                    A_UINT32 targ_buf,
+                    A_UINT32 targ_reply_fn,
+                    A_UINT32 targ_reply_arg)
+{
+    void *osbuf;
+    WMIX_DSETDATA_REPLY_CMD *data_reply;
+    int size;
+
+    size = sizeof(*data_reply) + length;
+
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Enter - length=%d status=%d\n", DBGARG, length, status));
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+    A_NETBUF_PUT(osbuf, size);
+    data_reply = (WMIX_DSETDATA_REPLY_CMD *)(A_NETBUF_DATA(osbuf));
+
+    data_reply->status                     = status;
+    data_reply->targ_buf                   = targ_buf;
+    data_reply->targ_reply_fn              = targ_reply_fn;
+    data_reply->targ_reply_arg             = targ_reply_arg;
+    data_reply->length                     = length;
+
+    if (status == A_OK) {
+        if (a_copy_from_user(data_reply->buf, user_buf, length)) {
+            return A_ERROR;
+        }
+    }
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_DSETDATA_REPLY_CMDID,
+                             NO_SYNC_WMIFLAG));
+}
+#endif /* CONFIG_HOST_DSET_SUPPORT */
+
+A_STATUS
+wmi_set_wsc_status_cmd(struct wmi_t *wmip, A_UINT32 status)
+{
+    void *osbuf;
+    char *cmd;
+
+	wps_enable = status;
+
+    osbuf = a_netbuf_alloc(sizeof(1));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    a_netbuf_put(osbuf, sizeof(1));
+
+    cmd = (char *)(a_netbuf_to_data(osbuf));
+
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd[0] = (status?1:0);
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_WSC_STATUS_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+#if defined(CONFIG_TARGET_PROFILE_SUPPORT)
+A_STATUS
+wmi_prof_cfg_cmd(struct wmi_t *wmip,
+                 A_UINT32 period,
+                 A_UINT32 nbins)
+{
+    void *osbuf;
+    WMIX_PROF_CFG_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMIX_PROF_CFG_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->period = period;
+    cmd->nbins  = nbins;
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_PROF_CFG_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_prof_addr_set_cmd(struct wmi_t *wmip, A_UINT32 addr)
+{
+    void *osbuf;
+    WMIX_PROF_ADDR_SET_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMIX_PROF_ADDR_SET_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->addr = addr;
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_PROF_ADDR_SET_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_prof_start_cmd(struct wmi_t *wmip)
+{
+    return wmi_simple_cmd_xtnd(wmip, WMIX_PROF_START_CMDID);
+}
+
+A_STATUS
+wmi_prof_stop_cmd(struct wmi_t *wmip)
+{
+    return wmi_simple_cmd_xtnd(wmip, WMIX_PROF_STOP_CMDID);
+}
+
+A_STATUS
+wmi_prof_count_get_cmd(struct wmi_t *wmip)
+{
+    return wmi_simple_cmd_xtnd(wmip, WMIX_PROF_COUNT_GET_CMDID);
+}
+
+/* Called to handle WMIX_PROF_CONT_EVENTID */
+static A_STATUS
+wmi_prof_count_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMIX_PROF_COUNT_EVENT *prof_data = (WMIX_PROF_COUNT_EVENT *)datap;
+
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Enter - addr=0x%x count=%d\n", DBGARG,
+        prof_data->addr, prof_data->count));
+
+    A_WMI_PROF_COUNT_RX(prof_data->addr, prof_data->count);
+
+    return A_OK;
+}
+#endif /* CONFIG_TARGET_PROFILE_SUPPORT */
+
+#ifdef OS_ROAM_MANAGEMENT
+
+#define ETHERNET_MAC_ADDRESS_LENGTH    6
+
+void
+wmi_scan_indication (struct wmi_t *wmip)
+{
+    struct ieee80211_node_table *nt;
+    A_UINT32 gen;
+    A_UINT32 size;
+    A_UINT32 bsssize;
+    bss_t *bss;
+    A_UINT32 numbss;
+    PNDIS_802_11_BSSID_SCAN_INFO psi;
+    PBYTE  pie;
+    NDIS_802_11_FIXED_IEs *pFixed;
+    NDIS_802_11_VARIABLE_IEs *pVar;
+    A_UINT32  RateSize;
+
+    struct ar6kScanIndication
+    {
+        NDIS_802_11_STATUS_INDICATION     ind;
+        NDIS_802_11_BSSID_SCAN_INFO_LIST  slist;
+    } *pAr6kScanIndEvent;
+
+    nt = &wmip->wmi_scan_table;
+
+    ++nt->nt_si_gen;
+
+
+    gen = nt->nt_si_gen;
+
+    size = offsetof(struct ar6kScanIndication, slist) +
+           offsetof(NDIS_802_11_BSSID_SCAN_INFO_LIST, BssidScanInfo);
+
+    numbss = 0;
+
+    IEEE80211_NODE_LOCK(nt);
+
+    //calc size
+    for (bss = nt->nt_node_first; bss; bss = bss->ni_list_next) {
+        if (bss->ni_si_gen != gen) {
+            bsssize = offsetof(NDIS_802_11_BSSID_SCAN_INFO, Bssid) + offsetof(NDIS_WLAN_BSSID_EX, IEs);
+            bsssize = bsssize + sizeof(NDIS_802_11_FIXED_IEs);
+
+#ifdef SUPPORT_WPA2
+            if (bss->ni_cie.ie_rsn) {
+                bsssize = bsssize + bss->ni_cie.ie_rsn[1] + 2;
+            }
+#endif
+            if (bss->ni_cie.ie_wpa) {
+                bsssize = bsssize + bss->ni_cie.ie_wpa[1] + 2;
+            }
+
+            // bsssize must be a multiple of 4 to maintain alignment.
+            bsssize = (bsssize + 3) & ~3;
+
+            size += bsssize;
+
+            numbss++;
+        }
+    }
+
+    if (0 == numbss)
+    {
+//        RETAILMSG(1, (L"AR6K: scan indication: 0 bss\n"));
+        ar6000_scan_indication (wmip->wmi_devt, NULL, 0);
+        IEEE80211_NODE_UNLOCK (nt);
+        return;
+    }
+
+    pAr6kScanIndEvent = A_MALLOC(size);
+
+    if (NULL == pAr6kScanIndEvent)
+    {
+        IEEE80211_NODE_UNLOCK(nt);
+        return;
+    }
+
+    A_MEMZERO(pAr6kScanIndEvent, size);
+
+    //copy data
+    pAr6kScanIndEvent->ind.StatusType = Ndis802_11StatusType_BssidScanInfoList;
+    pAr6kScanIndEvent->slist.Version = 1;
+    pAr6kScanIndEvent->slist.NumItems = numbss;
+
+    psi = &pAr6kScanIndEvent->slist.BssidScanInfo[0];
+
+    for (bss = nt->nt_node_first; bss; bss = bss->ni_list_next) {
+        if (bss->ni_si_gen != gen) {
+
+            bss->ni_si_gen = gen;
+
+            //Set scan time
+            psi->ScanTime = bss->ni_tstamp - WLAN_NODE_INACT_TIMEOUT_MSEC;
+
+            // Copy data to bssid_ex
+            bsssize = offsetof(NDIS_WLAN_BSSID_EX, IEs);
+            bsssize = bsssize + sizeof(NDIS_802_11_FIXED_IEs);
+
+#ifdef SUPPORT_WPA2
+            if (bss->ni_cie.ie_rsn) {
+                bsssize = bsssize + bss->ni_cie.ie_rsn[1] + 2;
+            }
+#endif
+            if (bss->ni_cie.ie_wpa) {
+                bsssize = bsssize + bss->ni_cie.ie_wpa[1] + 2;
+            }
+
+            // bsssize must be a multiple of 4 to maintain alignment.
+            bsssize = (bsssize + 3) & ~3;
+
+            psi->Bssid.Length = bsssize;
+
+            memcpy (psi->Bssid.MacAddress, bss->ni_macaddr, ETHERNET_MAC_ADDRESS_LENGTH);
+
+
+//if (((bss->ni_macaddr[3] == 0xCE) && (bss->ni_macaddr[4] == 0xF0) && (bss->ni_macaddr[5] == 0xE7)) ||
+//  ((bss->ni_macaddr[3] == 0x03) && (bss->ni_macaddr[4] == 0xE2) && (bss->ni_macaddr[5] == 0x70)))
+//            RETAILMSG (1, (L"%x\n",bss->ni_macaddr[5]));
+
+            psi->Bssid.Ssid.SsidLength = 0;
+            pie = bss->ni_cie.ie_ssid;
+
+            if (pie) {
+                // Format of SSID IE is:
+                //  Type   (1 octet)
+                //  Length (1 octet)
+                //  SSID (Length octets)
+                //
+                //  Validation of the IE should have occurred within WMI.
+                //
+                if (pie[1] <= 32) {
+                    psi->Bssid.Ssid.SsidLength = pie[1];
+                    memcpy(psi->Bssid.Ssid.Ssid, &pie[2], psi->Bssid.Ssid.SsidLength);
+                }
+            }
+            psi->Bssid.Privacy = (bss->ni_cie.ie_capInfo & 0x10) ? 1 : 0;
+
+            //Post the RSSI value relative to the Standard Noise floor value.
+            psi->Bssid.Rssi = bss->ni_rssi;
+
+            if (bss->ni_cie.ie_chan >= 2412 && bss->ni_cie.ie_chan <= 2484) {
+
+                if (bss->ni_cie.ie_rates && bss->ni_cie.ie_xrates) {
+                    psi->Bssid.NetworkTypeInUse = Ndis802_11OFDM24;
+                }
+                else {
+                    psi->Bssid.NetworkTypeInUse = Ndis802_11DS;
+                }
+            }
+            else {
+                psi->Bssid.NetworkTypeInUse = Ndis802_11OFDM5;
+            }
+
+            psi->Bssid.Configuration.Length = sizeof(psi->Bssid.Configuration);
+            psi->Bssid.Configuration.BeaconPeriod = bss->ni_cie.ie_beaconInt; // Units are Kmicroseconds (1024 us)
+            psi->Bssid.Configuration.ATIMWindow =  0;
+            psi->Bssid.Configuration.DSConfig =  bss->ni_cie.ie_chan * 1000;
+            psi->Bssid.InfrastructureMode = ((bss->ni_cie.ie_capInfo & 0x03) == 0x01 ) ? Ndis802_11Infrastructure : Ndis802_11IBSS;
+
+            RateSize = 0;
+            pie = bss->ni_cie.ie_rates;
+            if (pie) {
+                RateSize = (pie[1] < NDIS_802_11_LENGTH_RATES_EX) ? pie[1] : NDIS_802_11_LENGTH_RATES_EX;
+                memcpy(psi->Bssid.SupportedRates, &pie[2], RateSize);
+            }
+            pie = bss->ni_cie.ie_xrates;
+            if (pie && RateSize < NDIS_802_11_LENGTH_RATES_EX) {
+                memcpy(psi->Bssid.SupportedRates + RateSize, &pie[2],
+                       (pie[1] < (NDIS_802_11_LENGTH_RATES_EX - RateSize)) ? pie[1] : (NDIS_802_11_LENGTH_RATES_EX - RateSize));
+            }
+
+            // Copy the fixed IEs
+            psi->Bssid.IELength = sizeof(NDIS_802_11_FIXED_IEs);
+
+            pFixed = (NDIS_802_11_FIXED_IEs *)psi->Bssid.IEs;
+            memcpy(pFixed->Timestamp, bss->ni_cie.ie_tstamp, sizeof(pFixed->Timestamp));
+            pFixed->BeaconInterval = bss->ni_cie.ie_beaconInt;
+            pFixed->Capabilities = bss->ni_cie.ie_capInfo;
+
+            // Copy selected variable IEs
+
+            pVar = (NDIS_802_11_VARIABLE_IEs *)((PBYTE)pFixed + sizeof(NDIS_802_11_FIXED_IEs));
+
+#ifdef SUPPORT_WPA2
+            // Copy the WPAv2 IE
+            if (bss->ni_cie.ie_rsn) {
+                pie = bss->ni_cie.ie_rsn;
+                psi->Bssid.IELength += pie[1] + 2;
+                memcpy(pVar, pie, pie[1] + 2);
+                pVar = (NDIS_802_11_VARIABLE_IEs *)((PBYTE)pVar + pie[1] + 2);
+            }
+#endif
+            // Copy the WPAv1 IE
+            if (bss->ni_cie.ie_wpa) {
+                pie = bss->ni_cie.ie_wpa;
+                psi->Bssid.IELength += pie[1] + 2;
+                memcpy(pVar, pie, pie[1] + 2);
+                pVar = (NDIS_802_11_VARIABLE_IEs *)((PBYTE)pVar + pie[1] + 2);
+            }
+
+            // Advance buffer pointer
+            psi = (PNDIS_802_11_BSSID_SCAN_INFO)((BYTE*)psi + bsssize + FIELD_OFFSET(NDIS_802_11_BSSID_SCAN_INFO, Bssid));
+        }
+    }
+
+    IEEE80211_NODE_UNLOCK(nt);
+
+//    wmi_free_allnodes(wmip);
+
+//    RETAILMSG(1, (L"AR6K: scan indication: %u bss\n", numbss));
+
+    ar6000_scan_indication (wmip->wmi_devt, pAr6kScanIndEvent, size);
+
+    A_FREE(pAr6kScanIndEvent);
+}
+#endif
+A_UINT8
+ar6000_get_upper_threshold(A_INT16 rssi, SQ_THRESHOLD_PARAMS *sq_thresh,
+                           A_UINT32 size)
+{
+    A_UINT32 index;
+    A_UINT8 threshold = (A_UINT8)sq_thresh->upper_threshold[size - 1];
+
+    /* The list is already in sorted order. Get the next lower value */
+    for (index = 0; index < size; index ++) {
+        if (rssi < sq_thresh->upper_threshold[index]) {
+            threshold = (A_UINT8)sq_thresh->upper_threshold[index];
+            break;
+        }
+    }
+
+    return threshold;
+}
+
+A_UINT8
+ar6000_get_lower_threshold(A_INT16 rssi, SQ_THRESHOLD_PARAMS *sq_thresh,
+                           A_UINT32 size)
+{
+    A_UINT32 index;
+    A_UINT8 threshold = (A_UINT8)sq_thresh->lower_threshold[size - 1];
+
+    /* The list is already in sorted order. Get the next lower value */
+    for (index = 0; index < size; index ++) {
+        if (rssi > sq_thresh->lower_threshold[index]) {
+            threshold = (A_UINT8)sq_thresh->lower_threshold[index];
+            break;
+        }
+    }
+
+    return threshold;
+}
+static A_STATUS
+wmi_send_rssi_threshold_params(struct wmi_t *wmip,
+                              WMI_RSSI_THRESHOLD_PARAMS_CMD *rssiCmd)
+{
+    void    *osbuf;
+    A_INT8  size;
+    WMI_RSSI_THRESHOLD_PARAMS_CMD *cmd;
+
+    size = sizeof (*cmd);
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_RSSI_THRESHOLD_PARAMS_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+    A_MEMCPY(cmd, rssiCmd, sizeof(WMI_RSSI_THRESHOLD_PARAMS_CMD));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_RSSI_THRESHOLD_PARAMS_CMDID,
+                            NO_SYNC_WMIFLAG));
+}
+static A_STATUS
+wmi_send_snr_threshold_params(struct wmi_t *wmip,
+                             WMI_SNR_THRESHOLD_PARAMS_CMD *snrCmd)
+{
+    void    *osbuf;
+    A_INT8  size;
+    WMI_SNR_THRESHOLD_PARAMS_CMD *cmd;
+
+    size = sizeof (*cmd);
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+    cmd = (WMI_SNR_THRESHOLD_PARAMS_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+    A_MEMCPY(cmd, snrCmd, sizeof(WMI_SNR_THRESHOLD_PARAMS_CMD));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SNR_THRESHOLD_PARAMS_CMDID,
+                            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_target_event_report_cmd(struct wmi_t *wmip, WMI_SET_TARGET_EVENT_REPORT_CMD* cmd)
+{
+    void *osbuf;
+    WMI_SET_TARGET_EVENT_REPORT_CMD* alloc_cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    alloc_cmd = (WMI_SET_TARGET_EVENT_REPORT_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(alloc_cmd, sizeof(*cmd));
+    A_MEMCPY(alloc_cmd, cmd, sizeof(*cmd));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_TARGET_EVENT_REPORT_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_mcast_filter_cmd(struct wmi_t *wmip, A_UINT8 dot1, A_UINT8 dot2, A_UINT8 dot3, A_UINT8 dot4)
+{
+    void *osbuf;
+    WMI_SET_MCAST_FILTER_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_MCAST_FILTER_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->multicast_mac[0] = 0x01;
+    cmd->multicast_mac[1] = 0x00;
+    cmd->multicast_mac[2] = 0x5e;
+    cmd->multicast_mac[3] = dot2&0x7F;
+    cmd->multicast_mac[4] = dot3;
+    cmd->multicast_mac[5] = dot4;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_MCAST_FILTER_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+
+A_STATUS
+wmi_del_mcast_filter_cmd(struct wmi_t *wmip, A_UINT8 dot1, A_UINT8 dot2, A_UINT8 dot3, A_UINT8 dot4)
+{
+    void *osbuf;
+    WMI_SET_MCAST_FILTER_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_MCAST_FILTER_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->multicast_mac[0] = 0x01;
+    cmd->multicast_mac[1] = 0x00;
+    cmd->multicast_mac[2] = 0x5e;
+    cmd->multicast_mac[3] = dot2&0x7F;
+    cmd->multicast_mac[4] = dot3;
+    cmd->multicast_mac[5] = dot4;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_DEL_MCAST_FILTER_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+bss_t *wmi_rm_current_bss (struct wmi_t *wmip, A_UINT8 *id)
+{
+    wmi_get_current_bssid (wmip, id);
+    return wlan_node_remove (&wmip->wmi_scan_table, id);
+}
+
+/*
+ * Add a node to the node table.  It is an error to add a node that duplicates
+ * the bssid of a node already in the table.  This routine increments the node
+ * reference count twice:  once for the caller's node reference, and once for
+ * linking the node to the table.  The caller must drop its node reference when
+ * it is finished with the node.
+ */
+A_STATUS wmi_add_current_bss (struct wmi_t *wmip, A_UINT8 *id, bss_t *bss)
+{
+    wlan_setup_node (&wmip->wmi_scan_table, bss, id);
+    return A_OK;
+}
Index: linux-2.6/drivers/sdio/hcd/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/hcd/Kconfig
@@ -0,0 +1,67 @@
+#
+#
+#
+
+menu "Host Controllers"
+
+config SDIO_ELLEN
+	tristate "PCI ELLEN (Tokyo Electron) host controller"
+	depends on PCI && !MMC_SDHCI
+	default m
+	help
+	  good luck.
+
+config SDIO_OMAP_2420
+	tristate "ARM OMAP 2420 host controller"
+	depends on ARCH_OMAP2420 && !MMC_OMAP
+	default m
+	help
+	  good luck.
+
+config SDIO_ATHSDIO
+	tristate "Generic Atheros SDIO Host Controller Driver"
+	select MMC
+	default m
+	help
+	  This option enables an SDIO function driver for the linux MMC core
+	  that will claim all SDIO devices on behalf of the Atheros SDIO stack.
+	  The driver then acts as a translation layer between the Atheros SDIO
+	  stack and a linux MMC host controller driver.  In theory, this driver
+	  should allow the use of any Atheros SDIO function driver with any
+	  linux MMC host controller driver, eliminating the need to write a
+	  native host controller driver for the Atheros SDIO stack.
+
+	  Note that this driver only supports SDIO cards, not MMC or SD cards.
+	  MMC and SD cards will continue to be supported by the linux MMC core.
+
+config ATHSDIO_BOUNCE
+	bool "Use bounce buffers for misaligned data"
+	depends on SDIO_ATHSDIO
+	default y
+	help
+	  The data buffers passed from the AR6000 driver to the Atheros SDIO
+	  Host Controller driver are not, in general, aligned with cache lines.
+	  This may cause cache coherency errors if the Linux SDIO controller
+	  driver uses DMA for the transfers despite the misalignment, or it can
+	  seriously degrade performance if the Linux SDIO controller driver
+	  uses PIO for misaligned buffers.  If this option is enabled, then the
+	  Atheros SDIO Host Controller Driver will use a bounce buffer for
+	  transfers that do not meet the alignement requirements.
+
+config ATHSDIO_TX_ALIGN
+	int "Alignment requirement for transmit (write) buffers"
+	depends on ATHSDIO_BOUNCE
+	default 5
+	help
+	  A bounce buffer will be used for any transmit buffers that are not
+	  aligned to this power of 2.
+
+config ATHSDIO_RX_ALIGN
+	int "Alignment requirement for receive (read) buffers"
+	depends on ATHSDIO_BOUNCE
+	default 5
+	help
+	  A bounce buffer will be used for any receive buffers that are not
+	  aligned to this power of 2.
+
+endmenu
Index: linux-2.6/drivers/sdio/hcd/Makefile
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/hcd/Makefile
@@ -0,0 +1,4 @@
+# SDIO stack host controller Makefile
+obj-$(CONFIG_SDIO_ELLEN)		+= pci_ellen/
+obj-$(CONFIG_SDIO_OMAP2420)		+= omap2420/
+obj-$(CONFIG_SDIO_ATHSDIO)		+= athsdio.o
Index: linux-2.6/drivers/sdio/hcd/athsdio.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/hcd/athsdio.c
@@ -0,0 +1,937 @@
+/*
+ * Atheros SDIO function driver.
+ *
+ * Andy Lowe (alowe@mvista.com), MontaVista Software
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio.h>
+#include "../../mmc/core/sdio_ops.h"
+#include <linux/sdio/ctsystem.h>
+#include <linux/sdio/sdio_busdriver.h>
+#include <linux/sdio/sdio_hcd_defs.h>
+#include <linux/sdio/_sdio_defs.h>
+#include <linux/scatterlist.h>
+
+#define DRV_NAME "athsdio"
+
+struct athsdio_slot {
+	struct sdio_func *func;
+	struct _SDHCD hcd;
+	struct mmc_host_ops host_ops;
+	const struct mmc_host_ops *original_host_ops;
+	struct workqueue_struct *wq;
+	struct work_struct work;
+	struct work_struct set_priority_work;
+#ifdef CONFIG_ATHSDIO_BOUNCE
+	void *bounce_buffer;
+	int tx_align;
+	int rx_align;
+#endif
+};
+
+static struct athsdio_slot *pathslot;
+
+/*
+ * Convert MMC capabilities (MMC_CAP_*) to Atheros
+ * attributes (SDHCD_ATTRIB_*).
+ */
+static u32 mmc_cap_to_ath_attrib(unsigned long cap)
+{
+	u32 attrib = 0;
+
+	/*
+	 * Set the attributes that are assumed to be valid for all controllers.
+	 */
+	attrib |= SDHCD_ATTRIB_BUS_1BIT;
+
+	if (cap & MMC_CAP_4_BIT_DATA)
+		attrib |= SDHCD_ATTRIB_BUS_4BIT;
+
+	if (cap & MMC_CAP_MMC_HIGHSPEED)
+		attrib |= SDHCD_ATTRIB_MMC_HIGH_SPEED;
+
+	if (cap & MMC_CAP_SD_HIGHSPEED)
+		attrib |= SDHCD_ATTRIB_SD_HIGH_SPEED;
+
+	/*
+	 * The Linux MMC core has a capability flag (MMC_CAP_SDIO_IRQ) to
+	 * indicate that a host controller has the capability to
+	 * asynchronously detect interrupts from SDIO cards.  If the capability
+	 * is advertised, it is assumed to work for all supported bus widths.
+	 * For host controllers that do not support asynchronous detection of
+	 * SDIO interrupts, the Linux MMC core polls the card interrupt status
+	 * from a kernel thread every 10ms.  Thus, SDIO interrupts should work
+	 * regardless of whether the host controller supports asynchronous
+	 * detection, but the interrupt response latency might prove to be
+	 * unacceptable in polling mode.
+	 *
+	 * The Atheros SDIO stack has a capability flag
+	 * (SDHCD_ATTRIB_NO_4BIT_IRQ) to indicate that a host controller does
+	 * not support SDIO interrupt detection when the bus width is 4 bits.
+	 * SDIO interrupt detection is mandatory when the bus width is 1 bit.
+	 `*
+	 * Since the Linux MMC core always supports SDIO interrupt detection,
+	 * either polled or asynchronous, for any bus width, we never set the
+	 * SDHCD_ATTRIB_NO_4BIT_IRQ attribute flag.
+	 */
+
+	/*
+	 * These attributes aren't currently supported by the MMC core:
+	 *      SDHCD_ATTRIB_BUS_SPI
+	 *      SDHCD_ATTRIB_MULTI_BLK_IRQ
+	 *      SDHCD_ATTRIB_BUS_MMC8BIT
+	 *      SDHCD_ATTRIB_NO_SPI_CRC
+	 *      SDHCD_ATTRIB_AUTO_CMD12
+	 */
+
+	return attrib;
+}
+
+/*
+ * Convert an Atheros bus width to a name.
+ */
+static const unsigned char *ath_bus_width_name(SD_BUSMODE_FLAGS bus_flags)
+{
+	static const unsigned char *bus_width_name[] =
+	    { "Unknown", "SPI", "1 Bit", "4 Bits", "8 Bits" };
+	SD_BUSMODE_FLAGS bus_width = SDCONFIG_GET_BUSWIDTH(bus_flags);
+	int i;
+
+	switch (bus_width) {
+	case SDCONFIG_BUS_WIDTH_SPI:
+		i = 1;
+		break;
+	case SDCONFIG_BUS_WIDTH_1_BIT:
+		i = 2;
+		break;
+	case SDCONFIG_BUS_WIDTH_4_BIT:
+		i = 3;
+		break;
+	case SDCONFIG_BUS_WIDTH_MMC8_BIT:
+		i = 4;
+		break;
+	default:
+		i = 0;
+		break;
+	}
+
+	return bus_width_name[i];
+}
+
+/*
+ * Convert MMC bus width to Atheros bus width.
+ */
+static SD_BUSMODE_FLAGS mmc_to_ath_bus_width(unsigned bus_width)
+{
+	SD_BUSMODE_FLAGS ath_bus_width = 0;
+
+	switch (bus_width) {
+	case MMC_BUS_WIDTH_1:
+		ath_bus_width = SDCONFIG_BUS_WIDTH_1_BIT;
+		break;
+	case MMC_BUS_WIDTH_4:
+		ath_bus_width = SDCONFIG_BUS_WIDTH_4_BIT;
+		break;
+	default:
+		break;
+	}
+
+	return ath_bus_width;
+}
+
+/*
+ * Convert an Atheros slot power voltage to a name.
+ */
+static const unsigned char *ath_slot_power_name(SLOT_VOLTAGE_MASK slot_power)
+{
+	static const unsigned char *slot_power_name[] =
+	    { "Unknown", "3.3V", "3.0V", "2.8V", "2.0V", "1.8V", "1.6V" };
+	int i;
+
+	switch (slot_power) {
+	case SLOT_POWER_3_3V:
+		i = 1;
+		break;
+	case SLOT_POWER_3_0V:
+		i = 2;
+		break;
+	case SLOT_POWER_2_8V:
+		i = 3;
+		break;
+	case SLOT_POWER_2_0V:
+		i = 4;
+		break;
+	case SLOT_POWER_1_8V:
+		i = 5;
+		break;
+	case SLOT_POWER_1_6V:
+		i = 6;
+		break;
+	default:
+		i = 0;
+		break;
+	}
+
+	return slot_power_name[i];
+}
+
+/*
+ * Convert MMC Voltage mask (MMC_VDD_*) to Atheros slot power (SLOT_POWER_*)
+ * mask.
+ */
+static SLOT_VOLTAGE_MASK mmc_vdd_to_ath_slot_power(u32 ocr)
+{
+	SLOT_VOLTAGE_MASK slot_power = 0;
+
+	if (ocr & (MMC_VDD_35_36 | MMC_VDD_34_35 | MMC_VDD_33_34
+		   | MMC_VDD_32_33)) {
+		slot_power |= SLOT_POWER_3_3V;
+	}
+
+	if (ocr & (MMC_VDD_31_32 | MMC_VDD_30_31 | MMC_VDD_29_30))
+		slot_power |= SLOT_POWER_3_0V;
+
+	if (ocr & (MMC_VDD_28_29 | MMC_VDD_27_28))
+		slot_power |= SLOT_POWER_2_8V;
+
+	if (ocr & (MMC_VDD_26_27 | MMC_VDD_25_26 | MMC_VDD_24_25
+		   | MMC_VDD_23_24 | MMC_VDD_22_23 | MMC_VDD_21_22
+		   | MMC_VDD_20_21)) {
+		slot_power |= SLOT_POWER_2_0V;
+	}
+
+	if (ocr & MMC_VDD_165_195)
+		slot_power |= SLOT_POWER_1_8V;
+
+	return slot_power;
+}
+
+static int athsdio_unsupported_request(struct _SDHCD *hcd,
+				       struct _SDREQUEST *req)
+{
+	struct athsdio_slot *athslot = hcd->pContext;
+	struct device *dev = &athslot->func->dev;
+
+	dev_warn(dev, "athsdio_request: Ignoring unsupported CMD%d.\n",
+		 req->Command);
+
+	req->Status = SDIO_STATUS_ERROR;
+
+	return req->Status;
+}
+
+static int athsdio_cmd3_request(struct _SDHCD *hcd, struct _SDREQUEST *req)
+{
+	struct athsdio_slot *athslot = hcd->pContext;
+	struct mmc_card *card = athslot->func->card;
+
+	/*
+	 * CMD3 is sent during the SDIO initialization sequence, which the linux
+	 * MMC core has already completed.  We construct a response here using
+	 * the values that were saved when the card was initialized.
+	 */
+	*((u32 *) (&req->Response[1])) = (card->rca << 16);
+
+	req->Status = 0;
+
+	return req->Status;
+}
+
+static int athsdio_cmd5_request(struct _SDHCD *hcd, struct _SDREQUEST *req)
+{
+	struct athsdio_slot *athslot = hcd->pContext;
+	struct mmc_card *card = athslot->func->card;
+	struct mmc_host *host = card->host;
+
+	/*
+	 * CMD5 with argument 0 is sent during the SDIO initialization
+	 * sequence, which the linux MMC core has already completed.
+	 * We construct a response here using the values that were saved
+	 * when the card was initialized.
+	 */
+	*((u32 *) (&req->Response[1])) =
+	    (1 << 31) | (card->sdio_funcs << 28) | host->ocr;
+
+	req->Status = 0;
+
+	return req->Status;
+}
+
+static int athsdio_cmd7_request(struct _SDHCD *hcd, struct _SDREQUEST *req)
+{
+	struct athsdio_slot *athslot = hcd->pContext;
+	struct device *dev = &athslot->func->dev;
+
+	/*
+	 * CMD7 is sent during the SDIO initialization sequence, which the linux
+	 * MMC core has already completed.
+	 */
+	if (!req->Argument)
+		dev_warn(dev, "Ignoring CMD7 to deselect card.\n");
+	req->Status = 0;
+
+	return req->Status;
+}
+
+static int athsdio_cmd52_request(struct _SDHCD *hcd, struct _SDREQUEST *req)
+{
+	struct athsdio_slot *athslot = hcd->pContext;
+	struct sdio_func *func = athslot->func;
+	struct mmc_card *card = func->card;
+	struct mmc_command cmd;
+	int err;
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = SD_IO_RW_DIRECT;
+	cmd.arg = req->Argument;
+	cmd.flags = MMC_RSP_R5 | MMC_CMD_AC;
+
+	sdio_claim_host(func);
+	err = mmc_wait_for_cmd(card->host, &cmd, 0);
+	sdio_release_host(func);
+	if (err)
+		req->Status = SDIO_STATUS_DEVICE_ERROR;
+	else {
+		req->Status = 0;
+		*((u32 *) (&req->Response[1])) = cmd.resp[0];
+	}
+
+	return req->Status;
+}
+
+static int athsdio_cmd53_request(struct _SDHCD *hcd, struct _SDREQUEST *req)
+{
+	struct athsdio_slot *athslot = hcd->pContext;
+	struct sdio_func *func = athslot->func;
+	struct mmc_card *card = func->card;
+	struct device *dev = &func->dev;
+	struct mmc_request mrq;
+	struct mmc_command cmd;
+	struct mmc_data data;
+	struct scatterlist sg;
+#ifdef CONFIG_ATHSDIO_BOUNCE
+	int bounce = 0;
+#endif
+
+	memset(&mrq, 0, sizeof(struct mmc_request));
+	memset(&cmd, 0, sizeof(struct mmc_command));
+	memset(&data, 0, sizeof(struct mmc_data));
+
+	mrq.cmd = &cmd;
+	mrq.data = &data;
+
+	cmd.opcode = SD_IO_RW_EXTENDED;
+	cmd.arg = req->Argument;
+	cmd.flags = MMC_RSP_R5 | MMC_CMD_ADTC;
+
+	req->DataRemaining = req->BlockLen * req->BlockCount;
+	data.blksz = req->BlockLen;
+	data.blocks = req->BlockCount;
+	data.flags = (req->Argument & (1 << 31)) ? MMC_DATA_WRITE :
+	    MMC_DATA_READ;
+	data.sg = &sg;
+	data.sg_len = 1;
+
+#ifdef CONFIG_ATHSDIO_BOUNCE
+	if (data.flags & MMC_DATA_WRITE) {
+		if (!virt_addr_valid(req->pDataBuffer)
+		    || ((unsigned long)req->pDataBuffer &
+			(athslot->tx_align - 1))
+		    || (req->DataRemaining & (athslot->tx_align - 1))) {
+			/*
+			 * This tx buffer doesn't meet our alignment
+			 * requirements, so use the bounce buffer.
+			 */
+			memcpy(athslot->bounce_buffer, req->pDataBuffer,
+			       req->DataRemaining);
+			sg_init_one(&sg, athslot->bounce_buffer,
+				    req->DataRemaining);
+		} else
+			sg_init_one(&sg, req->pDataBuffer, req->DataRemaining);
+	} else {
+		if (!virt_addr_valid(req->pDataBuffer)
+		    || ((unsigned long)req->pDataBuffer &
+			(athslot->rx_align - 1))
+		    || (req->DataRemaining & (athslot->rx_align - 1))) {
+			/*
+			 * This rx buffer doesn't meet our alignment
+			 * requirements, so use the bounce buffer.
+			 */
+			bounce = 1;
+			sg_init_one(&sg, athslot->bounce_buffer,
+				    req->DataRemaining);
+		} else
+			sg_init_one(&sg, req->pDataBuffer, req->DataRemaining);
+	}
+#else
+	sg_init_one(&sg, req->pDataBuffer, req->DataRemaining);
+#endif
+
+	sdio_claim_host(func);
+	mmc_set_data_timeout(&data, card);
+
+	mmc_wait_for_req(card->host, &mrq);
+	sdio_release_host(func);
+
+#ifdef CONFIG_ATHSDIO_BOUNCE
+	if (bounce) {
+		memcpy(req->pDataBuffer, athslot->bounce_buffer,
+		       req->DataRemaining);
+	}
+#endif
+
+	if (cmd.error) {
+		req->Status = SDIO_STATUS_DEVICE_ERROR;
+		dev_warn(dev, "Error %d during CMD53 command phase.\n",
+			 cmd.error);
+	} else if (data.error) {
+		req->Status = SDIO_STATUS_DEVICE_ERROR;
+		dev_warn(dev, "Error %d during CMD53 data phase.\n",
+			 data.error);
+	} else {
+		req->Status = 0;
+		*((u32 *) (&req->Response[1])) = cmd.resp[0];
+
+		if (cmd.resp[0] & R5_ERROR)
+			req->Status = SDIO_STATUS_DATA_STATE_INVALID;
+		else if (cmd.resp[0] & R5_FUNCTION_NUMBER)
+			req->Status = SDIO_STATUS_INVALID_FUNC;
+		else if (cmd.resp[0] & R5_OUT_OF_RANGE)
+			req->Status = SDIO_STATUS_FUNC_ARG_ERROR;
+		if (!req->Status)
+			req->DataRemaining = 0;
+	}
+
+	return req->Status;
+}
+
+static void athsdio_work(struct work_struct *work)
+{
+	struct athsdio_slot *athslot =
+	    container_of(work, struct athsdio_slot, work);
+	struct _SDHCD *hcd = &athslot->hcd;
+	struct _SDREQUEST *req = GET_CURRENT_REQUEST(hcd);
+	int ret = 0;
+
+	switch (req->Command) {
+	case CMD3:		/* SD_SEND_RELATIVE_ADDR */
+		ret = athsdio_cmd3_request(hcd, req);
+		break;
+	case CMD5:		/* SD_IO_SEND_OP_COND */
+		ret = athsdio_cmd5_request(hcd, req);
+		break;
+	case CMD7:		/* MMC_SELECT_CARD */
+		ret = athsdio_cmd7_request(hcd, req);
+		break;
+	case CMD52:		/* SD_IO_RW_DIRECT */
+		ret = athsdio_cmd52_request(hcd, req);
+		break;
+	case CMD53:		/* SD_IO_RW_EXTENDED */
+		ret = athsdio_cmd53_request(hcd, req);
+		break;
+	default:
+		ret = athsdio_unsupported_request(hcd, req);
+		break;
+	}
+
+	SDIO_HandleHcdEvent(hcd, EVENT_HCD_TRANSFER_DONE);
+}
+
+static void athsdio_work_set_priority(struct work_struct *work)
+{
+	struct sched_param param = {.sched_priority = 1 };
+
+	sched_setscheduler(current, SCHED_FIFO, &param);
+}
+
+static void athsdio_irq_handler(struct sdio_func *func)
+{
+	struct athsdio_slot *athslot = sdio_get_drvdata(func);
+
+	/*
+	 * On entry, the Linux MMC host controller lock has already been
+	 * claimed, and the enable_sdio_irq() method of the host controller
+	 * driver has already been called to disable sdio interrupts.
+	 */
+
+	/*
+	 * The Atheros SDIO stack might call this driver to start a new command
+	 * when we notify it of the card interrupt, so we drop the host
+	 * controller lock.
+	 */
+	sdio_release_host(func);
+
+	/* Notify the Atheros SDIO stack of the card interrupt. */
+	SDIO_HandleHcdEvent(&athslot->hcd, EVENT_HCD_SDIO_IRQ_PENDING);
+
+	/* The host controller lock must be claimed on exit. */
+	sdio_claim_host(func);
+}
+
+/*
+ * The Atheros Host Controller Driver pConfigure method.
+ */
+int athsdio_configure(struct _SDHCD *hcd, struct _SDCONFIG *cfg)
+{
+	struct athsdio_slot *athslot = hcd->pContext;
+	struct sdio_func *func = athslot->func;
+	struct mmc_card *card = func->card;
+	struct mmc_host *host = card->host;
+	struct device *dev = &func->dev;
+	int ret = 0;
+
+	switch (cfg->Cmd) {
+	case SDCONFIG_SEND_INIT_CLOCKS:
+		/*
+		 * The MMC host controller driver does this automatically,
+		 * so no need to do anything here.
+		 */
+		break;
+	case SDCONFIG_SDIO_INT_CTRL:
+		{
+			struct _SDCONFIG_SDIO_INT_CTRL_DATA *intctl =
+			    cfg->pData;
+
+			/*
+			 * This is called with a spinlock held and CPU
+			 * interrupts disabled, so we can't call anything that
+			 * might sleep.
+			 */
+			if (intctl->SlotIRQEnable) {
+				dev_dbg(dev, "SDIO card interrupt enabled.\n");
+				if (host->caps & MMC_CAP_SDIO_IRQ) {
+					if (athslot->original_host_ops->
+					    enable_sdio_irq) {
+						athslot->original_host_ops->
+						    enable_sdio_irq(host, 1);
+					}
+				}
+			} else {
+				if (host->caps & MMC_CAP_SDIO_IRQ) {
+					if (athslot->original_host_ops->
+					    enable_sdio_irq) {
+						athslot->original_host_ops->
+						    enable_sdio_irq(host, 0);
+					}
+				}
+				dev_dbg(dev, "SDIO card interrupt "
+					"disabled.\n");
+			}
+		}
+		break;
+	case SDCONFIG_SDIO_REARM_INT:
+		/*
+		 * This is called with a spinlock held and CPU interrupts
+		 * disabled, so we can't call anything that might sleep.
+		 */
+		if (host->caps & MMC_CAP_SDIO_IRQ) {
+			if (athslot->original_host_ops->enable_sdio_irq) {
+				athslot->original_host_ops->
+				    enable_sdio_irq(host, 1);
+			}
+		}
+		break;
+	case SDCONFIG_BUS_MODE_CTRL:
+		/*
+		 * The MMC core automatically selects a clock frequency and
+		 * bus width when a card is inserted.
+		 */
+		{
+			struct _SDCONFIG_BUS_MODE_DATA *bus_mode = cfg->pData;
+			SD_BUSMODE_FLAGS bus_width;
+
+			bus_mode->ActualClockRate =
+			    (host->ios.clock + 500) / 1000;
+			dev_dbg(dev,
+				"Requested clock %d kHz, Actual clock %d "
+				"kHz\n", (bus_mode->ClockRate + 500) / 1000,
+				bus_mode->ActualClockRate);
+
+			bus_width = mmc_to_ath_bus_width(host->ios.bus_width);
+			if (bus_width !=
+			    SDCONFIG_GET_BUSWIDTH(bus_mode->BusModeFlags)) {
+				dev_dbg(dev, "Ignoring request to change bus "
+					"width from %s to %s.\n",
+					ath_bus_width_name(bus_width),
+					ath_bus_width_name(bus_mode->
+							   BusModeFlags));
+			} else {
+				dev_dbg(dev, "Bus width is %s.\n",
+					ath_bus_width_name(bus_width));
+			}
+		}
+		break;
+	case SDCONFIG_POWER_CTRL:
+		/*
+		 * The MMC core automatically selects a voltage and powers a
+		 * card when it is inserted, so we don't need to do anything
+		 * here.
+		 */
+		{
+			struct _SDCONFIG_POWER_CTRL_DATA *pwr = cfg->pData;
+			SLOT_VOLTAGE_MASK slot_power;
+
+			slot_power = mmc_vdd_to_ath_slot_power(host->ocr);
+			if (slot_power != pwr->SlotPowerVoltageMask) {
+				dev_dbg(dev, "Ignoring request to change slot "
+					"voltage from %s to %s.\n",
+					ath_slot_power_name(slot_power),
+					ath_slot_power_name(pwr->
+							    SlotPowerVoltageMask));
+			} else {
+				dev_dbg(dev, "Slot voltage is %s.\n",
+					ath_slot_power_name(slot_power));
+			}
+			if (!pwr->SlotPowerEnable) {
+				dev_dbg(dev, "Ignoring request to turn slot "
+					"power off.\n");
+			} else
+				dev_dbg(dev, "Slot power is on.\n");
+		}
+		break;
+	case SDCONFIG_GET_WP:
+		*((SDCONFIG_WP_VALUE *) cfg->pData) =
+		    (mmc_card_readonly(card)) ? 1 : 0;
+		break;
+	default:
+		dev_warn(dev, "Unsupported configuration command 0x%04x.\n",
+			 cfg->Cmd);
+		ret = SDIO_STATUS_INVALID_PARAMETER;
+	}
+
+	return ret;
+}
+
+/*
+ * The Atheros Host Controller Driver pRequest method.
+ */
+int athsdio_request(struct _SDHCD *hcd)
+{
+	struct athsdio_slot *athslot = hcd->pContext;
+	struct _SDREQUEST *req = GET_CURRENT_REQUEST(hcd);
+	struct device *dev = &athslot->func->dev;
+	int ret = 0;
+
+	if (IS_SDREQ_FORCE_DEFERRED_COMPLETE(req->Flags)) {
+		if (!queue_work(athslot->wq, &athslot->work)) {
+			dev_err(dev, "SDIO is busy.  Can't start CMD%d.\n",
+				req->Command);
+			req->Status = SDIO_STATUS_NO_RESOURCES;
+			return req->Status;
+		} else
+			return SDIO_STATUS_PENDING;
+	}
+
+	switch (req->Command) {
+	case CMD3:		/* SD_SEND_RELATIVE_ADDR */
+		ret = athsdio_cmd3_request(hcd, req);
+		break;
+	case CMD5:		/* SD_IO_SEND_OP_COND */
+		ret = athsdio_cmd5_request(hcd, req);
+		break;
+	case CMD7:		/* MMC_SELECT_CARD */
+		ret = athsdio_cmd7_request(hcd, req);
+		break;
+	case CMD52:		/* SD_IO_RW_DIRECT */
+		ret = athsdio_cmd52_request(hcd, req);
+		break;
+	case CMD53:		/* SD_IO_RW_EXTENDED */
+		/*
+		 * CMD53 is sometimes issued by the Atheros SDIO stack while it
+		 * is holding a spinlock or in interrupt context, so we defer
+		 * all CMD53 requests to a work queue.
+		 */
+		if (!queue_work(athslot->wq, &athslot->work)) {
+			dev_err(dev, "SDIO is busy.  Can't start CMD%d.\n",
+				req->Command);
+			req->Status = SDIO_STATUS_NO_RESOURCES;
+			ret = req->Status;
+		} else
+			ret = SDIO_STATUS_PENDING;
+		break;
+	default:
+		ret = athsdio_unsupported_request(hcd, req);
+		break;
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_ATHSDIO_BOUNCE
+static int athsdio_allocate_bounce_buffer(struct athsdio_slot *athslot)
+{
+	athslot->bounce_buffer = (void *)__get_free_page(GFP_KERNEL);
+	athslot->tx_align = (1 << CONFIG_ATHSDIO_TX_ALIGN);
+	athslot->rx_align = (1 << CONFIG_ATHSDIO_RX_ALIGN);
+
+	return !athslot->bounce_buffer;
+}
+
+static void athsdio_free_bounce_buffer(struct athsdio_slot *athslot)
+{
+	if (athslot->bounce_buffer)
+		free_page((unsigned long)athslot->bounce_buffer);
+}
+
+#else /* ifdef CONFIG_ATHSDIO_BOUNCE */
+
+static int athsdio_allocate_bounce_buffer(struct athsdio_slot *athslot)
+{
+	return 0;
+}
+
+static void athsdio_free_bounce_buffer(struct athsdio_slot *athslot)
+{
+}
+#endif /* ifdef CONFIG_ATHSDIO_BOUNCE */
+
+static void athsdio_enable_irq(struct mmc_host *host, int enable)
+{
+	struct athsdio_slot *athslot = pathslot;
+
+	if (!enable && athslot && athslot->original_host_ops->enable_sdio_irq)
+		athslot->original_host_ops->enable_sdio_irq(host, 0);
+}
+
+static void athsdio_restore_host_ops(struct sdio_func *func)
+{
+	struct athsdio_slot *athslot = sdio_get_drvdata(func);
+	struct mmc_card *card = func->card;
+	struct mmc_host *host = card->host;
+
+	if (host->caps & MMC_CAP_SDIO_IRQ) {
+		sdio_claim_host(func);
+
+		host->ops = athslot->original_host_ops;
+
+		sdio_release_host(func);
+
+		dev_dbg(&func->dev, "Restored host controller "
+			"interrupt ops.\n");
+	}
+}
+
+static void athsdio_replace_host_ops(struct sdio_func *func)
+{
+	struct athsdio_slot *athslot = sdio_get_drvdata(func);
+	struct mmc_card *card = func->card;
+	struct mmc_host *host = card->host;
+
+	/*
+	 * Replace the SDIO interrupt enable routine with a null routine.  The
+	 * Linux MMC core sdio_irq_thread() routine automatically
+	 * reenables SDIO card interrupts after calling the ISR, under the
+	 * assumption that the ISR will have cleared the interrupt request
+	 * before returning.  This doesn't work with the Atheros stack, because
+	 * it can defer clearing the interrupt request to a work queue.  We'll
+	 * manage enabling of the interrupt request locally.
+	 *
+	 * Note that replacing the SDIO interrupt operations for the host
+	 * controller means that this SDIO function driver cannot coexist with
+	 * any other SDIO function driver that enables SDIO card interrupts.
+	 */
+	if (host->caps & MMC_CAP_SDIO_IRQ) {
+		sdio_claim_host(func);
+
+		athslot->original_host_ops = host->ops;
+		athslot->host_ops = *host->ops;
+		athslot->host_ops.enable_sdio_irq = athsdio_enable_irq;
+
+		host->ops = &athslot->host_ops;
+
+		sdio_release_host(func);
+
+		dev_dbg(&func->dev, "Replaced host controller "
+			"interrupt ops.\n");
+	}
+}
+
+static void athsdio_remove(struct sdio_func *func)
+{
+	struct athsdio_slot *athslot;
+	struct _SDHCD *hcd;
+
+	while (down_interruptible(&athsdio_init_lock)) ;
+
+	athslot = sdio_get_drvdata(func);
+	hcd = &athslot->hcd;
+
+	dev_dbg(&func->dev, "Releasing SDIO function %04x:%04x\n",
+		func->vendor, func->device);
+
+	SDIO_UnregisterHostController(hcd);
+	destroy_workqueue(athslot->wq);
+	sdio_claim_host(func);
+	sdio_release_irq(func);
+	sdio_release_host(func);
+	athsdio_restore_host_ops(func);
+	athsdio_free_bounce_buffer(athslot);
+	pathslot = NULL;
+	sdio_set_drvdata(func, NULL);
+	kfree(athslot);
+
+	up(&athsdio_init_lock);
+}
+
+static int athsdio_probe(struct sdio_func *func,
+			 const struct sdio_device_id *id)
+{
+	struct device *dev;
+	struct mmc_card *card;
+	struct mmc_host *host;
+	struct athsdio_slot *athslot;
+	struct _SDHCD *hcd;
+	int ret;
+
+	while (down_interruptible(&athsdio_init_lock)) ;
+
+	dev = &func->dev;
+	card = func->card;
+	host = card->host;
+
+	athslot = kzalloc(sizeof(struct athsdio_slot), GFP_KERNEL);
+	if (athslot == NULL) {
+		dev_err(dev, "Out of memory.\n");
+		up(&athsdio_init_lock);
+		return -ENOMEM;
+	}
+
+	athslot->func = func;
+	sdio_set_drvdata(func, athslot);
+	pathslot = athslot;
+	hcd = &athslot->hcd;
+
+	if (athsdio_allocate_bounce_buffer(athslot)) {
+		dev_err(dev, "Out of memory.\n");
+		goto free_context;
+	}
+
+	SET_SDIO_STACK_VERSION(hcd);
+	hcd->pName = DRV_NAME;
+	hcd->Attributes = mmc_cap_to_ath_attrib(host->caps);
+	hcd->MaxBytesPerBlock = host->max_blk_size;
+	hcd->MaxBlocksPerTrans = host->max_blk_count;
+	hcd->MaxSlotCurrent = SDIO_EMPC_CURRENT_THRESHOLD;
+	hcd->MaxClockRate = host->f_max;
+	hcd->SlotVoltageCaps = mmc_vdd_to_ath_slot_power(host->ocr_avail);
+	if (hcd->SlotVoltageCaps) {
+		/*
+		 * The linux MMC core always selects the lowest available
+		 * supported voltage, so we express our preference accordingly.
+		 */
+		hcd->SlotVoltagePreferred =
+		    (1 << (fls(hcd->SlotVoltageCaps) - 1));
+	}
+	hcd->pContext = athslot;
+	hcd->pRequest = athsdio_request;
+	hcd->pConfigure = athsdio_configure;
+	hcd->pDevice = dev;
+	hcd->pModule = THIS_MODULE;
+
+	if (!(host->caps & MMC_CAP_SDIO_IRQ)) {
+		dev_warn(dev,
+			 "SDIO card interrupts supported in polling mode.\n");
+	}
+
+	athsdio_replace_host_ops(func);
+
+	sdio_claim_host(func);
+	ret = sdio_claim_irq(func, athsdio_irq_handler);
+	sdio_release_host(func);
+	if (ret) {
+		dev_err(dev, "Error %d when claiming SDIO IRQ.\n", ret);
+		goto restore_host_ops;
+	}
+
+	athslot->wq = create_singlethread_workqueue(DRV_NAME);
+	if (!athslot->wq) {
+		dev_err(dev, "Workqueue creation failed.\n");
+		goto release_irq;
+	}
+	INIT_WORK(&athslot->work, athsdio_work);
+	INIT_WORK(&athslot->set_priority_work, athsdio_work_set_priority);
+	queue_work(athslot->wq, &athslot->set_priority_work);
+
+	ret = SDIO_RegisterHostController(hcd);
+	if (ret < 0) {
+		dev_err(dev, "SDIO_RegisterHostController returned error %d.\n",
+			ret);
+		goto destroy_wq;
+	}
+
+	/* Notify the Atheros SDIO stack that a card is present. */
+	ret = SDIO_HandleHcdEvent(hcd, EVENT_HCD_ATTACH);
+	if (ret < 0) {
+		dev_err(dev, "SDIO_HandleHcdEvent returned error %d.\n", ret);
+		goto unregister;
+	}
+
+	dev_dbg(dev, "Claimed SDIO function %04x:%04x\n", func->vendor,
+		func->device);
+
+	up(&athsdio_init_lock);
+	return 0;
+
+      unregister:
+	SDIO_UnregisterHostController(hcd);
+
+      destroy_wq:
+	destroy_workqueue(athslot->wq);
+
+      release_irq:
+	sdio_claim_host(func);
+	sdio_release_irq(func);
+	sdio_release_host(func);
+
+      restore_host_ops:
+	athsdio_restore_host_ops(func);
+	athsdio_free_bounce_buffer(athslot);
+
+      free_context:
+	sdio_set_drvdata(func, NULL);
+	kfree(athslot);
+
+	up(&athsdio_init_lock);
+	return -ENODEV;
+}
+
+/*
+ * Claim any and all SDIO cards for the Atheros SDIO stack.
+ */
+const struct sdio_device_id athsdio_device_id[] = {
+	{SDIO_DEVICE(SDIO_ANY_ID, SDIO_ANY_ID)},
+	{ /* terminating NULL entry */ },
+};
+
+static struct sdio_driver athsdio_drv = {
+	.name = DRV_NAME,
+	.id_table = athsdio_device_id,
+	.probe = athsdio_probe,
+	.remove = athsdio_remove,
+};
+
+static void __exit athsdio_cleanup(void)
+{
+	sdio_unregister_driver(&athsdio_drv);
+}
+
+static int __init athsdio_init(void)
+{
+	return sdio_register_driver(&athsdio_drv);
+}
+
+MODULE_LICENSE("GPL");
+
+module_init(athsdio_init);
+module_exit(athsdio_cleanup);
Index: linux-2.6/drivers/sdio/hcd/omap2420/Makefile
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/hcd/omap2420/Makefile
@@ -0,0 +1,5 @@
+# SDIO omap host controller makefile
+#obj-m += sdio_omap_hcd.o
+#sdio_omap_hcd-objs := sdio_hcd.o sdio_hcd_os_2_6.o
+# until we either get 2420 menelaus defined or get 2430 working
+
Index: linux-2.6/drivers/sdio/hcd/omap2420/sdio_hcd.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/hcd/omap2420/sdio_hcd.c
@@ -0,0 +1,1363 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdio_hcd.c
+
+@abstract: Texas Instruments OMAP native Host Controller Driver
+
+#notes: OS independent code
+
+@notice: Copyright (c), 2004-2006 Atheros Communications, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions o this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (Simplified
+ *   Specification) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define MODULE_NAME  SDOMAPHCD
+#include "sdio_omap_hcd.h"
+
+#define FROM_ISR    TRUE
+#define FROM_NORMAL FALSE
+
+void EndHCTransfer(PSDHCD_DEVICE pDevice, PSDREQUEST pReq, BOOL FromIsr);
+void ResetController(PSDHCD_DEVICE pDevice, BOOL Restore, BOOL FromIsr);
+
+#define OMAP_REQ_PROCESSING_USE_CLOCK_CONTROL
+
+#ifdef OMAP_REQ_PROCESSING_USE_CLOCK_CONTROL
+    /* control clock during request processing */
+#define ReqProcClkStartStop(p,on) ClockStartStop((p),(on))
+#else
+    /* let clock run free */
+#define ReqProcClkStartStop(p,on)
+#endif
+
+#define OMAP_COMMAND_DONE_POLLING         2000000
+#define OMAP_SHORT_TRANSFER_DONE_POLLING  3000000
+
+#define WAIT_FOR_HC_STATUS(pHct,DoneMask,Error,ErrorMask,Status,Timeout)   \
+{                                                                            \
+     INT _timeoutCnt = (Timeout);                                            \
+     (Status) = SDIO_STATUS_SUCCESS;                                         \
+     while((_timeoutCnt > 0) &&                                               \
+            !(READ_HOST_REG16((pHct), OMAP_REG_MMC_MODULE_STATUS) & (DoneMask)) &&            \
+            !((Error) = READ_HOST_REG16((pHct), OMAP_REG_MMC_MODULE_STATUS) & (ErrorMask))){_timeoutCnt--;} \
+     (Error) = READ_HOST_REG16((pHct), OMAP_REG_MMC_MODULE_STATUS) & (ErrorMask);            \
+     if (0 == _timeoutCnt) {(Status) = SDIO_STATUS_DEVICE_ERROR; \
+           DBG_PRINT(SDDBG_ERROR, \
+           ("SDIO OMAP - status timeout, waiting for (mask=0x%X) (stat=0x%X)\n",\
+               (UINT)(DoneMask), READ_HOST_REG16((pHct), OMAP_REG_MMC_MODULE_STATUS))); \
+                             DBG_ASSERT(FALSE);}       \
+}
+
+#define SetFifoAFL(pHct,Depth) \
+{                              \
+    UINT16 fifoSettings = (Depth)/2;  \
+    if (fifoSettings > 0) {fifoSettings--;} \
+    fifoSettings = ((fifoSettings) << OMAP_REG_MMC_BUFFER_CONFIG_AFL_SHIFT) & \
+                                        OMAP_REG_MMC_BUFFER_CONFIG_AFL_MASK; \
+    WRITE_HOST_REG16((pHct), OMAP_REG_MMC_BUFFER_CONFIG, fifoSettings);     \
+}
+
+#define SetFifoAEL(pHct,Depth) \
+{                              \
+    UINT16 fifoSettings = (Depth)/2;  \
+    if (fifoSettings > 0) {fifoSettings--;} \
+    fifoSettings = ((fifoSettings) << OMAP_REG_MMC_BUFFER_CONFIG_AEL_SHIFT) & \
+                                        OMAP_REG_MMC_BUFFER_CONFIG_AEL_MASK; \
+    WRITE_HOST_REG16((pHct), OMAP_REG_MMC_BUFFER_CONFIG, fifoSettings);     \
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  GetResponseData - get the response data
+  Input:    pDevice - device context
+            pReq - the request
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void GetResponseData(PSDHCD_DEVICE pDevice, PSDREQUEST pReq)
+{
+    INT     wordCount;
+    INT     byteCount;
+    UINT16  readBuffer[8];
+    UINT    ii;
+
+    if (GET_SDREQ_RESP_TYPE(pReq->Flags) == SDREQ_FLAGS_NO_RESP) {
+        return;
+    }
+
+
+    byteCount = SD_DEFAULT_RESPONSE_BYTES;
+    if (GET_SDREQ_RESP_TYPE(pReq->Flags) == SDREQ_FLAGS_RESP_R2) {
+        byteCount = SD_R2_RESPONSE_BYTES - 1;
+        wordCount = (byteCount + 1) / 2;
+        /* move data into read buffer */
+        for (ii = 0; ii < wordCount; ii++) {
+            readBuffer[ii] = READ_HOST_REG16(pDevice, OMAP_REG_MMC_CMD_RESPONSE0+(ii*4));
+        }
+        memcpy(&pReq->Response[0],readBuffer,byteCount);
+    } else {
+        wordCount = (byteCount + 1) / 2;
+
+        /* move data into read buffer */
+        for (ii = 0; ii < wordCount; ii++) {
+            readBuffer[ii] = READ_HOST_REG16(pDevice, OMAP_REG_MMC_CMD_RESPONSE6+(ii*4));
+        }
+        memcpy(&pReq->Response[1],readBuffer,byteCount);
+    }
+
+    if (DBG_GET_DEBUG_LEVEL() >= OMAP_TRACE_REQUESTS) {
+        SDLIB_PrintBuffer(pReq->Response,byteCount,"SDIO OMAP - Response Dump");
+    }
+
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  DumpCurrentRequestInfo - debug dump
+  Input:    pDevice - device context
+  Output:
+  Return:
+  Notes: This function debug prints the current request
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void DumpCurrentRequestInfo(PSDHCD_DEVICE pDevice)
+{
+    if (pDevice->Hcd.pCurrentRequest != NULL) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO OMAP - Current Request Command:%d, ARG:0x%8.8X\n",
+                  pDevice->Hcd.pCurrentRequest->Command, pDevice->Hcd.pCurrentRequest->Argument));
+        if (IS_SDREQ_DATA_TRANS(pDevice->Hcd.pCurrentRequest->Flags)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO OMAP - Data %s, Blocks: %d, BlockLen:%d Remaining: %d \n",
+                      IS_SDREQ_WRITE_DATA(pDevice->Hcd.pCurrentRequest->Flags) ? "WRITE":"READ",
+                      pDevice->Hcd.pCurrentRequest->BlockCount,
+                      pDevice->Hcd.pCurrentRequest->BlockLen,
+                      pDevice->Hcd.pCurrentRequest->DataRemaining));
+        }
+    }
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  TranslateSDError - check for an SD error
+  Input:    pDevice - device context
+            Status -  error interrupt status register value
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS TranslateSDError(PSDHCD_DEVICE pDevice, PSDREQUEST pReq, UINT16 Status)
+{
+    if (Status & OMAP_REG_MMC_MODULE_STATUS_CERR) {
+        DBG_PRINT(SDDBG_WARN, ("SDIO OMAP TranslateSDError : Warning command response has error bits set\n"));
+        return SDIO_STATUS_SUCCESS;
+    }
+
+    if (Status & OMAP_REG_MMC_MODULE_STATUS_CTO) {
+        if (!((pReq->Command == 5) || (pReq->Command == 55) || (pReq->Command == 1))) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO OMAP Command Timeout: CMD:%d\n",pReq->Command));
+            if (IS_SDREQ_DATA_TRANS(pReq->Flags)) {
+                DBG_PRINT(SDDBG_ERROR,
+                    ("SDIO OMAP (CMD:%d) Timeout, %s Data Transfer, Blocks:%d, BlockLen:%d, Total:%d \n",
+                    pReq->Command,
+                    IS_SDREQ_WRITE_DATA(pReq->Flags) ? "TX":"RX",
+                    pReq->BlockCount, pReq->BlockLen, pReq->DataRemaining));
+            }
+        }
+        return SDIO_STATUS_BUS_RESP_TIMEOUT;
+    }
+
+    DBG_PRINT(SDDBG_WARN, ("SDIO OMAP TranslateSDError : current controller status: 0x%X\n",
+        READ_HOST_REG16(pDevice,OMAP_REG_MMC_MODULE_STATUS)));
+
+    if (Status & OMAP_REG_MMC_MODULE_STATUS_CCRC) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO OMAP TranslateSDError : command CRC error\n"));
+        return SDIO_STATUS_BUS_RESP_CRC_ERR;
+    }
+
+    if (Status & OMAP_REG_MMC_MODULE_STATUS_DCRC) {
+        if (IS_SDREQ_WRITE_DATA(pReq->Flags)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO OMAP TranslateSDError : write data CRC error\n"));
+            return SDIO_STATUS_BUS_WRITE_ERROR;
+        } else {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO OMAP TranslateSDError : read data CRC error\n"));
+            return SDIO_STATUS_BUS_READ_CRC_ERR;
+        }
+    }
+
+    if (Status & OMAP_REG_MMC_MODULE_STATUS_DTO) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO OMAP TranslateSDError : data timeout\n"));
+        return SDIO_STATUS_BUS_READ_TIMEOUT;
+    }
+
+    DBG_PRINT(SDDBG_ERROR, ("SDIO OMAP - untranslated error 0x%X\n", (UINT)Status));
+    return SDIO_STATUS_DEVICE_ERROR;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  ClockStartStop - SD clock control
+  Input:  pDevice - device object
+          On - turn on or off (TRUE/FALSE)
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void ClockStartStop(PSDHCD_DEVICE pDevice, BOOL On)
+{
+    UINT16 state;
+
+    DBG_PRINT(OMAP_TRACE_CLOCK, ("SDIO OMAP - ClockStartStop, %d\n", (UINT)On));
+
+    state = READ_HOST_REG16(pDevice, OMAP_REG_MMC_MODULE_CONFIG);
+    if (On) {
+        state &= ~OMAP_REG_MMC_MODULE_CONFIG_CLK_MASK;
+        state |= pDevice->Clock;
+        WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_MODULE_CONFIG, state);
+    } else {
+        state &= ~OMAP_REG_MMC_MODULE_CONFIG_CLK_MASK;
+        WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_MODULE_CONFIG, state);
+    }
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  SetBusMode - Set Bus mode
+  Input:  pDevice - device object
+          pMode - mode
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void SetBusMode(PSDHCD_DEVICE pDevice, PSDCONFIG_BUS_MODE_DATA pMode)
+{
+    int ii;
+    int clockIndex;
+    UINT16 state  = 0;
+    UINT32 rate;
+
+    DBG_PRINT(OMAP_TRACE_CONFIG , ("SDIO OMAP - SetBusMode\n"));
+
+        /* set clock index to the end max. divide */
+    pMode->ActualClockRate = (pDevice->BaseClock) / OMAP_MAX_CLOCK_DIVIDE;
+    clockIndex = OMAP_MAX_CLOCK_DIVIDE;
+    for (ii = 1; ii <= OMAP_MAX_CLOCK_DIVIDE ; ii++) {
+        rate = pDevice->BaseClock / ii;
+        if (pMode->ClockRate >= rate) {
+            pMode->ActualClockRate = rate;
+            clockIndex = ii;
+            break;
+        }
+    }
+
+    state = READ_HOST_REG16(pDevice, OMAP_REG_MMC_MODULE_CONFIG);
+
+    switch (SDCONFIG_GET_BUSWIDTH(pMode->BusModeFlags)) {
+        case SDCONFIG_BUS_WIDTH_1_BIT:
+            state &=  ~OMAP_REG_MMC_MODULE_CONFIG_4BIT;
+            break;
+        case SDCONFIG_BUS_WIDTH_4_BIT:
+            state |=  OMAP_REG_MMC_MODULE_CONFIG_4BIT;
+            break;
+        default:
+            break;
+    }
+
+    pDevice->Clock = clockIndex;
+    state &= ~OMAP_REG_MMC_MODULE_CONFIG_CLK_MASK;
+    state |= pDevice->Clock;
+    WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_MODULE_CONFIG, state);
+    MicroDelay(50);
+    DBG_PRINT(OMAP_TRACE_CONFIG , ("SDIO OMAP - SetBusMode Clock: %d Khz, ClockRate %d (%d) state:0x%X\n",
+                                   pMode->ActualClockRate, pMode->ClockRate, clockIndex, (UINT)state));
+}
+
+/*
+ * SetDataTimeout - set timeout for data transfers
+*/
+static void SetDataTimeout(PSDHCD_DEVICE pDevice, UINT TimeOut)
+{
+    UINT sdreg;
+    UINT to = TimeOut;
+
+    /* Check if we need to use timeout multiplier register */
+    sdreg = READ_HOST_REG16(pDevice, OMAP_REG_MMC_SDIO_MODE_CONFIG);
+    if (TimeOut > 0xFFFF) {
+        sdreg |= OMAP_REG_MMC_SDIO_MODE_CONFIG_DPE;
+        to /= 1024;
+    } else {
+        sdreg &= ~OMAP_REG_MMC_SDIO_MODE_CONFIG_DPE;
+    }
+    DBG_PRINT(OMAP_TRACE_CONFIG , ("SDIO OMAP - SetDataTimeout Timeout: %d, mode: 0x%x,  to: 0x%x\n",
+                        TimeOut, sdreg, to));
+    WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_SDIO_MODE_CONFIG, sdreg);
+    WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_DATA_READ_TIMEOUT, to);
+}
+
+/* DMA completion routine */
+void DMACompletion(PVOID pContext, SDIO_STATUS status, BOOL FromIsr)
+{
+    PSDHCD_DEVICE pDevice = (PSDHCD_DEVICE)pContext;
+    PSDREQUEST pReq = GET_CURRENT_REQUEST(&pDevice->Hcd);
+
+    if (!SDIO_SUCCESS(status)) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO OMAP (%s) (%s) DMA transfer failed, status: %d\n",
+            IS_SDREQ_WRITE_DATA(pReq->Flags) ? "TX":"RX",
+            (OMAP_DMA_COMMON == pDevice->DmaMode) ? "Common-Buffer" : "Direct",
+            status));
+    } else {
+        DBG_PRINT(OMAP_TRACE_DATA, ("SDIO OMAP (%s) (%s) DMA transfer completed \n",
+            IS_SDREQ_WRITE_DATA(pReq->Flags) ? "TX":"RX",
+            (OMAP_DMA_COMMON == pDevice->DmaMode) ? "Common-Buffer" : "Direct"));
+    }
+
+    CompleteRequestSyncDMA(pDevice, pReq, status);
+    return;
+}
+
+/* transfer a FIFO worth of data, returns TRUE of all data was transfered */
+BOOL HcdTransferTxData(PSDHCD_DEVICE pDevice, PSDREQUEST pReq)
+{
+    INT     dataCopy;
+    PUINT8  pBuf;
+    UINT16  data;
+    volatile UINT16 *pFifo;
+
+    pFifo = (volatile UINT16 *)((UINT32)GET_HC_REG_BASE(pDevice) + OMAP_REG_MMC_DATA_ACCESS);
+
+        /* if we get called here because of an AEL interrupt, we know we have
+         * OMAP_MMC_FIFO_SIZE - OMAP_MMC_AEL_FIFO_THRESH room in the fifo to store more data */
+    dataCopy = min(pReq->DataRemaining,(UINT32)(OMAP_MMC_FIFO_SIZE - OMAP_MMC_AEL_FIFO_THRESH));
+    pBuf = (PUINT8)pReq->pHcdContext;
+
+        /* update remaining count */
+    pReq->DataRemaining -= dataCopy;
+    DBG_ASSERT((INT)pReq->DataRemaining >= 0);
+
+        /* copy to fifo */
+    while (dataCopy) {
+        data = *pBuf;
+        dataCopy--;
+        pBuf++;
+        if (dataCopy) {
+            data |= ((UINT16)*pBuf) << 8;
+            dataCopy--;
+            pBuf++;
+        }
+        *pFifo = data;
+    }
+
+        /* update pointer position */
+    pReq->pHcdContext = (PVOID)pBuf;
+
+    DBG_PRINT(OMAP_TRACE_DATA, ("SDIO OMAP Pending TX Remaining: %d \n",pReq->DataRemaining));
+
+    if (pReq->DataRemaining) {
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+/* transfer a FIFO worth of data */
+BOOL HcdTransferRxData(PSDHCD_DEVICE pDevice, PSDREQUEST pReq, BOOL Flush)
+{
+
+    INT     dataCopy;
+    PUINT8  pBuf;
+    UINT16  data;
+    volatile UINT16 *pFifo;
+
+    pFifo = (volatile UINT16 *)((UINT32)GET_HC_REG_BASE(pDevice) + OMAP_REG_MMC_DATA_ACCESS);
+
+    if (Flush) {
+        dataCopy = min(pReq->DataRemaining,(UINT32)OMAP_MMC_FIFO_SIZE);
+    } else {
+            /* each time we are called, we know we have at least a threshold's worth of data */
+        dataCopy = min(pReq->DataRemaining,(UINT32)OMAP_MMC_AFL_FIFO_THRESH);
+    }
+        /* get where we are */
+    pBuf = (PUINT8)pReq->pHcdContext;
+        /* update remaining count */
+    pReq->DataRemaining -= dataCopy;
+
+    DBG_ASSERT((INT)pReq->DataRemaining >= 0);
+
+        /* copy from fifo */
+    while (dataCopy) {
+        data = *pFifo;
+        *pBuf = (UINT8)data;
+        dataCopy--;
+        pBuf++;
+        if (dataCopy) {
+            *pBuf = (UINT8)(data >> 8);
+            pBuf++;
+            dataCopy--;
+        }
+    }
+        /* update pointer position */
+    pReq->pHcdContext = (PVOID)pBuf;
+
+    DBG_PRINT(OMAP_TRACE_DATA, ("SDIO OMAP Pending RX Remaining: %d \n",pReq->DataRemaining));
+
+    if (pReq->DataRemaining < OMAP_MMC_AFL_FIFO_THRESH) {
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+SDIO_STATUS ProcessCommandDone(PSDHCD_DEVICE         pDevice,
+                               PSDREQUEST            pReq,
+                               BOOL                  FromIsr)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    UINT16      irqUnmask = 0;
+
+    do {
+
+            /* get the response data for the command */
+        GetResponseData(pDevice, pReq);
+
+            /* check for data */
+        if (!IS_SDREQ_DATA_TRANS(pReq->Flags)) {
+            break;
+        }
+
+            /* check with the bus driver if it is okay to continue with data */
+        status = SDIO_CheckResponse(&pDevice->Hcd, pReq, SDHCD_CHECK_DATA_TRANS_OK);
+
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR,
+                ("SDIO OMAP Check Response failed (CMD:%d), %s Data Transfer, Blocks:%d, BlockLen:%d, Total:%d \n",
+                pReq->Command,
+                IS_SDREQ_WRITE_DATA(pReq->Flags) ? "TX":"RX",
+                pReq->BlockCount, pReq->BlockLen, pReq->DataRemaining));
+            break;
+        }
+
+        if (pDevice->ShortTransfer) {
+            UINT16 hwErrors;
+            UINT16 waitMask;
+
+            DBG_PRINT(OMAP_TRACE_DATA, ("SDIO OMAP Short %s data transfer (%d bytes) \n",
+                                   IS_SDREQ_WRITE_DATA(pReq->Flags) ? "TX":"RX",
+                                   pReq->DataRemaining));
+
+                /* wait for block sent/receive or error */
+            waitMask = OMAP_REG_MMC_MODULE_STATUS_BRS;
+
+            if (IS_SDREQ_WRITE_DATA(pReq->Flags)) {
+                    /* load FIFO */
+                HcdTransferTxData(pDevice, pReq);
+                waitMask |= OMAP_REG_MMC_MODULE_STATUS_EOFB;
+            }
+
+            WAIT_FOR_HC_STATUS(pDevice,
+                               waitMask,
+                               hwErrors,
+                               OMAP_STATUS_DATA_PROCESSING_ERRORS,
+                               status,
+                               OMAP_SHORT_TRANSFER_DONE_POLLING);
+
+            if (!SDIO_SUCCESS(status)) {
+                ResetController(pDevice,TRUE,FromIsr);
+                break;
+            }
+
+            if (hwErrors) {
+                status = TranslateSDError(pDevice, pReq, hwErrors);
+                if (!SDIO_SUCCESS(status)) {
+                    break;
+                }
+            }
+
+            if (IS_SDREQ_WRITE_DATA(pReq->Flags)) {
+                    /* check for busy */
+                MicroDelay(1);
+                    /* check if card entered busy */
+                if (!(READ_HOST_REG16(pDevice, OMAP_REG_MMC_MODULE_STATUS) &
+                      OMAP_REG_MMC_MODULE_STATUS_CB)) {
+                        /* we are done */
+                    break;
+                }
+                    /* card entered busy */
+                WRITE_HOST_REG16(pDevice,
+                                 OMAP_REG_MMC_MODULE_STATUS,
+                                 OMAP_REG_MMC_MODULE_STATUS_CB);
+
+                     /* wait end of busy */
+                WAIT_FOR_HC_STATUS(pDevice,
+                                   OMAP_REG_MMC_MODULE_STATUS_EOFB,
+                                   hwErrors,
+                                   0, /* no need to check for errors */
+                                   status,
+                                   OMAP_SHORT_TRANSFER_DONE_POLLING)
+
+                if (!SDIO_SUCCESS(status)) {
+                    ResetController(pDevice,TRUE,FromIsr);
+                }
+
+            } else {
+                    /* unload FIFO */
+                HcdTransferRxData(pDevice, pReq, TRUE);
+            }
+                /* done */
+            break;
+        }
+
+            /* enable error interrupts, data transfer will require interrupts */
+        irqUnmask = OMAP_REG_MMC_INTERRUPT_ERRORS;
+        status = SDIO_STATUS_PENDING;
+
+        if (pDevice->DmaMode != OMAP_DMA_NONE) {
+                /* for DMA let the DMA hardware run , we only want the interrupt
+                 * for block sent/received in addition to the errors */
+            irqUnmask |= OMAP_REG_MMC_INTERRUPT_ENABLE_BRS;
+
+            break;
+        }
+
+        if (IS_SDREQ_WRITE_DATA(pReq->Flags)) {
+                /* set threshold for FIFO empty level */
+            SetFifoAEL(pDevice,OMAP_MMC_AEL_FIFO_THRESH);
+                /* wait for AEL interrupts */
+            irqUnmask |= OMAP_REG_MMC_INTERRUPT_ENABLE_AE;
+        } else {
+            if (pReq->DataRemaining < OMAP_MMC_AFL_FIFO_THRESH) {
+                    /* don't need AFL, wait for last block received interrupt instead */
+                irqUnmask |= OMAP_REG_MMC_INTERRUPT_ENABLE_BRS;
+            } else {
+                    /* set trigger level for FIFO full level */
+                SetFifoAFL(pDevice,OMAP_MMC_AFL_FIFO_THRESH);
+                    /* more data is expected */
+                irqUnmask |= OMAP_REG_MMC_INTERRUPT_ENABLE_AF;
+            }
+        }
+
+    } while (FALSE);
+
+    if (SDIO_STATUS_PENDING == status) {
+        if (irqUnmask != 0) {
+            UnmaskIrq(pDevice, irqUnmask, FromIsr);
+        }
+        DBG_PRINT(OMAP_TRACE_DATA, ("SDIO OMAP HcdRequest Pending %s data transfer \n",
+                                   IS_SDREQ_WRITE_DATA(pReq->Flags) ? "TX":"RX"));
+    }
+    return status;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  HcdRequest - SD request handler
+  Input:  pHcd - HCD object
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS HcdRequest(PSDHCD pHcd)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    PSDHCD_DEVICE pDevice = (PSDHCD_DEVICE)pHcd->pContext;
+    UINT16                temp;
+    PSDREQUEST            pReq;
+
+    pDevice->CompletionCount = 0;
+    pDevice->DmaMode = OMAP_DMA_NONE;
+    pDevice->ShortTransfer = FALSE;
+
+    pReq = GET_CURRENT_REQUEST(pHcd);
+    DBG_ASSERT(pReq != NULL);
+
+    do {
+        if (pDevice->ShuttingDown) {
+            DBG_PRINT(OMAP_TRACE_REQUESTS, ("SDIO OMAP HcdRequest returning canceled\n"));
+            status = SDIO_STATUS_CANCELED;
+            break;
+        }
+
+        ReqProcClkStartStop(pDevice, CLOCK_OFF);
+
+            /* make sure error ints and EOC is masked*/
+        MaskIrq(pDevice,
+                OMAP_REG_MMC_INTERRUPT_ERRORS | OMAP_REG_MMC_INTERRUPT_ENABLE_EOC,
+                FROM_NORMAL);
+
+        WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_BUFFER_CONFIG, 0);
+        WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_CMD_TIMEOUT, pDevice->TimeOut);
+
+            /* clear all status bits (including error bits) that deals with request processing */
+        WRITE_HOST_REG16(pDevice,
+                         OMAP_REG_MMC_MODULE_STATUS,
+                         OMAP_REG_MMC_MODULE_STATUS_REQ_PROCESS);
+
+        if (READ_HOST_REG16(pDevice,OMAP_REG_MMC_MODULE_STATUS) &
+            OMAP_REG_MMC_MODULE_STATUS_REQ_PROCESS) {
+            DBG_PRINT(SDDBG_WARN, ("SDIO OMAP ERROR!!! status did not clear: 0x%X\n",
+                READ_HOST_REG16(pDevice,OMAP_REG_MMC_MODULE_STATUS)));
+        }
+
+        switch (GET_SDREQ_RESP_TYPE(pReq->Flags)) {
+            default:
+            case SDREQ_FLAGS_NO_RESP:
+                temp = OMAP_REG_MMC_CMD_NORESPONSE;
+                break;
+            case SDREQ_FLAGS_RESP_R1:
+                temp = OMAP_REG_MMC_CMD_R1;
+                break;
+            case SDREQ_FLAGS_RESP_R1B:
+                temp = OMAP_REG_MMC_CMD_R1 | OMAP_REG_MMC_CMD_R1BUSY;
+                break;
+            case SDREQ_FLAGS_RESP_R2:
+                temp = OMAP_REG_MMC_CMD_R2;
+                break;
+            case SDREQ_FLAGS_RESP_R3:
+                temp = OMAP_REG_MMC_CMD_R3;
+                break;
+            case SDREQ_FLAGS_RESP_SDIO_R4:
+                    /* SDIO R4s are just OCR responses equivalent to an R3*/
+                 temp = OMAP_REG_MMC_CMD_R3;
+                break;
+            case SDREQ_FLAGS_RESP_SDIO_R5:
+                    /* R5s are just R1 responses, do not use the R5 type in this controller
+                     * because it will disable response timeout detection unless you set
+                     * the C5E,C14E..bits */
+                temp = OMAP_REG_MMC_CMD_R1;
+                break;
+            case SDREQ_FLAGS_RESP_R6:
+                temp = OMAP_REG_MMC_CMD_R6;
+                break;
+        }
+
+            /* get the command type */
+        switch (GET_SDREQ_RESP_TYPE(pReq->Flags)) {
+            case SDREQ_FLAGS_NO_RESP:
+                    /* broadcast no-response */
+                temp |= OMAP_REG_MMC_CMD_TYPE_BC;
+                break;
+
+            case SDREQ_FLAGS_RESP_R2:
+                if ((pReq->Command == CMD9) || (pReq->Command == CMD10)) {
+                    temp |= OMAP_REG_MMC_CMD_TYPE_AC;
+                } else if (pReq->Command == CMD2) {
+                    temp |= OMAP_REG_MMC_CMD_TYPE_BCR;
+                } else {
+                    DBG_ASSERT(FALSE);
+                }
+                break;
+            case SDREQ_FLAGS_RESP_R3:
+            case SDREQ_FLAGS_RESP_R6:
+            case SDREQ_FLAGS_RESP_SDIO_R4:
+                    /* responses that are broadcast */
+                temp |= OMAP_REG_MMC_CMD_TYPE_BCR;
+                break;
+            default:
+                /* all other commands are addressed responses */
+                if (IS_SDREQ_DATA_TRANS(pReq->Flags)) {
+                        /* commands with data */
+                    temp |= OMAP_REG_MMC_CMD_TYPE_ADTC;
+                } else {
+                        /* all commands without data */
+                    temp |= OMAP_REG_MMC_CMD_TYPE_AC;
+                }
+                break;
+        }
+
+        GetDefaults(pDevice);
+
+        ReqProcClkStartStop(pDevice, CLOCK_ON);
+
+        if (IS_SDREQ_DATA_TRANS(pReq->Flags)){
+            /* set the block size register */
+            WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_BLOCK_LENGTH, pReq->BlockLen-1);
+            /* set block count register */
+            WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_BLOCK_COUNT, pReq->BlockCount-1);
+            pReq->DataRemaining = pReq->BlockLen * pReq->BlockCount;
+            DBG_PRINT(OMAP_TRACE_DATA,
+                     ("SDIO OMAP HcdRequest: %s Data Transfer, Blocks:%d, BlockLen:%d, Total:%d \n",
+                                       IS_SDREQ_WRITE_DATA(pReq->Flags) ? "TX":"RX",
+                                       pReq->BlockCount, pReq->BlockLen, pReq->DataRemaining));
+        	DBG_PRINT(OMAP_TRACE_REQUESTS, ("SDIO OMAP HcdRequest: blen: 0x%X, nblk: 0x%X\n",
+                                 READ_HOST_REG16(pDevice, OMAP_REG_MMC_BLOCK_LENGTH),
+                                 READ_HOST_REG16(pDevice, OMAP_REG_MMC_BLOCK_COUNT)));
+                /* use the context to hold where we are in the buffer */
+            pReq->pHcdContext = pReq->pDataBuffer;
+            temp |= IS_SDREQ_WRITE_DATA(pReq->Flags) ?
+                    OMAP_REG_MMC_CMD_DDIR_WRITE : OMAP_REG_MMC_CMD_DDIR_READ;
+
+            SetDataTimeout(pDevice, pDevice->DataTimeOut);
+
+            if ((pReq->Flags & SDREQ_FLAGS_DATA_SHORT_TRANSFER) &&
+                (pReq->DataRemaining < OMAP_MAX_SHORT_TRANSFER_SIZE)) {
+                    /* flag current request as a short transfer */
+                pDevice->ShortTransfer = TRUE;
+            }
+
+            if (!pDevice->ShortTransfer) {
+                    /* setup dma transfer */
+                if (pDevice->DmaCapable) {
+                    if (pReq->Flags & SDREQ_FLAGS_DATA_DMA) {
+                            /* caller passed a scatter gather list */
+                        pDevice->DmaMode = OMAP_DMA_SG;
+                    } else {
+                            /* try common buffer */
+                        pDevice->DmaMode = OMAP_DMA_COMMON;
+                    }
+                } else {
+                    if (pReq->Flags & SDREQ_FLAGS_DATA_DMA) {
+                        DBG_ASSERT(FALSE);
+                        status = SDIO_STATUS_INVALID_PARAMETER;
+                        break;
+                    }
+                }
+            }
+
+            if (pDevice->DmaMode != OMAP_DMA_NONE) {
+                    /* check DMA */
+                status = CheckDMA(pDevice, pReq);
+
+                if (!SDIO_SUCCESS(status)) {
+                    if ((SDIO_STATUS_UNSUPPORTED == status) &&
+                        (OMAP_DMA_COMMON == pDevice->DmaMode)){
+                            /* if we tried common buffer, the length may be unaligned,
+                             * punt it to PIO mode */
+                        pDevice->DmaMode = OMAP_DMA_NONE;
+                        status = SDIO_STATUS_SUCCESS;
+                            /* fall through */
+                    } else {
+                            /* fail the request */
+                        break;
+                    }
+                } else {
+                        /* we are doing DMA */
+                    status = SetUpHCDDMA(pDevice,
+                                         pReq,
+                                         DMACompletion,
+                                         pDevice);
+                    if (!SDIO_SUCCESS(status)) {
+                        break;
+                    }
+                }
+            }
+
+        	DBG_PRINT(OMAP_TRACE_REQUESTS, ("SDIO OMAP HcdRequest:(1) blen: %d, nblk: %d\n",
+                   READ_HOST_REG16(pDevice, OMAP_REG_MMC_BLOCK_LENGTH),
+                   READ_HOST_REG16(pDevice, OMAP_REG_MMC_BLOCK_COUNT)));
+        }
+
+            /* set the argument register */
+        WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_ARG_LOW, (UINT16)(pReq->Argument & 0xFFFF));
+        WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_ARG_HI,  (UINT16)((pReq->Argument & 0xFFFF0000) >> 16));
+            /* set the command */
+        temp |= (pReq->Command & OMAP_REG_MMC_CMD_MASK);
+        DBG_PRINT(OMAP_TRACE_REQUESTS,
+                  ("SDIO OMAP HcdRequest CMDDAT:0x%X (RespType:%d, Command:0x%X , Arg:0x%X) \n",
+                  temp, GET_SDREQ_RESP_TYPE(pReq->Flags), pReq->Command, pReq->Argument));
+
+            /* set command timeout */
+        WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_CMD_TIMEOUT, pDevice->TimeOut);
+
+        if ((SDHCD_GET_OPER_CLOCK(pHcd) < pDevice->ClockSpinLimit) &&
+            (pReq->Command != CMD3)) {
+                /* clock rate is very low, need to use interrupts here */
+            UnmaskIrq(pDevice,
+                      OMAP_REG_MMC_INTERRUPT_ERRORS | OMAP_REG_MMC_INTERRUPT_ENABLE_EOC,
+                      FROM_NORMAL);
+
+            WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_CMD, temp);
+
+            status = SDIO_STATUS_PENDING;
+
+            if (pReq->Flags & SDREQ_FLAGS_DATA_TRANS) {
+                DBG_PRINT(OMAP_TRACE_REQUESTS,
+                    ("SDIO OMAP HcdRequest using interrupt for command done.*** with data. (clock:%d, ref:%d)\n",
+                    SDHCD_GET_OPER_CLOCK(pHcd),pDevice->ClockSpinLimit));
+            } else {
+                DBG_PRINT(OMAP_TRACE_REQUESTS,
+                    ("SDIO OMAP HcdRequest using interrupt for command done. (clock:%d, ref:%d) \n",
+                    SDHCD_GET_OPER_CLOCK(pHcd),pDevice->ClockSpinLimit));
+            }
+
+            break;
+        }
+
+            /* if we get here we are polling, interrupt errors and EOC should be masked */
+        WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_CMD, temp);
+
+        WAIT_FOR_HC_STATUS(pDevice,
+                           OMAP_REG_MMC_MODULE_STATUS_EOC,
+                           temp,
+                           OMAP_STATUS_CMD_PROCESSING_ERRORS,
+                           status,
+                           OMAP_COMMAND_DONE_POLLING);
+
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR,
+                    ("SDIO OMAP HCD (cmd-inline) polling failed (sd command:%d,status:%d)\n",
+                    pReq->Command,status));
+            ResetController(pDevice,TRUE,FROM_NORMAL);
+            if (pReq->Command == CMD3) {
+                status = SDIO_STATUS_SUCCESS;
+            } else {
+                break;
+            }
+        }
+
+        DBG_PRINT(OMAP_TRACE_REQUESTS,
+                    ("SDIO OMAP HCD (cmd-inline) statreg: 0x%X config:0x%X\n",
+                   READ_HOST_REG16(pDevice, OMAP_REG_MMC_MODULE_STATUS),
+                   READ_HOST_REG16(pDevice, OMAP_REG_MMC_MODULE_CONFIG)));
+
+        if (temp & OMAP_STATUS_CMD_PROCESSING_ERRORS) {
+            status = TranslateSDError(pDevice, pReq, temp);
+            if (!SDIO_SUCCESS(status)) {
+                break;
+            }
+        }
+
+        status = ProcessCommandDone(pDevice,pReq,FALSE);
+
+    } while (FALSE);
+
+    if (status != SDIO_STATUS_PENDING) {
+        pReq->Status = status;
+        EndHCTransfer(pDevice, pReq, FROM_NORMAL);
+        if (IS_SDREQ_FORCE_DEFERRED_COMPLETE(pReq->Flags)) {
+            DBG_PRINT(OMAP_TRACE_REQUESTS, ("SDIO OMAP HcdRequest deferring completion to work item \n"));
+                /* the HCD must do the indication in a separate context and return status pending */
+            QueueEventResponse(pDevice, WORK_ITEM_IO_COMPLETE);
+            return SDIO_STATUS_PENDING;
+        } else {
+                /* complete the request */
+            DBG_PRINT(OMAP_TRACE_REQUESTS, ("SDIO OMAP HcdRequest Command Done, status:%d \n", status));
+        }
+        pDevice->Cancel = FALSE;
+    }
+
+    return status;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  HcdConfig - HCD configuration handler
+  Input:  pHcd - HCD object
+          pConfig - configuration setting
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS HcdConfig(PSDHCD pHcd, PSDCONFIG pConfig)
+{
+    PSDHCD_DEVICE pDevice = (PSDHCD_DEVICE)pHcd->pContext;
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    UINT16 configSave;
+
+    if(pDevice->ShuttingDown) {
+        DBG_PRINT(OMAP_TRACE_REQUESTS, ("SDIO OMAP HcdConfig returning canceled\n"));
+        return SDIO_STATUS_CANCELED;
+    }
+
+    switch (GET_SDCONFIG_CMD(pConfig)){
+        case SDCONFIG_GET_WP:
+            if (WriteProtectSwitchOn(pDevice)) {
+                *((SDCONFIG_WP_VALUE *)pConfig->pData) = 1;
+            } else {
+                *((SDCONFIG_WP_VALUE *)pConfig->pData) = 0;
+            }
+            break;
+        case SDCONFIG_SEND_INIT_CLOCKS:
+            DBG_PRINT(OMAP_TRACE_REQUESTS, ("SDIO OMAP HcdConfig sending init clocks\n"));
+            MaskIrq(pDevice, OMAP_REG_MMC_INTERRUPT_ALL_INT,FROM_NORMAL);
+            ReqProcClkStartStop(pDevice, CLOCK_ON);
+            WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_CMD, OMAP_REG_MMC_CMD_INAB);
+            WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_MODULE_STATUS, OMAP_REG_MMC_MODULE_STATUS_ALL);
+            while(!(READ_HOST_REG16(pDevice, OMAP_REG_MMC_MODULE_STATUS) & OMAP_REG_MMC_MODULE_STATUS_EOC))
+                ;
+            WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_MODULE_STATUS, OMAP_REG_MMC_MODULE_STATUS_EOC);
+            ReqProcClkStartStop(pDevice, CLOCK_OFF);
+            break;
+        case SDCONFIG_SDIO_INT_CTRL:
+            if (GET_SDCONFIG_CMD_DATA(PSDCONFIG_SDIO_INT_CTRL_DATA,pConfig)->SlotIRQEnable) {
+                {
+                    SDIO_IRQ_MODE_FLAGS irqModeFlags;
+
+                    irqModeFlags =
+                        GET_SDCONFIG_CMD_DATA(PSDCONFIG_SDIO_INT_CTRL_DATA,pConfig)->IRQDetectMode;
+                    if (irqModeFlags & IRQ_DETECT_4_BIT) {
+                        DBG_PRINT(OMAP_TRACE_SDIO_INT, ("SDIO OMAP HcdConfig: 4 Bit IRQ mode \n"));
+                            /* in 4 bit mode, the clock needs to be left on */
+                        pDevice->KeepClockOn = TRUE;
+                    } else {
+                            /* in 1 bit mode, the clock can be left off */
+                        pDevice->KeepClockOn = FALSE;
+                    }
+                }
+                pDevice->IrqDetectArmed = TRUE;
+
+                    /* enable SDIO mode IRQ detection */
+                configSave = READ_HOST_REG16(pDevice, OMAP_REG_MMC_SDIO_MODE_CONFIG);
+                configSave |= OMAP_REG_MMC_SDIO_MODE_CONFIG_IRQE;
+                WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_SDIO_MODE_CONFIG, configSave);
+                    /* enable detection IRQ */
+                DBG_PRINT(OMAP_TRACE_SDIO_INT, ("SDIO OMAP HcdConfig: enable SDIO IRQ\n"));
+                UnmaskIrq(pDevice, OMAP_REG_MMC_INTERRUPT_ENABLE_CIRQ, FROM_NORMAL);
+            } else {
+                pDevice->KeepClockOn = FALSE;
+                pDevice->IrqDetectArmed = FALSE;
+                DBG_PRINT(OMAP_TRACE_SDIO_INT, ("SDIO OMAP HcdConfig: disable SDIO IRQ\n"));
+                MaskIrq(pDevice, OMAP_REG_MMC_INTERRUPT_ENABLE_CIRQ, FROM_NORMAL);
+                configSave = READ_HOST_REG16(pDevice, OMAP_REG_MMC_SDIO_MODE_CONFIG);
+                configSave &= ~OMAP_REG_MMC_SDIO_MODE_CONFIG_IRQE;
+                WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_SDIO_MODE_CONFIG, configSave);
+            }
+            break;
+        case SDCONFIG_SDIO_REARM_INT:
+                /* re-enable IRQ detection */
+            DBG_PRINT(OMAP_TRACE_SDIO_INT, ("SDIO OMAP HcdConfig - SDIO IRQ re-armed\n"));
+                /* make sure status is cleared */
+            WRITE_HOST_REG16(pDevice,
+                             OMAP_REG_MMC_MODULE_STATUS,
+                             OMAP_REG_MMC_MODULE_STATUS_CIRQ);
+            pDevice->IrqDetectArmed = TRUE;
+            UnmaskIrq(pDevice, OMAP_REG_MMC_INTERRUPT_ENABLE_CIRQ, FROM_NORMAL);
+            break;
+        case SDCONFIG_BUS_MODE_CTRL:
+            SetBusMode(pDevice, (PSDCONFIG_BUS_MODE_DATA)(pConfig->pData));
+                /* save it in case we have to restore it later */
+            memcpy(&pDevice->SavedBusMode,pConfig->pData,sizeof(SDCONFIG_BUS_MODE_DATA));
+            break;
+        case SDCONFIG_POWER_CTRL:
+            DBG_PRINT(OMAP_TRACE_CONFIG, ("SDIO OMAP HcdConfig PwrControl: En:%d, VCC:0x%X \n",
+                      GET_SDCONFIG_CMD_DATA(PSDCONFIG_POWER_CTRL_DATA,pConfig)->SlotPowerEnable,
+                      GET_SDCONFIG_CMD_DATA(PSDCONFIG_POWER_CTRL_DATA,pConfig)->SlotPowerVoltageMask));
+            status = SetPowerLevel(pDevice,
+                     GET_SDCONFIG_CMD_DATA(PSDCONFIG_POWER_CTRL_DATA,pConfig)->SlotPowerEnable,
+                     GET_SDCONFIG_CMD_DATA(PSDCONFIG_POWER_CTRL_DATA,pConfig)->SlotPowerVoltageMask);
+            break;
+        case SDCONFIG_GET_HCD_DEBUG:
+            *((CT_DEBUG_LEVEL *)pConfig->pData) = DBG_GET_DEBUG_LEVEL();
+            break;
+        case SDCONFIG_SET_HCD_DEBUG:
+            DBG_SET_DEBUG_LEVEL(*((CT_DEBUG_LEVEL *)pConfig->pData));
+            break;
+        default:
+            /* invalid request */
+            DBG_PRINT(SDDBG_WARN, ("SDIO OMAP HCD: HcdConfig - unsupported command: 0x%X\n",
+                                    GET_SDCONFIG_CMD(pConfig)));
+            status = SDIO_STATUS_INVALID_PARAMETER;
+    }
+
+    return status;
+}
+
+void ResetController(PSDHCD_DEVICE pDevice, BOOL Restore, BOOL FromIsr)
+{
+    INT ii;
+
+    ClockStartStop(pDevice, CLOCK_OFF);
+
+    WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_SYSTEM_CONTROL, OMAP_REG_MMC_SYSTEM_CONTROL_SW_RESET);
+    WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_SYSTEM_CONTROL, 0);
+
+        /* wait for done */
+    for(ii = 0;
+        (!(READ_HOST_REG16(pDevice, OMAP_REG_MMC_SYSTEM_STATUS) &  OMAP_REG_MMC_SYSTEM_STATUS_RESET_DONE))
+        && (ii < 1000);
+        ii++);
+
+    if (ii >= 1000) {
+            /* reset on 1610 is broken, see errata, use alternate approach */
+            /* cycle power */
+         WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_MODULE_CONFIG, 0);
+         WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_MODULE_CONFIG,
+                                         OMAP_REG_MMC_MODULE_CONFIG_PWRON | 1);
+    }
+
+    WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_MODULE_CONFIG,
+                     OMAP_REG_MMC_MODULE_CONFIG_MODE_MMCSD | OMAP_REG_MMC_MODULE_CONFIG_PWRON);
+
+         /* configure the SDIO mode */
+    WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_SDIO_MODE_CONFIG,
+                     OMAP_REG_MMC_SDIO_MODE_CONFIG_DCR4);
+
+    SetDataTimeout(pDevice, OMAP_DEFAULT_DATA_TIMEOUT);
+
+        /* set the default timeouts */
+    WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_CMD_TIMEOUT, pDevice->TimeOut);
+        /* clear all status bits, from chip erratta, the status may not clear on a reset */
+    WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_MODULE_STATUS, OMAP_REG_MMC_MODULE_STATUS_ALL);
+
+    if (!Restore) {
+        return;
+    }
+
+        /* restore bus clock and bus mode */
+    SetBusMode(pDevice,&pDevice->SavedBusMode);
+
+        /* restore interrupt state */
+    if (pDevice->IrqDetectArmed) {
+        UnmaskIrq(pDevice, OMAP_REG_MMC_INTERRUPT_ENABLE_CIRQ, FromIsr);
+    }
+
+}
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  HcdInitialize - Initialize controller
+  Input:  pDeviceContext - device context
+  Output:
+  Return:
+  Notes: I/O resources must be mapped before calling this function
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS HcdInitialize(PSDHCD_DEVICE pDeviceContext)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    UINT16 version;
+
+    DBG_PRINT(SDDBG_TRACE, ("+SDIO OMAP HcdInitialize\n"));
+
+        /* reset the controller */
+    ResetController(pDeviceContext, FALSE,FROM_NORMAL);
+
+        /* display version info */
+    version = READ_HOST_REG16(pDeviceContext, OMAP_REG_MMC_MODULE_REV);
+    DBG_PRINT(SDDBG_TRACE, ("SDIO OMAP HcdInitialize: Module Spec verison: %d.%d\n",
+              ((version & OMAP_REG_MMC_MODULE_REV_MAJOR_MASK) >> OMAP_REG_MMC_MODULE_REV_MAJOR_SHIFT),
+              ((version & OMAP_REG_MMC_MODULE_REV_MINOR_MASK) >> OMAP_REG_MMC_MODULE_REV_MINOR_SHIFT)));
+
+    if (pDeviceContext->BaseClock == 0) {
+         DBG_PRINT(SDDBG_ERROR, ("SDIO OMAP invalid base clock setting\n"));
+         status = SDIO_STATUS_DEVICE_ERROR;
+         return status;
+    }
+
+    DBG_PRINT(SDDBG_TRACE,
+    ("SDIO OMAP Using base clock: %dHz, max bus clock: %dHz, max blocks: %d max bytes per block: %d\n",
+                            pDeviceContext->BaseClock,
+                            pDeviceContext->Hcd.MaxClockRate,
+                            pDeviceContext->Hcd.MaxBlocksPerTrans,
+                            pDeviceContext->Hcd.MaxBytesPerBlock));
+
+    DBG_PRINT(SDDBG_TRACE, ("SDIO OMAP HcdInitialize: SlotVoltageCaps: 0x%X, MaxSlotCurrent: 0x%X\n",
+                        (UINT)pDeviceContext->Hcd.SlotVoltageCaps, (UINT)pDeviceContext->Hcd.MaxSlotCurrent));
+
+    /* interrupts will get enabled by the caller after all of the OS dependent work is done */
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO OMAP HcdInitialize\n"));
+    return status;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  HcdDeinitialize - deactivate controller
+  Input:  pDeviceContext - context
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void HcdDeinitialize(PSDHCD_DEVICE pDeviceContext)
+{
+    PSDREQUEST pReq;
+
+    DBG_PRINT(SDDBG_TRACE, ("+SDIO OMAP HcdDeinitialize\n"));
+
+
+    pReq = GET_CURRENT_REQUEST(&pDeviceContext->Hcd);
+
+    if (pReq != NULL) {
+        pReq->Status = SDIO_STATUS_CANCELED;
+        DBG_PRINT(SDDBG_TRACE,
+        ("SDIO OMAP HcdDeinitialize - cancelling request. (command:%d) mod status:0x%X, IRQ Enables:0x%X\n",
+        pReq->Command,  (UINT)READ_HOST_REG16(pDeviceContext, OMAP_REG_MMC_MODULE_STATUS),
+        (UINT)READ_HOST_REG16(pDeviceContext, OMAP_REG_MMC_INTERRUPT_ENABLE)));
+    }
+
+    pDeviceContext->KeepClockOn = FALSE;
+    MaskIrq(pDeviceContext, OMAP_REG_MMC_INTERRUPT_ALL_INT, FROM_NORMAL);
+    pDeviceContext->ShuttingDown = TRUE;
+    ClockStartStop(pDeviceContext, CLOCK_OFF);
+
+    if (pReq != NULL) {
+        SDIO_HandleHcdEvent(&pDeviceContext->Hcd, EVENT_HCD_TRANSFER_DONE);
+    }
+
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO OMAP HcdDeinitialize\n"));
+}
+
+void EndHCTransfer(PSDHCD_DEVICE pDevice, PSDREQUEST pReq, BOOL FromIsr)
+{
+
+    if (!SDIO_SUCCESS(pReq->Status) && (pDevice->DmaMode != OMAP_DMA_NONE)) {
+            /* DMA may be running cancel the DMA transfer */
+        SDCancelDMATransfer(pDevice);
+    }
+
+    MaskIrq(pDevice,
+            (OMAP_REG_MMC_INTERRUPT_ALL_INT & ~OMAP_REG_MMC_INTERRUPT_ENABLE_CIRQ),FromIsr);
+
+    if (!pDevice->KeepClockOn) {
+        ReqProcClkStartStop(pDevice, CLOCK_OFF);
+    }
+
+    if (!SDIO_SUCCESS(pReq->Status)) {
+          switch (pReq->Status) {
+            case SDIO_STATUS_BUS_READ_TIMEOUT:
+            case SDIO_STATUS_BUS_READ_CRC_ERR:
+            case SDIO_STATUS_BUS_WRITE_ERROR:
+            case SDIO_STATUS_BUS_RESP_CRC_ERR:
+                DBG_PRINT(SDDBG_TRACE, ("SDIO OMAP - resetting controller on bus errors (CMD:%d) \n",
+                        pReq->Command));
+                    /* controller gets stuck on some errors */
+                ResetController(pDevice,TRUE,FromIsr);
+                break;
+            default:
+                break;
+        }
+    }
+
+    if ((DBG_GET_DEBUG_LEVEL() >= OMAP_TRACE_DATA) && SDIO_SUCCESS(pReq->Status) &&
+        IS_SDREQ_DATA_TRANS(pReq->Flags) && (pDevice->DmaMode != OMAP_DMA_SG)) {
+        if (!IS_SDREQ_WRITE_DATA(pReq->Flags)) {
+            SDLIB_PrintBuffer(pReq->pDataBuffer,(pReq->BlockLen*pReq->BlockCount),"SDIO OMAP - RX DataDump");
+        } else {
+            SDLIB_PrintBuffer(pReq->pDataBuffer,(pReq->BlockLen*pReq->BlockCount),"SDIO OMAP - TX DataDump");
+        }
+    }
+
+}
+
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  HcdSDInterrupt - process controller interrupt
+  Input:  pDeviceContext - context
+  Output:
+  Return: TRUE if interrupt was handled
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+BOOL HcdSDInterrupt(PSDHCD_DEVICE pDevice)
+{
+    UINT16      statusErrs,errorMask,statusMask;
+    PSDREQUEST  pReq = NULL;
+    SDIO_STATUS status = SDIO_STATUS_PENDING;
+
+    DBG_PRINT(OMAP_TRACE_MMC_INT, ("+SDIO OMAP ISR handler \n"));
+
+    pReq = GET_CURRENT_REQUEST(&pDevice->Hcd);
+
+    while (1) {
+
+            /* get status */
+        statusErrs = READ_HOST_REG16(pDevice, OMAP_REG_MMC_MODULE_STATUS);
+
+        DBG_PRINT(OMAP_TRACE_MMC_INT, ("SDIO OMAP ISR, status: 0x%X \n",
+                  (UINT)statusErrs));
+
+            /* for ISR processing, only deal with interrupts that are actually enabled */
+        statusMask = READ_HOST_REG16(pDevice, OMAP_REG_MMC_INTERRUPT_ENABLE);
+        statusErrs &= statusMask;
+            /* ack the status bits we care about */
+        WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_MODULE_STATUS, statusErrs);
+
+        DBG_PRINT(OMAP_TRACE_MMC_INT, ("SDIO OMAP ISR, valid status: 0x%X, IRQ Enables:0x%X\n",
+                  (UINT)statusErrs, statusMask));
+
+            /* deal with SDIO interrupts */
+        if (statusErrs & OMAP_REG_MMC_MODULE_STATUS_CIRQ) {
+            if (READ_HOST_REG16(pDevice, OMAP_REG_MMC_SDIO_MODE_CONFIG)
+                    & OMAP_REG_MMC_SDIO_MODE_CONFIG_IRQE) {
+                        /* this interrupt is level triggered and will remain set until the card interrupt
+                       source is cleared. */
+                    DBG_PRINT(OMAP_TRACE_SDIO_INT, ("SDIO OMAP ISR - SDIO_IRQ detected\n"));
+                        /* ack*/
+                    WRITE_HOST_REG16(pDevice,
+                                     OMAP_REG_MMC_MODULE_STATUS,
+                                     OMAP_REG_MMC_MODULE_STATUS_CIRQ);
+                    MaskIrq(pDevice, OMAP_REG_MMC_INTERRUPT_ENABLE_CIRQ, FROM_ISR);
+                    QueueEventResponse(pDevice, WORK_ITEM_SDIO_IRQ);
+            } else {
+                DBG_ASSERT_WITH_MSG(FALSE,
+                        "SDIO OMAP ISR - unexpected card interrupt!\n");
+            }
+        }
+
+        if (0 == statusErrs) {
+                /* nothing to process */
+            break;
+        }
+
+        if (NULL == pReq) {
+                /* nothing more to do */
+            break;
+        }
+
+        errorMask = OMAP_REG_MMC_MODULE_STATUS_CTO  |
+                    OMAP_REG_MMC_MODULE_STATUS_CCRC;
+
+        if (IS_SDREQ_DATA_TRANS(pReq->Flags)){
+            errorMask |= OMAP_REG_MMC_MODULE_STATUS_DTO | OMAP_REG_MMC_MODULE_STATUS_DCRC;
+        }
+
+        if (statusErrs & errorMask) {
+            status = TranslateSDError(pDevice, pReq, (statusErrs & errorMask));
+            if (!SDIO_SUCCESS(status)) {
+                break;
+            }
+        }
+
+
+        /* if we reach here, there were no command processing errors */
+
+        if (statusErrs & OMAP_REG_MMC_MODULE_STATUS_EOC) {
+            MaskIrq(pDevice, OMAP_REG_MMC_INTERRUPT_ENABLE_EOC, FROM_ISR);
+            status = ProcessCommandDone(pDevice,
+                                        pReq,
+                                        TRUE);
+            if (!SDIO_SUCCESS(status)) {
+                break;
+            }
+        }
+
+        if (statusErrs & OMAP_REG_MMC_MODULE_STATUS_AE) {
+            DBG_ASSERT(IS_SDREQ_DATA_TRANS(pReq->Flags));
+            DBG_ASSERT(IS_SDREQ_WRITE_DATA(pReq->Flags));
+            DBG_PRINT(OMAP_TRACE_MMC_INT, ("SDIO OMAP ISR TX Transfer AE\n"));
+
+                /* refill the FIFO */
+            if (HcdTransferTxData(pDevice, pReq)) {
+                    /* fifo contains final data, disable almost empty interrupts */
+                MaskIrq(pDevice, OMAP_REG_MMC_INTERRUPT_ENABLE_AE, FROM_ISR);
+                    /* get ready for BRS or EOFB, it has been observed that EOFB can come early
+                     * and mask out the BRS bit, this looks like a controller bug */
+                UnmaskIrq(pDevice,
+                          OMAP_REG_MMC_INTERRUPT_ENABLE_BRS | OMAP_REG_MMC_INTERRUPT_ENABLE_EOFB,
+                          FROM_ISR);
+                DBG_PRINT(OMAP_TRACE_BUSY,
+                    ("SDIO OMAP ISR, TX near complete, waiting for BRS or EOFB (bcnt:%d,blen:%d)\n",
+                   (UINT)READ_HOST_REG16(pDevice, OMAP_REG_MMC_BLOCK_COUNT),
+                   (UINT)READ_HOST_REG16(pDevice, OMAP_REG_MMC_BLOCK_LENGTH)));
+            } else {
+                    /* more data to go, if this is a multi-block transfer we want to make sure
+                     * the EOFB is cleared for all blocks except the last one, we will
+                     * actually wait for EOFB on the last block */
+                if (READ_HOST_REG16(pDevice, OMAP_REG_MMC_BLOCK_COUNT) > 2) {
+                    WRITE_HOST_REG16(pDevice,
+                                     OMAP_REG_MMC_MODULE_STATUS,
+                                     OMAP_REG_MMC_MODULE_STATUS_EOFB);
+                }
+            }
+        }
+
+        if (statusErrs & OMAP_REG_MMC_MODULE_STATUS_AF) {
+            DBG_ASSERT(IS_SDREQ_DATA_TRANS(pReq->Flags));
+            DBG_ASSERT(!IS_SDREQ_WRITE_DATA(pReq->Flags));
+            DBG_PRINT(OMAP_TRACE_MMC_INT, ("SDIO OMAP ISR RX Transfer AF\n"));
+                /* drain the FIFO */
+            if (HcdTransferRxData(pDevice, pReq, FALSE)) {
+                    /* last bit of data remaining, we can wait for BRS */
+                MaskIrq(pDevice, OMAP_REG_MMC_INTERRUPT_ENABLE_AF, FROM_ISR);
+                    /* get ready for BRS */
+                UnmaskIrq(pDevice, OMAP_REG_MMC_INTERRUPT_ENABLE_BRS,FROM_ISR);
+                DBG_PRINT(OMAP_TRACE_MMC_INT, ("SDIO OMAP ISR, RX near complete, waiting for BRS \n"));
+            }
+        }
+
+        if (statusErrs & OMAP_REG_MMC_MODULE_STATUS_BRS) {
+            DBG_ASSERT(IS_SDREQ_DATA_TRANS(pReq->Flags));
+            MaskIrq(pDevice, OMAP_REG_MMC_INTERRUPT_ENABLE_BRS, FROM_ISR);
+            if (IS_SDREQ_WRITE_DATA(pReq->Flags)) {
+                    /* check for busy on write operations */
+                MicroDelay(10);
+                    /* check card enter busy */
+                if (!(READ_HOST_REG16(pDevice, OMAP_REG_MMC_MODULE_STATUS) &
+                      OMAP_REG_MMC_MODULE_STATUS_CB)) {
+                    DBG_PRINT(OMAP_TRACE_BUSY, ("SDIO OMAP ISR TX Transfer Done - not busy \n"));
+                    status = SDIO_STATUS_SUCCESS;
+                        /* we are done */
+                    break;
+                }
+
+                    /* clear status */
+                WRITE_HOST_REG16(pDevice,
+                                 OMAP_REG_MMC_MODULE_STATUS,
+                                 OMAP_REG_MMC_MODULE_STATUS_CB);
+                DBG_PRINT(OMAP_TRACE_BUSY, ("SDIO OMAP ISR TX Transfer Done - waiting on busy release \n"));
+                statusErrs &= ~OMAP_REG_MMC_MODULE_STATUS_CB;
+                UnmaskIrq(pDevice, OMAP_REG_MMC_INTERRUPT_ENABLE_EOFB,FROM_ISR);
+
+            } else {
+                 DBG_PRINT(OMAP_TRACE_MMC_INT, ("SDIO OMAP ISR RX Transfer Done \n"));
+                 if (pDevice->DmaMode == OMAP_DMA_NONE) {
+                        /* In PIO mode, the FIFO may contain some residue data */
+                     HcdTransferRxData(pDevice, pReq, TRUE);
+                     DBG_ASSERT(pReq->DataRemaining == 0);
+                 }
+                 status = SDIO_STATUS_SUCCESS;
+                 break;
+            }
+        }
+
+        if (statusErrs & OMAP_REG_MMC_MODULE_STATUS_EOFB) {
+            DBG_ASSERT(IS_SDREQ_DATA_TRANS(pReq->Flags));
+            DBG_ASSERT(IS_SDREQ_WRITE_DATA(pReq->Flags));
+            MaskIrq(pDevice, OMAP_REG_MMC_INTERRUPT_ENABLE_EOFB,FROM_ISR);
+            DBG_PRINT(OMAP_TRACE_BUSY,("SDIO OMAP ISR Card Busy Done (bcnt:%d,blen:%d)\n",
+                   (UINT)READ_HOST_REG16(pDevice, OMAP_REG_MMC_BLOCK_COUNT),
+                   (UINT)READ_HOST_REG16(pDevice, OMAP_REG_MMC_BLOCK_LENGTH)));
+                /* the write operation is finally done */
+            status = SDIO_STATUS_SUCCESS;
+            break;
+        }
+
+    }
+
+    if (status != SDIO_STATUS_PENDING) {
+        pReq->Status = status;
+        EndHCTransfer(pDevice,pReq,FROM_ISR);
+        if (OMAP_DMA_NONE == pDevice->DmaMode) {
+                /* queue work item to notify bus driver of I/O completion */
+            QueueEventResponse(pDevice, WORK_ITEM_IO_COMPLETE);
+        } else {
+                /* using some form of DMA */
+            if (!SDIO_SUCCESS(status)) {
+                    /* EndHCTransfer will cancel DMA, no need to synch with DMA */
+                QueueEventResponse(pDevice, WORK_ITEM_IO_COMPLETE);
+            } else {
+                    /* sync request completion with DMA */
+                CompleteRequestSyncDMA(pDevice,pReq,status);
+            }
+        }
+    }
+
+    DBG_PRINT(OMAP_TRACE_MMC_INT, ("-SDIO OMAP ISR handler \n"));
+
+    return TRUE;
+}
+
+
+
Index: linux-2.6/drivers/sdio/hcd/omap2420/sdio_hcd_linux.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/hcd/omap2420/sdio_hcd_linux.h
@@ -0,0 +1,147 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdio_hcd_linux.h
+
+@abstract: include file for Texas Instruments OMAP host controller, linux dependent code
+
+@notice: Copyright (c), 2004-2006 Atheros Communications, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions o this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (Simplified
+ *   Specification) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#ifndef __SDIO_HCD_LINUX_H___
+#define __SDIO_HCD_LINUX_H___
+
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <linux/device.h>
+#endif
+#include <asm/arch/dma.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <asm/arch/clock.h>
+#endif
+#include <asm/irq.h>
+#include <linux/delay.h>
+
+
+#define SDHCD_MAX_DEVICE_NAME     12
+
+#define OMAP_BASE_ADDRESS1        0x4809C000
+#define OMAP_BASE_LENGTH          0x6A
+
+#define OMAP_MODULE_CLOCK         96000000
+#define OMAP_MAX_DEVICE_COUNT     2
+#define OMAP_DEFAULT_DEVICE_COUNT 1
+#define OMAP_DEFAULT_FIRST_DEVICE 0
+#define OMAP_DMA_MASK             0xFFFFFFFF
+
+#define HCD_COMMAND_MIN_POLLING_CLOCK 5000000
+
+/* debounce delay for slot */
+#define SD_SLOT_DEBOUNCE_MS  500
+
+
+/* device base name */
+#define SDIO_BD_BASE "sdiobd"
+
+/* mapped memory address */
+typedef struct _SDHCD_MEMORY {
+    ULONG Raw;      /* start of address range */
+    ULONG Length;   /* length of range */
+    PVOID pMapped;  /* the mapped address */
+}SDHCD_MEMORY, *PSDHCD_MEMORY;
+
+typedef void (*PDMA_TRANSFER_COMPLETION)(PVOID,SDIO_STATUS,BOOL);
+
+/* device data*/
+typedef struct _HCD_OS_INFO {
+    POS_PNPDEVICE pBusDevice;      /* our device registered with bus driver */
+    SDHCD_MEMORY  Address;          /* memory address of this device */
+    spinlock_t    AddressSpinlock;   /* use to protect reghisters when needed */
+    UINT8         InitStateMask;
+#define SDIO_BASE_MAPPED           0x01
+#define SDIO_IRQ_INTERRUPT_INIT    0x04
+#define SDHC_REGISTERED            0x10
+#define SDHC_HW_INIT               0x40
+#define SDHC_TIMER_INIT            0x80
+    spinlock_t   Lock;            /* lock against the ISR */
+    BOOL         CardInserted;    /* card inserted flag */
+    BOOL         Cancel;
+    BOOL         ShuttingDown;    /* indicates shut down of HCD) */
+    struct work_struct iocomplete_work; /* work item definintions */
+    struct work_struct carddetect_work; /* work item definintions */
+    struct work_struct sdioirq_work; /* work item definintions */
+    DMA_ADDRESS hDmaBuffer;       /* handle for data buffer */
+    PUINT8      pDmaBuffer;       /* virtual address of command buffer */
+    UINT32      CommonBufferSize; /* size of CommonBuffer */
+    int         Interrupt;
+    int         DmaRxId;
+    int         DmaTxId;
+    int         DmaRxChannel;      /* receive DMA channel */
+    int         DmaTxChannel;      /* transmit DMA channel */
+    int         LastTransfer;      /* length of last transfer */
+    PSDDMA_DESCRIPTOR pDmaList;    /* in use scatter-gather list */
+    UINT        SGcount;           /* count of in-use scatter gather list */
+    PVOID       TransferContext;   /* context passed to TransferCompletion routine */
+    PDMA_TRANSFER_COMPLETION pTransferCompletion; /* transfer completion routine */
+}HCD_OS_INFO, *PHCD_OS_INFO;
+
+typedef struct _SDHCD_DRIVER {
+    OS_PNPDEVICE   HcdDevice;     /* the OS device for this HCD */
+    OS_PNPDRIVER   HcdDriver;     /* the OS driver for this HCD */
+    SDDMA_DESCRIPTION Dma;        /* driver DMA description */
+}SDHCD_DRIVER, *PSDHCD_DRIVER;
+
+
+#define WORK_ITEM_IO_COMPLETE  0
+#define WORK_ITEM_CARD_DETECT  1
+#define WORK_ITEM_SDIO_IRQ     2
+
+
+#define READ_HOST_REG32(pDevice, OFFSET)  \
+    _READ_DWORD_REG((((UINT32)((pDevice)->OSInfo.Address.pMapped))) + (OFFSET))
+#define WRITE_HOST_REG32(pDevice, OFFSET, VALUE) \
+    _WRITE_DWORD_REG((((UINT32)((pDevice)->OSInfo.Address.pMapped))) + (OFFSET),(VALUE))
+#define READ_HOST_REG16(pDevice, OFFSET)  \
+    _READ_WORD_REG((((UINT32)((pDevice)->OSInfo.Address.pMapped))) + (OFFSET))
+#define WRITE_HOST_REG16(pDevice, OFFSET, VALUE) \
+    _WRITE_WORD_REG((((UINT32)((pDevice)->OSInfo.Address.pMapped))) + (OFFSET),(VALUE))
+
+#define GET_HC_REG_BASE(pDevice) (pDevice)->OSInfo.Address.pMapped
+
+#define OMAP_USE_DBG_GPIO
+/* prototypes */
+#endif /* __SDIO_HCD_LINUX_H___ */
Index: linux-2.6/drivers/sdio/hcd/omap2420/sdio_hcd_os_2_6.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/hcd/omap2420/sdio_hcd_os_2_6.c
@@ -0,0 +1,731 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdio_hcd_os_2_6.c
+
+@abstract: Linux OMAP native SDIO Host Controller Driver, 2.6 and higher
+
+#notes: includes initialization and DMA code
+
+@notice: Copyright (c), 2004-2006 Atheros Communications, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions o this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (Simplified
+ *   Specification) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#include <linux/sdio/ctsystem.h>
+#include "sdio_omap_hcd.h"
+#include <linux/fs.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+
+#include <asm/mach-types.h>
+#include <asm/arch/dma.h>
+#include <asm/arch/mux.h>
+#include <linux/dma-mapping.h>
+#include <asm/arch/board.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/menelaus.h>
+#include <asm/arch/clock.h>
+
+extern INT gpiodebug;
+extern INT noDMA;
+extern SDHCD_DRIVER_CONTEXT HcdContext;
+extern int clk_safe(struct clk *clk);
+
+static irqreturn_t hcd_sdio_irq(int irq, void *context, struct pt_regs * r);
+static void setupOmapDma(PSDHCD_DEVICE pDevice,
+                         int           Length,
+                         DMA_ADDRESS   DmaAddress,
+                         BOOL          RX);
+static void SD_DMACompleteCallback(int Channel, u16 DMAStatus, PVOID pContext);
+
+void ToggleGPIOPin(PSDHCD_DEVICE pDevice, INT PinNo)
+{
+    if (!gpiodebug) {
+        return;
+    }
+
+    switch (PinNo) {
+        case DBG_GPIO_PIN_1:
+            omap_set_gpio_dataout(16,TRUE);
+            omap_set_gpio_dataout(16,FALSE);
+            break;
+        case DBG_GPIO_PIN_2:
+            break;
+        default:
+            break;
+    }
+}
+
+
+#define OMAP_CONTROL_PADCONF_BASE_ADDRESS 0x48000000
+#define OMAP_CONTROL_PADCONF_SIZE 0x0400
+#define OMAP_PAD_PULLUPDWN_ENABLE (1 << 3)
+#define OMAP_PAD_PULLUP_TYPE      (1 << 4)
+#define OMAP_PAD_PULLDOWN_TYPE    (0 << 4)
+
+void OmapPadConfig(UINT32 Offset, UINT8 BitPos, UINT8 PadValue)
+{
+    UINT32 value;
+    UINT32 padConfig = (UINT32)ioremap(OMAP_CONTROL_PADCONF_BASE_ADDRESS,
+                               OMAP_CONTROL_PADCONF_SIZE);
+
+    value = readl(padConfig+Offset);
+    value &= ~((UINT32)0xff << BitPos);
+    value |= (UINT32)PadValue << BitPos;
+    writel(value,padConfig+Offset);
+}
+
+
+/*
+ * MapAddress - maps I/O address
+*/
+static SYSTEM_STATUS MapAddress(PSDHCD_MEMORY pMap, PTEXT pDescription) {
+
+    if (request_mem_region(pMap->Raw, pMap->Length, pDescription) == NULL) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO OMAP Local HCD: MapAddress - memory in use\n"));
+        return -EBUSY;
+    }
+    pMap->pMapped = ioremap_nocache(pMap->Raw, pMap->Length);
+    if (pMap->pMapped == NULL) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO OMAP Local HCD: MapAddress - unable to map memory\n"));
+        /* cleanup region */
+        release_mem_region(pMap->Raw, pMap->Length);
+        return -EFAULT;
+    }
+    return 0;
+}
+
+/*
+ * UnmapAddress - unmaps the address
+*/
+static void UnmapAddress(PSDHCD_MEMORY pMap) {
+    iounmap(pMap->pMapped);
+    release_mem_region(pMap->Raw, pMap->Length);
+    pMap->pMapped = NULL;
+}
+
+SDIO_STATUS SlotEnableControl(BOOL Enable)
+{
+    int value;
+    SDIO_STATUS status = SDIO_STATUS_ERROR;
+
+    do {
+        value = menelaus_read(MENELAUS_LDO_CTRL7);
+        if (value == -1) {
+            DBG_ASSERT(FALSE);
+            break;
+        }
+        if (Enable) {
+            value |= 0x03;
+        } else {
+            value &= ~0x03;
+        }
+        value = menelaus_write(value, MENELAUS_LDO_CTRL7);
+        if (value == -1) {
+            DBG_ASSERT(FALSE);
+            break;
+        }
+
+        value = menelaus_read(MENELAUS_MCT_CTRL3);
+        if (value == -1) {
+            DBG_ASSERT(FALSE);
+            break;
+        }
+        if (Enable) {
+            value |= 0x01;
+        } else {
+            value &= ~0x01;
+        }
+        value = menelaus_write(value, MENELAUS_MCT_CTRL3);
+        if (value == -1) {
+            DBG_ASSERT(FALSE);
+            break;
+        }
+
+
+        status = SDIO_STATUS_SUCCESS;
+    } while (FALSE);
+
+    return status;
+}
+/*
+ * unsetup the OMAP registers
+*/
+void DeinitOmap(PSDHCD_DEVICE pDevice)
+{
+
+    if (pDevice->OSInfo.InitStateMask & SDIO_IRQ_INTERRUPT_INIT) {
+        disable_irq(pDevice->OSInfo.Interrupt);
+        free_irq(pDevice->OSInfo.Interrupt, pDevice);
+        pDevice->OSInfo.InitStateMask &= ~SDIO_IRQ_INTERRUPT_INIT;
+    }
+
+        /* deallocate DMA buffer  */
+    if (pDevice->OSInfo.pDmaBuffer != NULL) {
+        dma_free_coherent(&pDevice->OSInfo.pBusDevice->dev,
+                          pDevice->OSInfo.CommonBufferSize,
+                          pDevice->OSInfo.pDmaBuffer,
+                          pDevice->OSInfo.hDmaBuffer);
+        pDevice->OSInfo.pDmaBuffer = NULL;
+    }
+
+    if (pDevice->OSInfo.DmaRxChannel != -1) {
+        omap_free_dma(pDevice->OSInfo.DmaRxChannel);
+        pDevice->OSInfo.DmaRxChannel = -1;
+    }
+
+    if (pDevice->OSInfo.DmaTxChannel != -1) {
+        omap_free_dma(pDevice->OSInfo.DmaTxChannel);
+        pDevice->OSInfo.DmaTxChannel = -1;
+    }
+
+    if (pDevice->OSInfo.InitStateMask & SDIO_BASE_MAPPED) {
+        pDevice->OSInfo.InitStateMask &= ~SDIO_BASE_MAPPED;
+        UnmapAddress(&pDevice->OSInfo.Address);
+    }
+
+    SlotEnableControl(FALSE);
+}
+
+void FifoTxTest(PSDHCD_DEVICE pDevice)
+{
+    INT     dataCopy = 1000;
+    volatile UINT16 *pFifo;
+
+    pFifo = (volatile UINT16 *)((UINT32)GET_HC_REG_BASE(pDevice) + OMAP_REG_MMC_DATA_ACCESS);
+
+    DBG_PRINT(SDDBG_TRACE, ("SDIO OMAP HCD: FifoTest (0x%X) \n", (UINT)pFifo));
+
+
+    while (dataCopy) {
+        *pFifo = (UINT16)dataCopy;
+        dataCopy--;
+    }
+
+    DBG_PRINT(SDDBG_TRACE, ("SDIO OMAP HCD: FifoTest Done\n"));
+}
+
+/*
+ * setup the OMAP registers
+*/
+SDIO_STATUS InitOmap(PSDHCD_DEVICE pDevice, UINT deviceNumber)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    ULONG       baseAddress;
+    int         err;
+    struct      clk *clksrc;
+
+    do {
+
+        pDevice->OSInfo.Interrupt = INT_MMC_IRQ;
+        baseAddress = OMAP_BASE_ADDRESS1;
+        pDevice->OSInfo.DmaRxId = OMAP_DMA_MMC1_RX;
+        pDevice->OSInfo.DmaTxId = OMAP_DMA_MMC1_TX;
+        pDevice->OSInfo.DmaRxChannel = -1;
+        pDevice->OSInfo.DmaTxChannel = -1;
+
+        SlotEnableControl(TRUE);
+
+        clksrc = clk_get(NULL,"mmc_ick");
+        if (NULL == clksrc) {
+            DBG_ASSERT(FALSE);
+            status = SDIO_STATUS_NO_RESOURCES;
+            break;
+        }
+
+        clk_use(clksrc);
+
+        clksrc = clk_get(NULL,"mmc_fck");
+        if (NULL == clksrc) {
+            DBG_ASSERT(FALSE);
+            status = SDIO_STATUS_NO_RESOURCES;
+            break;
+        }
+        clk_use(clksrc);
+        clk_safe(clksrc);
+
+
+        if (!noDMA) {
+            UINT32 gcrVal;
+
+            gcrVal = readl(OMAP_DMA4_GCR_REG);
+            DBG_PRINT(SDDBG_TRACE, ("SDIO OMAP HCD: DMA4_GCR : 0x%X \n",gcrVal));
+            gcrVal &= ~0xff;
+            gcrVal |= 64;
+            writel(gcrVal, OMAP_DMA4_GCR_REG);
+            DBG_PRINT(SDDBG_TRACE, ("SDIO OMAP HCD: DMA4_GCR reread: 0x%X \n",readl(OMAP_DMA4_GCR_REG)));
+                /* allocate a DMA buffer larger enough for the command buffers and the data buffers */
+            pDevice->OSInfo.pDmaBuffer =  dma_alloc_coherent(&pDevice->OSInfo.pBusDevice->dev,
+                                                             pDevice->OSInfo.CommonBufferSize,
+                                                             &pDevice->OSInfo.hDmaBuffer,
+                                                             GFP_DMA);
+            DBG_PRINT(SDDBG_TRACE, ("SDIO OMAP HCD: InitOmap - pDmaBuffer: 0x%X, hDmaBuffer: 0x%X Size:%d\n",
+                (UINT)pDevice->OSInfo.pDmaBuffer ,
+                (UINT)pDevice->OSInfo.hDmaBuffer,
+                pDevice->OSInfo.CommonBufferSize));
+
+            if (pDevice->OSInfo.pDmaBuffer == NULL) {
+                DBG_PRINT(SDDBG_ERROR, ("SDIO OMAP HCD: InitOmap - unable to get DMA buffer\n"));
+                status =  SDIO_STATUS_NO_RESOURCES;
+                break;
+            }
+
+            pDevice->DmaCapable = TRUE;
+                /* tell upper drivers that we support direct DMA */
+            pDevice->Hcd.pDmaDescription = &HcdContext.Driver.Dma;
+
+        }
+
+        if (gpiodebug) {
+              /* setup GPIO 16 */
+#define CONTROL_PADCONF_Y11       0x00E8
+            OmapPadConfig(CONTROL_PADCONF_Y11,
+                          0,
+                          0x3 | OMAP_PAD_PULLUPDWN_ENABLE | OMAP_PAD_PULLUP_TYPE);
+            omap_set_gpio_direction(16, OMAP24XX_DIR_OUTPUT);
+            omap_set_gpio_dataout(16,FALSE);
+        }
+
+        err = omap_request_dma(pDevice->OSInfo.DmaRxId,
+                               "SDIO TX",
+                               SD_DMACompleteCallback,
+                               pDevice,
+                               &pDevice->OSInfo.DmaRxChannel);
+
+        if (err < 0) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO OMAP HCD: OmapInit, unable to get RX DMA channel, %d\n",err));
+            status = SDIO_STATUS_NO_RESOURCES;
+            break;
+        }
+
+        err = omap_request_dma(pDevice->OSInfo.DmaTxId,
+                               "SDIO TX",
+                               SD_DMACompleteCallback,
+                               pDevice,
+                               &pDevice->OSInfo.DmaTxChannel);
+
+        if (err < 0) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO OMAP HCD: OmapInit, unable to get TX DMA channel, %d\n",err));
+            status = SDIO_STATUS_NO_RESOURCES;
+            break;
+        }
+
+            /* map the memory address for the control registers */
+        pDevice->OSInfo.Address.pMapped = (PVOID)IO_ADDRESS(baseAddress);
+        pDevice->OSInfo.Address.Raw = baseAddress;
+        pDevice->OSInfo.Address.Length = OMAP_BASE_LENGTH;
+        if (MapAddress(&pDevice->OSInfo.Address, "SDHC Regs") < 0) {
+            status = SDIO_STATUS_NO_RESOURCES;
+            break;
+        }
+        DBG_PRINT(SDDBG_TRACE,
+               ("SDIO OMAP - InitOMAP I/O Virt:0x%X Phys:0x%X\n",
+               (UINT)pDevice->OSInfo.Address.pMapped, (UINT)pDevice->OSInfo.Address.Raw));
+
+        //FifoTxTest(pDevice);
+
+        pDevice->OSInfo.InitStateMask |= SDIO_BASE_MAPPED;
+
+
+                /* map the controller interrupt, we map it to each device.
+                   Interrupts can be called from this point on */
+        err = request_irq(pDevice->OSInfo.Interrupt, hcd_sdio_irq, 0,
+                          "OMAP HCD", pDevice);
+        if (err < 0) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO OMAP HCD: OmapInit, unable to map interrupt \n"));
+            err = -ENODEV;
+            status = SDIO_STATUS_NO_RESOURCES;
+            break;
+        }
+
+        pDevice->OSInfo.InitStateMask |= SDIO_IRQ_INTERRUPT_INIT;
+
+    } while (FALSE);
+
+    if (!SDIO_SUCCESS(status)) {
+        DeinitOmap(pDevice);
+    }
+
+    return status;
+}
+
+void SetupTXCommonBufferDMATransfer(PSDHCD_DEVICE pDevice, PSDREQUEST pReq)
+{
+    UINT32 length;
+        /* adjust length */
+    length = min(pDevice->OSInfo.CommonBufferSize,
+                 pReq->DataRemaining);
+        /* copy to common buffer */
+    memcpy(pDevice->OSInfo.pDmaBuffer, pReq->pHcdContext, length);
+        /* adjust where we are */
+    pReq->pHcdContext = (PUCHAR)pReq->pHcdContext + length;
+    pReq->DataRemaining -= length;
+        /* setup this chunk */
+    setupOmapDma(pDevice, length, pDevice->OSInfo.hDmaBuffer,FALSE);
+    DBG_PRINT(OMAP_TRACE_DATA,
+        ("SDIO OMAP TX Common Buffer DMA,  This Transfer: %d, Remaining:%d\n",
+        length,pReq->DataRemaining));
+}
+/*
+ *  DMA transmit complete callback
+*/
+static void SD_DMACompleteCallback(int Channel, u16 DMAStatus, PVOID pContext)
+{
+    PSDHCD_DEVICE pDevice = (PSDHCD_DEVICE)pContext;
+    SDIO_STATUS   status = SDIO_STATUS_PENDING;
+    PSDREQUEST    pReq;
+
+    pReq = GET_CURRENT_REQUEST(&pDevice->Hcd);
+
+    DBG_PRINT(OMAP_TRACE_DATA,
+            ("SDIO OMAP SD_DMACompleteCallback (%s)- DMAStatus: 0x%X, lch: %d \n",
+               IS_SDREQ_WRITE_DATA(pReq->Flags) ? "TX":"RX",(UINT)status, Channel));
+    do {
+
+        if (DMAStatus == OMAP_DMA_SYNC_IRQ) {
+                /* only a synch int, ignore it */
+            break;
+        }
+
+        if (OMAP_DMA_SG == pDevice->DmaMode) {
+            DBG_ASSERT(pDevice->OSInfo.pDmaList != NULL);
+            DBG_ASSERT(pDevice->OSInfo.SGcount != 0);
+                /* unmap scatter gather */
+            dma_unmap_sg(pDevice->Hcd.pDevice,
+                         pDevice->OSInfo.pDmaList,
+                         pDevice->OSInfo.SGcount,
+                         IS_SDREQ_WRITE_DATA(pReq->Flags) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+            pDevice->OSInfo.pDmaList = NULL;
+            pDevice->OSInfo.SGcount = 0;
+        }
+
+            /* handle errors */
+        if (DMAStatus & (OMAP_DMA_TOUT_IRQ | OMAP_DMA_DROP_IRQ)) {
+            status = SDIO_STATUS_DEVICE_ERROR;
+            break;
+        }
+
+            /* no DMA errors */
+        status = SDIO_STATUS_SUCCESS;
+
+        if (OMAP_DMA_SG == pDevice->DmaMode) {
+                /* nothing more to do */
+            break;
+        }
+
+            /* handle common buffer DMA */
+        if (IS_SDREQ_WRITE_DATA(pReq->Flags)) {
+            if (pReq->DataRemaining) {
+                    /* send the next chunk */
+                SetupTXCommonBufferDMATransfer(pDevice,pReq);
+                status = SDIO_STATUS_PENDING;
+                break;
+            }
+        } else {
+            UINT32 length;
+
+            memcpy(pReq->pHcdContext, pDevice->OSInfo.pDmaBuffer, pDevice->OSInfo.LastTransfer);
+                /* adjust where we are */
+            pReq->pHcdContext = (PUCHAR)pReq->pHcdContext + pDevice->OSInfo.LastTransfer;
+            pReq->DataRemaining -= pDevice->OSInfo.LastTransfer;
+                /* set up next transfer */
+            length = min(pDevice->OSInfo.CommonBufferSize,
+                         pReq->DataRemaining);
+            if (length) {
+                DBG_PRINT(OMAP_TRACE_DATA,
+                    ("SDIO OMAP RX Common Buffer DMA,  Pending Transfer: %d, Remaining:%d\n",
+                            length, pReq->DataRemaining));
+                setupOmapDma(pDevice, length, pDevice->OSInfo.hDmaBuffer,TRUE);
+                pDevice->OSInfo.LastTransfer = length;
+                status = SDIO_STATUS_PENDING;
+                break;
+            }
+        }
+    } while (FALSE);
+
+    if (status != SDIO_STATUS_PENDING) {
+            /* call callback */
+        pDevice->OSInfo.pTransferCompletion(pDevice->OSInfo.TransferContext, status, TRUE);
+    }
+
+}
+
+
+void DumpDMASettings(PSDHCD_DEVICE pDevice, BOOL TX)
+{
+    int channel = TX ? pDevice->OSInfo.DmaTxChannel : pDevice->OSInfo.DmaRxChannel;
+
+    DBG_PRINT(SDDBG_TRACE, ("OMAP DMA Reg Dump (%s) Channel:0x%X, DMAREQ:%d \n",
+             TX ? "Transmit":"Receive", channel,
+             TX ? pDevice->OSInfo.DmaTxId:pDevice->OSInfo.DmaRxId));
+    DBG_PRINT(SDDBG_TRACE, ("  CCR       : 0x%X \n",_READ_DWORD_REG(OMAP_DMA4_CCR_REG(channel))));
+    DBG_PRINT(SDDBG_TRACE, ("  CLNK_CTRL : 0x%X \n",_READ_DWORD_REG(OMAP_DMA4_CLNK_CTRL_REG(channel))));
+    DBG_PRINT(SDDBG_TRACE, ("  CICR      : 0x%X \n",_READ_DWORD_REG(OMAP_DMA4_CICR_REG(channel))));
+    DBG_PRINT(SDDBG_TRACE, ("  CSR       : 0x%X \n", _READ_DWORD_REG(OMAP_DMA4_CSR_REG(channel))));
+    DBG_PRINT(SDDBG_TRACE, ("  CSDP      : 0x%X \n",_READ_DWORD_REG(OMAP_DMA4_CSDP_REG(channel))));
+    DBG_PRINT(SDDBG_TRACE, ("  CEN       : 0x%X \n", _READ_DWORD_REG(OMAP_DMA4_CEN_REG(channel))));
+    DBG_PRINT(SDDBG_TRACE, ("  CFN       : 0x%X \n", _READ_DWORD_REG(OMAP_DMA4_CFN_REG(channel))));
+    DBG_PRINT(SDDBG_TRACE, ("  CSSA      : 0x%X \n",_READ_DWORD_REG(OMAP_DMA4_CSSA_REG(channel))));
+    DBG_PRINT(SDDBG_TRACE, ("  CDSA      : 0x%X \n",_READ_DWORD_REG(OMAP_DMA4_CDSA_REG(channel))));
+    DBG_PRINT(SDDBG_TRACE, ("  CSEI      : 0x%X \n", _READ_DWORD_REG(OMAP_DMA4_CSEI_REG(channel))));
+    DBG_PRINT(SDDBG_TRACE, ("  CSFI      : 0x%X \n", _READ_DWORD_REG(OMAP_DMA4_CSFI_REG(channel))));
+    DBG_PRINT(SDDBG_TRACE, ("  CDEI      : 0x%X \n", _READ_DWORD_REG(OMAP_DMA4_CDEI_REG(channel))));
+    DBG_PRINT(SDDBG_TRACE, ("  CDFI      : 0x%X \n", _READ_DWORD_REG(OMAP_DMA4_CDFI_REG(channel))));
+    DBG_PRINT(SDDBG_TRACE, ("  CSAC      : 0x%X \n", _READ_DWORD_REG(OMAP_DMA4_CSAC_REG(channel))));
+    DBG_PRINT(SDDBG_TRACE, ("  CDAC      : 0x%X \n", _READ_DWORD_REG(OMAP_DMA4_CDAC_REG(channel))));
+    DBG_PRINT(SDDBG_TRACE, ("  CCEN     : 0x%X \n", _READ_DWORD_REG(OMAP_DMA4_CCEN_REG(channel))));
+    DBG_PRINT(SDDBG_TRACE, ("  CCFN      : 0x%X \n", _READ_DWORD_REG(OMAP_DMA4_CCFN_REG(channel))));
+
+}
+
+#define FIFO_SYNC_BLOCK_SIZE (OMAP_MMC_FIFO_SIZE/2)  /* sync set to 1/2 full/empty*/
+
+/* setup DMA for transfer */
+static void setupOmapDma(PSDHCD_DEVICE pDevice,
+                         int           Length,
+                         DMA_ADDRESS   SystemAddress,
+                         BOOL          RX)
+{
+    INT  fifoLen;
+    INT  cen,cfn;
+    int channel = RX ? pDevice->OSInfo.DmaRxChannel : pDevice->OSInfo.DmaTxChannel;
+    BOOL burstEnable = FALSE;
+    UINT32 csdp;
+
+    UINT32 address = pDevice->OSInfo.Address.Raw + OMAP_REG_MMC_DATA_ACCESS;
+
+    if (Length == (FIFO_SYNC_BLOCK_SIZE * (Length/FIFO_SYNC_BLOCK_SIZE))) {
+            /* multiple of fifo synch size */
+        cen = FIFO_SYNC_BLOCK_SIZE>>1;
+        cfn = (Length/FIFO_SYNC_BLOCK_SIZE);
+        fifoLen = 0xF; /* threshold set to 32 bytes which is half way on the FIFOs */
+            /* enable bursting since we are nicely divisible by a FIFO size */
+        burstEnable = TRUE;
+    } else {
+        if (Length < FIFO_SYNC_BLOCK_SIZE) {
+            cen = Length>>1;
+            cfn = 1;
+            fifoLen = (Length>>1)-1;
+            fifoLen = (fifoLen < 0) ? 0 : fifoLen;
+        } else {
+            if (Length == (8 * (Length/8))) {
+                cen = 1;
+                cfn = (Length+1)>>1;
+                fifoLen = 0;
+            } else {
+                cen = 1;
+                cfn = (Length+1)>>1;
+                fifoLen = 0;
+            }
+        }
+    }
+
+    omap_set_dma_transfer_params(channel,
+                                 OMAP_DMA_DATA_TYPE_S16,
+                                 cen,
+                                 cfn,
+                                 OMAP_DMA_SYNC_BLOCK,
+                                 RX ? pDevice->OSInfo.DmaRxId : pDevice->OSInfo.DmaTxId,
+                                 RX ? TRUE : FALSE);
+
+
+    if (RX) {
+        omap_set_dma_src_params(channel,
+                                OMAP_DMA_AMODE_CONSTANT,
+                                (int)address,
+                                0,
+                                0);
+
+        omap_set_dma_dest_params(channel,
+                                 OMAP_DMA_AMODE_POST_INC,
+                                 SystemAddress,
+                                 0,
+                                 0);
+    } else {
+
+            /* source is system memory */
+        omap_set_dma_src_params(channel,
+                                OMAP_DMA_AMODE_POST_INC,
+                                (int)SystemAddress,
+                                0,
+                                0);
+
+        omap_set_dma_dest_params(channel,
+                                OMAP_DMA_AMODE_CONSTANT,
+                                (int)address,
+                                0,
+                                0);
+    }
+
+    DBG_PRINT(OMAP_TRACE_DATA, ("OMAP DMA channel sync ID: %d \n",
+             (RX) ? pDevice->OSInfo.DmaRxId : pDevice->OSInfo.DmaTxId));
+
+
+    if (DBG_GET_DEBUG_LEVEL() >= OMAP_TRACE_DMA_DUMP) {
+        DumpDMASettings(pDevice, RX ? FALSE:TRUE);
+    }
+
+    csdp = readl(OMAP_DMA4_CSDP_REG(channel));
+        /* clear previous burst settings */
+    csdp &= ~((0x3 << 7) | (0x3 << 14) | (1 << 13) | (1 << 6));
+
+    if (burstEnable) {
+        csdp |= (0x2 << 7) | (0x2 << 14) | (1 << 13) | (1 << 6); /* 32 byte burst enable */
+    }
+
+    writel(csdp, OMAP_DMA4_CSDP_REG(channel));
+
+    if (RX) {
+        WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_BUFFER_CONFIG, OMAP_REG_MMC_BUFFER_CONFIG_RXDE |
+                        ((fifoLen << OMAP_REG_MMC_BUFFER_CONFIG_AFL_SHIFT) & OMAP_REG_MMC_BUFFER_CONFIG_AFL_MASK));
+    } else {
+        WRITE_HOST_REG16(pDevice, OMAP_REG_MMC_BUFFER_CONFIG, OMAP_REG_MMC_BUFFER_CONFIG_TXDE |
+                        ((fifoLen << OMAP_REG_MMC_BUFFER_CONFIG_AEL_SHIFT) & OMAP_REG_MMC_BUFFER_CONFIG_AEL_MASK));
+    }
+        /* start */
+    omap_start_dma(channel);
+}
+
+SDIO_STATUS CheckDMA(PSDHCD_DEVICE pDevice,
+                     PSDREQUEST    pReq)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+
+    do {
+
+        if ((OMAP_DMA_COMMON == pDevice->DmaMode) &&
+            (pReq->DataRemaining & 0x1)) {
+                /* DMA requires WORD alignment, tell caller to punt it to PIO mode */
+            status = SDIO_STATUS_UNSUPPORTED;
+            break;
+        }
+
+        if (OMAP_DMA_SG == pDevice->DmaMode) {
+                /* doing direct DMA */
+            if  (pReq->DescriptorCount > 1) {
+                DBG_ASSERT(FALSE);
+                status = SDIO_STATUS_INVALID_PARAMETER;
+                break;
+            }
+        }
+    } while (FALSE);
+
+    return status;
+}
+
+SDIO_STATUS SetUpHCDDMA(PSDHCD_DEVICE            pDevice,
+                        PSDREQUEST               pReq,
+                        PDMA_TRANSFER_COMPLETION pCompletion,
+                        PVOID                    pContext)
+{
+    SDIO_STATUS status = SDIO_STATUS_PENDING;
+    UINT32 length = pReq->DataRemaining;
+    PSDDMA_DESCRIPTOR pDesc = NULL;
+
+    DBG_PRINT(OMAP_TRACE_DATA,
+        ("+SDIO OMAP SetUpHCDDMA: length: %d\n",length));
+
+    do {
+
+        pDevice->OSInfo.pTransferCompletion = pCompletion;
+        pDevice->OSInfo.TransferContext = pContext;
+
+        if (OMAP_DMA_COMMON == pDevice->DmaMode) {
+            if (IS_SDREQ_WRITE_DATA(pReq->Flags)) {
+                SetupTXCommonBufferDMATransfer(pDevice,pReq);
+            } else {
+                length = min(pDevice->OSInfo.CommonBufferSize,
+                             pReq->DataRemaining);
+                setupOmapDma(pDevice, length, pDevice->OSInfo.hDmaBuffer,TRUE);
+                pDevice->OSInfo.LastTransfer = length;
+            }
+            break;
+        }
+
+            /* setup scatter gather */
+        DBG_ASSERT(pDesc != NULL);
+            /* map DMA */
+        dma_map_sg(pDevice->Hcd.pDevice,
+                   pDesc,
+                   pReq->DescriptorCount,
+                   IS_SDREQ_WRITE_DATA(pReq->Flags) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+
+        pDevice->OSInfo.pDmaList = pDesc;
+        pDevice->OSInfo.SGcount = pReq->DescriptorCount;
+        DBG_PRINT(OMAP_TRACE_DATA,
+          ("SDIO OMAP SetUpHCDDMA, Direct DMA  dma_address:0x%X\n", (UINT32)sg_dma_address(pDesc)));
+
+        setupOmapDma(pDevice,
+                     length,
+                     sg_dma_address(pDesc),
+                     IS_SDREQ_WRITE_DATA(pReq->Flags) ? FALSE : TRUE);
+
+    } while (FALSE);
+
+    DBG_PRINT(OMAP_TRACE_DATA,
+        ("-SDIO OMAP SetUpHCDDMA: status %d\n",status));
+
+    return status;
+}
+
+/*
+ * SDCancelTransfer - stop DMA transfer
+*/
+void SDCancelDMATransfer(PSDHCD_DEVICE pDevice)
+{
+    DBG_PRINT(OMAP_TRACE_DATA, ("SDIO OMAP SDCancelDMATransfer\n"));
+    if (pDevice->OSInfo.DmaRxChannel != -1) {
+        omap_stop_dma(pDevice->OSInfo.DmaRxChannel);
+    }
+    if (pDevice->OSInfo.DmaTxChannel != -1) {
+        omap_stop_dma(pDevice->OSInfo.DmaTxChannel);
+    }
+}
+
+/* SDIO interrupt request */
+static irqreturn_t hcd_sdio_irq(int irq, void *context, struct pt_regs * r)
+{
+    irqreturn_t retStat;
+
+    DBG_PRINT(OMAP_TRACE_MMC_INT, ("SDIO OMAP SDIO IRQ \n"));
+
+        /* call OS independent ISR */
+    if (HcdSDInterrupt((PSDHCD_DEVICE)context)) {
+        retStat = IRQ_HANDLED;
+    } else {
+        retStat = IRQ_NONE;
+    }
+    return retStat;
+}
Index: linux-2.6/drivers/sdio/hcd/omap2420/sdio_omap_hcd.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/hcd/omap2420/sdio_omap_hcd.h
@@ -0,0 +1,371 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdio_pmap_hcd.h
+
+@abstract: include file for OMAP native MMC/SD host controller, OS independent code
+
+@notice: Copyright (c), 2004-2006 Atheros Communications, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions o this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (Simplified
+ *   Specification) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#ifndef __SDIO_OMAP_HCD_H___
+#define __SDIO_OMAP_HCD_H___
+
+#include <linux/sdio/ctsystem.h>
+
+#include <linux/sdio/sdio_busdriver.h>
+#include <linux/sdio/_sdio_defs.h>
+#include <linux/sdio/sdio_lib.h>
+#include "sdio_hcd_linux.h"
+
+enum OMAP_TRACE_ENUM {
+    OMAP_TRACE_CARD_INSERT = (SDDBG_TRACE + 1),
+    OMAP_TRACE_SDIO_INT = (SDDBG_TRACE + 2),
+    OMAP_TRACE_WORK,
+    OMAP_TRACE_REQUESTS,
+    OMAP_TRACE_DATA,
+    OMAP_TRACE_DMA_DUMP,
+    OMAP_TRACE_CONFIG,
+    OMAP_TRACE_MMC_INT,
+    OMAP_TRACE_CLOCK,
+    OMAP_TRACE_LAST
+};
+
+#define OMAP_TRACE_BUSY  OMAP_TRACE_DATA
+
+#define OMAP_MAX_BYTES_PER_BLOCK  2048
+#define OMAP_MAX_BLOCKS           2048
+#define OMAP_DEFAULT_CURRENT      500
+#define OMAP_DEFAULT_CMD_TIMEOUT  64
+#define OMAP_DEFAULT_DATA_TIMEOUT 400000
+
+#define OMAP_MMC_FIFO_SIZE           64
+/* almost full, for RX */
+#define OMAP_MMC_AFL_FIFO_THRESH     32 //62
+ /* almost empty, for TX */
+#define OMAP_MMC_AEL_FIFO_THRESH     32 // 2
+#define OMAP_MAX_SHORT_TRANSFER_SIZE 16
+
+#define OMAP_REG_MMC_CMD                    0x00
+    #define OMAP_REG_MMC_CMD_DDIR_READ           (1<<15)
+    #define OMAP_REG_MMC_CMD_DDIR_WRITE          (0)
+    #define OMAP_REG_MMC_CMD_STREAM_MODE_NORMAL  (0)
+    #define OMAP_REG_MMC_CMD_TYPE_BC             (0)
+    #define OMAP_REG_MMC_CMD_TYPE_BCR            (1<<12)
+    #define OMAP_REG_MMC_CMD_TYPE_AC             (2<<12)
+    #define OMAP_REG_MMC_CMD_TYPE_ADTC           (3<<12)
+    #define OMAP_REG_MMC_CMD_R1BUSY              (1<<11)
+    #define OMAP_REG_MMC_CMD_NORESPONSE          (0)
+    #define OMAP_REG_MMC_CMD_R1                  (1<<8)
+    #define OMAP_REG_MMC_CMD_R2                  (2<<8)
+    #define OMAP_REG_MMC_CMD_R3                  (3<<8)
+    #define OMAP_REG_MMC_CMD_R4                  (4<<8)
+    #define OMAP_REG_MMC_CMD_R5                  (5<<8)
+    #define OMAP_REG_MMC_CMD_R6                  (6<<8)
+    #define OMAP_REG_MMC_CMD_INAB                (1<<7)
+    #define OMAP_REG_MMC_CMD_CTO_DTO             (1<<6)
+    #define OMAP_REG_MMC_CMD_MASK                (0x3F)
+
+
+#define OMAP_REG_MMC_ARG_LOW                0x04
+#define OMAP_REG_MMC_ARG_HI                 0x08
+
+#define OMAP_REG_MMC_MODULE_CONFIG          0x0C
+    #define OMAP_REG_MMC_MODULE_CONFIG_4BIT      (1<<15)
+    #define OMAP_REG_MMC_MODULE_CONFIG_MODE_MMCSD (0<<12)
+    #define OMAP_REG_MMC_MODULE_CONFIG_MODE_SPI  (1<<12)
+    #define OMAP_REG_MMC_MODULE_CONFIG_MODE_TEST (2<<12)
+    #define OMAP_REG_MMC_MODULE_CONFIG_PWRON     (1<<11)
+    #define OMAP_REG_MMC_MODULE_CONFIGE_BE       (1<<10)
+    #define OMAP_REG_MMC_MODULE_CONFIG_CLK_MASK  (0x3FF)
+
+#define OMAP_REG_MMC_MODULE_STATUS          0x10
+    #define OMAP_REG_MMC_MODULE_STATUS_CERR      (1<<14)
+    #define OMAP_REG_MMC_MODULE_STATUS_CIRQ      (1<<13)
+    #define OMAP_REG_MMC_MODULE_STATUS_OCRB      (1<<12)
+    #define OMAP_REG_MMC_MODULE_STATUS_AE        (1<<11)
+    #define OMAP_REG_MMC_MODULE_STATUS_AF        (1<<10)
+    #define OMAP_REG_MMC_MODULE_STATUS_CRW       (1<<9)
+    #define OMAP_REG_MMC_MODULE_STATUS_CCRC      (1<<8)
+    #define OMAP_REG_MMC_MODULE_STATUS_CTO       (1<<7)
+    #define OMAP_REG_MMC_MODULE_STATUS_DCRC      (1<<6)
+    #define OMAP_REG_MMC_MODULE_STATUS_DTO       (1<<5)
+    #define OMAP_REG_MMC_MODULE_STATUS_EOFB      (1<<4)
+    #define OMAP_REG_MMC_MODULE_STATUS_BRS       (1<<3)
+    #define OMAP_REG_MMC_MODULE_STATUS_CB        (1<<2)
+    #define OMAP_REG_MMC_MODULE_STATUS_CD        (1<<1)
+    #define OMAP_REG_MMC_MODULE_STATUS_EOC       (1<<0)
+    #define OMAP_REG_MMC_MODULE_STATUS_ALL       (0x7FFF)
+    #define OMAP_REG_MMC_MODULE_STATUS_REQ_PROCESS \
+          ((~(OMAP_REG_MMC_MODULE_STATUS_CIRQ | OMAP_REG_MMC_MODULE_STATUS_CD\
+             )) & OMAP_REG_MMC_MODULE_STATUS_ALL)
+    #define OMAP_STATUS_CMD_PROCESSING_ERRORS \
+            (OMAP_REG_MMC_MODULE_STATUS_CERR | OMAP_REG_MMC_MODULE_STATUS_CTO | \
+            OMAP_REG_MMC_MODULE_STATUS_CCRC)
+    #define OMAP_STATUS_DATA_PROCESSING_ERRORS \
+            (OMAP_REG_MMC_MODULE_STATUS_DCRC | OMAP_REG_MMC_MODULE_STATUS_DTO)
+
+#define OMAP_REG_MMC_INTERRUPT_ENABLE       0x14
+    #define OMAP_REG_MMC_INTERRUPT_ENABLE_CERR   (1<<14)
+    #define OMAP_REG_MMC_INTERRUPT_ENABLE_CIRQ   (1<<13)
+    #define OMAP_REG_MMC_INTERRUPT_ENABLE_OCRB   (1<<12)
+    #define OMAP_REG_MMC_INTERRUPT_ENABLE_AE     (1<<11)
+    #define OMAP_REG_MMC_INTERRUPT_ENABLE_AF     (1<<10)
+    #define OMAP_REG_MMC_INTERRUPT_ENABLE_CRW    (1<<9)
+    #define OMAP_REG_MMC_INTERRUPT_ENABLE_CCRC   (1<<8)
+    #define OMAP_REG_MMC_INTERRUPT_ENABLE_CTO    (1<<7)
+    #define OMAP_REG_MMC_INTERRUPT_ENABLE_DCRC   (1<<6)
+    #define OMAP_REG_MMC_INTERRUPT_ENABLE_DTO    (1<<5)
+    #define OMAP_REG_MMC_INTERRUPT_ENABLE_EOFB   (1<<4)
+    #define OMAP_REG_MMC_INTERRUPT_ENABLE_BRS    (1<<3)
+    #define OMAP_REG_MMC_INTERRUPT_ENABLE_CB     (1<<2)
+    #define OMAP_REG_MMC_INTERRUPT_ENABLE_CD     (1<<1)
+    #define OMAP_REG_MMC_INTERRUPT_ENABLE_EOC    (1<<0)
+    #define OMAP_REG_MMC_INTERRUPT_ALL_INT       (0x7FFF)
+    #define OMAP_REG_MMC_INTERRUPT_NONE_INT      (0)
+    #define OMAP_REG_MMC_INTERRUPT_ERRORS        (OMAP_REG_MMC_INTERRUPT_ENABLE_CCRC | \
+                                                  OMAP_REG_MMC_INTERRUPT_ENABLE_CTO  | \
+                                                  OMAP_REG_MMC_INTERRUPT_ENABLE_DCRC | \
+                                                  OMAP_REG_MMC_INTERRUPT_ENABLE_DTO  | \
+                                                  OMAP_REG_MMC_INTERRUPT_ENABLE_CERR)
+    #define OMAP_REG_MMC_INTERRUPT_REQUESTS  (OMAP_REG_MMC_INTERRUPT_ERRORS | \
+                                              OMAP_REG_MMC_INTERRUPT_ENABLE_EOC | \
+                                              OMAP_REG_MMC_INTERRUPT_ENABLE_AF | \
+                                              OMAP_REG_MMC_INTERRUPT_ENABLE_AE | \
+                                              OMAP_REG_MMC_INTERRUPT_ENABLE_EOFB )
+
+#define OMAP_REG_MMC_CMD_TIMEOUT            0x18
+    /* low 8-bit valid */
+
+#define OMAP_REG_MMC_DATA_READ_TIMEOUT      0x1C
+    /* 16-bit */
+
+#define OMAP_REG_MMC_DATA_ACCESS            0x20
+    /* 16-bit */
+
+#define OMAP_REG_MMC_BLOCK_LENGTH           0x24
+    /* low 11-bit */
+
+#define OMAP_REG_MMC_BLOCK_COUNT            0x28
+    /* low 11-bit */
+
+#define OMAP_REG_MMC_BUFFER_CONFIG          0x2C
+    #define OMAP_REG_MMC_BUFFER_CONFIG_RXDE      (1<<15)
+    #define OMAP_REG_MMC_BUFFER_CONFIG_AFL_MASK  (0x1F00)
+    #define OMAP_REG_MMC_BUFFER_CONFIG_AFL_SHIFT (8)
+    #define OMAP_REG_MMC_BUFFER_CONFIG_TXDE      (1<<7)
+    #define OMAP_REG_MMC_BUFFER_CONFIG_AEL_MASK  (0x1F)
+    #define OMAP_REG_MMC_BUFFER_CONFIG_AEL_SHIFT (0)
+
+#define OMAP_REG_MMC_SPI_CONFIG             0x30
+    #define OMAP_REG_MMC_SPI_CONFIG_STR          (1<<15)
+    #define OMAP_REG_MMC_SPI_CONFIG_WNR          (1<<14)
+    #define OMAP_REG_MMC_SPI_CONFIG_SODV         (1<<13)
+    #define OMAP_REG_MMC_SPI_CONFIG_CSTR         (1<<12)
+    #define OMAP_REG_MMC_SPI_CONFIG_CSHOLD05     (0)
+    #define OMAP_REG_MMC_SPI_CONFIG_CSHOLD15     (1<<10)
+    #define OMAP_REG_MMC_SPI_CONFIG_CSHOLD25     (2<<10)
+    #define OMAP_REG_MMC_SPI_CONFIG_CSHOLD35     (3<<10)
+    #define OMAP_REG_MMC_SPI_CONFIG_TCSS1        (0)
+    #define OMAP_REG_MMC_SPI_CONFIG_TCSS2        (1<<8)
+    #define OMAP_REG_MMC_SPI_CONFIG_TCSS3        (2<<8)
+    #define OMAP_REG_MMC_SPI_CONFIG_TCSS4        (3<<8)
+    #define OMAP_REG_MMC_SPI_CONFIG_CSEL         (1<<7)
+    #define OMAP_REG_MMC_SPI_CONFIG_CS1          (0)
+    #define OMAP_REG_MMC_SPI_CONFIG_CS2          (1<<4)
+    #define OMAP_REG_MMC_SPI_CONFIG_CS3          (2<<4)
+    #define OMAP_REG_MMC_SPI_CONFIG_CS4          (3<<4)
+    #define OMAP_REG_MMC_SPI_CONFIG_CSM          (1<<3)
+    #define OMAP_REG_MMC_SPI_CONFIG_CSD          (1<<2)
+    #define OMAP_REG_MMC_SPI_CONFIG_POL_RISE        (0)
+    #define OMAP_REG_MMC_SPI_CONFIG_POL_FALL        (1)
+
+#define OMAP_REG_MMC_SDIO_MODE_CONFIG       0x34
+    #define OMAP_REG_MMC_SDIO_MODE_CONFIG_C5E    (1<<15)
+    #define OMAP_REG_MMC_SDIO_MODE_CONFIG_C14E   (1<<14)
+    #define OMAP_REG_MMC_SDIO_MODE_CONFIG_C13E   (1<<13)
+    #define OMAP_REG_MMC_SDIO_MODE_CONFIG_C12E   (1<<12)
+    #define OMAP_REG_MMC_SDIO_MODE_CONFIG_D3PS   (1<<11)
+    #define OMAP_REG_MMC_SDIO_MODE_CONFIG_D3ES   (1<<10)
+    #define OMAP_REG_MMC_SDIO_MODE_CONFIG_CDWE   (1<<9)
+    #define OMAP_REG_MMC_SDIO_MODE_CONFIG_IWE    (1<<8)
+    #define OMAP_REG_MMC_SDIO_MODE_CONFIG_DCR4   (1<<7)
+    #define OMAP_REG_MMC_SDIO_MODE_CONFIG_XDTS   (1<<6)
+    #define OMAP_REG_MMC_SDIO_MODE_CONFIG_DPE    (1<<5)
+    #define OMAP_REG_MMC_SDIO_MODE_CONFIG_RW     (1<<4)
+    #define OMAP_REG_MMC_SDIO_MODE_CONFIG_CDE    (1<<2)
+    #define OMAP_REG_MMC_SDIO_MODE_CONFIG_RWE    (1<<1)
+    #define OMAP_REG_MMC_SDIO_MODE_CONFIG_IRQE   (1<<0)
+
+#define OMAP_REG_MMC_SYSTEM_TEST            0x38
+    #define OMAP_REG_MMC_SYSTEM_TEST_WAKD        (1<<15)
+    #define OMAP_REG_MMC_SYSTEM_TEST_SSB         (1<<14)
+    #define OMAP_REG_MMC_SYSTEM_TEST_RDYD        (1<<13)
+    #define OMAP_REG_MMC_SYSTEM_TEST_DDIR        (1<<12)
+    #define OMAP_REG_MMC_SYSTEM_TEST_D3D         (1<<11)
+    #define OMAP_REG_MMC_SYSTEM_TEST_D2D         (1<<10)
+    #define OMAP_REG_MMC_SYSTEM_TEST_D1D         (1<<9)
+    #define OMAP_REG_MMC_SYSTEM_TEST_D0D         (1<<8)
+    #define OMAP_REG_MMC_SYSTEM_TEST_CDIR        (1<<7)
+    #define OMAP_REG_MMC_SYSTEM_TEST_CDAT        (1<<6)
+    #define OMAP_REG_MMC_SYSTEM_TEST_MCKD        (1<<5)
+    #define OMAP_REG_MMC_SYSTEM_TEST_SCKD        (1<<4)
+    #define OMAP_REG_MMC_SYSTEM_TEST_CS3D        (1<<3)
+    #define OMAP_REG_MMC_SYSTEM_TEST_CS2D        (1<<2)
+    #define OMAP_REG_MMC_SYSTEM_TEST_CS1D        (1<<1)
+    #define OMAP_REG_MMC_SYSTEM_TEST_CS0D        (1<<0)
+
+
+#define OMAP_REG_MMC_MODULE_REV             0x3C
+    #define OMAP_REG_MMC_MODULE_REV_MINOR_MASK   (0xF)
+    #define OMAP_REG_MMC_MODULE_REV_MINOR_SHIFT  (0)
+    #define OMAP_REG_MMC_MODULE_REV_MAJOR_MASK   (0xF0)
+    #define OMAP_REG_MMC_MODULE_REV_MAJOR_SHIFT  (4)
+
+#define OMAP_REG_MMC_CMD_RESPONSE0          0x40
+    /* response bits 15-0 */
+#define OMAP_REG_MMC_CMD_RESPONSE1          0x44
+    /* response bits 31-16 */
+#define OMAP_REG_MMC_CMD_RESPONSE2          0x48
+    /* response bits 47-32 */
+#define OMAP_REG_MMC_CMD_RESPONSE3          0x4C
+    /* response bits 63-48 */
+#define OMAP_REG_MMC_CMD_RESPONSE4          0x50
+    /* response bits 79-64 */
+#define OMAP_REG_MMC_CMD_RESPONSE5          0x54
+    /* response bits 95-80 */
+#define OMAP_REG_MMC_CMD_RESPONSE6          0x58
+    /* response bits 111-96 */
+#define OMAP_REG_MMC_CMD_RESPONSE7          0x5C
+    /* response bits 127-112 */
+
+#define OMAP_REG_MMC_SUSPEND_RESUME         0x60
+    #define OMAP_REG_MMC_SUSPEND_RESUME_STOP     (1<<3)
+    #define OMAP_REG_MMC_SUSPEND_RESUME_SAVE     (1<<2)
+    #define OMAP_REG_MMC_SUSPEND_RESUME_RESUME   (1<<1)
+    #define OMAP_REG_MMC_SUSPEND_RESUME_SUSPEND  (1<<0)
+
+#define OMAP_REG_MMC_SYSTEM_CONTROL         0x64
+    #define OMAP_REG_MMC_SYSTEM_CONTROL_SW_RESET (1<<1)
+
+#define OMAP_REG_MMC_SYSTEM_STATUS          0x68
+    #define OMAP_REG_MMC_SYSTEM_STATUS_RESET_DONE (1<<0)
+
+
+
+#define SD_DEFAULT_RESPONSE_BYTES 6
+
+
+#define CLOCK_ON  TRUE
+#define CLOCK_OFF FALSE
+
+#define OMAP_MAX_CLOCK_DIVIDE   1023
+
+typedef struct _SD_CLOCK_TBL_ENTRY {
+    INT       ClockRateDivisor;  /* divisor */
+    UINT16    RegisterValue;     /* register value for clock divisor */
+}SD_CLOCK_TBL_ENTRY;
+
+typedef enum _OMAP_DMA_MODE {
+    OMAP_DMA_NONE = 0,
+    OMAP_DMA_COMMON,
+    OMAP_DMA_SG
+}OMAP_DMA_MODE,*POMAP_DMA_MODE;
+
+typedef struct _SDHCD_DEVICE {
+    SDLIST        List;              /* linked list */
+    SDHCD         Hcd;               /* HCD description for bus driver */
+    OMAP_DMA_MODE DmaMode;           /* current DMA mode */
+    BOOL          DmaCapable;        /* os layer supports DMA */
+    UINT16        Clock;             /* current clock bit settings */
+    UINT32        BaseClock;         /* base clock in hz */
+    UINT32        TimeOut;           /* command timeout setting */
+    UINT32        DataTimeOut;       /* data timeout setting */
+    UINT32        ClockSpinLimit;    /* clock limit for command spin loops */
+    BOOL          KeepClockOn;
+    BOOL          IrqDetectArmed;    /* IRQ detect was armed */
+    UINT8         CompletionCount;   /* used to track when both DMA and command complete are done */
+    BOOL          Cancel;
+    BOOL          ShuttingDown;
+    BOOL          ShortTransfer;     /* do short transfer */
+    SDCONFIG_BUS_MODE_DATA SavedBusMode; /* saved bus mode */
+    HCD_OS_INFO   OSInfo;            /* the single device's OS-Specific */
+}SDHCD_DEVICE, *PSDHCD_DEVICE;
+
+/* driver wide data, this driver only supports one device,
+ * so we include the per device data here also */
+typedef struct _SDHCD_DRIVER_CONTEXT {
+    PTEXT        pDescription;       /* human readable device decsription */
+    SDLIST       DeviceList;         /* the list of current devices handled by this driver */
+    OS_SEMAPHORE DeviceListSem;      /* protection for the DeviceList */
+    UINT         DeviceCount;        /* number of devices currently installed */
+    SDHCD_DRIVER Driver;             /* OS dependent driver specific info */
+}SDHCD_DRIVER_CONTEXT, *PSDHCD_DRIVER_CONTEXT;
+
+
+/* prototypes */
+SDIO_STATUS HcdRequest(PSDHCD pHcd);
+SDIO_STATUS HcdConfig(PSDHCD pHcd, PSDCONFIG pReq);
+SDIO_STATUS HcdInitialize(PSDHCD_DEVICE pDeviceContext);
+void HcdDeinitialize(PSDHCD_DEVICE pDeviceContext);
+BOOL HcdSDInterrupt(PSDHCD_DEVICE pDeviceContext);
+BOOL HcdTransferTxData(PSDHCD_DEVICE pDevice, PSDREQUEST pReq);
+BOOL HcdTransferRxData(PSDHCD_DEVICE pDevice, PSDREQUEST pReq, BOOL Flush);
+
+
+/* OS-dependent layer prototypes */
+SDIO_STATUS QueueEventResponse(PSDHCD_DEVICE pDeviceContext, INT WorkItemID);
+UINT16 MaskIrq(PSDHCD_DEVICE pDevice, UINT16 Mask, BOOL FromIsr);
+UINT16 UnmaskIrq(PSDHCD_DEVICE pDevice, UINT16 Mask, BOOL FromIsr);
+SDIO_STATUS SetUpHCDDMA(PSDHCD_DEVICE            pDevice,
+                        PSDREQUEST               pReq,
+                        PDMA_TRANSFER_COMPLETION pCompletion,
+                        PVOID                    pContext);
+BOOL WriteProtectSwitchOn(PSDHCD_DEVICE pDevice);
+void SDCancelDMATransfer(PSDHCD_DEVICE pDevice);
+SDIO_STATUS SetPowerLevel(PSDHCD_DEVICE pDeviceContext, BOOL On, SLOT_VOLTAGE_MASK Level);
+void GetDefaults(PSDHCD_DEVICE pDeviceContext);
+void CompleteRequestSyncDMA(PSDHCD_DEVICE pDeviceContext, PSDREQUEST pRequest, SDIO_STATUS Status);
+void MicroDelay(INT Microseconds);
+SDIO_STATUS CheckDMA(PSDHCD_DEVICE pDevice, PSDREQUEST    pReq);
+#define DBG_GPIO_PIN_1  1
+#define DBG_GPIO_PIN_2  2
+
+#ifdef OMAP_USE_DBG_GPIO
+void ToggleGPIOPin(PSDHCD_DEVICE pDevice, INT PinNo);
+#else
+#define ToggleGPIOPin(p,n)
+#endif
+/* end OS layer prototypes */
+
+#endif /* __SDIO_OMAP_HCD_H___ */
Index: linux-2.6/drivers/sdio/hcd/pci_ellen/Makefile
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/hcd/pci_ellen/Makefile
@@ -0,0 +1,7 @@
+#
+# SDIO pci_ellen host controller makefile
+#
+obj-m += sdio_pciellen_hcd.o
+
+sdio_pciellen_hcd-objs := sdio_hcd.o sdio_hcd_os.o
+
Index: linux-2.6/drivers/sdio/hcd/pci_ellen/sdio_hcd.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/hcd/pci_ellen/sdio_hcd.c
@@ -0,0 +1,1238 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdio_hcd.c
+
+@abstract: Tokyo Electron PCI Ellen SDIO Host Controller Driver
+
+#notes: OS independent code
+
+@notice: Copyright (c), 2004-2005 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#include "sdio_pciellen_hcd.h"
+
+#define CLOCK_ON  TRUE
+#define CLOCK_OFF FALSE
+
+void Dbg_DumpBuffer(PUCHAR pBuffer, INT Length);
+SDIO_STATUS SetPowerLevel(PSDHCD_DEVICE pDeviceContext, BOOL On, SLOT_VOLTAGE_MASK Level);
+
+
+SD_CLOCK_TBL_ENTRY SDClockDivisorTable[SD_CLOCK_MAX_ENTRIES] =
+{   /* clock rate divisor, divisor setting */
+    {1, 0x0000},
+    {2, 0x0100},
+    {4, 0x0200},
+    {8, 0x0400},
+    {16,0x0800},
+    {32,0x1000},
+    {64,0x2000},
+    {128,0x4000},
+    {256,0x8000},
+};
+
+
+#define WAIT_REGISTER32_CHANGE(pDevice, pStatus, reg,mask,cmp,timout) \
+    {\
+        if (!WaitRegisterBitsChange((pDevice),    \
+                                    (pStatus),    \
+                                    (reg),        \
+                                    (mask),       \
+                                    (cmp),        \
+                                    (timout))) {  \
+           DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen - Reg Change Timeout : 0x%X src:%s, line:%d \n",\
+           (reg),__FILE__, __LINE__));        \
+        }                                     \
+    }
+
+#define WAIT_FOR_DAT_CMD_DAT_READY(pDevice, pStatus) \
+        WAIT_REGISTER32_CHANGE(pDevice,            \
+                             pStatus,            \
+                             HOST_REG_PRESENT_STATE,(HOST_REG_PRESENT_STATE_BUFFER_COMMAND_INHIBIT_DAT | \
+                             HOST_REG_PRESENT_STATE_BUFFER_COMMAND_INHIBIT_CMD), \
+                             0, 30000)
+
+
+INLINE BOOL WaitRegisterBitsChange(PSDHCD_DEVICE pDevice,
+                                   SDIO_STATUS   *pStatus,
+                                   UINT32         Reg,
+                                   UINT32         Mask,
+                                   UINT32         CompareMask,
+                                   UINT32         Count)
+{
+    while (Count) {
+
+        if ((READ_HOST_REG32(pDevice, Reg) & Mask) == CompareMask) {
+            break;
+        }
+
+        Count--;
+    }
+
+    if (0 == Count) {
+        if (pStatus != NULL) {
+            *pStatus = SDIO_STATUS_ERROR;
+        }
+        return FALSE;
+    }
+
+    if (pStatus != NULL) {
+        *pStatus = SDIO_STATUS_SUCCESS;
+    }
+
+    return TRUE;
+}
+
+
+/* reset command data line state machines - xx*/
+void ResetCmdDatLine(PSDHCD_DEVICE pDevice)
+{
+    DBG_PRINT(SDDBG_TRACE, ("SDIO PCI Ellen Issuing CMD DAT Reset \n"));
+        // issue reset
+    WRITE_HOST_REG32(pDevice, HOST_REG_SW_RESET,
+            (HOST_REG_SW_RST_CMD_LINE | HOST_REG_SW_RST_DAT_LINE));
+        // wait for bits to clear
+    WAIT_REGISTER32_CHANGE(pDevice, NULL,
+                         HOST_REG_SW_RESET,
+                         HOST_REG_SW_RST_CMD_LINE | HOST_REG_SW_RST_DAT_LINE,
+                         0,
+                         30000);
+    DBG_PRINT(SDDBG_TRACE, ("SDIO PCI Ellen CMD DAT Reset Done \n"));
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  GetResponseData - get the response data
+  Input:    pDevice - device context
+            pReq - the request
+  Output:
+  Return: returns status
+  Notes: This function returns SDIO_STATUS_SUCCESS for SD mode.
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS GetResponseData(PSDHCD_DEVICE pDevice, PSDREQUEST pReq)
+{
+    INT     dwordCount;
+    INT     byteCount;
+    UINT32  readBuffer[4];
+    UINT    ii;
+
+    if (GET_SDREQ_RESP_TYPE(pReq->Flags) == SDREQ_FLAGS_NO_RESP) {
+        return SDIO_STATUS_SUCCESS;
+    }
+
+
+    byteCount = SD_DEFAULT_RESPONSE_BYTES;
+    if (GET_SDREQ_RESP_TYPE(pReq->Flags) == SDREQ_FLAGS_RESP_R2) {
+        byteCount = SD_R2_RESPONSE_BYTES;
+    }
+    dwordCount = (byteCount + 3) / 4;
+
+    /* move data into read buffer */
+    for (ii = 0; ii < dwordCount; ii++) {
+        readBuffer[ii] = READ_HOST_REG32(pDevice, HOST_REG_RESPONSE+(ii*4));
+    }
+
+    /* handle normal SD/MMC responses */
+
+    /* the standard host strips the CRC for all responses and puts them in
+     * a nice linear order */
+    memcpy(&pReq->Response[1],readBuffer,byteCount);
+
+    if (DBG_GET_DEBUG_LEVEL() >= PXA_TRACE_REQUESTS) {
+        if (GET_SDREQ_RESP_TYPE(pReq->Flags) == SDREQ_FLAGS_RESP_R2) {
+            byteCount = 17;
+        }
+        SDLIB_PrintBuffer(pReq->Response,byteCount,"SDIO PCI Ellen - Response Dump");
+    }
+
+    return SDIO_STATUS_SUCCESS;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  DumpCurrentRequestInfo - debug dump
+  Input:    pDevice - device context
+  Output:
+  Return:
+  Notes: This function debug prints the current request
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void DumpCurrentRequestInfo(PSDHCD_DEVICE pDevice)
+{
+    if (pDevice->Hcd.pCurrentRequest != NULL) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen - Current Request Command:%d, ARG:0x%8.8X\n",
+                  pDevice->Hcd.pCurrentRequest->Command, pDevice->Hcd.pCurrentRequest->Argument));
+        if (IS_SDREQ_DATA_TRANS(pDevice->Hcd.pCurrentRequest->Flags)) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen - Data %s, Blocks: %d, BlockLen:%d Remaining: %d \n",
+                      IS_SDREQ_WRITE_DATA(pDevice->Hcd.pCurrentRequest->Flags) ? "WRITE":"READ",
+                      pDevice->Hcd.pCurrentRequest->BlockCount,
+                      pDevice->Hcd.pCurrentRequest->BlockLen,
+                      pDevice->Hcd.pCurrentRequest->DataRemaining));
+        }
+    }
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  TranslateSDError - check for an SD error
+  Input:    pDevice - device context
+            Status -  error interrupt status register value
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS TranslateSDError(PSDHCD_DEVICE pDevice, UINT16 Status)
+{
+    if (Status & HOST_REG_ERROR_INT_STATUS_CRCERR) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen - RESP CRC ERROR \n"));
+        return SDIO_STATUS_BUS_RESP_CRC_ERR;
+    } else if (Status & HOST_REG_ERROR_INT_STATUS_DATATIMEOUTERR) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen - DATA TIMEOUT ERROR \n"));
+        return SDIO_STATUS_BUS_READ_TIMEOUT;
+    } else if (Status & HOST_REG_ERROR_INT_STATUS_DATACRCERR) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen - READDATA CRC ERROR \n"));
+        DumpCurrentRequestInfo(pDevice);
+        return SDIO_STATUS_BUS_READ_CRC_ERR;
+    } else if (Status & HOST_REG_ERROR_INT_STATUS_CMDTIMEOUTERR) {
+        if (pDevice->CardInserted) {
+                /* hide error if we are polling an empty slot */
+            DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen - RESPONSE TIMEOUT \n"));
+        }
+        return SDIO_STATUS_BUS_RESP_TIMEOUT;
+    }
+    DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen - untranslated error 0x%X\n", (UINT)Status));
+
+    return SDIO_STATUS_DEVICE_ERROR;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  ClockStartStop - SD clock control
+  Input:  pDevice - device object
+          On - turn on or off (TRUE/FALSE)
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void ClockStartStop(PSDHCD_DEVICE pDevice, BOOL On)
+{
+    /* beware, an unprotected read-modify-write */
+    UINT16 state;
+
+    DBG_PRINT(PXA_TRACE_CLOCK, ("SDIO PCI Ellen - ClockStartStop, %d\n", (UINT)On));
+
+    state = READ_HOST_REG16(pDevice, HOST_REG_CLOCK_CONTROL);
+
+    if (On) {
+        state |= HOST_REG_CLOCK_CONTROL_SD_ENABLE;
+        WRITE_HOST_REG16(pDevice, HOST_REG_CLOCK_CONTROL, state);
+    } else {
+        state &= ~HOST_REG_CLOCK_CONTROL_SD_ENABLE;
+        WRITE_HOST_REG16(pDevice, HOST_REG_CLOCK_CONTROL, state);
+    }
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  SetBusMode - Set Bus mode
+  Input:  pDevice - device object
+          pMode - mode
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void SetBusMode(PSDHCD_DEVICE pDevice, PSDCONFIG_BUS_MODE_DATA pMode)
+{
+    int ii;
+    int clockIndex;
+    UINT16 state;
+    UINT32 rate;
+
+    DBG_PRINT(PXA_TRACE_CONFIG , ("SDIO PCI Ellen - SetMode\n"));
+
+        /* set clock index to the end, the table is sorted this way */
+    clockIndex = SD_CLOCK_MAX_ENTRIES - 1;
+    pMode->ActualClockRate = (pDevice->BaseClock) / SDClockDivisorTable[clockIndex].ClockRateDivisor;
+    for (ii = 0; ii < SD_CLOCK_MAX_ENTRIES; ii++) {
+        rate = pDevice->BaseClock / SDClockDivisorTable[ii].ClockRateDivisor;
+        if (pMode->ClockRate >= rate) {
+            pMode->ActualClockRate = rate;
+            clockIndex = ii;
+            break;
+        }
+    }
+
+    switch (SDCONFIG_GET_BUSWIDTH(pMode->BusModeFlags)) {
+        case SDCONFIG_BUS_WIDTH_1_BIT:
+            WRITE_HOST_REG8(pDevice, HOST_REG_CONTROL, HOST_REG_CONTROL_1BIT_WIDTH);
+            //WRITE_HOST_REG16(pDevice, HOST_REG_CONTROL, HOST_REG_CONTROL_1BIT_WIDTH);
+            break;
+        case SDCONFIG_BUS_WIDTH_4_BIT:
+            WRITE_HOST_REG8(pDevice, HOST_REG_CONTROL, HOST_REG_CONTROL_4BIT_WIDTH);
+            //WRITE_HOST_REG16(pDevice, HOST_REG_CONTROL, HOST_REG_CONTROL_4BIT_WIDTH);
+            break;
+        default:
+            break;
+    }
+
+        /* set the clock divisor, unprotected read modify write */
+    state = SDClockDivisorTable[clockIndex].RegisterValue | HOST_REG_CLOCK_CONTROL_CLOCK_ENABLE;
+    WRITE_HOST_REG16(pDevice, HOST_REG_CLOCK_CONTROL, state);
+
+        /* wait for stable */
+    while(!(READ_HOST_REG16(pDevice, HOST_REG_CLOCK_CONTROL) & HOST_REG_CLOCK_CONTROL_CLOCK_STABLE)) {
+      ;
+    }
+    WRITE_HOST_REG16(pDevice, HOST_REG_CLOCK_CONTROL, state | HOST_REG_CLOCK_CONTROL_SD_ENABLE);
+
+    state = READ_HOST_REG16(pDevice, HOST_REG_CLOCK_CONTROL);
+    DBG_PRINT(PXA_TRACE_CONFIG , ("SDIO PCI Ellen - Clock: %d Khz, ClockRate %d (%d) state:0x%X\n",
+                                   pMode->ActualClockRate, pMode->ClockRate, clockIndex, (UINT)state));
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  HcdTransferTxData - data transmit transfer
+  Input:  pDevice - device object
+          pReq    - transfer request
+  Output:
+  Return:
+  Notes: writes request data
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+BOOL HcdTransferTxData(PSDHCD_DEVICE pDevice, PSDREQUEST pReq)
+{
+    INT     dataCopy;
+    PUINT8  pBuf;
+
+    dataCopy = min(pReq->DataRemaining, (UINT)pReq->BlockLen);
+    pBuf = (PUINT8)pReq->pHcdContext;
+
+    /* update remaining count */
+    pReq->DataRemaining -= dataCopy;
+    /* set the block data */
+    while(dataCopy) {
+        UINT32 outData = 0;
+        UINT   count = 0;
+        if (dataCopy > 4) {
+            outData = ((UINT32)(*(pBuf+0))) |
+                      (((UINT32)(*(pBuf+1))) << 8) |
+                      (((UINT32)(*(pBuf+2))) << 16) |
+                      (((UINT32)(*(pBuf+3))) << 24);
+            WRITE_HOST_REG32(pDevice, HOST_REG_BUFFER_DATA_PORT, outData);
+            dataCopy -= 4;
+            pBuf += 4;
+        } else {
+            for(count = 0; (dataCopy > 0) && (count < 4); count++) {
+               outData |= (*pBuf) << (count*8);
+               pBuf++;
+               dataCopy--;
+            }
+            WRITE_HOST_REG32(pDevice, HOST_REG_BUFFER_DATA_PORT, outData);
+        }
+    }
+
+        /* update pointer position */
+    pReq->pHcdContext = (PVOID)pBuf;
+    if (pReq->DataRemaining) {
+        return FALSE;
+    }
+    return TRUE;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  HcdTransferRxData - data receive transfer
+  Input:  pDevice - device object
+          pReq    - transfer request
+  Output:
+  Return:
+  Notes: reads request data
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void HcdTransferRxData(PSDHCD_DEVICE pDevice, PSDREQUEST pReq)
+{
+    INT     dataCopy;
+    PUINT8  pBuf;
+
+    dataCopy = min(pReq->DataRemaining, (UINT)pReq->BlockLen);
+    pBuf = (PUINT8)pReq->pHcdContext;
+
+    /* update remaining count */
+    pReq->DataRemaining -= dataCopy;
+    /* set the block data */
+    while(dataCopy) {
+        UINT32 inData;
+        UINT   count = 0;
+        inData = READ_HOST_REG32(pDevice, HOST_REG_BUFFER_DATA_PORT);
+        for(count = 0; (dataCopy > 0) && (count < 4); count++) {
+            *pBuf = (inData >> (count*8)) & 0xFF;
+            dataCopy--;
+            pBuf++;
+        }
+    }
+
+        /* update pointer position */
+    pReq->pHcdContext = (PVOID)pBuf;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  HcdRequest - SD request handler
+  Input:  pHcd - HCD object
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS HcdRequest(PSDHCD pHcd)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    PSDHCD_DEVICE pDevice = (PSDHCD_DEVICE)pHcd->pContext;
+    UINT16                temp;
+    UINT16                ints;
+    PSDREQUEST            pReq;
+
+    pReq = GET_CURRENT_REQUEST(pHcd);
+    DBG_ASSERT(pReq != NULL);
+        /* make sure clock is off */
+    ClockStartStop(pDevice, CLOCK_OFF);
+
+    if(pDevice->ShuttingDown) {
+        DBG_PRINT(PXA_TRACE_REQUESTS, ("SDIO PCI Ellen HcdRequest returning canceled\n"));
+        return SDIO_STATUS_CANCELED;
+    }
+    /* make sure error ints are disabled */
+    WRITE_HOST_REG16(pDevice, HOST_REG_INT_ERR_SIGNAL_ENABLE,
+                (UINT16)(~HOST_REG_ERROR_INT_STATUS_ALL_ERR));
+
+    switch (GET_SDREQ_RESP_TYPE(pReq->Flags)) {
+        default:
+        case SDREQ_FLAGS_NO_RESP:
+            temp = 0x00;
+            break;
+        case SDREQ_FLAGS_RESP_R2:
+            temp = 0x01 |
+                    HOST_REG_COMMAND_REGISTER_CRC_CHECK_ENABLE;
+            break;
+        case SDREQ_FLAGS_RESP_R3:
+        case SDREQ_FLAGS_RESP_SDIO_R4:
+            temp = 0x02;
+            break;
+        case SDREQ_FLAGS_RESP_R1:
+        case SDREQ_FLAGS_RESP_SDIO_R5:
+        case SDREQ_FLAGS_RESP_R6:
+            temp = 0x02 | HOST_REG_COMMAND_REGISTER_CRC_CHECK_ENABLE
+                        | HOST_REG_COMMAND_REGISTER_CMD_INDEX_CHECK_ENABLE;
+            break;
+        case SDREQ_FLAGS_RESP_R1B:
+            temp = 0x03 | HOST_REG_COMMAND_REGISTER_CRC_CHECK_ENABLE
+                        | HOST_REG_COMMAND_REGISTER_CMD_INDEX_CHECK_ENABLE;
+            break;
+    }
+
+        /* start the clock */
+    ClockStartStop(pDevice, CLOCK_ON);
+    /* mask the remove while we are spinning on the CMD ready bits */
+    MaskIrq(pDevice, HOST_REG_INT_STATUS_ALLOW_INSERT_REMOVE_ONLY);
+    WAIT_FOR_DAT_CMD_DAT_READY(pDevice, &status);
+
+    if (!SDIO_SUCCESS(status)) {
+        ResetCmdDatLine(pDevice);
+        goto processComplete;
+    }
+        /* clear any error statuses */
+    WRITE_HOST_REG16(pDevice, HOST_REG_ERROR_INT_STATUS, HOST_REG_ERROR_INT_STATUS_ALL_ERR);
+    WRITE_HOST_REG16(pDevice, HOST_REG_NORMAL_INT_STATUS, HOST_REG_NORMAL_INT_STATUS_ALL_ERR);
+
+    if (pReq->Flags & SDREQ_FLAGS_DATA_TRANS){
+        /* set the block size register */
+        WRITE_HOST_REG16(pDevice, HOST_REG_BLOCK_SIZE, pReq->BlockLen);
+        /* set block count register */
+        WRITE_HOST_REG16(pDevice, HOST_REG_BLOCK_COUNT, pReq->BlockCount);
+        pReq->DataRemaining = pReq->BlockLen * pReq->BlockCount;
+        DBG_PRINT(PXA_TRACE_DATA, ("SDIO PCI Ellen %s Data Transfer, Blocks:%d, BlockLen:%d, Total:%d \n",
+                                   IS_SDREQ_WRITE_DATA(pReq->Flags) ? "TX":"RX",
+                                   pReq->BlockCount, pReq->BlockLen, pReq->DataRemaining));
+            /* use the context to hold where we are in the buffer */
+        pReq->pHcdContext = pReq->pDataBuffer;
+        temp |= HOST_REG_COMMAND_REGISTER_DATA_PRESENT;
+    }
+
+    /* set the argument register */
+    WRITE_HOST_REG32(pDevice, HOST_REG_ARGUMENT, pReq->Argument);
+    /* set transfer mode register */
+    WRITE_HOST_REG16(pDevice, HOST_REG_TRANSFER_MODE,
+            ((pReq->BlockCount > 1) ? HOST_REG_TRANSFER_MODE_MULTI_BLOCK:0) |
+            ((pReq->BlockCount > 1) ? HOST_REG_TRANSFER_MODE_BLOCKCOUNT_ENABLE:0) |
+            ((pReq->Flags & SDREQ_FLAGS_AUTO_CMD12) ? HOST_REG_TRANSFER_MODE_AUTOCMD12 : 0) |
+            ((IS_SDREQ_WRITE_DATA(pReq->Flags))?0 : HOST_REG_TRANSFER_MODE_READ));
+
+    /* block cmd timeout errors */
+    WRITE_HOST_REG16(pDevice, HOST_REG_INT_ERR_SIGNAL_ENABLE,
+                HOST_REG_ERROR_INT_STATUS_ALL_ERR & ~HOST_REG_ERROR_INT_STATUS_CMDTIMEOUTERR);
+
+    /* set command register, make sure it is clear to write */
+    temp |= (pReq->Command << HOST_REG_COMMAND_REGISTER_CMD_SHIFT);
+    DBG_PRINT(PXA_TRACE_REQUESTS, ("SDIO PCI Ellen CMDDAT:0x%X (RespType:%d, Command:0x%X , Arg:0x%X) \n",
+              temp, GET_SDREQ_RESP_TYPE(pReq->Flags), pReq->Command, pReq->Argument));
+
+
+    if (SDHCD_GET_OPER_CLOCK(pHcd) < pDevice->ClockSpinLimit) {
+            /* clock rate is very low, need to use interrupts here */
+            /* enable error interrupts */
+        WRITE_HOST_REG16(pDevice, HOST_REG_INT_ERR_SIGNAL_ENABLE,
+                HOST_REG_ERROR_INT_STATUS_ALL_ERR);
+        UnmaskIrq(pDevice, HOST_REG_INT_STATUS_CMD_COMPLETE_ENABLE);
+        WRITE_HOST_REG16(pDevice, HOST_REG_INT_ERR_SIGNAL_ENABLE,
+                            HOST_REG_ERROR_INT_STATUS_ALL_ERR);
+
+        if (pReq->Flags & SDREQ_FLAGS_DATA_TRANS) {
+             if (IS_SDREQ_WRITE_DATA(pReq->Flags)) {
+                 TRACE_SIGNAL_DATA_WRITE(pDevice, TRUE);
+             } else {
+                 TRACE_SIGNAL_DATA_READ(pDevice, TRUE);
+             }
+        }
+
+        WRITE_HOST_REG16(pDevice, HOST_REG_COMMAND_REGISTER, temp);
+
+        status = SDIO_STATUS_PENDING;
+        if (pReq->Flags & SDREQ_FLAGS_DATA_TRANS) {
+            DBG_PRINT(PXA_TRACE_REQUESTS, ("SDIO PCI Ellen using interrupt for command done.*** with data. (clock:%d, ref:%d)\n",
+                SDHCD_GET_OPER_CLOCK(pHcd),pDevice->ClockSpinLimit));
+        } else {
+            DBG_PRINT(PXA_TRACE_REQUESTS, ("SDIO PCI Ellen using interrupt for command done. (clock:%d, ref:%d) \n",
+                SDHCD_GET_OPER_CLOCK(pHcd),pDevice->ClockSpinLimit));
+        }
+        return status;
+    } else {
+        if (pReq->Flags & SDREQ_FLAGS_DATA_TRANS) {
+             if (IS_SDREQ_WRITE_DATA(pReq->Flags)) {
+                 TRACE_SIGNAL_DATA_WRITE(pDevice, TRUE);
+             } else {
+                 TRACE_SIGNAL_DATA_READ(pDevice, TRUE);
+             }
+        }
+        WRITE_HOST_REG16(pDevice, HOST_REG_COMMAND_REGISTER, temp);
+        if (pReq->Flags & SDREQ_FLAGS_DATA_TRANS) {
+            WAIT_REGISTER32_CHANGE(pDevice,
+                                   &status,
+                                   HOST_REG_PRESENT_STATE,
+                                   HOST_REG_PRESENT_STATE_BUFFER_COMMAND_INHIBIT_CMD,
+                                   0, 30000);
+        } else  {
+            WAIT_FOR_DAT_CMD_DAT_READY(pDevice, &status);
+        }
+
+        if (!SDIO_SUCCESS(status)) {
+            ResetCmdDatLine(pDevice);
+            goto processComplete;
+        }
+    }
+
+    /* check for errors */
+    temp = READ_HOST_REG16(pDevice, HOST_REG_ERROR_INT_STATUS);
+    ints = READ_HOST_REG16(pDevice, HOST_REG_NORMAL_INT_STATUS);
+    if (ints & HOST_REG_NORMAL_INT_STATUS_TRANSFER_COMPLETE) {
+        DBG_PRINT(PXA_TRACE_MMC_INT, ("SDIO PCI Ellen HcdRequest clearing possible data timeout errors: 0x%X, ints: 0x%X \n",
+                                      temp, ints));
+        temp &= ~HOST_REG_ERROR_INT_STATUS_DATATIMEOUTERR;
+    }
+    WRITE_HOST_REG16(pDevice, HOST_REG_NORMAL_INT_STATUS,
+                                HOST_REG_NORMAL_INT_STATUS_CMD_COMPLETE);
+
+    UnmaskIrq(pDevice, HOST_REG_INT_STATUS_ALLOW_INSERT_REMOVE_ONLY);
+
+    if (temp != 0) {
+        if (temp & HOST_REG_ERROR_INT_STATUS_CMDTIMEOUTERR) {
+            /* toggle timeout gpio */
+            TRACE_SIGNAL_DATA_TIMEOUT(pDevice, TRUE);
+            TRACE_SIGNAL_DATA_TIMEOUT(pDevice, FALSE);
+        }
+        status = TranslateSDError(pDevice, temp);
+        /* clear any existing errors - non-synchronized clear */
+        WRITE_HOST_REG16(pDevice, HOST_REG_ERROR_INT_STATUS, HOST_REG_ERROR_INT_STATUS_ALL_ERR);
+            /* reset statemachine, just in case */
+        ResetCmdDatLine(pDevice);
+    } else if (pDevice->Cancel) {
+        status = SDIO_STATUS_CANCELED;
+    } else {
+            /* get the response data for the command */
+        status = GetResponseData(pDevice, pReq);
+    }
+
+
+        /* check for data */
+    if (SDIO_SUCCESS(status) && (pReq->Flags & SDREQ_FLAGS_DATA_TRANS)){
+
+            /* check with the bus driver if it is okay to continue with data */
+        status = SDIO_CheckResponse(pHcd, pReq, SDHCD_CHECK_DATA_TRANS_OK);
+
+        if (SDIO_SUCCESS(status)) {
+            /* re-enable the cmd timeout error */
+            WRITE_HOST_REG16(pDevice, HOST_REG_INT_ERR_SIGNAL_ENABLE,
+                    HOST_REG_ERROR_INT_STATUS_ALL_ERR);
+            if (IS_SDREQ_WRITE_DATA(pReq->Flags)) {
+                /* see if the buffer is ready, it should be */
+                ints = READ_HOST_REG16(pDevice, HOST_REG_NORMAL_INT_STATUS);
+                if (ints & HOST_REG_INT_STATUS_BUFFER_WRITE_RDY_ENABLE) {
+                    WRITE_HOST_REG16(pDevice,
+                                    HOST_REG_NORMAL_INT_STATUS,
+                                    HOST_REG_NORMAL_INT_STATUS_BUFFER_WRITE_RDY);
+
+                    /* send the initial buffer */
+                    /* transfer data */
+                    HcdTransferTxData(pDevice, pReq);
+                }
+                    /* expecting interrupt */
+                UnmaskIrq(pDevice, HOST_REG_INT_STATUS_TRANSFER_COMPLETE_ENABLE
+                                   | HOST_REG_INT_STATUS_BUFFER_WRITE_RDY_ENABLE);
+            } else {
+                UnmaskIrq(pDevice, HOST_REG_INT_STATUS_TRANSFER_COMPLETE_ENABLE
+                                   | HOST_REG_INT_STATUS_BUFFER_READ_RDY_ENABLE);
+            }
+            DBG_PRINT(PXA_TRACE_DATA, ("SDIO PCI Ellen Pending %s transfer \n",
+                                       IS_SDREQ_WRITE_DATA(pReq->Flags) ? "TX":"RX"));
+
+                /* return pending */
+            status = SDIO_STATUS_PENDING;
+        } else {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen : Response for Data transfer error :%d n",status));
+            ResetCmdDatLine(pDevice);
+        }
+    }
+
+processComplete:
+
+    if (status != SDIO_STATUS_PENDING) {
+        if (!pDevice->KeepClockOn) {
+            ClockStartStop(pDevice, CLOCK_OFF);
+        }
+        pReq->Status = status;
+
+        if (IS_SDREQ_FORCE_DEFERRED_COMPLETE(pReq->Flags)) {
+            DBG_PRINT(PXA_TRACE_REQUESTS, ("SDIO PCI Ellen deferring completion to work item \n"));
+                /* the HCD must do the indication in a separate context and return status pending */
+            QueueEventResponse(pDevice, WORK_ITEM_IO_COMPLETE);
+            return SDIO_STATUS_PENDING;
+        } else {
+                /* complete the request */
+            DBG_PRINT(PXA_TRACE_REQUESTS, ("SDIO PCI Ellen Command Done, status:%d \n", status));
+        }
+        pDevice->Cancel = FALSE;
+    }
+
+    return status;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  HcdConfig - HCD configuration handler
+  Input:  pHcd - HCD object
+          pConfig - configuration setting
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS HcdConfig(PSDHCD pHcd, PSDCONFIG pConfig)
+{
+    PSDHCD_DEVICE pDevice = (PSDHCD_DEVICE)pHcd->pContext;
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    UINT16      command;
+    UINT32 temp;
+
+    if(pDevice->ShuttingDown) {
+        DBG_PRINT(PXA_TRACE_REQUESTS, ("SDIO PCI Ellen HcdConfig returning canceled\n"));
+        return SDIO_STATUS_CANCELED;
+    }
+
+    command = GET_SDCONFIG_CMD(pConfig);
+
+    switch (command){
+        case SDCONFIG_GET_WP:
+            /* get write protect */
+            temp = READ_HOST_REG32(pDevice, HOST_REG_PRESENT_STATE);
+            /* if write enabled, set WP value to zero */
+            *((SDCONFIG_WP_VALUE *)pConfig->pData) =
+                    (temp & HOST_REG_PRESENT_STATE_WRITE_ENABLED )? 0 : 1;
+            break;
+        case SDCONFIG_SEND_INIT_CLOCKS:
+            ClockStartStop(pDevice,CLOCK_ON);
+                /* should be at least 80 clocks at our lowest clock setting */
+            status = OSSleep(100);
+            ClockStartStop(pDevice,CLOCK_OFF);
+            break;
+        case SDCONFIG_SDIO_INT_CTRL:
+            if (GET_SDCONFIG_CMD_DATA(PSDCONFIG_SDIO_INT_CTRL_DATA,pConfig)->SlotIRQEnable) {
+                {
+                    SDIO_IRQ_MODE_FLAGS irqModeFlags;
+                    UINT8               blockGapControl;
+
+                    irqModeFlags = GET_SDCONFIG_CMD_DATA(PSDCONFIG_SDIO_INT_CTRL_DATA,pConfig)->IRQDetectMode;
+                    if (irqModeFlags & IRQ_DETECT_4_BIT) {
+                        DBG_PRINT(SDDBG_TRACE, ("SDIO PCI Ellen: 4 Bit IRQ mode \r\n"));
+                            /* in 4 bit mode, the clock needs to be left on */
+                        pDevice->KeepClockOn = TRUE;
+                        blockGapControl = READ_HOST_REG8(pDevice,HOST_REG_BLOCK_GAP);
+                        if (irqModeFlags & IRQ_DETECT_MULTI_BLK) {
+                            blockGapControl |= HOST_REG_INT_DETECT_AT_BLOCK_GAP;
+                            DBG_PRINT(SDDBG_TRACE, ("SDIO PCI Ellen: 4 Bit Multi-block IRQ detection enabled \r\n"));
+                        } else {
+                                // no interrupts between blocks
+                            blockGapControl &= ~HOST_REG_INT_DETECT_AT_BLOCK_GAP;
+                        }
+                        WRITE_HOST_REG8(pDevice,HOST_REG_BLOCK_GAP,blockGapControl);
+                    } else {
+                            /* in 1 bit mode, the clock can be left off */
+                        pDevice->KeepClockOn = FALSE;
+                    }
+                }
+                    /* enable detection */
+                EnableDisableSDIOIRQ(pDevice,TRUE,FALSE);
+            } else {
+                pDevice->KeepClockOn = FALSE;
+                EnableDisableSDIOIRQ(pDevice,FALSE,FALSE);
+            }
+            break;
+        case SDCONFIG_SDIO_REARM_INT:
+                /* re-enable IRQ detection */
+            EnableDisableSDIOIRQ(pDevice,TRUE,FALSE);
+            break;
+        case SDCONFIG_BUS_MODE_CTRL:
+            SetBusMode(pDevice, (PSDCONFIG_BUS_MODE_DATA)(pConfig->pData));
+            break;
+        case SDCONFIG_POWER_CTRL:
+            DBG_PRINT(PXA_TRACE_CONFIG, ("SDIO PCI Ellen PwrControl: En:%d, VCC:0x%X \n",
+                      GET_SDCONFIG_CMD_DATA(PSDCONFIG_POWER_CTRL_DATA,pConfig)->SlotPowerEnable,
+                      GET_SDCONFIG_CMD_DATA(PSDCONFIG_POWER_CTRL_DATA,pConfig)->SlotPowerVoltageMask));
+            status = SetPowerLevel(pDevice,
+                     GET_SDCONFIG_CMD_DATA(PSDCONFIG_POWER_CTRL_DATA,pConfig)->SlotPowerEnable,
+                     GET_SDCONFIG_CMD_DATA(PSDCONFIG_POWER_CTRL_DATA,pConfig)->SlotPowerVoltageMask);
+            break;
+        default:
+            /* invalid request */
+            DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen Local HCD: HcdConfig - bad command: 0x%X\n",
+                                    command));
+            status = SDIO_STATUS_INVALID_PARAMETER;
+    }
+
+    return status;
+}
+
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  SetPowerLevel - Set power level of board
+  Input:  pDeviceContext - device context
+          On - if true turns power on, else off
+          Level - SLOT_VOLTAGE_MASK level
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS SetPowerLevel(PSDHCD_DEVICE pDeviceContext, BOOL On, SLOT_VOLTAGE_MASK Level)
+{
+    UINT8 out;
+    UINT32 capCurrent;
+
+    capCurrent = READ_HOST_REG32(pDeviceContext, HOST_REG_MAX_CURRENT_CAPABILITIES);
+
+    switch (Level) {
+      case SLOT_POWER_3_3V:
+        out = HOST_REG_POWER_CONTROL_VOLT_3_3;
+            /* extract */
+        capCurrent = (capCurrent & HOST_REG_MAX_CURRENT_CAPABILITIES_3_3_MASK) >>
+                        HOST_REG_MAX_CURRENT_CAPABILITIES_3_3_SHIFT;
+        break;
+      case SLOT_POWER_3_0V:
+        out = HOST_REG_POWER_CONTROL_VOLT_3_0;
+            /* extract */
+        capCurrent = (capCurrent & HOST_REG_MAX_CURRENT_CAPABILITIES_3_0_MASK) >>
+                        HOST_REG_MAX_CURRENT_CAPABILITIES_3_0_SHIFT;
+        break;
+      case SLOT_POWER_1_8V:
+        out = HOST_REG_POWER_CONTROL_VOLT_1_8;
+            /* extract */
+        capCurrent = (capCurrent & HOST_REG_MAX_CURRENT_CAPABILITIES_1_8_MASK) >>
+                        HOST_REG_MAX_CURRENT_CAPABILITIES_1_8_SHIFT;
+        break;
+      default:
+        DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen SetPowerLevel - illegal power level %d\n",
+                                (UINT)Level));
+        return SDIO_STATUS_INVALID_PARAMETER;
+    }
+
+    if (capCurrent != 0) {
+            /* convert to mA and set max current */
+        pDeviceContext->Hcd.MaxSlotCurrent = capCurrent * HOST_REG_MAX_CURRENT_CAPABILITIES_SCALER;
+    } else {
+        DBG_PRINT(SDDBG_WARN, ("SDIO PCI Ellen No Current Caps value for VMask:0x%X, using 200mA \n",
+                  Level));
+            /* set a value */
+        pDeviceContext->Hcd.MaxSlotCurrent = 200;
+    }
+
+    if (On) {
+        out |= HOST_REG_POWER_CONTROL_ON;
+    }
+
+    WRITE_HOST_REG8(pDeviceContext, HOST_REG_POWER_CONTROL, out);
+    return SDIO_STATUS_SUCCESS;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  SetPowerOn - Set power on or off for card
+  Input:  pDeviceContext - device context
+          On - if true turns power on, else off
+  Output:
+  Return:
+  Notes: leavse the level alone
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void SetPowerOn(PSDHCD_DEVICE pDeviceContext, BOOL On)
+{
+    /* non-synchronized read modify write */
+    UINT8 out = READ_HOST_REG8(pDeviceContext, HOST_REG_POWER_CONTROL);
+    if (On) {
+        out |= HOST_REG_POWER_CONTROL_ON;
+    } else {
+        out &= ~HOST_REG_POWER_CONTROL_ON;
+    }
+    WRITE_HOST_REG8(pDeviceContext, HOST_REG_POWER_CONTROL, out);
+    return;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  HcdInitialize - Initialize MMC controller
+  Input:  pDeviceContext - device context
+  Output:
+  Return:
+  Notes: I/O resources must be mapped before calling this function
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS HcdInitialize(PSDHCD_DEVICE pDeviceContext)
+{
+    UINT32 caps;
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    UINT32 clockValue;
+    DBG_PRINT(SDDBG_TRACE, ("+SDIO PCI Ellen HcdInitialize\n"));
+
+        /* reset the device */
+    DBG_PRINT(SDDBG_TRACE, ("SDIO PCI Ellen HcdInitialize, resetting\n"));
+    WRITE_HOST_REG8(pDeviceContext, HOST_REG_SW_RESET, HOST_REG_SW_RESET_ALL);
+        /* wait for done */
+    while(READ_HOST_REG8(pDeviceContext, HOST_REG_SW_RESET) &  HOST_REG_SW_RESET_ALL)
+        ;
+    DBG_PRINT(SDDBG_TRACE, ("SDIO PCI Ellen HcdInitialize, reset\n"));
+
+        /* turn off clock */
+    ClockStartStop(pDeviceContext, CLOCK_OFF);
+        /* display version info */
+    DBG_PRINT(SDDBG_TRACE, ("SDIO PCI Ellen HcdInitialize: Spec verison: %s, Vendor version: %d\n",
+       (((READ_HOST_REG16(pDeviceContext, HOST_REG_VERSION) & HOST_REG_VERSION_SPEC_VERSION_MASK )== 0)?
+        "SD Host Spec. 1.0": "SD Host Spec. **UNKNOWN**"),
+        (READ_HOST_REG16(pDeviceContext, HOST_REG_VERSION) >> HOST_REG_VERSION_VENDOR_VERSION_SHIFT) &&
+        HOST_REG_VERSION_VENDOR_VERSION_MASK));
+
+        /* get capabilities */
+    caps = READ_HOST_REG32(pDeviceContext, HOST_REG_CAPABILITIES);
+    pDeviceContext->HighSpeed = (caps & HOST_REG_CAPABILITIES_HIGH_SPEED);
+    switch((caps & HOST_REG_CAPABILITIES_MAX_BLOCK_LEN_MASK) >> HOST_REG_CAPABILITIES_MAX_BLOCK_LEN_SHIFT) {
+        case 0x00:
+            pDeviceContext->Hcd.MaxBytesPerBlock = 512;
+            break;
+        case 0x01:
+            pDeviceContext->Hcd.MaxBytesPerBlock = 1024;
+            break;
+        case 0x02:
+            pDeviceContext->Hcd.MaxBytesPerBlock = 2048;
+            break;
+        case 0x03:
+            pDeviceContext->Hcd.MaxBytesPerBlock = 512;
+            DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen invalid buffer length\n"));
+            status = SDIO_STATUS_DEVICE_ERROR;
+            break;
+    }
+
+    clockValue = (caps & HOST_REG_CAPABILITIES_CLOCK_MASK) >> HOST_REG_CAPABILITIES_CLOCK_SHIFT;
+    if (clockValue != 0) {
+            /* convert to Hz */
+        pDeviceContext->BaseClock = clockValue*1000*1000;
+    } else {
+        DBG_PRINT(SDDBG_WARN, ("SDIO PCI Ellen base clock is zero! (caps:0x%X) \n",caps));
+            /* fall through and see if a default was setup */
+    }
+    if (pDeviceContext->BaseClock == 0) {
+         DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen invalid base clock setting\n"));
+         status = SDIO_STATUS_DEVICE_ERROR;
+         return status;
+    }
+
+    pDeviceContext->Hcd.MaxClockRate =  pDeviceContext->BaseClock;
+    DBG_PRINT(SDDBG_TRACE, ("SDIO PCI Ellen Using clock %dHz, max. block %d, high speed %s\n",
+                            pDeviceContext->BaseClock, pDeviceContext->Hcd.MaxBytesPerBlock,
+                            (pDeviceContext->HighSpeed)? "supported" : "not supported"));
+    /* setup the supported voltages and max current */
+    pDeviceContext->Hcd.SlotVoltageCaps = 0;
+    /* max current is dynamically set based on the desired voltage, see SetPowerLevel() */
+    pDeviceContext->Hcd.MaxSlotCurrent = 0;
+
+    if (caps & HOST_REG_CAPABILITIES_VOLT_1_8) {
+        pDeviceContext->Hcd.SlotVoltageCaps |= SLOT_POWER_1_8V;
+        pDeviceContext->Hcd.SlotVoltagePreferred = SLOT_POWER_1_8V;
+    }
+    if(caps & HOST_REG_CAPABILITIES_VOLT_3_0) {
+        pDeviceContext->Hcd.SlotVoltageCaps |= SLOT_POWER_3_0V;
+        pDeviceContext->Hcd.SlotVoltagePreferred = SLOT_POWER_3_0V;
+    }
+    if(caps & HOST_REG_CAPABILITIES_VOLT_3_3) {
+        pDeviceContext->Hcd.SlotVoltageCaps |= SLOT_POWER_3_3V;
+        pDeviceContext->Hcd.SlotVoltagePreferred = SLOT_POWER_3_3V;
+    }
+
+    DBG_PRINT(SDDBG_TRACE, ("SDIO PCI Ellen HcdInitialize: caps: 0x%X, SlotVoltageCaps: 0x%X, MaxSlotCurrent: 0x%X\n",
+                        (UINT)caps, (UINT)pDeviceContext->Hcd.SlotVoltageCaps, (UINT)pDeviceContext->Hcd.MaxSlotCurrent));
+
+        /* set the default timeout */
+    WRITE_HOST_REG8(pDeviceContext, HOST_REG_TIMEOUT_CONTROL, pDeviceContext->TimeOut);
+
+    /* clear any existing errors */
+    WRITE_HOST_REG16(pDeviceContext, HOST_REG_NORMAL_INT_STATUS, HOST_REG_NORMAL_INT_STATUS_ALL_ERR);
+    WRITE_HOST_REG16(pDeviceContext, HOST_REG_ERROR_INT_STATUS, HOST_REG_ERROR_INT_STATUS_ALL_ERR);
+    /* enable error interrupts */
+    WRITE_HOST_REG16(pDeviceContext, HOST_REG_ERR_STATUS_ENABLE, HOST_REG_ERROR_INT_STATUS_ALL_ERR);
+//??    WRITE_HOST_REG16(pDeviceContext, HOST_REG_INT_ERR_SIGNAL_ENABLE,
+//??                HOST_REG_ERROR_INT_STATUS_ALL_ERR & ~HOST_REG_ERROR_INT_STATUS_CMDTIMEOUTERR);
+    /* leave disabled for now */
+    WRITE_HOST_REG16(pDeviceContext, HOST_REG_INT_ERR_SIGNAL_ENABLE,
+                (UINT16)~HOST_REG_ERROR_INT_STATUS_ALL_ERR);
+    /* enble statuses */
+    WRITE_HOST_REG16(pDeviceContext, HOST_REG_INT_STATUS_ENABLE, HOST_REG_INT_STATUS_ALL);
+
+
+    /* interrupts will get enabled by the caller after all of the OS dependent work is done */
+    /*UnmaskIrq(pDeviceContext, HOST_REG_INT_STATUS_ALLOW_INSERT_REMOVE_ONLY);*/
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO PCI Ellen HcdInitialize\n"));
+    return status;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  HcdDeinitialize - deactivate controller
+  Input:  pDeviceContext - context
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void HcdDeinitialize(PSDHCD_DEVICE pDeviceContext)
+{
+    DBG_PRINT(SDDBG_TRACE, ("+SDIO PCI Ellen HcdDeinitialize\n"));
+    pDeviceContext->KeepClockOn = FALSE;
+    MaskIrq(pDeviceContext, HOST_REG_INT_STATUS_ALL);
+    pDeviceContext->ShuttingDown = TRUE;
+    /* disable error interrupts */
+    /* clear any existing errors */
+    WRITE_HOST_REG16(pDeviceContext, HOST_REG_ERROR_INT_STATUS, HOST_REG_ERROR_INT_STATUS_ALL_ERR);
+    /* disable error interrupts */
+    WRITE_HOST_REG16(pDeviceContext, HOST_REG_INT_ERR_SIGNAL_ENABLE,
+                                     (UINT16)~HOST_REG_ERROR_INT_STATUS_ALL_ERR);
+    WRITE_HOST_REG16(pDeviceContext, HOST_REG_ERR_STATUS_ENABLE,
+                                     (UINT16)~HOST_REG_ERROR_INT_STATUS_ALL_ERR);
+    ClockStartStop(pDeviceContext, CLOCK_OFF);
+    SetPowerOn(pDeviceContext, FALSE);
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO PCI Ellen HcdDeinitialize\n"));
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  HcdSDInterrupt - process controller interrupt
+  Input:  pDeviceContext - context
+  Output:
+  Return: TRUE if interrupt was handled
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+BOOL HcdSDInterrupt(PSDHCD_DEVICE pDeviceContext)
+{
+    UINT16      ints;
+    UINT16      errors;
+    UINT16 enables;
+    UINT16 statenables;
+    PSDREQUEST  pReq;
+    SDIO_STATUS status = SDIO_STATUS_PENDING;
+
+    DBG_PRINT(PXA_TRACE_MMC_INT, ("+SDIO PCI Ellen HcdSDInterrupt Int handler \n"));
+
+
+    ints = READ_HOST_REG16(pDeviceContext, HOST_REG_NORMAL_INT_STATUS);
+    errors = READ_HOST_REG16(pDeviceContext, HOST_REG_ERROR_INT_STATUS);
+
+    if ((ints == 0) && (errors == 0)) {
+        DBG_PRINT(SDDBG_ERROR, ("-SDIO PCI Ellen HcdSDInterrupt False Interrupt! \n"));
+        return FALSE;
+    }
+    enables = READ_HOST_REG16(pDeviceContext, HOST_REG_INT_SIGNAL_ENABLE);
+    statenables = READ_HOST_REG16(pDeviceContext, HOST_REG_INT_STATUS_ENABLE);
+    DBG_PRINT(PXA_TRACE_MMC_INT, ("SDIO PCI Ellen HcdSDInterrupt, ints: 0x%X errors: 0x%x, sigenables: 0x%X, statenable: 0x%X\n",
+            (UINT)ints, (UINT)errors, (UINT)enables, (UINT)statenables));
+                /* clear any error statuses */
+    WRITE_HOST_REG16(pDeviceContext, HOST_REG_ERROR_INT_STATUS, errors);
+
+    pReq = GET_CURRENT_REQUEST(&pDeviceContext->Hcd);
+
+    if (ints & HOST_REG_NORMAL_INT_STATUS_TRANSFER_COMPLETE) {
+        DBG_PRINT(PXA_TRACE_MMC_INT, ("SDIO PCI Ellen HcdSDInterrupt clearing possible data timeout errors: 0x%X \n",
+                                      errors));
+        errors &= ~HOST_REG_ERROR_INT_STATUS_DATATIMEOUTERR;
+    }
+    /* handle the error cases first */
+    if (errors != 0) {
+        if (errors & HOST_REG_ERROR_INT_STATUS_VENDOR_MASK) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen HcdSDInterrupt vendor error 0x%X: \n",
+                        (UINT)((errors & HOST_REG_ERROR_INT_STATUS_VENDOR_MASK) >>
+                                HOST_REG_ERROR_INT_STATUS_VENDOR_SHIFT)));
+        }
+        if (errors & HOST_REG_ERROR_INT_STATUS_AUTOCMD12ERR) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen HcdSDInterrupt auto cmd12 error\n"));
+        }
+        if (errors & HOST_REG_ERROR_INT_STATUS_CURRENTLIMITERR) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen HcdSDInterrupt current limit error\n"));
+        }
+        if (errors & HOST_REG_ERROR_INT_STATUS_DATAENDBITERR) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen HcdSDInterrupt data end bit error\n"));
+        }
+        if (errors & HOST_REG_ERROR_INT_STATUS_DATACRCERR) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen HcdSDInterrupt data CRC error\n"));
+        }
+        if (errors & HOST_REG_ERROR_INT_STATUS_DATATIMEOUTERR) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen HcdSDInterrupt data timeout error\n"));
+        }
+        if (errors & HOST_REG_ERROR_INT_STATUS_CMDINDEXERR) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen HcdSDInterrupt CMD index error\n"));
+        }
+        if (errors & HOST_REG_ERROR_INT_STATUS_CMDENDBITERR) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen HcdSDInterrupt CMD end bit error\n"));
+        }
+        if (errors & HOST_REG_ERROR_INT_STATUS_CRCERR) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen HcdSDInterrupt CRC error\n"));
+        }
+        if (errors & HOST_REG_ERROR_INT_STATUS_CMDTIMEOUTERR) {
+            /* toggle timeout gpio */
+            TRACE_SIGNAL_DATA_TIMEOUT(pDeviceContext, TRUE);
+            DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen HcdSDInterrupt CMD timeout error\n"));
+            TRACE_SIGNAL_DATA_TIMEOUT(pDeviceContext, FALSE);
+        }
+        if (ints & HOST_REG_INT_STATUS_CARD_INT_STAT_ENABLE) {
+              /* disable SDIO interrupt */
+            EnableDisableSDIOIRQ(pDeviceContext,FALSE,TRUE);
+        }
+        /* process insert/remove even on error conditions */
+        if (ints &
+            (HOST_REG_INT_STATUS_CARD_INSERT_ENABLE | HOST_REG_INT_STATUS_CARD_REMOVAL_ENABLE)){
+            /* card was inserted or removed, clear interrupt */
+            WRITE_HOST_REG16(pDeviceContext,
+                             HOST_REG_NORMAL_INT_STATUS,
+                             HOST_REG_INT_STATUS_CARD_INSERT_ENABLE |
+                             HOST_REG_INT_STATUS_CARD_REMOVAL_ENABLE);
+            enables = MaskIrqFromIsr(pDeviceContext, HOST_REG_INT_STATUS_ALL);
+            QueueEventResponse(pDeviceContext, WORK_ITEM_CARD_DETECT);
+        }
+
+    } else {
+        /* only look at ints that are enabled */
+        ints &= enables;
+
+        //DBG_PRINT(SDDBG_TRACE, ("SDIO PCI Ellen ints: 0x%X errors: 0x%x, sigenables: 0x%X, statenable: 0x%X\n",
+        //    (UINT)ints, (UINT)errors, (UINT)enables, (UINT)statenables));
+        if ((pDeviceContext->CardInserted) &&
+            (ints & HOST_REG_INT_STATUS_CARD_INT_STAT_ENABLE)) {
+              /* SD card interrupt*/
+              /* disable the interrupt, the user must clear the interrupt */
+            EnableDisableSDIOIRQ(pDeviceContext,FALSE,TRUE);
+            QueueEventResponse(pDeviceContext, WORK_ITEM_SDIO_IRQ);
+            /* continue looking for other interrupt causes */
+        } else if (ints & HOST_REG_INT_STATUS_CARD_INT_STAT_ENABLE) {
+              /* disable bogus interrupt */
+            EnableDisableSDIOIRQ(pDeviceContext,FALSE,TRUE);
+        }
+
+        if (ints &
+            (HOST_REG_INT_STATUS_CARD_INSERT_ENABLE | HOST_REG_INT_STATUS_CARD_REMOVAL_ENABLE)){
+            /* card was inserted or removed, clear interrupt */
+            WRITE_HOST_REG16(pDeviceContext,
+                             HOST_REG_NORMAL_INT_STATUS,
+                             HOST_REG_INT_STATUS_CARD_INSERT_ENABLE |
+                             HOST_REG_INT_STATUS_CARD_REMOVAL_ENABLE);
+            enables = MaskIrqFromIsr(pDeviceContext, HOST_REG_INT_STATUS_ALL);
+            QueueEventResponse(pDeviceContext, WORK_ITEM_CARD_DETECT);
+            return TRUE;
+        }
+
+        if (pDeviceContext->CardInserted && (pReq != NULL)) {
+            if (ints & HOST_REG_NORMAL_INT_STATUS_CMD_COMPLETE) {
+                WRITE_HOST_REG16(pDeviceContext, HOST_REG_NORMAL_INT_STATUS,
+                                HOST_REG_NORMAL_INT_STATUS_CMD_COMPLETE);
+                MaskIrqFromIsr(pDeviceContext, HOST_REG_INT_STATUS_CMD_COMPLETE_ENABLE);
+                    /* get the response data for the command */
+                status = GetResponseData(pDeviceContext, pReq);
+                DBG_PRINT(PXA_TRACE_MMC_INT, ("SDIO PCI Ellen HcdSDInterrupt command complete, status: %d\n",status));
+
+                if (SDIO_SUCCESS(status) && (pReq->Flags & SDREQ_FLAGS_DATA_TRANS)){
+
+                        /* check with the bus driver if it is okay to continue with data */
+                    status = SDIO_CheckResponse(&pDeviceContext->Hcd, pReq, SDHCD_CHECK_DATA_TRANS_OK);
+
+                    /* re-enable the cmd timeout error */
+                    WRITE_HOST_REG16(pDeviceContext, HOST_REG_INT_ERR_SIGNAL_ENABLE,
+                            HOST_REG_ERROR_INT_STATUS_ALL_ERR);
+
+                    DBG_PRINT(PXA_TRACE_MMC_INT, ("SDIO PCI Ellen HcdSDInterrupt status %d\n", status));
+                    if (SDIO_SUCCESS(status)) {
+                        if (IS_SDREQ_WRITE_DATA(pReq->Flags)) {
+                                /* expecting interrupt */
+                            DBG_PRINT(PXA_TRACE_MMC_INT, ("SDIO PCI Ellen HcdSDInterrupt unmasking write\n"));
+                            UnmaskIrqFromIsr(pDeviceContext, HOST_REG_INT_STATUS_TRANSFER_COMPLETE_ENABLE
+                                            | HOST_REG_INT_STATUS_BUFFER_WRITE_RDY_ENABLE);
+                        } else {
+                            DBG_PRINT(PXA_TRACE_MMC_INT, ("SDIO PCI Ellen HcdSDInterrupt unmasking read\n"));
+                            UnmaskIrqFromIsr(pDeviceContext, HOST_REG_INT_STATUS_TRANSFER_COMPLETE_ENABLE
+                                            | HOST_REG_INT_STATUS_BUFFER_READ_RDY_ENABLE);
+                        }
+                        DBG_PRINT(PXA_TRACE_DATA, ("SDIO PCI Ellen Pending from ISR %s transfer \n",
+                                                IS_SDREQ_WRITE_DATA(pReq->Flags) ? "TX":"RX"));
+                    	status = SDIO_STATUS_PENDING;
+                    } else {
+                        DBG_PRINT(SDDBG_ERROR, ("SDIO PCI Ellen : Response for Data transfer error :%d n",status));
+                        ResetCmdDatLine(pDeviceContext);
+                    }
+                } else {
+                    status = SDIO_STATUS_SUCCESS;
+                }
+            } else {
+                if (IS_SDREQ_DATA_TRANS(pReq->Flags)) {
+                    if (IS_SDREQ_WRITE_DATA(pReq->Flags)) {
+                        /* TX processing */
+                        if (ints &
+                                (HOST_REG_NORMAL_INT_STATUS_BUFFER_WRITE_RDY)) {
+                            /* clear interrupt */
+                            WRITE_HOST_REG16(pDeviceContext,
+                                            HOST_REG_NORMAL_INT_STATUS,
+                                            HOST_REG_NORMAL_INT_STATUS_BUFFER_WRITE_RDY);
+                            if (pReq->DataRemaining > 0) {
+                                /* transfer data */
+                                HcdTransferTxData(pDeviceContext, pReq);
+                                return TRUE;
+                            } else {
+                                /* re-read the interrupt status message to allow us to catch the
+                                   transfer complete in one interrupt */
+                                ints = READ_HOST_REG16(pDeviceContext, HOST_REG_NORMAL_INT_STATUS);
+                                ints &= enables;
+                                DBG_PRINT(PXA_TRACE_MMC_INT, ("SDIO PCI Ellen HcdSDInterrupt re-enable \n"));
+                            }
+                        }
+                    } else {
+                        /* RX processing */
+                        if (ints &
+                            (HOST_REG_NORMAL_INT_STATUS_BUFFER_READ_RDY)) {
+                            /* clear interrupt */
+                            WRITE_HOST_REG16(pDeviceContext,
+                                            HOST_REG_NORMAL_INT_STATUS,
+                                            HOST_REG_NORMAL_INT_STATUS_BUFFER_READ_RDY );
+                                /* unload fifo */
+                            HcdTransferRxData(pDeviceContext, pReq);
+                            if (pReq->DataRemaining > 0) {
+                                return TRUE;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (ints & HOST_REG_NORMAL_INT_STATUS_TRANSFER_COMPLETE) {
+                if (IS_SDREQ_DATA_TRANS(pReq->Flags)) {
+                    DBG_PRINT(PXA_TRACE_MMC_INT, ("SDIO PCI Ellen HcdSDInterrupt Transfer done \n"));
+                    /* clear interrupt */
+                    WRITE_HOST_REG16(pDeviceContext,
+                                     HOST_REG_NORMAL_INT_STATUS,
+                                     HOST_REG_NORMAL_INT_STATUS_TRANSFER_COMPLETE);
+                        /* if we get here without an error, we are done with the read
+                         * data operation */
+                    status = SDIO_STATUS_SUCCESS;
+                }
+            }
+        }
+    }
+    if (errors) {
+            /* alter status based on error */
+        status = TranslateSDError(pDeviceContext, errors);
+    }
+
+    if (status != SDIO_STATUS_PENDING) {
+        if (IS_SDREQ_DATA_TRANS(pReq->Flags)) {
+            if (IS_SDREQ_WRITE_DATA(pReq->Flags)) {
+                TRACE_SIGNAL_DATA_WRITE(pDeviceContext, FALSE);
+            } else {
+                TRACE_SIGNAL_DATA_READ(pDeviceContext, FALSE);
+            }
+        }
+            /* turn off interrupts and clock */
+        MaskIrqFromIsr(pDeviceContext,
+                    ~(HOST_REG_INT_STATUS_ALLOW_INSERT_REMOVE_ONLY |
+                      HOST_REG_INT_STATUS_CARD_INT_STAT_ENABLE) );
+
+        if (errors) {
+                /* reset statemachine */
+            ResetCmdDatLine(pDeviceContext);
+        }
+
+        if (!pDeviceContext->KeepClockOn) {
+            ClockStartStop(pDeviceContext, CLOCK_OFF);
+        }
+        if (pDeviceContext->CardInserted && (pReq != NULL)) {
+                /* set the status */
+            pReq->Status = status;
+                /* queue work item to notify bus driver of I/O completion */
+            QueueEventResponse(pDeviceContext, WORK_ITEM_IO_COMPLETE);
+        } else {
+            DBG_PRINT(PXA_TRACE_MMC_INT, ("SDIO PCI Ellen HcdSDInterrupt, no request to report: status %d \n",
+                                           status));
+        }
+    }
+
+    DBG_PRINT(PXA_TRACE_MMC_INT, ("-SDIO PCI Ellen HcdSDInterrupt Int handler \n"));
+    return TRUE;
+}
+
+
+
Index: linux-2.6/drivers/sdio/hcd/pci_ellen/sdio_hcd_linux.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/hcd/pci_ellen/sdio_hcd_linux.h
@@ -0,0 +1,195 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdio_hcd_linux.h
+
+@abstract: include file for Tokyo Electron PCI Ellen host controller, linux dependent code
+
+@notice: Copyright (c), 2004-2005 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#ifndef __SDIO_HCD_LINUX_H___
+#define __SDIO_HCD_LINUX_H___
+
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/device.h>
+
+
+#include <asm/irq.h>
+
+
+#define SDHCD_MAX_DEVICE_NAME 12
+
+#define CARD_INSERT_POLARITY   FALSE
+#define WP_POLARITY            TRUE
+#define HCD_COMMAND_MIN_POLLING_CLOCK 5000000
+
+/* debounce delay for slot */
+#define SD_SLOT_DEBOUNCE_MS  500
+
+/* the config space slot number and start for SD host */
+#define PCI_CONFIG_SLOT   0x40
+#define GET_SLOT_COUNT(config)\
+    ((((config)>>4)& 0x7) +1)
+#define GET_SLOT_FIRST(config)\
+    ((config) & 0x7)
+
+/* device base name */
+#define SDIO_BD_BASE "sdiobd"
+
+/* mapped memory address */
+typedef struct _SDHCD_MEMORY {
+    ULONG Raw;      /* start of address range */
+    ULONG Length;   /* length of range */
+    PVOID pMapped;  /* the mapped address */
+}SDHCD_MEMORY, *PSDHCD_MEMORY;
+
+typedef enum _SDHCD_TYPE {
+    TYPE_CLASS,     /* standard class device */
+    TYPE_PCIELLEN,  /* Tokuo Electron PCI Ellen card */
+}SDHCD_TYPE, *PSDHCD_TYPE;
+
+/* device data*/
+typedef struct _SDHCD_DEVICE {
+    struct pci_dev *pBusDevice;    /* our device registered with bus driver */
+    SDLIST  List;                  /* linked list */
+    SDHCD   Hcd;                   /* HCD description for bus driver */
+    char    DeviceName[SDHCD_MAX_DEVICE_NAME]; /* our chr device name */
+    SDHCD_MEMORY Address;          /* memory address of this device */
+    spinlock_t AddressSpinlock;    /* use to protect reghisters when needed */
+    SDHCD_MEMORY ControlRegs;      /* memory address of shared control registers */
+    SDHCD_TYPE Type;               /* type of this device */
+    UINT8   InitStateMask;
+#define SDIO_BAR_MAPPED            0x01
+#define SDIO_LAST_CONTROL_BAR_MAPPED 0x02 /* set on device that will unmap the shared control registers */
+#define SDIO_IRQ_INTERRUPT_INIT    0x04
+#define SDHC_REGISTERED            0x10
+#define SDHC_HW_INIT               0x40
+#define TIMER_INIT                 0x80
+    spinlock_t   Lock;            /* lock against the ISR */
+    BOOL         CardInserted;    /* card inserted flag */
+    BOOL         Cancel;
+    BOOL         ShuttingDown;    /* indicates shut down of HCD) */
+    BOOL         HighSpeed;       /* device supports high speed, 25-50 Mhz */
+    UINT32       BaseClock;       /* base clock in hz */
+    UINT32       TimeOut;         /* timeout setting */
+    UINT32       ClockSpinLimit;  /* clock limit for command spin loops */
+    BOOL         KeepClockOn;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    struct work_struct iocomplete_work; /* work item definintions */
+    struct work_struct carddetect_work; /* work item definintions */
+    struct work_struct sdioirq_work; /* work item definintions */
+#else
+    struct delayed_work iocomplete_work; /* work item definintions */
+    struct delayed_work carddetect_work; /* work item definintions */
+    struct delayed_work sdioirq_work; /* work item definintions */
+#endif
+}SDHCD_DEVICE, *PSDHCD_DEVICE;
+
+
+#define WORK_ITEM_IO_COMPLETE  0
+#define WORK_ITEM_CARD_DETECT  1
+#define WORK_ITEM_SDIO_IRQ     2
+
+
+#define READ_HOST_REG32(pDevice, OFFSET)  \
+    _READ_DWORD_REG((((UINT32)((pDevice)->Address.pMapped))) + (OFFSET))
+#define WRITE_HOST_REG32(pDevice, OFFSET, VALUE) \
+    _WRITE_DWORD_REG((((UINT32)((pDevice)->Address.pMapped))) + (OFFSET),(VALUE))
+#define READ_HOST_REG16(pDevice, OFFSET)  \
+    _READ_WORD_REG((((UINT32)((pDevice)->Address.pMapped))) + (OFFSET))
+#define WRITE_HOST_REG16(pDevice, OFFSET, VALUE) \
+    _WRITE_WORD_REG((((UINT32)((pDevice)->Address.pMapped))) + (OFFSET),(VALUE))
+#define READ_HOST_REG8(pDevice, OFFSET)  \
+    _READ_BYTE_REG((((UINT32)((pDevice)->Address.pMapped))) + (OFFSET))
+#define WRITE_HOST_REG8(pDevice, OFFSET, VALUE) \
+    _WRITE_BYTE_REG((((UINT32)((pDevice)->Address.pMapped))) + (OFFSET),(VALUE))
+
+#define READ_CONTROL_REG32(pDevice, OFFSET)  \
+    _READ_DWORD_REG((((UINT32)((pDevice)->ControlRegs.pMapped))) + (OFFSET))
+#define WRITE_CONTROL_REG32(pDevice, OFFSET, VALUE) \
+    _WRITE_DWORD_REG((((UINT32)((pDevice)->ControlRegs.pMapped))) + (OFFSET),(VALUE))
+#define READ_CONTROL_REG16(pDevice, OFFSET)  \
+    _READ_WORD_REG((((UINT32)((pDevice)->ControlRegs.pMapped))) + (OFFSET))
+#define WRITE_CONTROL_REG16(pDevice, OFFSET, VALUE) \
+    _WRITE_WORD_REG((((UINT32)((pDevice)->ControlRegs.pMapped))) + (OFFSET),(VALUE))
+
+/* PLX 9030 control registers */
+#define INTCSR 0x4C
+#define INTCSR_LINTi1ENABLE         (1 << 0)
+#define INTCSR_LINTi1STATUS         (1 << 2)
+#define INTCSR_LINTi2ENABLE         (1 << 3)
+#define INTCSR_LINTi2STATUS         (1 << 5)
+#define INTCSR_PCIINTENABLE         (1 << 6)
+
+#define GPIOCTRL 0x54
+#define GPIO8_PIN_DIRECTION     (1 << 25)
+#define GPIO8_DATA_MASK         (1 << 26)
+#define GPIO3_PIN_SELECT        (1 << 9)
+#define GPIO3_PIN_DIRECTION     (1 << 10)
+#define GPIO3_DATA_MASK         (1 << 11)
+#define GPIO2_PIN_SELECT        (1 << 6)
+#define GPIO2_PIN_DIRECTION     (1 << 7)
+#define GPIO2_DATA_MASK         (1 << 8)
+#define GPIO4_PIN_SELECT        (1 << 12)
+#define GPIO4_PIN_DIRECTION     (1 << 13)
+#define GPIO4_DATA_MASK         (1 << 14)
+
+#define GPIO_CONTROL(pDevice, on,  GpioMask)   \
+{                                   \
+     UINT32 temp;                    \
+     temp = READ_CONTROL_REG32((pDevice),GPIOCTRL);   \
+     if (on) temp |= (GpioMask); else temp &= ~(GpioMask);   \
+     WRITE_CONTROL_REG32((pDevice),GPIOCTRL, temp);   \
+}
+
+//??#define TRACE_SIGNAL_DATA_WRITE(pDevice, on) GPIO_CONTROL((pDevice),(on),GPIO8_DATA_MASK)
+//??#define TRACE_SIGNAL_DATA_READ(pDevice, on) GPIO_CONTROL((pDevice),(on),GPIO2_DATA_MASK)
+//??#define TRACE_SIGNAL_DATA_ISR(pDevice, on) GPIO_CONTROL((pDevice),(on),GPIO4_DATA_MASK)
+//??#define TRACE_SIGNAL_DATA_IOCOMP(pDevice, on) GPIO_CONTROL((pDevice),(on),GPIO3_DATA_MASK)
+#define TRACE_SIGNAL_DATA_WRITE(pDevice, on)
+#define TRACE_SIGNAL_DATA_READ(pDevice, on)
+#define TRACE_SIGNAL_DATA_ISR(pDevice, on)
+#define TRACE_SIGNAL_DATA_IOCOMP(pDevice, on)
+#define TRACE_SIGNAL_DATA_TIMEOUT(pDevice, on) GPIO_CONTROL((pDevice),(on),GPIO3_DATA_MASK)
+
+/* prototypes */
+#endif /* __SDIO_HCD_LINUX_H___ */
Index: linux-2.6/drivers/sdio/hcd/pci_ellen/sdio_hcd_os.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/hcd/pci_ellen/sdio_hcd_os.c
@@ -0,0 +1,851 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdio_hcd_os.c
+
+@abstract: Linux Tokyo Electron PCI Ellen SDIO Host Controller Driver
+
+#notes: includes module load and unload functions
+
+@notice: Copyright (c), 2004-2006 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+/* debug level for this module*/
+
+#define DBG_DECLARE 4;
+#include <linux/sdio/ctsystem.h>
+
+#include "sdio_pciellen_hcd.h"
+#include <linux/fs.h>
+#include <linux/ioport.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+
+#define DESCRIPTION "SDIO Tokyo Electron PCI Ellen HCD"
+#define AUTHOR "Atheros Communications, Inc."
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#define ATH_INIT_WORK(_t, _f, _c)	INIT_WORK((_t), (void (*)(void *))(_f), (_c));
+#else
+#define ATH_INIT_WORK(_t, _f, _c)	INIT_DELAYED_WORK((_t), (_f));
+#endif
+
+static SYSTEM_STATUS Probe(struct pci_dev *pPCIdevice, const struct pci_device_id *pId);
+static void Remove(struct pci_dev *pPCIdevice);
+static int MapAddress(struct pci_dev *pPCIdevice, char *pName, UINT8 bar, PSDHCD_MEMORY pAddress);
+static void UnmapAddress(PSDHCD_MEMORY pMap);
+static void RemoveDevice(struct pci_dev *pPCIdevice, PSDHCD_DRIVER_CONTEXT pHcdContext);
+static SDIO_STATUS InitEllen(PSDHCD_DEVICE pDeviceContext);
+static void GetDefaults(PSDHCD_DEVICE pDeviceContext);
+static irqreturn_t hcd_sdio_irq(int irq, void *context
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+, struct pt_regs * r
+#endif
+  );
+
+static void hcd_iocomplete_wqueue_handler(
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+void *context);
+#else
+struct work_struct *work);
+#endif
+
+static void hcd_carddetect_wqueue_handler(
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+void *context);
+#else
+struct work_struct *work);
+#endif
+
+
+static void hcd_sdioirq_wqueue_handler(
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+void *context);
+#else
+struct work_struct *work);
+#endif
+
+/* debug print parameter */
+module_param(debuglevel, int, 0644);
+MODULE_PARM_DESC(debuglevel, "debuglevel 0-7, controls debug prints");
+#define DEFAULT_ATTRIBUTES (SDHCD_ATTRIB_BUS_1BIT      | \
+                            SDHCD_ATTRIB_BUS_4BIT      | \
+                            SDHCD_ATTRIB_MULTI_BLK_IRQ | \
+                            SDHCD_ATTRIB_AUTO_CMD12    | \
+                            SDHCD_ATTRIB_POWER_SWITCH )
+
+static UINT32 hcdattributes = DEFAULT_ATTRIBUTES;
+module_param(hcdattributes, int, 0644);
+MODULE_PARM_DESC(hcdattributes, "PCIELLEN Attributes");
+static INT BaseClock = 0;
+module_param(BaseClock, int, 0444);
+MODULE_PARM_DESC(BaseClock, "BaseClock Hz when not present in configuration");
+static UINT32 timeout = HOST_REG_TIMEOUT_CONTROL_DEFAULT;
+module_param(timeout, int, 0644);
+MODULE_PARM_DESC(timeout, "PCIELLEN timeout flags");
+static UINT32 ClockSpinLimit = HCD_COMMAND_MIN_POLLING_CLOCK;
+module_param(ClockSpinLimit, int, 0644);
+MODULE_PARM_DESC(ClockSpinLimit, "PCIELLEN command clock spin time");
+
+
+
+
+/* the driver context data */
+static SDHCD_DRIVER_CONTEXT HcdContext = {
+   .pDescription  = DESCRIPTION,
+   .DeviceCount   = 0,
+};
+
+#define PCI_CLASS_SYSTEM_SDIO    0x0805
+/* PCI devices supported */
+static const struct pci_device_id pci_ids [] = {
+  {
+    .vendor = 0x1679, .device = 0x3000,
+    .subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID,
+    .driver_data =  (unsigned long) &HcdContext,
+  },
+  {
+   PCI_DEVICE_CLASS(PCI_CLASS_SYSTEM_SDIO << 8, 0xFFFFFF00),
+    .driver_data =  (unsigned long) &HcdContext,
+  },
+ { /* end: all zeroes */ }
+};
+MODULE_DEVICE_TABLE (pci, pci_ids);
+
+/* tell PCI bus driver about us */
+static struct pci_driver sdio_pci_driver = {
+    .name =     "sdio_pciellenhcd",
+    .id_table = pci_ids,
+
+    .probe =    Probe,
+    .remove =   Remove,
+
+#ifdef CONFIG_PM
+    .suspend =  NULL,
+    .resume =  NULL,
+#endif
+};
+
+
+
+/*
+ * Probe - probe to setup our device, if present
+*/
+static SYSTEM_STATUS Probe(struct pci_dev *pPCIdevice, const struct pci_device_id *pId)
+{
+    SYSTEM_STATUS err = 0;
+    SDIO_STATUS   status = SDIO_STATUS_SUCCESS;
+    PSDHCD_DRIVER_CONTEXT pHcdContext;
+    PSDHCD_DEVICE pDeviceContext = NULL;
+    PSDHCD_DEVICE pLastDeviceContext;
+    int ii;
+    int count;
+    int firstBar;
+    UINT8 config;
+    SDHCD_TYPE type = TYPE_CLASS;
+
+    DBG_PRINT(SDDBG_TRACE, ("SDIO PCIELLEN HCD: Probe - probing for new device\n"));
+    if ((pId == NULL) || (pId->driver_data == 0)) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO PCIELLEN HCD: Probe - no device\n"));
+        return -EINVAL;
+    }
+    pHcdContext = (PSDHCD_DRIVER_CONTEXT)pId->driver_data;
+
+    if (pci_enable_device(pPCIdevice) < 0) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO PCIELLEN HCD: Probe  - failed to enable device\n"));
+        return -ENODEV;
+    }
+    if ((pId->vendor == pci_ids[0].vendor) && (pId->device == pci_ids[0].device)) {
+        type = TYPE_PCIELLEN;
+        DBG_PRINT(SDDBG_TRACE, ("SDIO PCIELLEN HCD: Probe  - setting PCI Ellen type\n"));
+    }
+    /* get the number of slots supported and the initial BAR for it */
+    pci_read_config_byte(pPCIdevice, PCI_CONFIG_SLOT, &config);
+    count = GET_SLOT_COUNT(config);
+    firstBar = GET_SLOT_FIRST(config);
+    if (type == TYPE_PCIELLEN) {
+        /* move the first bar to the right start place */
+        firstBar = 2;
+    }
+    if (count > 0) {
+        DBG_PRINT(SDDBG_TRACE, ("SDIO PCI BD: Probe - slot count: %d, first BAR: %d\n", count, firstBar));
+    } else {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO PCI BD: Probe - no slots defined, first BAR: %d\n", firstBar));
+        pci_disable_device(pPCIdevice);
+        return -ENODEV;
+    }
+
+    /* create a device for each slot that we have */
+    for(ii = 0; ii < count; ii++, firstBar++) {
+        pLastDeviceContext = pDeviceContext;
+        /* allocate a device context for this new device */
+        pDeviceContext =  (PSDHCD_DEVICE)KernelAlloc(sizeof(SDHCD_DEVICE));
+        if (pDeviceContext == NULL) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO PCI BD: Probe - no memory for device context\n"));
+            err = -ENOMEM;
+            break;
+        }
+        ZERO_POBJECT(pDeviceContext);
+        SDLIST_INIT(&pDeviceContext->List);
+        pDeviceContext->Type = type;
+        pDeviceContext->pBusDevice = pPCIdevice;
+        spin_lock_init(&pDeviceContext->Lock);
+        spin_lock_init(&pDeviceContext->AddressSpinlock);
+
+        SET_SDIO_STACK_VERSION(&pDeviceContext->Hcd);
+        pDeviceContext->Hcd.pName = (PTEXT)KernelAlloc(SDHCD_MAX_DEVICE_NAME+1);
+        snprintf(pDeviceContext->Hcd.pName, SDHCD_MAX_DEVICE_NAME, SDIO_BD_BASE"%i:%i",
+                 pHcdContext->DeviceCount++, ii);
+        pDeviceContext->Hcd.Attributes = hcdattributes;
+        pDeviceContext->Hcd.MaxBlocksPerTrans = SDIO_SD_MAX_BLOCKS;
+        pDeviceContext->Hcd.pContext = pDeviceContext;
+        pDeviceContext->Hcd.pRequest = HcdRequest;
+        pDeviceContext->Hcd.pConfigure = HcdConfig;
+        pDeviceContext->Hcd.pDevice = &pPCIdevice->dev;
+        pDeviceContext->Hcd.pModule = THIS_MODULE;
+        pDeviceContext->BaseClock = BaseClock;
+        pDeviceContext->TimeOut = timeout;
+        pDeviceContext->ClockSpinLimit = ClockSpinLimit;
+        /* add device to our list of devices */
+            /* protect the devicelist */
+        if (!SDIO_SUCCESS(status = SemaphorePendInterruptable(&pHcdContext->DeviceListSem))) {
+            break;;   /* wait interrupted */
+        }
+        SDListInsertTail(&pHcdContext->DeviceList, &pDeviceContext->List);
+        SemaphorePost(&pHcdContext->DeviceListSem);
+
+        /* map the slots memory BAR */
+        status = MapAddress(pPCIdevice, pDeviceContext->DeviceName,
+                            (UINT8)firstBar, &pDeviceContext->Address);
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_ERROR,
+               ("SDIO PCIELLEN HCD: Probe - failed to map device memory address %s 0x%X, status %d\n",
+                pDeviceContext->DeviceName, (UINT)pci_resource_start(pPCIdevice, firstBar),
+                status));
+               break;
+        }
+        pDeviceContext->InitStateMask |= SDIO_BAR_MAPPED;
+
+        if (type == TYPE_PCIELLEN) {
+            if (pLastDeviceContext == NULL) {
+                /* map the slots control register BAR */
+                status = MapAddress(pPCIdevice, pDeviceContext->DeviceName,
+                                    (UINT8)0, &pDeviceContext->ControlRegs);
+                if (!SDIO_SUCCESS(status)) {
+                    DBG_PRINT(SDDBG_ERROR,
+                       ("SDIO PCIELLEN HCD: Probe - failed to map device control address %s 0x%X, status %d\n",
+                        pDeviceContext->DeviceName, (UINT)pci_resource_start(pPCIdevice, 0),
+                        status));
+                       break;
+                }
+            } else {
+                /* copy the prior mapping */
+                pDeviceContext->ControlRegs = pLastDeviceContext->ControlRegs;
+            }
+            if ((ii+1) == count) {
+                /* mark last one */
+                pDeviceContext->InitStateMask |= SDIO_LAST_CONTROL_BAR_MAPPED;
+            }
+        }
+        /* initialize work items */
+        ATH_INIT_WORK(&(pDeviceContext->iocomplete_work), hcd_iocomplete_wqueue_handler, pDeviceContext);
+        ATH_INIT_WORK(&(pDeviceContext->carddetect_work), hcd_carddetect_wqueue_handler, pDeviceContext);
+        ATH_INIT_WORK(&(pDeviceContext->sdioirq_work), hcd_sdioirq_wqueue_handler, pDeviceContext);
+
+        /* map the controller interrupt, we map it to each device.
+           Interrupts can be called from this point on */
+        err = request_irq(pPCIdevice->irq, hcd_sdio_irq, IRQF_SHARED,
+                          pDeviceContext->DeviceName, pDeviceContext);
+        if (err < 0) {
+              DBG_PRINT(SDDBG_ERROR, ("SDIO PCIELLEN - probe, unable to map interrupt \n"));
+              err = -ENODEV;
+              break;
+        }
+        pDeviceContext->InitStateMask |= SDIO_IRQ_INTERRUPT_INIT;
+
+        if (!SDIO_SUCCESS((status = HcdInitialize(pDeviceContext)))) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO PCIELLEN Probe - failed to init HW, status =%d\n",status));
+            err = SDIOErrorToOSError(status);
+            break;
+        }
+        pDeviceContext->InitStateMask |= SDHC_HW_INIT;
+
+           /* register with the SDIO bus driver */
+        if (!SDIO_SUCCESS((status = SDIO_RegisterHostController(&pDeviceContext->Hcd)))) {
+            DBG_PRINT(SDDBG_ERROR, ("SDIO PCIELLEN Probe - failed to register with host, status =%d\n",status));
+            err = SDIOErrorToOSError(status);
+            break;
+        }
+        pDeviceContext->InitStateMask |= SDHC_REGISTERED;
+
+        /* queue a work item to check for a card present at start up
+           this call will unmask the insert/remove interrupts */
+        QueueEventResponse(pDeviceContext, WORK_ITEM_CARD_DETECT);
+    }
+
+
+    if ((err < 0) || (!SDIO_SUCCESS(status))){
+        pHcdContext->DeviceCount--;
+        RemoveDevice(pPCIdevice, pHcdContext);
+    } else {
+
+      if (type == TYPE_PCIELLEN) {
+          InitEllen(pDeviceContext);
+      }
+
+        DBG_PRINT(SDDBG_ERROR, ("SDIO PCIELLEN Probe - HCD ready! \n"));
+    }
+    return 0;
+}
+
+/* Remove - remove  device
+ * perform the undo of the Probe
+*/
+static void Remove(struct pci_dev *pPCIdevice)
+{
+    PSDHCD_DRIVER_CONTEXT pHcdContext = &HcdContext;
+
+    DBG_PRINT(SDDBG_TRACE, ("+SDIO PCIELLEN HCD: Remove - removing device\n"));
+
+    RemoveDevice(pPCIdevice, pHcdContext);
+    pHcdContext->DeviceCount--;
+
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO PCIELLEN HCD: Remove\n"));
+    return;
+}
+
+/*
+ * RemoveDevice - remove all devices associated with bus device
+*/
+static void RemoveDevice(struct pci_dev *pPCIdevice, PSDHCD_DRIVER_CONTEXT pHcdContext)
+{
+    PSDHCD_DEVICE pDeviceContext;
+    DBG_PRINT(SDDBG_TRACE, ("+SDIO PCIELLEN HCD: RemoveDevice\n"));
+
+    /* protect the devicelist */
+    if (!SDIO_SUCCESS(SemaphorePendInterruptable(&pHcdContext->DeviceListSem))) {
+        return;   /* wait interrupted */
+    }
+
+    SDITERATE_OVER_LIST_ALLOW_REMOVE(&pHcdContext->DeviceList, pDeviceContext, SDHCD_DEVICE, List)
+        if (pDeviceContext->pBusDevice == pPCIdevice) {
+            if (pDeviceContext->InitStateMask & SDHC_HW_INIT) {
+                HcdDeinitialize(pDeviceContext);
+            }
+
+            if (pDeviceContext->InitStateMask & SDHC_REGISTERED) {
+                SDIO_UnregisterHostController(&pDeviceContext->Hcd);
+            }
+
+            /* wait for any of our work items to run */
+            flush_scheduled_work();
+
+            if (pDeviceContext->InitStateMask & SDIO_IRQ_INTERRUPT_INIT) {
+                free_irq(pPCIdevice->irq, pDeviceContext);
+            }
+
+            if (pDeviceContext->InitStateMask & SDIO_BAR_MAPPED) {
+                UnmapAddress(&pDeviceContext->Address);
+            }
+
+            if (pDeviceContext->InitStateMask & SDIO_LAST_CONTROL_BAR_MAPPED) {
+                UnmapAddress(&pDeviceContext->ControlRegs);
+            }
+            if (pDeviceContext->Hcd.pName != NULL) {
+                KernelFree(pDeviceContext->Hcd.pName);
+                pDeviceContext->Hcd.pName = NULL;
+            }
+            KernelFree(pDeviceContext);
+        }
+    SDITERATE_END;
+    SemaphorePost(&pHcdContext->DeviceListSem);
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO PCIELLEN HCD: RemoveDevice\n"));
+}
+
+/*
+ * MapAddress - sets up the address for a given BAR
+*/
+static int MapAddress(struct pci_dev *pPCIdevice, char *pName, UINT8 bar, PSDHCD_MEMORY pAddress)
+{
+    if (pci_resource_flags(pPCIdevice, bar) & PCI_BASE_ADDRESS_SPACE  ) {
+        DBG_PRINT(SDDBG_WARN, ("SDIO PCIELLEN HCD: MapAddress, port I/O not supported\n"));
+        return -ENOMEM;
+    }
+    pAddress->Raw = pci_resource_start(pPCIdevice, bar);
+    pAddress->Length = pci_resource_len(pPCIdevice, bar);
+    if (!request_mem_region (pAddress->Raw, pAddress->Length, pName)) {
+        DBG_PRINT(SDDBG_WARN, ("SDIO PCIELLEN HCD: MapAddress - memory in use: 0x%X(0x%X)\n",
+                               (UINT)pAddress->Raw, (UINT)pAddress->Length));
+        return -EBUSY;
+    }
+    pAddress->pMapped = ioremap_nocache(pAddress->Raw, pAddress->Length);
+    if (pAddress->pMapped == NULL) {
+        DBG_PRINT(SDDBG_WARN, ("SDIO PCIELLEN HCD: MapAddress - unable to map memory\n"));
+        /* cleanup region */
+        release_mem_region (pAddress->Raw, pAddress->Length);
+        return -EFAULT;
+    }
+    DBG_PRINT(SDDBG_TRACE, ("SDIO PCIELLEN HCD: MapAddress - mapped memory: 0x%X(0x%X) to 0x%X\n",
+                            (UINT)pAddress->Raw, (UINT)pAddress->Length, (UINT)pAddress->pMapped));
+    return 0;
+}
+
+
+
+/*
+ * UnmapAddress - unmaps the address
+*/
+static void UnmapAddress(PSDHCD_MEMORY pAddress) {
+    iounmap(pAddress->pMapped);
+    release_mem_region(pAddress->Raw, pAddress->Length);
+    pAddress->pMapped = NULL;
+}
+
+/*
+ * InitEllen - initialize the Ellen card control registers
+ *
+*/
+static SDIO_STATUS InitEllen(PSDHCD_DEVICE pDeviceContext)
+{
+    UINT32 temp = READ_CONTROL_REG16(pDeviceContext, INTCSR);
+    DBG_PRINT(SDDBG_TRACE, ("SDIO PCIELLEN HCD: InitEllen INTCSR - 0x%X\n", (UINT)temp));
+
+    WRITE_CONTROL_REG16(pDeviceContext, INTCSR,
+        (UINT16)temp | INTCSR_LINTi1ENABLE | INTCSR_LINTi2ENABLE | INTCSR_PCIINTENABLE);
+
+    temp = READ_CONTROL_REG32((pDeviceContext),GPIOCTRL);
+        /* set GPIO 2,3 and 8 as output */
+    temp &= ~(GPIO3_PIN_SELECT | GPIO2_PIN_SELECT | GPIO4_PIN_SELECT);
+    temp |= (GPIO8_PIN_DIRECTION | GPIO3_PIN_DIRECTION | GPIO2_PIN_DIRECTION | GPIO4_PIN_DIRECTION);
+    WRITE_CONTROL_REG32((pDeviceContext),GPIOCTRL, temp);
+    DBG_PRINT(SDDBG_TRACE, ("SDIO PCIELLEN HCD: InitEllen GPIOCTRL - 0x%X\n", (UINT)temp));
+    TRACE_SIGNAL_DATA_WRITE(pDeviceContext, FALSE);
+    TRACE_SIGNAL_DATA_READ(pDeviceContext, FALSE);
+    TRACE_SIGNAL_DATA_ISR(pDeviceContext, FALSE);
+    TRACE_SIGNAL_DATA_IOCOMP(pDeviceContext, FALSE);
+
+    return SDIO_STATUS_SUCCESS;
+}
+
+/*
+ * QueueEventResponse - queues an event in a process context back to the bus driver
+ *
+*/
+SDIO_STATUS QueueEventResponse(PSDHCD_DEVICE pDeviceContext, INT WorkItemID)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    struct work_struct  *work;
+#else
+    struct delayed_work *work;
+#endif
+
+    if (pDeviceContext->ShuttingDown) {
+        return SDIO_STATUS_CANCELED;
+    }
+
+    switch (WorkItemID) {
+        case WORK_ITEM_IO_COMPLETE:
+            work = &pDeviceContext->iocomplete_work;
+            break;
+        case WORK_ITEM_CARD_DETECT:
+            work = &pDeviceContext->carddetect_work;
+            break;
+        case WORK_ITEM_SDIO_IRQ:
+            work = &pDeviceContext->sdioirq_work;
+            break;
+        default:
+            DBG_ASSERT(FALSE);
+            return SDIO_STATUS_ERROR;
+            break;
+    }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    if (schedule_work(work) > 0) {
+#else
+    if (schedule_delayed_work(work,0) > 0) {
+#endif
+        return SDIO_STATUS_SUCCESS;
+    } else {
+        return SDIO_STATUS_PENDING;
+    }
+}
+
+/*
+ * hcd_iocomplete_wqueue_handler - the work queue for io completion
+*/
+static void hcd_iocomplete_wqueue_handler(
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+void *context)
+{
+    PSDHCD_DEVICE pDeviceContext = (PSDHCD_DEVICE)context;
+#else
+struct work_struct *work)
+{
+    PSDHCD_DEVICE pDeviceContext =
+      container_of( work, SDHCD_DEVICE, iocomplete_work.work );
+#endif
+
+    if (!pDeviceContext->ShuttingDown) {
+        TRACE_SIGNAL_DATA_IOCOMP(pDeviceContext, TRUE);
+        SDIO_HandleHcdEvent(&pDeviceContext->Hcd, EVENT_HCD_TRANSFER_DONE);
+        TRACE_SIGNAL_DATA_IOCOMP(pDeviceContext, FALSE);
+    }
+}
+
+/*
+ * hcd_carddetect_handler - the work queue for card detect debouncing
+*/
+static void hcd_carddetect_wqueue_handler(
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+void *context)
+{
+    PSDHCD_DEVICE pDeviceContext = (PSDHCD_DEVICE)context;
+#else
+struct work_struct *work)
+{
+    PSDHCD_DEVICE pDeviceContext =
+      container_of( work, SDHCD_DEVICE, carddetect_work.work );
+#endif
+
+    HCD_EVENT event;
+    volatile UINT32 temp;
+
+    event = EVENT_HCD_NOP;
+
+    DBG_PRINT(SDDBG_TRACE, ("+ SDIO PCIELLEN Card Detect Work Item \n"));
+    if (pDeviceContext->ShuttingDown) {
+        return;
+    }
+
+    DBG_PRINT(SDDBG_TRACE, ("SDIO PCIELLEN Card Detect Delaying to debounce card... \n"));
+        /* sleep for slot debounce if there is no card */
+    OSSleep(SD_SLOT_DEBOUNCE_MS);
+
+    /* wait for stable */
+    while(!(temp = READ_HOST_REG32(pDeviceContext, HOST_REG_PRESENT_STATE))&
+            HOST_REG_PRESENT_STATE_CARD_STATE_STABLE) {
+        ;
+    }
+
+    if (pDeviceContext->CardInserted) {
+        /* look for removal */
+        if (!(temp & HOST_REG_PRESENT_STATE_CARD_INSERTED)) {
+            /* card not present */
+            event = EVENT_HCD_DETACH;
+            pDeviceContext->CardInserted = FALSE;
+            pDeviceContext->KeepClockOn = FALSE;
+            /* turn the power off */
+            SetPowerOn(pDeviceContext, FALSE);
+            MaskIrq(pDeviceContext, HOST_REG_INT_STATUS_ALL);
+            DBG_PRINT(PXA_TRACE_CARD_INSERT, ("SDIO PCIELLEN Card Detect REMOVE\n"));
+        }
+    } else {
+        /* look for insert */
+        if (temp & HOST_REG_PRESENT_STATE_CARD_INSERTED) {
+            /* card present */
+            event = EVENT_HCD_ATTACH;
+            pDeviceContext->CardInserted = TRUE;
+            GetDefaults(pDeviceContext);
+
+            DBG_PRINT(PXA_TRACE_CARD_INSERT, ("SDIO PCIELLEN Card Detect INSERT\n"));
+        }
+    }
+                /* clear interrupt */
+    WRITE_HOST_REG16(pDeviceContext,
+                     HOST_REG_NORMAL_INT_STATUS,
+                     HOST_REG_INT_STATUS_CARD_INSERT_ENABLE |
+                     HOST_REG_INT_STATUS_CARD_REMOVAL_ENABLE);
+    UnmaskIrq(pDeviceContext, HOST_REG_INT_STATUS_ALLOW_INSERT_REMOVE_ONLY);
+
+    if (event != EVENT_HCD_NOP) {
+        SDIO_HandleHcdEvent(&pDeviceContext->Hcd, event);
+    }
+
+    DBG_PRINT(PXA_TRACE_CARD_INSERT, ("- SDIO PCIELLEN Card Detect Work Item \n"));
+}
+
+/*
+ * hcd_sdioirq_handler - the work queue for handling SDIO IRQ
+*/
+static void hcd_sdioirq_wqueue_handler(
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+void *context)
+{
+    PSDHCD_DEVICE pDeviceContext = (PSDHCD_DEVICE)context;
+#else
+struct work_struct *work)
+{
+    PSDHCD_DEVICE pDeviceContext =
+      container_of( work, SDHCD_DEVICE, sdioirq_work.work );
+#endif
+
+    DBG_PRINT(PXA_TRACE_SDIO_INT, ("SDIO PCIELLEN: hcd_sdioirq_wqueue_handler \n"));
+    if (!pDeviceContext->ShuttingDown) {
+        SDIO_HandleHcdEvent(&pDeviceContext->Hcd, EVENT_HCD_SDIO_IRQ_PENDING);
+    }
+}
+
+
+/* SDIO interrupt request */
+static irqreturn_t hcd_sdio_irq(int irq, void *context
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+, struct pt_regs * r
+#endif
+  )
+  {
+    irqreturn_t retStat;
+    UINT16 intStat;
+
+    DBG_PRINT(PXA_TRACE_SDIO_INT, ("SDIO PCIELLEN SDIO IRQ \n"));
+
+    if (((PSDHCD_DEVICE)context)->Type == TYPE_PCIELLEN) {
+        /* see if we interrupted */
+        intStat = READ_CONTROL_REG16((PSDHCD_DEVICE)context, INTCSR);
+        DBG_PRINT(PXA_TRACE_SDIO_INT, ("intStat: 0x%X\n", (UINT)intStat));
+        if (!(intStat & (INTCSR_LINTi1STATUS | INTCSR_LINTi2STATUS))) {
+            return IRQ_NONE;
+        }
+    }
+
+    TRACE_SIGNAL_DATA_ISR((PSDHCD_DEVICE)context, TRUE);
+        /* call OS independent ISR */
+    if (HcdSDInterrupt((PSDHCD_DEVICE)context)) {
+        retStat = IRQ_HANDLED;
+    } else {
+        retStat = IRQ_NONE;
+    }
+    TRACE_SIGNAL_DATA_ISR((PSDHCD_DEVICE)context, FALSE);
+    return retStat;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  UnmaskIrq - Unmask SD interrupts
+  Input:    pDevice - host controller
+            Mask - mask value
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+UINT16 UnmaskIrq(PSDHCD_DEVICE pDevice, UINT32 Mask)
+{
+    UINT16 ints;
+    /* protected read-modify-write */
+    spin_lock_irq(&pDevice->AddressSpinlock);
+    ints = READ_HOST_REG16(pDevice, HOST_REG_INT_SIGNAL_ENABLE);
+    ints |= Mask;
+    WRITE_HOST_REG16(pDevice, HOST_REG_INT_SIGNAL_ENABLE, ints);
+    spin_unlock_irq(&pDevice->AddressSpinlock);
+    return ints;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  MaskIrq - Mask SD interrupts
+  Input:    pDevice - host controller
+            Mask - mask value
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+UINT16 MaskIrq(PSDHCD_DEVICE pDevice, UINT32 Mask)
+{
+    UINT16 ints;
+    /* protected read-modify-write */
+    spin_lock_irq(&pDevice->AddressSpinlock);
+    ints = READ_HOST_REG16(pDevice, HOST_REG_INT_SIGNAL_ENABLE);
+    ints &= ~Mask;
+    WRITE_HOST_REG16(pDevice, HOST_REG_INT_SIGNAL_ENABLE, ints);
+    spin_unlock_irq(&pDevice->AddressSpinlock);
+    return ints;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  MaskIrqFromIsr - Mask SD interrupts, called from ISR
+  Input:    pDevice - host controller
+            Mask - mask value
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+UINT16 MaskIrqFromIsr(PSDHCD_DEVICE pDevice, UINT32 Mask)
+{
+    UINT16 ints;
+    /* protected read-modify-write */
+    spin_lock(&pDevice->AddressSpinlock);
+    ints = READ_HOST_REG16(pDevice, HOST_REG_INT_SIGNAL_ENABLE);
+    ints &= ~Mask;
+    WRITE_HOST_REG16(pDevice, HOST_REG_INT_SIGNAL_ENABLE, ints);
+    spin_unlock(&pDevice->AddressSpinlock);
+    return ints;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  UnmaskIrqFromIsr - Unmask SD interrupts
+  Input:    pDevice - host controller
+            Mask - mask value
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+UINT16 UnmaskIrqFromIsr(PSDHCD_DEVICE pDevice, UINT32 Mask)
+{
+    UINT16 ints;
+    /* protected read-modify-write */
+    spin_lock(&pDevice->AddressSpinlock);
+    ints = READ_HOST_REG16(pDevice, HOST_REG_INT_SIGNAL_ENABLE);
+    ints |= Mask;
+    WRITE_HOST_REG16(pDevice, HOST_REG_INT_SIGNAL_ENABLE, ints);
+    spin_unlock(&pDevice->AddressSpinlock);
+    return ints;
+}
+
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  GetDefaults - get the user modifiable data items
+  Input:    pDeviceContext - host controller
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void GetDefaults(PSDHCD_DEVICE pDeviceContext)
+{
+    //can't change this dynanmically: pDeviceContext->BaseClock = BaseClock;
+    pDeviceContext->TimeOut = timeout;
+    pDeviceContext->ClockSpinLimit = ClockSpinLimit;
+}
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  EnableDisableSDIOIRQ - enable SDIO interrupt detection
+  Input:    pDevice - host controller
+            Enable - enable SDIO IRQ detection
+            FromIsr - called from ISR
+  Output:
+  Return:
+  Notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void EnableDisableSDIOIRQ(PSDHCD_DEVICE pDevice, BOOL Enable, BOOL FromIsr)
+{
+    UINT16 intsEnables;
+
+    if (FromIsr) {
+        if (Enable) {
+                // isr should never re-enable
+            DBG_ASSERT(FALSE);
+        } else {
+            MaskIrqFromIsr(pDevice, HOST_REG_INT_STATUS_CARD_INT_STAT_ENABLE);
+        }
+    } else {
+        if (Enable) {
+            UnmaskIrq(pDevice, HOST_REG_INT_STATUS_CARD_INT_STAT_ENABLE);
+        } else {
+            MaskIrq(pDevice, HOST_REG_INT_STATUS_CARD_INT_STAT_ENABLE);
+        }
+    }
+
+    /* protected read-modify-write */
+    if (FromIsr) {
+        spin_lock(&pDevice->AddressSpinlock);
+    } else {
+        spin_lock_irq(&pDevice->AddressSpinlock);
+    }
+
+    intsEnables = READ_HOST_REG16(pDevice, HOST_REG_INT_STATUS_ENABLE);
+    if (Enable) {
+        intsEnables |=  HOST_REG_INT_STATUS_CARD_INT_STAT_ENABLE;
+    } else {
+        intsEnables &= ~HOST_REG_INT_STATUS_CARD_INT_STAT_ENABLE;
+    }
+
+    WRITE_HOST_REG16(pDevice, HOST_REG_INT_STATUS_ENABLE, intsEnables);
+
+    if (FromIsr) {
+        spin_unlock(&pDevice->AddressSpinlock);
+    } else {
+        spin_unlock_irq(&pDevice->AddressSpinlock);
+    }
+
+
+}
+
+/*
+ * module init
+*/
+static int __init sdio_pci_hcd_init(void) {
+    SYSTEM_STATUS err;
+    SDIO_STATUS status;
+
+    REL_PRINT(SDDBG_TRACE, ("+SDIO PCIELLEN HCD: loaded\n"));
+
+    SDLIST_INIT(&HcdContext.DeviceList);
+    status = SemaphoreInitialize(&HcdContext.DeviceListSem, 1);
+    if (!SDIO_SUCCESS(status)) {
+       return SDIOErrorToOSError(status);
+    }
+
+    /* register with the PCI bus driver */
+    err = pci_module_init(&sdio_pci_driver);
+    if (err < 0) {
+        DBG_PRINT(SDDBG_ERROR, ("SDIO PCIELLEN HCD: failed to register with system PCI bus driver, %d\n",
+                                err));
+    }
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO PCIELLEN HCD: sdio_pci_hcd_init\n"));
+    return err;
+}
+
+/*
+ * module cleanup
+*/
+static void __exit sdio_pci_hcd_cleanup(void) {
+    REL_PRINT(SDDBG_TRACE, ("+SDIO PCIELLEN HCD: unloaded\n"));
+    pci_unregister_driver(&sdio_pci_driver);
+    DBG_PRINT(SDDBG_TRACE, ("-SDIO PCIELLEN HCD: leave sdio_pci_hcd_cleanup\n"));
+}
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_DESCRIPTION(DESCRIPTION);
+MODULE_AUTHOR(AUTHOR);
+
+module_init(sdio_pci_hcd_init);
+module_exit(sdio_pci_hcd_cleanup);
+
Index: linux-2.6/drivers/sdio/hcd/pci_ellen/sdio_pciellen_hcd.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/hcd/pci_ellen/sdio_pciellen_hcd.h
@@ -0,0 +1,256 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdio_pciellen_hcd.h
+
+@abstract: include file for Tokyo Electron PCI Ellen host controller, OS independent code
+
+@notice: Copyright (c), 2004 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#ifndef __SDIO_PCIELLEN_HCD_H___
+#define __SDIO_PCIELLEN_HCD_H___
+
+#include <linux/sdio/ctsystem.h>
+#include <linux/sdio/sdio_busdriver.h>
+#include <linux/sdio/sdio_lib.h>
+#include "sdio_hcd_linux.h"
+
+enum PXA_TRACE_ENUM {
+    PXA_TRACE_CARD_INSERT = (SDDBG_TRACE + 1),
+    PXA_TRACE_DATA = (SDDBG_TRACE + 2),
+    PXA_TRACE_REQUESTS,
+    PXA_TRACE_CONFIG,
+    PXA_TRACE_MMC_INT,
+    PXA_TRACE_CLOCK,
+    PXA_TRACE_SDIO_INT,
+    PXA_TRACE_LAST
+};
+
+#define HOST_REG_BLOCK_SIZE                         0x04
+
+#define HOST_REG_BLOCK_COUNT                        0x06
+
+#define HOST_REG_ARGUMENT                           0x08
+
+#define HOST_REG_TRANSFER_MODE                      0x0C
+#define HOST_REG_TRANSFER_MODE_MULTI_BLOCK          (1 << 5)
+#define HOST_REG_TRANSFER_MODE_READ                 (1 << 4)
+#define HOST_REG_TRANSFER_MODE_AUTOCMD12            (1 << 2)
+#define HOST_REG_TRANSFER_MODE_BLOCKCOUNT_ENABLE    (1 << 1)
+#define HOST_REG_TRANSFER_MODE_DMA_ENABLE           (1 << 0)
+
+#define HOST_REG_COMMAND_REGISTER                   0x0E
+#define HOST_REG_COMMAND_REGISTER_CMD_SHIFT         8
+#define HOST_REG_COMMAND_REGISTER_DATA_PRESENT      (1 << 5)
+#define HOST_REG_COMMAND_REGISTER_CMD_INDEX_CHECK_ENABLE (1 << 4)
+#define HOST_REG_COMMAND_REGISTER_CRC_CHECK_ENABLE  (1 << 3)
+
+
+#define HOST_REG_RESPONSE                           0x10  /* 32-bit reguisters 0x10 through 0x1C */
+
+#define HOST_REG_BUFFER_DATA_PORT                   0x20
+
+#define HOST_REG_PRESENT_STATE                      0x24
+#define HOST_REG_PRESENT_STATE_WRITE_ENABLED        (1 << 19)
+#define HOST_REG_PRESENT_STATE_CARD_DETECT          (1 << 18)
+#define HOST_REG_PRESENT_STATE_CARD_STATE_STABLE    (1 << 17)
+#define HOST_REG_PRESENT_STATE_CARD_INSERTED        (1 << 16)
+#define HOST_REG_PRESENT_STATE_BUFFER_READ_ENABLE   (1 << 11)
+#define HOST_REG_PRESENT_STATE_BUFFER_WRITE_ENABLE  (1 << 10)
+#define HOST_REG_PRESENT_STATE_BUFFER_READ_TRANSFER_ACTIVE (1 << 9)
+#define HOST_REG_PRESENT_STATE_BUFFER_WRITE_TRANSFER_ACTIVE (1 << 8)
+#define HOST_REG_PRESENT_STATE_BUFFER_DAT_LINE_ACTIVE (1 << 2)
+#define HOST_REG_PRESENT_STATE_BUFFER_COMMAND_INHIBIT_DAT (1 << 1)
+#define HOST_REG_PRESENT_STATE_BUFFER_COMMAND_INHIBIT_CMD (1 << 0)
+
+
+#define HOST_REG_CONTROL                        0x28
+#define HOST_REG_CONTROL_LED_ON                 (1 << 0)
+#define HOST_REG_CONTROL_1BIT_WIDTH             0x00
+#define HOST_REG_CONTROL_4BIT_WIDTH             (1 << 1)
+#define HOST_REG_CONTROL_HI_SPEED               (1 << 2)
+
+#define HOST_REG_POWER_CONTROL                      0x29
+#define HOST_REG_POWER_CONTROL_ON                   (1 << 0)
+#define HOST_REG_POWER_CONTROL_VOLT_3_3             (7 << 1)
+#define HOST_REG_POWER_CONTROL_VOLT_3_0             (6 << 1)
+#define HOST_REG_POWER_CONTROL_VOLT_1_8             (5 << 1)
+
+#define HOST_REG_BLOCK_GAP                          0x2A
+#define HOST_REG_INT_DETECT_AT_BLOCK_GAP             (1 << 3)
+
+#define HOST_REG_CLOCK_CONTROL                      0x2C
+#define HOST_REG_CLOCK_CONTROL_CLOCK_ENABLE         (1 << 0)
+#define HOST_REG_CLOCK_CONTROL_CLOCK_STABLE         (1 << 1)
+#define HOST_REG_CLOCK_CONTROL_SD_ENABLE            (1 << 2)
+
+#define HOST_REG_TIMEOUT_CONTROL                    0x2E
+#define HOST_REG_TIMEOUT_CONTROL_DEFAULT            0x0C
+
+#define HOST_REG_SW_RESET                           0x2F
+#define HOST_REG_SW_RESET_ALL                       (1 << 0)
+#define HOST_REG_SW_RST_CMD_LINE                    (1 << 1)
+#define HOST_REG_SW_RST_DAT_LINE                    (1 << 2)
+
+#define HOST_REG_NORMAL_INT_STATUS                  0x30
+#define HOST_REG_NORMAL_INT_STATUS_ERROR            (1 << 15)
+#define HOST_REG_NORMAL_INT_STATUS_CARD_INTERRUPT   (1 << 8)
+#define HOST_REG_NORMAL_INT_STATUS_CARD_REMOVAL     (1 << 7)
+#define HOST_REG_NORMAL_INT_STATUS_CARD_INSERT      (1 << 6)
+#define HOST_REG_NORMAL_INT_STATUS_BUFFER_READ_RDY  (1 << 5)
+#define HOST_REG_NORMAL_INT_STATUS_BUFFER_WRITE_RDY (1 << 4)
+#define HOST_REG_NORMAL_INT_STATUS_DMA_INT          (1 << 3)
+#define HOST_REG_NORMAL_INT_STATUS_BLOCK_GAP        (1 << 2)
+#define HOST_REG_NORMAL_INT_STATUS_TRANSFER_COMPLETE (1 << 1)
+#define HOST_REG_NORMAL_INT_STATUS_CMD_COMPLETE     (1 << 0)
+#define HOST_REG_NORMAL_INT_STATUS_ALL_ERR          0xFFFF
+
+#define HOST_REG_ERROR_INT_STATUS                   0x32
+#define HOST_REG_ERROR_INT_STATUS_VENDOR_MASK       0xF000
+#define HOST_REG_ERROR_INT_STATUS_VENDOR_SHIFT      12
+#define HOST_REG_ERROR_INT_STATUS_AUTOCMD12ERR      (1 << 8)
+#define HOST_REG_ERROR_INT_STATUS_CURRENTLIMITERR   (1 << 7)
+#define HOST_REG_ERROR_INT_STATUS_DATAENDBITERR     (1 << 6)
+#define HOST_REG_ERROR_INT_STATUS_DATACRCERR        (1 << 5)
+#define HOST_REG_ERROR_INT_STATUS_DATATIMEOUTERR    (1 << 4)
+#define HOST_REG_ERROR_INT_STATUS_CMDINDEXERR       (1 << 3)
+#define HOST_REG_ERROR_INT_STATUS_CMDENDBITERR      (1 << 2)
+#define HOST_REG_ERROR_INT_STATUS_CRCERR            (1 << 1)
+#define HOST_REG_ERROR_INT_STATUS_CMDTIMEOUTERR     (1 << 0)
+#define HOST_REG_ERROR_INT_STATUS_ALL_ERR           0xFFFF
+
+#define HOST_REG_INT_STATUS_ENABLE                  0x34
+#define HOST_REG_INT_STATUS_CARD_INT_STAT_ENABLE    (1 << 8)
+#define HOST_REG_INT_STATUS_CARD_REMOVAL_ENABLE     (1 << 7)
+#define HOST_REG_INT_STATUS_CARD_INSERT_ENABLE      (1 << 6)
+#define HOST_REG_INT_STATUS_BUFFER_READ_RDY_ENABLE  (1 << 5)
+#define HOST_REG_INT_STATUS_BUFFER_WRITE_RDY_ENABLE (1 << 4)
+#define HOST_REG_INT_STATUS_DMA_ENABLE              (1 << 3)
+#define HOST_REG_INT_STATUS_BLOCK_GAP_ENABLE        (1 << 2)
+#define HOST_REG_INT_STATUS_TRANSFER_COMPLETE_ENABLE (1 << 1)
+#define HOST_REG_INT_STATUS_CMD_COMPLETE_ENABLE     (1 << 0)
+#define HOST_REG_INT_STATUS_ALL                      0x00F3
+#define HOST_REG_INT_STATUS_ALLOW_INSERT_REMOVE_ONLY 0x00C0
+
+#define HOST_REG_ERR_STATUS_ENABLE                  0x36
+/* same bits as HOST_REG_ERROR_INT_STATUS */
+
+#define HOST_REG_INT_SIGNAL_ENABLE                  0x38
+/* same bits as HOST_REG_INT_STATUS_ENABLE */
+
+#define HOST_REG_INT_ERR_SIGNAL_ENABLE              0x3A
+/* same bits as HOST_REG_ERR_STATUS_ENABLE */
+
+#define HOST_REG_CAPABILITIES                       0x40
+#define HOST_REG_CAPABILITIES_VOLT_1_8              (1 << 26)
+#define HOST_REG_CAPABILITIES_VOLT_3_0              (1 << 25)
+#define HOST_REG_CAPABILITIES_VOLT_3_3              (1 << 24)
+#define HOST_REG_CAPABILITIES_SUSPEND_RESUME        (1 << 23)
+#define HOST_REG_CAPABILITIES_DMA                   (1 << 22)
+#define HOST_REG_CAPABILITIES_HIGH_SPEED            (1 << 21)
+#define HOST_REG_CAPABILITIES_SUSPEND_RESUME        (1 << 23)
+#define HOST_REG_CAPABILITIES_MAX_BLOCK_LEN_MASK    0x30000
+#define HOST_REG_CAPABILITIES_MAX_BLOCK_LEN_SHIFT   16
+#define HOST_REG_CAPABILITIES_CLOCK_MASK            0x3F00
+#define HOST_REG_CAPABILITIES_CLOCK_SHIFT           8
+#define HOST_REG_CAPABILITIES_TIMEOUT_CLOCK_UNITS   (1 << 7)
+#define HOST_REG_CAPABILITIES_TIMEOUT_FREQ_MASK     0x3F
+#define HOST_REG_CAPABILITIES_TIMEOUT_FREQ_SHIFT    0
+
+#define HOST_REG_MAX_CURRENT_CAPABILITIES           0x48
+#define HOST_REG_MAX_CURRENT_CAPABILITIES_1_8_MASK  0xFF0000
+#define HOST_REG_MAX_CURRENT_CAPABILITIES_1_8_SHIFT 16
+#define HOST_REG_MAX_CURRENT_CAPABILITIES_3_0_MASK  0x00FF00
+#define HOST_REG_MAX_CURRENT_CAPABILITIES_3_0_SHIFT 8
+#define HOST_REG_MAX_CURRENT_CAPABILITIES_3_3_MASK  0x0000FF
+#define HOST_REG_MAX_CURRENT_CAPABILITIES_3_3_SHIFT 0
+#define HOST_REG_MAX_CURRENT_CAPABILITIES_SCALER    4
+
+#define HOST_REG_VERSION                            0xFE
+#define HOST_REG_VERSION_SPEC_VERSION_MASK          0xFF
+#define HOST_REG_VERSION_VENDOR_VERSION_MASK        0xFF00
+#define HOST_REG_VERSION_VENDOR_VERSION_SHIFT       8
+
+#define SDIO_BD_MAX_SLOTS                           24
+#define SDIO_SD_MAX_BLOCKS                      ((UINT)0xFFFF)
+#define SDMMC_RESP_TIMEOUT_CLOCKS          64
+#define SDMMC_DATA_TIMEOUT_CLOCKS          0xFFFF
+
+#define SPI_ENABLE_WITH_CRC  (MMC_SPI_CS_ENABLE | MMC_SPI_ENABLE | \
+                              MMC_SPI_CRC_ENABLE | MMC_SPI_SEL_CS0)
+#define SPI_ENABLE_NO_CRC  (MMC_SPI_CS_ENABLE | MMC_SPI_ENABLE | \
+                            MMC_SPI_SEL_CS0)
+
+#define SD_DEFAULT_RESPONSE_BYTES 6
+#define SD_R2_RESPONSE_BYTES      16
+
+#define SD_CLOCK_MAX_ENTRIES 9
+
+typedef struct _SD_CLOCK_TBL_ENTRY {
+    INT       ClockRateDivisor;  /* divisor */
+    UINT16    RegisterValue;     /* register value for clock divisor */
+}SD_CLOCK_TBL_ENTRY;
+
+/* driver wide data, this driver only supports one device,
+ * so we include the per device data here also */
+typedef struct _SDHCD_DRIVER_CONTEXT {
+    PTEXT        pDescription;       /* human readable device decsription */
+    SDLIST       DeviceList;         /* the list of current devices handled by this driver */
+    OS_SEMAPHORE DeviceListSem;      /* protection for the DeviceList */
+    UINT         DeviceCount;        /* number of devices currently installed */
+}SDHCD_DRIVER_CONTEXT, *PSDHCD_DRIVER_CONTEXT;
+
+
+/* prototypes */
+SDIO_STATUS HcdRequest(PSDHCD pHcd);
+SDIO_STATUS HcdConfig(PSDHCD pHcd, PSDCONFIG pReq);
+SDIO_STATUS HcdInitialize(PSDHCD_DEVICE pDeviceContext);
+void HcdDeinitialize(PSDHCD_DEVICE pDeviceContext);
+BOOL HcdSDInterrupt(PSDHCD_DEVICE pDeviceContext);
+SDIO_STATUS QueueEventResponse(PSDHCD_DEVICE pDeviceContext, INT WorkItemID);
+BOOL HcdTransferTxData(PSDHCD_DEVICE pDevice, PSDREQUEST pReq);
+void HcdTransferRxData(PSDHCD_DEVICE pDevice, PSDREQUEST pReq);
+void SetPowerOn(PSDHCD_DEVICE pDeviceContext, BOOL On);
+UINT16 MaskIrq(PSDHCD_DEVICE pDevice, UINT32 Mask);
+UINT16 UnmaskIrq(PSDHCD_DEVICE pDevice, UINT32 Mask);
+UINT16 MaskIrqFromIsr(PSDHCD_DEVICE pDevice, UINT32 Mask);
+UINT16 UnmaskIrqFromIsr(PSDHCD_DEVICE pDevice, UINT32 Mask);
+void EnableDisableSDIOIRQ(PSDHCD_DEVICE pDevice, BOOL Enable, BOOL FromIsr);
+
+
+#endif /* __SDIO_PCIELLEN_HCD_H___ */
Index: linux-2.6/drivers/sdio/lib/Makefile
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/lib/Makefile
@@ -0,0 +1,6 @@
+#
+# SDIO stack library Makefile
+#
+obj-$(CONFIG_SDIO) += sdio_lib.o
+sdio_lib-objs := sdio_lib_c.o sdio_lib_os.o
+
Index: linux-2.6/drivers/sdio/lib/_sdio_lib.h
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/lib/_sdio_lib.h
@@ -0,0 +1,50 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: _sdio_lib.h
+
+@abstract: SDIO Lib internal include
+
+#notes:
+
+@notice: Copyright (c), 2004-2006 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#ifndef ___SDIO_LIB_H___
+#define ___SDIO_LIB_H___
+
+#endif /* ___SDIO_LIB_H___*/
Index: linux-2.6/drivers/sdio/lib/sdio_lib_c.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/lib/sdio_lib_c.c
@@ -0,0 +1,908 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdio_lib_c.c
+
+@abstract: OS independent SDIO library functions
+@category abstract: Support_Reference Support Functions.
+
+@notes: Support functions for device I/O
+
+@notice: Copyright (c), 2004-2005 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define MODULE_NAME  SDLIB_
+
+#include <linux/sdio/ctsystem.h>
+#include <linux/sdio/sdio_busdriver.h>
+#include <linux/sdio/_sdio_defs.h>
+#include <linux/sdio/sdio_lib.h>
+#include "_sdio_lib.h"
+
+#define _Cmd52WriteByteCommon(pDev, Address, pValue) \
+                _SDLIB_IssueCMD52((pDev),0,(Address),(pValue),1,TRUE)
+#define _Cmd52ReadByteCommon(pDev, Address, pValue) \
+                _SDLIB_IssueCMD52((pDev),0,(Address),pValue,1,FALSE)
+#define _Cmd52ReadMultipleCommon(pDev, Address, pBuf,length) \
+                _SDLIB_IssueCMD52((pDev),0,(Address),(pBuf),(length),FALSE)
+
+/* inline version */
+static INLINE void _iSDLIB_SetupCMD52Request(UINT8         FuncNo,
+                                             UINT32        Address,
+                                             BOOL          Write,
+                                             UINT8         WriteData,
+                                             PSDREQUEST    pRequest) {
+    if (Write) {
+        SDIO_SET_CMD52_ARG(pRequest->Argument,CMD52_WRITE,
+                           FuncNo,
+                           CMD52_NORMAL_WRITE,Address,WriteData);
+    } else {
+        SDIO_SET_CMD52_ARG(pRequest->Argument,CMD52_READ,FuncNo,0,Address,0x00);
+    }
+
+    pRequest->Flags = SDREQ_FLAGS_RESP_SDIO_R5;
+    pRequest->Command = CMD52;
+}
+
+/**++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Setup cmd52 requests
+
+  @function name: SDLIB_SetupCMD52Request
+  @prototype: void SDLIB_SetupCMD52Request(UINT8         FuncNo,
+                                           UINT32        Address,
+                                           BOOL          Write,
+                                           UINT8         WriteData,
+                                           PSDREQUEST    pRequest)
+  @category: PD_Reference
+
+  @input:  FunctionNo - function number.
+  @input:  Address - I/O address, 17-bit register address.
+  @input:  Write  - TRUE if a write operation, FALSE for reads.
+  @input:  WriteData - write data, byte to write if write operation.
+
+  @output: pRequest - request is updated with cmd52 parameters
+
+  @return: none
+
+  @notes: This function does not perform any I/O. For register reads, the completion
+          routine can use the SD_R5_GET_READ_DATA() macro to extract the register value.
+          The routine should also extract the response flags using the SD_R5_GET_RESP_FLAGS()
+          macro and check the flags with the SD_R5_ERRORS mask.
+
+  @example: Getting the register value from the completion routine:
+          flags = SD_R5_GET_RESP_FLAGS(pRequest->Response);
+          if (flags & SD_R5_ERRORS) {
+             ... errors
+          } else {
+             registerValue = SD_R5_GET_READ_DATA(pRequest->Response);
+          }
+
+  @see also: SDLIB_IssueCMD52
+  @see also: SDDEVICE_CALL_REQUEST_FUNC
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void _SDLIB_SetupCMD52Request(UINT8         FuncNo,
+                              UINT32        Address,
+                              BOOL          Write,
+                              UINT8         WriteData,
+                              PSDREQUEST    pRequest)
+{
+    _iSDLIB_SetupCMD52Request(FuncNo,Address,Write,WriteData,pRequest);
+}
+
+/**++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Issue a CMD52 to read or write a register
+
+  @function name: SDLIB_IssueCMD52
+  @prototype: SDIO_STATUS SDLIB_IssueCMD52(PSDDEVICE     pDevice,
+                                           UINT8         FuncNo,
+                                           UINT32        Address,
+                                           PUINT8        pData,
+                                           INT           ByteCount,
+                                           BOOL          Write)
+  @category: PD_Reference
+  @input: pDevice - the device that is the target of the command.
+  @input: FunctionNo - function number of the target.
+  @input: Address - 17-bit register address.
+  @input: ByteCount - number of bytes to read or write,
+  @input: Write - TRUE if a write operation, FALSE for reads.
+  @input: pData - data buffer for writes.
+
+  @output: pData - data buffer for writes.
+
+  @return: SDIO Status
+
+  @notes:  This function will allocate a request and issue multiple byte reads or writes
+           to satisfy the ByteCount requested.  This function is fully synchronous and will block
+           the caller.
+
+  @see also: SDLIB_SetupCMD52Request
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS _SDLIB_IssueCMD52(PSDDEVICE     pDevice,
+                              UINT8         FuncNo,
+                              UINT32        Address,
+                              PUINT8        pData,
+                              INT           ByteCount,
+                              BOOL          Write)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+
+    PSDREQUEST  pReq = NULL;
+
+    pReq = SDDeviceAllocRequest(pDevice);
+
+    if (NULL == pReq) {
+        return SDIO_STATUS_NO_RESOURCES;
+    }
+
+    while (ByteCount) {
+        _iSDLIB_SetupCMD52Request(FuncNo,Address,Write,*pData,pReq);
+        status = SDDEVICE_CALL_REQUEST_FUNC(pDevice,pReq);
+        if (!SDIO_SUCCESS(status)) {
+            break;
+        }
+
+        status = ConvertCMD52ResponseToSDIOStatus(SD_R5_GET_RESP_FLAGS(pReq->Response));
+        if (!SDIO_SUCCESS(status)) {
+            DBG_PRINT(SDDBG_TRACE, ("SDIO Library: CMD52 resp error: 0x%X \n",
+                                    SD_R5_GET_RESP_FLAGS(pReq->Response)));
+            break;
+        }
+        if (!Write) {
+                /* store the byte */
+            *pData =  SD_R5_GET_READ_DATA(pReq->Response);
+        }
+        pData++;
+        Address++;
+        ByteCount--;
+    }
+
+    SDDeviceFreeRequest(pDevice,pReq);
+    return status;
+}
+
+
+
+/**++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Find a device's tuple.
+
+  @function name: SDLIB_FindTuple
+  @prototype: SDIO_STATUS SDLIB_FindTuple(PSDDEVICE  pDevice,
+                                          UINT8      Tuple,
+                                          UINT32     *pTupleScanAddress,
+                                          PUINT8     pBuffer,
+                                          UINT8      *pLength)
+
+  @category: PD_Reference
+  @input: pDevice - the device that is the target of the command.
+  @input: Tuple - 8-bit ID of tuple to find
+  @input: pTupleScanAddress - On entry pTupleScanAddress is the adddress to start scanning
+  @input: pLength - length of pBuffer
+
+  @output: pBuffer - storage for tuple
+  @output: pTupleScanAddress - address of the next tuple
+  @output: pLength - length of tuple read
+
+  @return: status
+
+  @notes: It is possible to have the same tuple ID multiple times with different lengths. This function
+          blocks and is fully synchronous.
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS _SDLIB_FindTuple(PSDDEVICE  pDevice,
+                             UINT8      Tuple,
+                             UINT32     *pTupleScanAddress,
+                             PUINT8     pBuffer,
+                             UINT8      *pLength)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    UINT32      scanStart = *pTupleScanAddress;
+    UINT8       tupleCode;
+    UINT8       tupleLink;
+
+        /* sanity check */
+    if (scanStart < SDIO_CIS_AREA_BEGIN) {
+        return SDIO_STATUS_CIS_OUT_OF_RANGE;
+    }
+
+    while (TRUE) {
+            /* check for end */
+        if (scanStart > SDIO_CIS_AREA_END) {
+            status = SDIO_STATUS_TUPLE_NOT_FOUND;
+            break;
+        }
+            /* get the code */
+        status = _Cmd52ReadByteCommon(pDevice, scanStart, &tupleCode);
+        if (!SDIO_SUCCESS(status)) {
+            break;
+        }
+        if (CISTPL_END == tupleCode) {
+                /* found the end */
+            status = SDIO_STATUS_TUPLE_NOT_FOUND;
+            break;
+        }
+            /* bump past tuple code */
+        scanStart++;
+            /* get the tuple link value */
+        status = _Cmd52ReadByteCommon(pDevice, scanStart, &tupleLink);
+        if (!SDIO_SUCCESS(status)) {
+            break;
+        }
+            /* bump past tuple link*/
+        scanStart++;
+            /* check tuple we just found */
+        if (tupleCode == Tuple) {
+             DBG_PRINT(SDDBG_TRACE, ("SDIO Library: Tuple:0x%2.2X Found at Address:0x%X, TupleLink:0x%X \n",
+                                     Tuple, (scanStart - 2), tupleLink));
+            if (tupleLink != CISTPL_LINK_END) {
+                    /* return the next scan address to the caller */
+                *pTupleScanAddress = scanStart + tupleLink;
+            } else {
+                    /* the tuple link is an end marker */
+                *pTupleScanAddress = 0xFFFFFFFF;
+            }
+                /* go get the tuple */
+            status = _Cmd52ReadMultipleCommon(pDevice, scanStart,pBuffer,min(*pLength,tupleLink));
+            if (SDIO_SUCCESS(status)) {
+                    /* set the actual return length */
+                *pLength = min(*pLength,tupleLink);
+            }
+                /* break out of loop */
+            break;
+        }
+            /*increment past this entire tuple */
+        scanStart += tupleLink;
+    }
+
+    return status;
+}
+
+/**++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Issue an SDIO configuration command.
+
+  @function name: SDLIB_IssueConfig
+  @prototype: SDIO_STATUS _SDLIB_IssueConfig(PSDDEVICE        pDevice,
+                                             SDCONFIG_COMMAND Command,
+                                             PVOID            pData,
+                                             INT              Length)
+
+  @category: PD_Reference
+  @input:  pDevice - the device that is the target of the command.
+  @input:  Command - command to send, see example.
+  @input:  pData - command's data
+  @input:  Length length of pData
+
+  @output: pData - updated on commands that return data.
+
+  @return: SDIO Status
+
+  @example: Command and data pairs:
+            Type                               Data
+            SDCONFIG_GET_WP             SDCONFIG_WP_VALUE
+            SDCONFIG_SEND_INIT_CLOCKS   none
+            SDCONFIG_SDIO_INT_CTRL      SDCONFIG_SDIO_INT_CTRL_DATA
+            SDCONFIG_SDIO_REARM_INT     none
+            SDCONFIG_BUS_MODE_CTRL      SDCONFIG_BUS_MODE_DATA
+            SDCONFIG_POWER_CTRL         SDCONFIG_POWER_CTRL_DATA
+
+  @notes:
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS _SDLIB_IssueConfig(PSDDEVICE        pDevice,
+                               SDCONFIG_COMMAND Command,
+                               PVOID            pData,
+                               INT              Length)
+{
+    SDCONFIG  configHdr;
+    SET_SDCONFIG_CMD_INFO(&configHdr,Command,pData,Length);
+    return SDDEVICE_CALL_CONFIG_FUNC(pDevice,&configHdr);
+}
+
+/**++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Set function block size
+
+  @function name: SDLIB_SetFunctionBlockSize
+  @prototype: SDIO_STATUS SDLIB_SetFunctionBlockSize(PSDDEVICE        pDevice,
+                                                     UINT16           BlockSize)
+
+  @category: PD_Reference
+  @input:  pDevice - the device that is the target of the command.
+  @input:  BlockSize - block size to set in function
+
+  @output: none
+
+  @return: SDIO Status
+
+  @notes:  Issues CMD52 to set the block size.  This function is fully synchronous and may
+           block.
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS _SDLIB_SetFunctionBlockSize(PSDDEVICE        pDevice,
+                                        UINT16           BlockSize)
+{
+    UINT8   data[2];
+
+      /* endian safe */
+    data[0] = (UINT8)BlockSize;
+    data[1] = (UINT8)(BlockSize >> 8);
+        /* write the function blk size control register */
+    return _SDLIB_IssueCMD52(pDevice,
+                             0,    /* function 0 register space */
+                             FBR_FUNC_BLK_SIZE_LOW_OFFSET(CalculateFBROffset(
+                             SDDEVICE_GET_SDIO_FUNCNO(pDevice))),
+                             data,
+                             2,
+                             TRUE);
+}
+
+/**++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Print a buffer to the debug output
+
+  @function name: SDLIB_PrintBuffer
+  @prototype: void SDLIB_PrintBuffer(PUCHAR pBuffer, INT Length, PTEXT pDescription)
+  @category: Support_Reference
+
+  @input:  pBuffer - Hex buffer to be printed.
+  @input:  Length - length of pBuffer.
+  @input:  pDescription - String title to be printed above the dump.
+
+  @output: none
+
+  @return: none
+
+  @notes:  Prints the buffer by converting to ASCII and using REL_PRINT() with 16
+           bytes per line.
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void _SDLIB_PrintBuffer(PUCHAR pBuffer, INT Length, PTEXT pDescription)
+{
+    TEXT  line[49];
+    TEXT  address[5];
+    TEXT  ascii[17];
+    TEXT  temp[5];
+    INT   i;
+    UCHAR num;
+    USHORT offset = 0;
+
+    REL_PRINT(0,
+              ("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"));
+    if (pDescription != NULL) {
+        REL_PRINT(0, ("Description: %s \n\n",pDescription));
+    } else {
+        REL_PRINT(0, ("Description: NONE \n\n"));
+    }
+    REL_PRINT(0,
+              ("Offset                   Data                               ASCII        \n"));
+    REL_PRINT(0,
+              ("--------------------------------------------------------------------------\n"));
+
+    while (Length) {
+        line[0] = (TEXT)0;
+        ascii[0] = (TEXT)0;
+        address[0] = (TEXT)0;
+        sprintf(address,"%4.4X",offset);
+        for (i = 0; i < 16; i++) {
+            if (Length != 0) {
+                num = *pBuffer;
+                sprintf(temp,"%2.2X ",num);
+                strcat(line,temp);
+                if ((num >= 0x20) && (num <= 0x7E)) {
+                    sprintf(temp,"%c",*pBuffer);
+                } else {
+                    sprintf(temp,"%c",0x2e);
+                }
+                strcat(ascii,temp);
+                pBuffer++;
+                Length--;
+            } else {
+                    /* pad partial line with spaces */
+                strcat(line,"   ");
+                strcat(ascii," ");
+            }
+        }
+        REL_PRINT(0,("%s    %s   %s\n", address, line, ascii));
+        offset += 16;
+    }
+    REL_PRINT(0,
+              ("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"));
+
+}
+
+/**++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get default operational current
+
+  @function name: SDLIB_GetDefaultOpCurrent
+  @prototype: SDIO_STATUS SDLIB_GetDefaultOpCurrent(PSDDEVICE  pDevice, SD_SLOT_CURRENT *pOpCurrent)
+  @category: PD_Reference
+
+  @input: pDevice - the device that is the target of the command.
+
+  @output: pOpCurrent - operational current in mA.
+
+  @return: SDIO_STATUS
+
+  @notes:  This routine reads the function's CISTPL_FUNCE tuple for the default operational
+           current. For SDIO 1.0 devices this value is read from the 8-bit TPLFE_OP_MAX_PWR
+           field.  For SDIO 1.1 devices, the HP MAX power field is used only if the device is
+           operating in HIPWR mode. Otherwise the 8-bit TPLFE_OP_MAX_PWR field is used.
+           Some systems may restrict high power/current mode and force cards to operate in a
+           legacy (< 200mA) mode.  This function is fully synchronous and will block the caller.
+
+   @example: Getting the default operational current for this function:
+            // get default operational current
+       status = SDLIB_GetDefaultOpCurrent(pDevice, &slotCurrent);
+       if (!SDIO_SUCCESS(status)) {
+           .. failed
+       }
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS _SDLIB_GetDefaultOpCurrent(PSDDEVICE  pDevice, SD_SLOT_CURRENT *pOpCurrent)
+{
+    UINT32              nextTpl;
+    UINT8               tplLength;
+    struct SDIO_FUNC_EXT_FUNCTION_TPL_1_1 funcTuple;
+    SDIO_STATUS         status;
+
+      /* get the FUNCE tuple */
+    nextTpl = SDDEVICE_GET_SDIO_FUNC_CISPTR(pDevice);
+    tplLength = sizeof(funcTuple);
+        /* go get the function Extension tuple */
+    status = _SDLIB_FindTuple(pDevice,
+                              CISTPL_FUNCE,
+                              &nextTpl,
+                              (PUINT8)&funcTuple,
+                              &tplLength);
+
+    if (!SDIO_SUCCESS(status)) {
+        DBG_PRINT(SDDBG_ERROR, ("SDLIB_GetDefaultOpCurrent: Failed to get FuncE Tuple: %d \n", status));
+        return status;
+    }
+       /* use the operational power (8-bit) value of current in mA as default*/
+    *pOpCurrent = funcTuple.CommonInfo.OpMaxPwr;
+    if ((tplLength >= sizeof(funcTuple)) && (SDDEVICE_IS_SDIO_REV_GTEQ_1_10(pDevice))) {
+            /* we have a 1.1 tuple */
+             /* check for HIPWR mode */
+        if (SDDEVICE_GET_CARD_FLAGS(pDevice) & CARD_HIPWR) {
+                /* use the maximum operational power (16 bit ) from the tuple */
+            *pOpCurrent = CT_LE16_TO_CPU_ENDIAN(funcTuple.HiPwrMaxPwr);
+        }
+    }
+    return SDIO_STATUS_SUCCESS;
+}
+
+
+static INLINE void FreeMessageBlock(PSDMESSAGE_QUEUE pQueue, PSDMESSAGE_BLOCK pMsg) {
+    SDListInsertHead(&pQueue->FreeMessageList, &pMsg->SDList);
+}
+static INLINE void QueueMessageBlock(PSDMESSAGE_QUEUE pQueue, PSDMESSAGE_BLOCK pMsg) {
+    SDListInsertTail(&pQueue->MessageList, &pMsg->SDList);
+}
+static INLINE void QueueMessageToHead(PSDMESSAGE_QUEUE pQueue, PSDMESSAGE_BLOCK pMsg) {
+    SDListInsertHead(&pQueue->MessageList, &pMsg->SDList);
+}
+
+static INLINE PSDMESSAGE_BLOCK GetFreeMessageBlock(PSDMESSAGE_QUEUE pQueue) {
+    PSDLIST pItem = SDListRemoveItemFromHead(&pQueue->FreeMessageList);
+    if (pItem != NULL) {
+        return CONTAINING_STRUCT(pItem, SDMESSAGE_BLOCK , SDList);
+    }
+    return NULL;
+}
+static INLINE PSDMESSAGE_BLOCK GetQueuedMessage(PSDMESSAGE_QUEUE pQueue) {
+    PSDLIST pItem = SDListRemoveItemFromHead(&pQueue->MessageList);
+    if (pItem != NULL) {
+        return CONTAINING_STRUCT(pItem, SDMESSAGE_BLOCK , SDList);
+    }
+    return NULL;
+}
+
+/**++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Create a message queue
+
+  @function name: SDLIB_CreateMessageQueue
+  @prototype: PSDMESSAGE_QUEUE SDLIB_CreateMessageQueue(INT MaxMessages, INT MaxMessageLength)
+  @category: Support_Reference
+
+  @input: MaxMessages - Maximum number of messages this queue supports
+  @input: MaxMessageLength - Maximum size of each message
+
+  @return: Message queue object, NULL on failure
+
+  @notes:  This function creates a simple first-in-first-out message queue.  The caller must determine
+           the maximum number of messages the queue supports and the size of each message.  This
+           function will pre-allocate memory for each message. A producer of data posts a message
+           using SDLIB_PostMessage with a user defined data structure. A consumer of this data
+           can retrieve the message (in FIFO order) using SDLIB_GetMessage. A message queue does not
+           provide a signaling mechanism for notifying a consumer of data. Notifying a consumer is
+           user defined.
+
+  @see also: SDLIB_DeleteMessageQueue, SDLIB_GetMessage, SDLIB_PostMessage.
+
+  @example: Creating a message queue:
+       typedef struct _MyMessage {
+           UINT8 Code;
+           PVOID pDataBuffer;
+       } MyMessage;
+            // create message queue, 16 messages max.
+       pMsgQueue = SDLIB_CreateMessageQueue(16,sizeof(MyMessage));
+       if (NULL == pMsgQueue) {
+           .. failed
+       }
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+PSDMESSAGE_QUEUE _CreateMessageQueue(INT MaxMessages, INT MaxMessageLength)
+{
+    PSDMESSAGE_QUEUE pQueue = NULL;
+    SDIO_STATUS      status = SDIO_STATUS_SUCCESS;
+    INT              ii;
+    PSDMESSAGE_BLOCK pMsg;
+
+    do {
+        pQueue = (PSDMESSAGE_QUEUE)KernelAlloc(sizeof(SDMESSAGE_QUEUE));
+
+        if (NULL == pQueue) {
+            status = SDIO_STATUS_NO_RESOURCES;
+            break;
+        }
+        SDLIST_INIT(&pQueue->MessageList);
+        SDLIST_INIT(&pQueue->FreeMessageList);
+        pQueue->MaxMessageLength = MaxMessageLength;
+        status = CriticalSectionInit(&pQueue->MessageCritSection);
+        if (!SDIO_SUCCESS(status)) {
+            break;
+        }
+            /* allocate message blocks */
+        for (ii = 0; ii < MaxMessages; ii++) {
+            pMsg = (PSDMESSAGE_BLOCK)KernelAlloc(sizeof(SDMESSAGE_BLOCK) + MaxMessageLength -1);
+            if (NULL == pMsg) {
+                break;
+            }
+            FreeMessageBlock(pQueue, pMsg);
+        }
+
+        if (0 == ii) {
+            status = SDIO_STATUS_NO_RESOURCES;
+            break;
+        }
+
+    } while (FALSE);
+
+    if (!SDIO_SUCCESS(status)) {
+        if (pQueue != NULL) {
+            _DeleteMessageQueue(pQueue);
+            pQueue = NULL;
+        }
+    }
+    return pQueue;
+}
+
+/**++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Delete a message queue
+
+  @function name: SDLIB_DeleteMessageQueue
+  @prototype: void SDLIB_DeleteMessageQueue(PSDMESSAGE_QUEUE pQueue)
+  @category: Support_Reference
+
+  @input: pQueue - message queue to delete
+
+  @notes: This function flushes the message queue and frees all memory allocated for
+          messages.
+
+  @see also: SDLIB_CreateMessageQueue
+
+  @example: Deleting a message queue:
+       if (pMsgQueue != NULL) {
+            SDLIB_DeleteMessageQueue(pMsgQueue);
+       }
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void _DeleteMessageQueue(PSDMESSAGE_QUEUE pQueue)
+{
+    PSDMESSAGE_BLOCK pMsg;
+    SDIO_STATUS     status;
+    CT_DECLARE_IRQ_SYNC_CONTEXT();
+
+    status = CriticalSectionAcquireSyncIrq(&pQueue->MessageCritSection);
+
+        /* cleanup free list */
+    while (1) {
+        pMsg = GetFreeMessageBlock(pQueue);
+        if (pMsg != NULL) {
+            KernelFree(pMsg);
+        } else {
+            break;
+        }
+    }
+        /* cleanup any in the queue */
+    while (1) {
+        pMsg = GetQueuedMessage(pQueue);
+        if (pMsg != NULL) {
+            KernelFree(pMsg);
+        } else {
+            break;
+        }
+    }
+
+    status = CriticalSectionReleaseSyncIrq(&pQueue->MessageCritSection);
+    CriticalSectionDelete(&pQueue->MessageCritSection);
+    KernelFree(pQueue);
+
+}
+
+/**++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Post a message queue
+
+  @function name: SDLIB_PostMessage
+  @prototype: SDIO_STATUS SDLIB_PostMessage(PSDMESSAGE_QUEUE pQueue, PVOID pMessage, INT MessageLength)
+  @category: Support_Reference
+
+  @input: pQueue - message queue to post to
+  @input: pMessage - message to post
+  @input: MessageLength - length of message (for validation)
+
+  @return: SDIO_STATUS
+
+  @notes: The message queue uses an internal list of user defined message structures.  When
+          posting a message the message is copied into an allocated structure and queued.  The memory
+          pointed to by pMessage does not need to be allocated and can reside on the stack.
+          The length of the message to post can be smaller that the maximum message size. This allows
+          for variable length messages up to the maximum message size. This
+          function returns SDIO_STATUS_NO_RESOURCES, if the message queue is full.  This
+          function returns SDIO_STATUS_BUFFER_TOO_SMALL, if the message size exceeds the maximum
+          size of a message.  Posting and getting messsages from a message queue is safe in any
+          driver context.
+
+  @see also: SDLIB_CreateMessageQueue , SDLIB_GetMessage
+
+  @example: Posting a message
+       MyMessage message;
+           // set up message
+       message.code = MESSAGE_DATA_READY;
+       message.pData = pInstance->pDataBuffers[currentIndex];
+           // post message
+       status = SDLIB_PostMessage(pInstance->pReadQueue,&message,sizeof(message));
+       if (!SDIO_SUCCESS(status)) {
+           // failed
+       }
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS _PostMessage(PSDMESSAGE_QUEUE pQueue, PVOID pMessage, INT MessageLength)
+{
+    SDIO_STATUS status2;
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    PSDMESSAGE_BLOCK pMsg;
+    CT_DECLARE_IRQ_SYNC_CONTEXT();
+
+    if (MessageLength > pQueue->MaxMessageLength) {
+        return SDIO_STATUS_BUFFER_TOO_SMALL;
+    }
+
+    status = CriticalSectionAcquireSyncIrq(&pQueue->MessageCritSection);
+    if (!SDIO_SUCCESS(status)) {
+        return status;
+    }
+
+    do {
+            /* get a message block */
+        pMsg = GetFreeMessageBlock(pQueue);
+        if (NULL == pMsg) {
+            status = SDIO_STATUS_NO_RESOURCES;
+            break;
+        }
+            /* copy the message */
+        memcpy(pMsg->MessageStart,pMessage,MessageLength);
+            /* set the length of the message */
+        pMsg->MessageLength = MessageLength;
+            /* queue the message to the list  */
+        QueueMessageBlock(pQueue,pMsg);
+    } while (FALSE);
+
+    status2 = CriticalSectionReleaseSyncIrq(&pQueue->MessageCritSection);
+    return status;
+}
+
+/**++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get a message from a message queue
+
+  @function name: SDLIB_GetMessage
+  @prototype: SDIO_STATUS SDLIB_GetMessage(PSDMESSAGE_QUEUE pQueue, PVOID pData, INT *pBufferLength)
+  @category: Support_Reference
+
+  @input: pQueue - message queue to retreive a message from
+  @input: pBufferLength - on entry, the length of the data buffer
+  @output: pData - buffer to hold the message
+  @output: pBufferLength - on return, contains the number of bytes copied
+
+  @return: SDIO_STATUS
+
+  @notes: The message queue uses an internal list of user defined message structures.  The message is
+          dequeued (FIFO order) and copied to the callers buffer.  The internal allocation for the message
+          is returned back to the message queue. This function returns SDIO_STATUS_NO_MORE_MESSAGES
+          if the message queue is empty. If the length of the buffer is smaller than the length of
+          the message at the head of the queue,this function returns SDIO_STATUS_BUFFER_TOO_SMALL and
+          returns the required length in pBufferLength.
+
+  @see also: SDLIB_CreateMessageQueue , SDLIB_PostMessage
+
+  @example: Getting a message
+       MyMessage message;
+       INT       length;
+           // set length
+       length = sizeof(message);
+           // post message
+       status = SDLIB_GetMessage(pInstance->pReadQueue,&message,&length);
+       if (!SDIO_SUCCESS(status)) {
+           // failed
+       }
+
+  @example: Checking queue for a message and getting the size of the message
+       INT       length;
+           // use zero length to get the size of the message
+       length = 0;
+       status = SDLIB_GetMessage(pInstance->pReadQueue,NULL,&length);
+       if (status == SDIO_STATUS_NO_MORE_MESSAGES) {
+            // no messages in queue
+       } else if (status == SDIO_STATUS_BUFFER_TOO_SMALL) {
+            // message exists in queue and length of message is returned
+            messageSizeInQueue = length;
+       } else {
+            // some other failure
+       }
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+SDIO_STATUS _GetMessage(PSDMESSAGE_QUEUE pQueue, PVOID pData, INT *pBufferLength)
+{
+    SDIO_STATUS status2;
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+    PSDMESSAGE_BLOCK pMsg;
+    CT_DECLARE_IRQ_SYNC_CONTEXT();
+
+    status = CriticalSectionAcquireSyncIrq(&pQueue->MessageCritSection);
+    if (!SDIO_SUCCESS(status)) {
+        return status;
+    }
+
+    do {
+        pMsg = GetQueuedMessage(pQueue);
+        if (NULL == pMsg) {
+            status = SDIO_STATUS_NO_MORE_MESSAGES;
+            break;
+        }
+        if (*pBufferLength < pMsg->MessageLength) {
+                /* caller buffer is too small */
+            *pBufferLength = pMsg->MessageLength;
+                /* stick it back to the front */
+            QueueMessageToHead(pQueue, pMsg);
+            status = SDIO_STATUS_BUFFER_TOO_SMALL;
+            break;
+        }
+            /* copy the message to the callers buffer */
+        memcpy(pData,pMsg->MessageStart,pMsg->MessageLength);
+            /* return actual length */
+        *pBufferLength = pMsg->MessageLength;
+            /* return this message block back to the free list  */
+        FreeMessageBlock(pQueue, pMsg);
+
+    } while (FALSE);
+
+    status2 = CriticalSectionReleaseSyncIrq(&pQueue->MessageCritSection);
+
+    return status;
+}
+
+/* the following documents the OS helper APIs */
+
+/**++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Create an OS-specific helper task/thread
+
+  @function name: SDLIB_OSCreateHelper
+  @prototype: SDIO_STATUS SDLIB_OSCreateHelper(POSKERNEL_HELPER pHelper,
+                                               PHELPER_FUNCTION pFunction,
+                                               PVOID            pContext)
+  @category: Support_Reference
+
+  @input: pHelper - caller allocated helper object
+  @input: pFunction - helper function
+  @input: pContext - helper context
+
+  @return: SDIO_STATUS
+
+  @notes: This function creates a helper task/thread that runs in a new execution context. The newly
+          created task/thread invokes the helper function. The thread/task exits when the helper
+          function returns.  The helper function has the prototype of:
+          THREAD_RETURN HelperFunction(POSKERNEL_HELPER pHelper)
+          The helper function usually implements a while loop and suspends execution using
+          SD_WAIT_FOR_WAKEUP().  On exit the helper function can return an OS-specific THREAD_RETURN
+          code (usually zero). The helper function executes in a fully schedule-able context and
+          can block on semaphores and sleep.
+
+  @see also: SDLIB_OSDeleteHelper , SD_WAIT_FOR_WAKEUP
+
+  @example: A thread helper function:
+       THREAD_RETURN HelperFunction(POSKERNEL_HELPER pHelper)
+       {
+           SDIO_STATUS status;
+           PMYCONTEXT pContext = (PMYCONTEXT)SD_GET_OS_HELPER_CONTEXT(pHelper);
+                // wait for wake up
+           while(1) {
+                  status = SD_WAIT_FOR_WAKEUP(pHelper);
+                  if (!SDIO_SUCCESS(status)) {
+                      break;
+                  }
+                  if (SD_IS_HELPER_SHUTTING_DOWN(pHelper)) {
+                      //... shutting down
+                      break;
+                  }
+                  // handle wakeup...
+            }
+            return 0;
+       }
+
+  @example: Creating a helper:
+       status = SDLIB_OSCreateHelper(&pInstance->OSHelper,HelperFunction,pInstance);
+       if (!SDIO_SUCCESS(status)) {
+           // failed
+       }
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+/**++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Delete an OS helper task/thread
+
+  @function name: SDLIB_OSDeleteHelper
+  @prototype: void SDLIB_OSDeleteHelper(POSKERNEL_HELPER pHelper)
+  @category: Support_Reference
+
+  @input: pHelper - caller allocated helper object
+
+  @notes: This function wakes the helper and waits(blocks) until the helper exits. The caller can
+          only pass an OS helper structure that was initialized sucessfully by
+          SDLIB_OSCreateHelper.  The caller must be in a schedulable context.
+
+  @see also: SDLIB_OSCreateHelper
+
+  @example: Deleting a helper:
+       if (pInstance->HelperCreated) {
+               // clean up the helper if we successfully created it
+           SDLIB_OSDeleteHelper(&pInstance->OSHelper);
+       }
+
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+
Index: linux-2.6/drivers/sdio/lib/sdio_lib_os.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/sdio/lib/sdio_lib_os.c
@@ -0,0 +1,261 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdio_function_os.c
+
+@abstract: Linux implementation module for SDIO library
+
+#notes: includes module load and unload functions
+
+@notice: Copyright (c), 2004 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+/* debug level for this module*/
+#ifdef CONFIG_SDIO_MODULE
+#define DBG_DECLARE 4;
+#endif
+#include <linux/sdio/ctsystem.h>
+
+#include <linux/module.h>
+#include <linux/init.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <linux/kthread.h>
+#endif
+
+#include <linux/sdio/sdio_busdriver.h>
+#include <linux/sdio/sdio_lib.h>
+
+#define DESCRIPTION "SDIO Kernel Library"
+#define AUTHOR "Atheros Communications, Inc."
+
+/* debug print parameter */
+
+CT_DECLARE_MODULE_PARAM_INTEGER(debuglevel);
+MODULE_PARM_DESC(debuglevel, "debuglevel 0-7, controls debug prints");
+
+
+
+/* proxies */
+SDIO_STATUS SDLIB_IssueCMD52(PSDDEVICE     pDevice,
+                            UINT8         FuncNo,
+                            UINT32        Address,
+                            PUINT8        pData,
+                            INT           ByteCount,
+                            BOOL          Write)
+{
+    return _SDLIB_IssueCMD52(pDevice,FuncNo,Address,pData,ByteCount,Write);
+}
+
+SDIO_STATUS SDLIB_FindTuple(PSDDEVICE  pDevice,
+                         UINT8      Tuple,
+                         UINT32     *pTupleScanAddress,
+                         PUINT8     pBuffer,
+                         UINT8      *pLength)
+{
+    return _SDLIB_FindTuple(pDevice,Tuple,pTupleScanAddress,pBuffer,pLength);
+}
+
+SDIO_STATUS SDLIB_IssueConfig(PSDDEVICE        pDevice,
+                              SDCONFIG_COMMAND Command,
+                              PVOID            pData,
+                              INT              Length)
+{
+    return _SDLIB_IssueConfig(pDevice,Command,pData,Length);
+}
+
+void SDLIB_PrintBuffer(PUCHAR pBuffer,INT Length,PTEXT pDescription)
+{
+    _SDLIB_PrintBuffer(pBuffer,Length,pDescription);
+}
+
+SDIO_STATUS SDLIB_SetFunctionBlockSize(PSDDEVICE        pDevice,
+                                       UINT16           BlockSize)
+{
+    return _SDLIB_SetFunctionBlockSize(pDevice,BlockSize);
+}
+
+void SDLIB_SetupCMD52Request(UINT8         FuncNo,
+                             UINT32        Address,
+                             BOOL          Write,
+                             UINT8         WriteData,
+                             PSDREQUEST    pRequest)
+{
+    _SDLIB_SetupCMD52Request(FuncNo,Address,Write,WriteData,pRequest);
+}
+
+SDIO_STATUS SDLIB_GetDefaultOpCurrent(PSDDEVICE  pDevice, SD_SLOT_CURRENT *pOpCurrent)
+{
+    return _SDLIB_GetDefaultOpCurrent(pDevice,pOpCurrent);
+}
+
+/* helper function launcher */
+INT HelperLaunch(PVOID pContext)
+{
+    INT exit;
+        /* call function */
+    exit = ((POSKERNEL_HELPER)pContext)->pHelperFunc((POSKERNEL_HELPER)pContext);
+    complete_and_exit(&((POSKERNEL_HELPER)pContext)->Completion, exit);
+    return exit;
+}
+
+/*
+ * OSCreateHelper - create a worker kernel thread
+*/
+SDIO_STATUS SDLIB_OSCreateHelper(POSKERNEL_HELPER pHelper,
+                           PHELPER_FUNCTION pFunction,
+                           PVOID            pContext)
+{
+    SDIO_STATUS status = SDIO_STATUS_SUCCESS;
+
+    memset(pHelper,0,sizeof(OSKERNEL_HELPER));
+
+    do {
+        pHelper->pContext = pContext;
+        pHelper->pHelperFunc = pFunction;
+        status = SignalInitialize(&pHelper->WakeSignal);
+        if (!SDIO_SUCCESS(status)) {
+            break;
+        }
+        init_completion(&pHelper->Completion);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        pHelper->pTask = kthread_create(HelperLaunch,
+                                       (PVOID)pHelper,
+                                       "SDIO Helper");
+        if (NULL == pHelper->pTask) {
+            status = SDIO_STATUS_NO_RESOURCES;
+            break;
+        }
+        wake_up_process(pHelper->pTask);
+#else
+    /* 2.4 */
+        pHelper->pTask = kernel_thread(HelperLaunch,
+                                       (PVOID)pHelper,
+                                       (CLONE_FS | CLONE_FILES | SIGCHLD));
+        if (pHelper->pTask < 0) {
+            DBG_PRINT(SDDBG_TRACE,
+                ("SDIO BusDriver - OSCreateHelper, failed to create thread\n"));
+        }
+#endif
+
+    } while (FALSE);
+
+    if (!SDIO_SUCCESS(status)) {
+        SDLIB_OSDeleteHelper(pHelper);
+    }
+    return status;
+}
+
+/*
+ * OSDeleteHelper - delete thread created with OSCreateHelper
+*/
+void SDLIB_OSDeleteHelper(POSKERNEL_HELPER pHelper)
+{
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    if (pHelper->pTask != NULL) {
+#else
+    /* 2.4 */
+    if (pHelper->pTask >= 0) {
+#endif
+        pHelper->ShutDown = TRUE;
+        SignalSet(&pHelper->WakeSignal);
+            /* wait for thread to exit */
+        wait_for_completion(&pHelper->Completion);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        pHelper->pTask = NULL;
+#else
+    /* 2.4 */
+        pHelper->pTask = 0;
+#endif
+    }
+
+    SignalDelete(&pHelper->WakeSignal);
+}
+
+/*
+ * module init
+*/
+static int __init sdio_lib_init(void) {
+    REL_PRINT(SDDBG_TRACE, ("SDIO Library load\n"));
+    return 0;
+}
+
+/*
+ * module cleanup
+*/
+static void __exit sdio_lib_cleanup(void) {
+    REL_PRINT(SDDBG_TRACE, ("SDIO Library unload\n"));
+}
+
+PSDMESSAGE_QUEUE SDLIB_CreateMessageQueue(INT MaxMessages, INT MaxMessageLength)
+{
+    return _CreateMessageQueue(MaxMessages,MaxMessageLength);
+
+}
+void SDLIB_DeleteMessageQueue(PSDMESSAGE_QUEUE pQueue)
+{
+    _DeleteMessageQueue(pQueue);
+}
+
+SDIO_STATUS SDLIB_PostMessage(PSDMESSAGE_QUEUE pQueue, PVOID pMessage, INT MessageLength)
+{
+    return _PostMessage(pQueue,pMessage,MessageLength);
+}
+
+SDIO_STATUS SDLIB_GetMessage(PSDMESSAGE_QUEUE pQueue, PVOID pData, INT *pBufferLength)
+{
+    return _GetMessage(pQueue,pData,pBufferLength);
+}
+
+MODULE_LICENSE("GPL and additional rights");
+MODULE_DESCRIPTION(DESCRIPTION);
+MODULE_AUTHOR(AUTHOR);
+module_init(sdio_lib_init);
+module_exit(sdio_lib_cleanup);
+EXPORT_SYMBOL(SDLIB_IssueCMD52);
+EXPORT_SYMBOL(SDLIB_FindTuple);
+EXPORT_SYMBOL(SDLIB_IssueConfig);
+EXPORT_SYMBOL(SDLIB_PrintBuffer);
+EXPORT_SYMBOL(SDLIB_SetFunctionBlockSize);
+EXPORT_SYMBOL(SDLIB_SetupCMD52Request);
+EXPORT_SYMBOL(SDLIB_GetDefaultOpCurrent);
+EXPORT_SYMBOL(SDLIB_OSCreateHelper);
+EXPORT_SYMBOL(SDLIB_OSDeleteHelper);
+EXPORT_SYMBOL(SDLIB_CreateMessageQueue);
+EXPORT_SYMBOL(SDLIB_DeleteMessageQueue);
+EXPORT_SYMBOL(SDLIB_PostMessage);
+EXPORT_SYMBOL(SDLIB_GetMessage);
Index: linux-2.6/drivers/Kconfig
===================================================================
--- linux-2.6.orig/drivers/Kconfig
+++ linux-2.6/drivers/Kconfig
@@ -14,6 +14,8 @@ source "drivers/parport/Kconfig"
 
 source "drivers/pnp/Kconfig"
 
+source "drivers/sdio/Kconfig"
+
 source "drivers/block/Kconfig"
 
 # misc before ide - BLK_DEV_SGIIOC4 depends on SGI_IOC4
Index: linux-2.6/drivers/Makefile
===================================================================
--- linux-2.6.orig/drivers/Makefile
+++ linux-2.6/drivers/Makefile
@@ -91,3 +91,4 @@ obj-$(CONFIG_PPC_PS3)		+= ps3/
 obj-$(CONFIG_OF)		+= of/
 obj-$(CONFIG_SSB)		+= ssb/
 obj-$(CONFIG_VIRTIO)		+= virtio/
+obj-$(CONFIG_SDIO)              += sdio/
Index: linux-2.6/drivers/pnp/Kconfig
===================================================================
--- linux-2.6.orig/drivers/pnp/Kconfig
+++ linux-2.6/drivers/pnp/Kconfig
@@ -5,7 +5,6 @@
 menuconfig PNP
 	bool "Plug and Play support"
 	depends on HAS_IOMEM
-	depends on ISA || ACPI
 	---help---
 	  Plug and Play (PnP) is a standard for peripherals which allows those
 	  peripherals to be configured by software, e.g. assign IRQ's or other
Index: linux-2.6/arch/arm/Kconfig
===================================================================
--- linux-2.6.orig/arch/arm/Kconfig
+++ linux-2.6/arch/arm/Kconfig
@@ -1001,6 +1001,8 @@ source "drivers/parport/Kconfig"
 
 source "drivers/pnp/Kconfig"
 
+source "drivers/sdio/Kconfig"
+
 source "drivers/block/Kconfig"
 
 # misc before ide - BLK_DEV_SGIIOC4 depends on SGI_IOC4
Index: linux-2.6/include/linux/sdio/_sdio_defs.h
===================================================================
--- /dev/null
+++ linux-2.6/include/linux/sdio/_sdio_defs.h
@@ -0,0 +1,642 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: _sdio_defs.h
+
+@abstract: SD/SDIO definitions
+
+@notice: Copyright (c), 2004-2006 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#ifndef ___SDIO_DEFS_H___
+#define ___SDIO_DEFS_H___
+
+#define SD_INIT_BUS_CLOCK   100000    /* initialization clock in hz */
+#define SPI_INIT_BUS_CLOCK  100000    /* initialization clock in hz */
+#define SD_MAX_BUS_CLOCK    25000000  /* max clock speed in hz */
+#define SD_HS_MAX_BUS_CLOCK 50000000  /* SD high speed max clock speed in hz */
+#define SDIO_LOW_SPEED_MAX_BUS_CLOCK 400000 /* max low speed clock in hz */
+#define SDMMC_MIN_INIT_CLOCKS   80    /* minimun number of initialization clocks */
+#define SDIO_EMPC_CURRENT_THRESHOLD  300  /* SDIO 1.10 , EMPC (mA) threshold, we add some overhead */
+
+/* commands */
+#define CMD0    0
+#define CMD1    1
+#define CMD2    2
+#define CMD3    3
+#define CMD4    4
+#define CMD5    5
+#define CMD6    6
+#define CMD7    7
+#define CMD9    9
+#define CMD10   10
+#define CMD12   12
+#define CMD13   13
+#define CMD15   15
+#define CMD16   16
+#define CMD17   17
+#define CMD18   18
+#define CMD24   24
+#define CMD25   25
+#define CMD27   27
+#define CMD28   28
+#define CMD29   29
+#define CMD30   30
+#define CMD32   32
+#define CMD33   33
+#define CMD38   38
+#define CMD42   42
+#define CMD52   52
+#define CMD53   53
+#define CMD55   55
+#define CMD56   56
+#define CMD58   58
+#define CMD59   59
+#define ACMD6   6
+#define ACMD13  13
+#define ACMD22  22
+#define ACMD23  23
+#define ACMD41  41
+#define ACMD42  42
+#define ACMD51  51
+
+#define SD_ACMD6_BUS_WIDTH_1_BIT         0x00
+#define SD_ACMD6_BUS_WIDTH_4_BIT         0x02
+
+#define SD_CMD59_CRC_OFF            0x00000000
+#define SD_CMD59_CRC_ON             0x00000001
+
+/* SD/SPI max response size */
+#define SD_MAX_CMD_RESPONSE_BYTES SD_R2_RESPONSE_BYTES
+
+#define SD_R1_RESPONSE_BYTES  6
+#define SD_R1B_RESPONSE_BYTES SD_R1_RESPONSE_BYTES
+#define SD_R1_GET_CMD(pR) ((pR)[5] & 0xC0))
+#define SD_R1_SET_CMD(pR,cmd)  (pR)[5] = (cmd) & 0xC0
+#define SD_R1_GET_CARD_STATUS(pR) (((UINT32)((pR)[1]))        |  \
+                                  (((UINT32)((pR)[2])) << 8)  |  \
+                                  (((UINT32)((pR)[3])) << 16) |  \
+                                  (((UINT32)((pR)[4])) << 24) )
+#define SD_R1_SET_CMD_STATUS(pR,status) \
+{                                      \
+    (pR)[1] = (UINT8)(status);         \
+    (pR)[2] = (UINT8)((status) >> 8);  \
+    (pR)[3] = (UINT8)((status) >> 16); \
+    (pR)[4] = (UINT8)((status) >> 24); \
+}
+
+/* SD R1 card status bit masks */
+#define SD_CS_CMD_OUT_OF_RANGE  ((UINT32)(1 << 31))
+#define SD_CS_ADDRESS_ERR       (1 << 30)
+#define SD_CS_BLK_LEN_ERR       (1 << 29)
+#define SD_CS_ERASE_SEQ_ERR     (1 << 28)
+#define SD_CS_ERASE_PARAM_ERR   (1 << 27)
+#define SD_CS_WP_ERR            (1 << 26)
+#define SD_CS_CARD_LOCKED       (1 << 25)
+#define SD_CS_LK_UNLK_FAILED    (1 << 24)
+#define SD_CS_PREV_CMD_CRC_ERR  (1 << 23)
+#define SD_CS_ILLEGAL_CMD_ERR   (1 << 22)
+#define SD_CS_ECC_FAILED        (1 << 21)
+#define SD_CS_CARD_INTERNAL_ERR (1 << 20)
+#define SD_CS_GENERAL_ERR       (1 << 19)
+#define SD_CS_CSD_OVERWR_ERR    (1 << 16)
+#define SD_CS_WP_ERASE_SKIP     (1 << 15)
+#define SD_CS_ECC_DISABLED      (1 << 14)
+#define SD_CS_ERASE_RESET       (1 << 13)
+#define SD_CS_GET_STATE(status) (((status) >> 9) & 0x0f)
+#define SD_CS_SET_STATE(status, state) \
+{                               \
+    (status) &= ~(0x0F << 9);   \
+    (status) |= (state) << 9    \
+}
+
+#define SD_CS_TRANSFER_ERRORS \
+                ( SD_CS_ADDRESS_ERR       | \
+                  SD_CS_BLK_LEN_ERR       | \
+                  SD_CS_ERASE_SEQ_ERR     | \
+                  SD_CS_ERASE_PARAM_ERR   | \
+                  SD_CS_WP_ERR            | \
+                  SD_CS_ECC_FAILED        | \
+                  SD_CS_CARD_INTERNAL_ERR | \
+                  SD_CS_GENERAL_ERR )
+
+#define SD_CS_STATE_IDLE   0
+#define SD_CS_STATE_READY  1
+#define SD_CS_STATE_IDENT  2
+#define SD_CS_STATE_STBY   3
+#define SD_CS_STATE_TRANS  4
+#define SD_CS_STATE_DATA   5
+#define SD_CS_STATE_RCV    6
+#define SD_CS_STATE_PRG    7
+#define SD_CS_STATE_DIS    8
+#define SD_CS_READY_FOR_DATA    (1 << 8)
+#define SD_CS_APP_CMD           (1 << 5)
+#define SD_CS_AKE_SEQ_ERR       (1 << 3)
+
+/* SD R2 response */
+#define SD_R2_RESPONSE_BYTES  17
+#define MAX_CSD_CID_BYTES     16
+#define SD_R2_SET_STUFF_BITS(pR)   (pR)[16] = 0x3F
+#define GET_SD_CSD_TRANS_SPEED(pR) (pR)[12]
+#define GET_SD_CID_MANFID(pR)      (pR)[15]
+#define GET_SD_CID_PN_1(pR)        (pR)[12]
+#define GET_SD_CID_PN_2(pR)        (pR)[11]
+#define GET_SD_CID_PN_3(pR)        (pR)[10]
+#define GET_SD_CID_PN_4(pR)        (pR)[9]
+#define GET_SD_CID_PN_5(pR)        (pR)[8]
+#define GET_SD_CID_PN_6(pR)        (pR)[7]
+
+#define GET_SD_CID_OEMID(pR)      ((((UINT16)(pR)[14]) << 8 )| (UINT16)((pR)[13]))
+#define SDMMC_OCR_VOLTAGE_MASK 0x7FFFFFFF
+/* SD R3 response */
+#define SD_R3_RESPONSE_BYTES 6
+#define SD_R3_GET_OCR(pR) ((((UINT32)((pR)[1])) |  \
+                           (((UINT32)((pR)[2])) << 8)  |  \
+                           (((UINT32)((pR)[3])) << 16) | \
+                           (((UINT32)((pR)[4])) << 24)) & SDMMC_OCR_VOLTAGE_MASK)
+#define SD_R3_IS_CARD_READY(pR)  (((pR)[4] & 0x80) == 0x80)
+
+/* OCR bit definitions */
+#define SD_OCR_CARD_PWR_UP_STATUS  ((UINT32)(1 << 31))
+#define SD_OCR_3_5_TO_3_6_VDD      (1 << 23)
+#define SD_OCR_3_4_TO_3_5_VDD      (1 << 22)
+#define SD_OCR_3_3_TO_3_4_VDD      (1 << 21)
+#define SD_OCR_3_2_TO_3_3_VDD      (1 << 20)
+#define SD_OCR_3_1_TO_3_2_VDD      (1 << 19)
+#define SD_OCR_3_0_TO_3_1_VDD      (1 << 18)
+#define SD_OCR_2_9_TO_3_0_VDD      (1 << 17)
+#define SD_OCR_2_8_TO_2_9_VDD      (1 << 16)
+#define SD_OCR_2_7_TO_2_8_VDD      (1 << 15)
+#define SD_OCR_2_6_TO_2_7_VDD      (1 << 14)
+#define SD_OCR_2_5_TO_2_6_VDD      (1 << 13)
+#define SD_OCR_2_4_TO_2_5_VDD      (1 << 12)
+#define SD_OCR_2_3_TO_2_4_VDD      (1 << 11)
+#define SD_OCR_2_2_TO_2_3_VDD      (1 << 10)
+#define SD_OCR_2_1_TO_2_2_VDD      (1 << 9)
+#define SD_OCR_2_0_TO_2_1_VDD      (1 << 8)
+#define SD_OCR_1_9_TO_2_0_VDD      (1 << 7)
+#define SD_OCR_1_8_TO_1_9_VDD      (1 << 6)
+#define SD_OCR_1_7_TO_1_8_VDD      (1 << 5)
+#define SD_OCR_1_6_TO_1_7_VDD      (1 << 4)
+
+/* SD Status data block */
+#define SD_STATUS_DATA_BYTES        64
+#define SDS_GET_DATA_WIDTH(buffer)  ((buffer)[0] & 0xC0)
+#define SDS_BUS_1_BIT               0x00
+#define SDS_BUS_4_BIT               0x80
+#define SDS_GET_SECURE_MODE(buffer) ((buffer)[0] & 0x20)
+#define SDS_CARD_SECURE_MODE        0x20
+#define SDS_GET_CARD_TYPE(buffer)   ((buffer)[60] & 0x0F)
+#define SDS_SD_CARD_RW              0x00
+#define SDS_SD_CARD_ROM             0x01
+
+/* SD R6 response */
+#define SD_R6_RESPONSE_BYTES 6
+#define SD_R6_GET_RCA(pR) ((UINT16)((pR)[3]) | (((UINT16)((pR)[4])) << 8))
+#define SD_R6_GET_CS(pR)  ((UINT16)((pR)[1]) | (((UINT16)((pR)[2])) << 8))
+
+/* SD Configuration Register (SCR) */
+#define SD_SCR_BYTES            8
+#define SCR_REV_1_0             0x00
+#define SCR_SD_SPEC_1_00        0x00
+#define SCR_SD_SPEC_1_10        0x01
+#define SCR_BUS_SUPPORTS_1_BIT  0x01
+#define SCR_BUS_SUPPORTS_4_BIT  0x04
+#define SCR_SD_SECURITY_MASK    0x70
+#define SCR_SD_NO_SECURITY      0x00
+#define SCR_SD_SECURITY_1_0     0x10
+#define SCR_SD_SECURITY_2_0     0x20
+#define SCR_DATA_STATUS_1_AFTER_ERASE  0x80
+
+#define GET_SD_SCR_STRUCT_VER(pB) ((pB)[7] >> 4)
+#define GET_SD_SCR_SDSPEC_VER(pB) ((pB)[7] & 0x0F)
+#define GET_SD_SCR_BUSWIDTHS(pB)  ((pB)[6] & 0x0F)
+#define GET_SD_SCR_BUSWIDTHS_FLAGS(pB)  (pB)[6]
+#define GET_SD_SCR_SECURITY(pB)   (((pB)[6] >> 4) & 0x07)
+#define GET_SD_SCR_DATA_STAT_AFTER_ERASE(pB) (((pB)[6] >> 7) & 0x01)
+
+/* SDIO R4 Response */
+#define SD_SDIO_R4_RESPONSE_BYTES 6
+#define SD_SDIO_R4_GET_OCR(pR) ((UINT32)((pR)[1])        |  \
+                          (((UINT32)(pR)[2]) << 8)  |  \
+                          (((UINT32)(pR)[3]) << 16))
+#define SD_SDIO_R4_IS_MEMORY_PRESENT(pR)   (((pR)[4] & 0x08) == 0x08)
+#define SD_SDIO_R4_GET_IO_FUNC_COUNT(pR)   (((pR)[4] >> 4) & 0x07)
+#define SD_SDIO_R4_IS_CARD_READY(pR)       (((pR)[4] & 0x80) == 0x80)
+
+/* SDIO R5 response */
+#define SD_SDIO_R5_RESPONSE_BYTES      6
+#define SD_SDIO_R5_READ_DATA_OFFSET    1
+#define SD_R5_GET_READ_DATA(pR)  (pR)[SD_SDIO_R5_READ_DATA_OFFSET]
+#define SD_R5_RESP_FLAGS_OFFSET   2
+#define SD_R5_GET_RESP_FLAGS(pR) (pR)[SD_R5_RESP_FLAGS_OFFSET]
+#define SD_R5_SET_CMD(pR,cmd)  (pR)[5] = (cmd) & 0xC0
+#define SD_R5_RESP_CMD_ERR  (1 << 7) /* for previous cmd */
+#define SD_R5_ILLEGAL_CMD   (1 << 6)
+#define SD_R5_GENERAL_ERR   (1 << 3)
+#define SD_R5_INVALID_FUNC  (1 << 1)
+#define SD_R5_ARG_RANGE_ERR (1 << 0)
+#define SD_R5_CURRENT_CMD_ERRORS (SD_R5_ILLEGAL_CMD | SD_R5_GENERAL_ERR \
+                                 | SD_R5_INVALID_FUNC | SD_R5_ARG_RANGE_ERR)
+#define SD_R5_ERRORS (SD_R5_CURRENT_CMD_ERRORS)
+
+#define SD_R5_GET_IO_STATE(pR) (((pR)[2] >> 4) & 0x03)
+#define SD_R5_STATE_DIS 0x00
+#define SD_R5_STATE_CMD 0x01
+#define SD_R5_STATE_TRN 0x02
+
+/* SDIO Modified R6 Response */
+#define SD_SDIO_R6_RESPONSE_BYTES 6
+#define SD_SDIO_R6_GET_RCA(pR)  ((UINT16)((pR)[3]) | ((UINT16)((pR)[4]) << 8))
+#define SD_SDIO_R6_GET_CSTAT(pR)((UINT16)((pR)[1]) | ((UINT16)((pR)[2]) << 8))
+
+/* SPI mode R1 response */
+#define SPI_R1_RESPONSE_BYTES   1
+#define GET_SPI_R1_RESP_TOKEN(pR) (pR)[0]
+#define SPI_CS_STATE_IDLE       0x01
+#define SPI_CS_ERASE_RESET      (1 << 1)
+#define SPI_CS_ILLEGAL_CMD      (1 << 2)
+#define SPI_CS_CMD_CRC_ERR      (1 << 3)
+#define SPI_CS_ERASE_SEQ_ERR    (1 << 4)
+#define SPI_CS_ADDRESS_ERR      (1 << 5)
+#define SPI_CS_PARAM_ERR        (1 << 6)
+#define SPI_CS_ERR_MASK         0x7c
+
+/* SPI mode R2 response */
+#define SPI_R2_RESPONSE_BYTES  2
+#define GET_SPI_R2_RESP_TOKEN(pR)   (pR)[1]
+#define GET_SPI_R2_STATUS_TOKEN(pR) (pR)[0]
+/* the first response byte is defined above */
+/* the second response byte is defined below */
+#define SPI_CS_CARD_IS_LOCKED      (1 << 0)
+#define SPI_CS_LOCK_UNLOCK_FAILED  (1 << 1)
+#define SPI_CS_ERROR               (1 << 2)
+#define SPI_CS_INTERNAL_ERROR      (1 << 3)
+#define SPI_CS_ECC_FAILED          (1 << 4)
+#define SPI_CS_WP_VIOLATION        (1 << 5)
+#define SPI_CS_ERASE_PARAM_ERR     (1 << 6)
+#define SPI_CS_OUT_OF_RANGE        (1 << 7)
+
+/* SPI mode R3 response */
+#define SPI_R3_RESPONSE_BYTES 5
+#define SPI_R3_GET_OCR(pR) ((((UINT32)((pR)[0])) |         \
+                            (((UINT32)((pR)[1])) << 8)  |  \
+                            (((UINT32)((pR)[2])) << 16) |  \
+                            (((UINT32)((pR)[3])) << 24)) & SDMMC_OCR_VOLTAGE_MASK)
+#define SPI_R3_IS_CARD_READY(pR)  (((pR)[3] & 0x80) == 0x80)
+#define GET_SPI_R3_RESP_TOKEN(pR) (pR)[4]
+
+/* SPI mode SDIO R4 response */
+#define SPI_SDIO_R4_RESPONSE_BYTES 5
+#define SPI_SDIO_R4_GET_OCR(pR) ((UINT32)((pR)[0])        |  \
+                          (((UINT32)(pR)[1]) << 8)   |  \
+                          (((UINT32)(pR)[2]) << 16))
+#define SPI_SDIO_R4_IS_MEMORY_PRESENT(pR)   (((pR)[3] & 0x08) == 0x08)
+#define SPI_SDIO_R4_GET_IO_FUNC_COUNT(pR)   (((pR)[3] >> 4) & 0x07)
+#define SPI_SDIO_R4_IS_CARD_READY(pR)       (((pR)[3] & 0x80) == 0x80)
+#define GET_SPI_SDIO_R4_RESP_TOKEN(pR)  (pR)[4]
+
+/* SPI Mode SDIO R5 response */
+#define SPI_SDIO_R5_RESPONSE_BYTES 2
+#define GET_SPI_SDIO_R5_RESP_TOKEN(pR)     (pR)[1]
+#define GET_SPI_SDIO_R5_RESPONSE_RDATA(pR) (pR)[0]
+#define SPI_R5_IDLE_STATE   0x01
+#define SPI_R5_ILLEGAL_CMD  (1 << 2)
+#define SPI_R5_CMD_CRC      (1 << 3)
+#define SPI_R5_FUNC_ERR     (1 << 4)
+#define SPI_R5_PARAM_ERR    (1 << 6)
+
+/* SDIO COMMAND 52 Definitions */
+#define CMD52_READ  0
+#define CMD52_WRITE 1
+#define CMD52_READ_AFTER_WRITE 1
+#define CMD52_NORMAL_WRITE     0
+#define SDIO_SET_CMD52_ARG(arg,rw,func,raw,address,writedata) \
+    (arg) = (((rw) & 1) << 31)           | \
+            (((func) & 0x7) << 28)       | \
+            (((raw) & 1) << 27)          | \
+            (1 << 26)                    | \
+            (((address) & 0x1FFFF) << 9) | \
+            (1 << 8)                     | \
+            ((writedata) & 0xFF)
+#define SDIO_SET_CMD52_READ_ARG(arg,func,address) \
+    SDIO_SET_CMD52_ARG(arg,CMD52_READ,(func),0,address,0x00)
+#define SDIO_SET_CMD52_WRITE_ARG(arg,func,address,value) \
+    SDIO_SET_CMD52_ARG(arg,CMD52_WRITE,(func),CMD52_NORMAL_WRITE,address,value)
+
+/* SDIO COMMAND 53 Definitions */
+#define CMD53_READ          0
+#define CMD53_WRITE         1
+#define CMD53_BLOCK_BASIS   1
+#define CMD53_BYTE_BASIS    0
+#define CMD53_FIXED_ADDRESS 0
+#define CMD53_INCR_ADDRESS  1
+#define SDIO_SET_CMD53_ARG(arg,rw,func,mode,opcode,address,bytes_blocks) \
+    (arg) = (((rw) & 1) << 31)                  | \
+            (((func) & 0x7) << 28)              | \
+            (((mode) & 1) << 27)                | \
+            (((opcode) & 1) << 26)              | \
+            (((address) & 0x1FFFF) << 9)        | \
+            ((bytes_blocks) & 0x1FF)
+
+#define SDIO_MAX_LENGTH_BYTE_BASIS  512
+#define SDIO_MAX_BLOCKS_BLOCK_BASIS 511
+#define SDIO_MAX_BYTES_PER_BLOCK    2048
+#define SDIO_COMMON_AREA_FUNCTION_NUMBER 0
+#define SDIO_FIRST_FUNCTION_NUMBER       1
+#define SDIO_LAST_FUNCTION_NUMBER        7
+
+#define CMD53_CONVERT_BYTE_BASIS_BLK_LENGTH_PARAM(b) (((b) < SDIO_MAX_LENGTH_BYTE_BASIS) ? (b) : 0)
+#define CMD53_CONVERT_BLOCK_BASIS_BLK_COUNT_PARAM(b) (((b) <= SDIO_MAX_BLOCKS_BLOCK_BASIS) ? (b) : 0)
+
+
+/* SDIO COMMON Registers */
+
+/* revision register */
+#define CCCR_SDIO_REVISION_REG  0x00
+#define CCCR_REV_MASK           0x0F
+#define CCCR_REV_1_0            0x00
+#define CCCR_REV_1_1            0x01
+#define SDIO_REV_MASK           0xF0
+#define SDIO_REV_1_00           0x00
+#define SDIO_REV_1_10           0x10
+#define SDIO_REV_1_20           0x20
+/* SD physical spec revision */
+#define SD_SPEC_REVISION_REG    0x01
+#define SD_REV_MASK             0x0F
+#define SD_REV_1_01             0x00
+#define SD_REV_1_10             0x01
+/* I/O Enable  */
+#define SDIO_ENABLE_REG         0x02
+/* I/O Ready */
+#define SDIO_READY_REG          0x03
+/* Interrupt Enable */
+#define SDIO_INT_ENABLE_REG     0x04
+#define SDIO_INT_MASTER_ENABLE  0x01
+#define SDIO_INT_ALL_ENABLE     0xFE
+/* Interrupt Pending */
+#define SDIO_INT_PENDING_REG    0x05
+#define SDIO_INT_PEND_MASK      0xFE
+/* I/O Abort */
+#define SDIO_IO_ABORT_REG       0x06
+#define SDIO_IO_RESET           (1 << 3)
+/* Bus Interface */
+#define SDIO_BUS_IF_REG         0x07
+#define CARD_DETECT_DISABLE     0x80
+#define SDIO_BUS_WIDTH_1_BIT    0x00
+#define SDIO_BUS_WIDTH_4_BIT    0x02
+/* Card Capabilities */
+#define SDIO_CARD_CAPS_REG          0x08
+#define SDIO_CAPS_CMD52_WHILE_DATA  0x01   /* card can issue CMD52 while data transfer */
+#define SDIO_CAPS_MULTI_BLOCK       0x02   /* card supports multi-block data transfers */
+#define SDIO_CAPS_READ_WAIT         0x04   /* card supports read-wait protocol */
+#define SDIO_CAPS_SUSPEND_RESUME    0x08   /* card supports I/O function suspend/resume */
+#define SDIO_CAPS_INT_MULTI_BLK     0x10   /* interrupts between multi-block data capable */
+#define SDIO_CAPS_ENB_INT_MULTI_BLK 0x20   /* enable ints between muli-block data */
+#define SDIO_CAPS_LOW_SPEED         0x40   /* low speed card */
+#define SDIO_CAPS_4BIT_LS           0x80   /* 4 bit low speed card */
+/* Common CIS pointer */
+#define SDIO_CMN_CIS_PTR_LOW_REG    0x09
+#define SDIO_CMN_CIS_PTR_MID_REG    0x0a
+#define SDIO_CMN_CIS_PTR_HI_REG     0x0b
+/* Bus suspend */
+#define SDIO_BUS_SUSPEND_REG            0x0c
+#define SDIO_FUNC_SUSPEND_STATUS_MASK   0x01 /* selected function is suspended */
+#define SDIO_SUSPEND_FUNCTION           0x02 /* suspend the current selected function */
+/* Function select (for bus suspension) */
+#define SDIO_FUNCTION_SELECT_REG        0x0d
+#define SDIO_SUSPEND_FUNCTION_0         0x00
+#define SDIO_SUSPEND_MEMORY_FUNC_MASK    0x08
+/* Function Execution */
+#define SDIO_FUNCTION_EXEC_REG          0x0e
+#define SDIO_MEMORY_FUNC_EXEC_MASK      0x01
+/* Function Ready */
+#define SDIO_FUNCTION_READY_REG          0x0f
+#define SDIO_MEMORY_FUNC_BUSY_MASK       0x01
+
+/* power control 1.10 only  */
+#define SDIO_POWER_CONTROL_REG            0x12
+#define SDIO_POWER_CONTROL_SMPC           0x01
+#define SDIO_POWER_CONTROL_EMPC           0x02
+
+/* high speed control , 1.20 only */
+#define SDIO_HS_CONTROL_REG               0x13
+#define SDIO_HS_CONTROL_SHS               0x01
+#define SDIO_HS_CONTROL_EHS               0x02
+
+/* Function Base Registers */
+#define xFUNCTION_FBR_OFFSET(funcNo) (0x100*(funcNo))
+/* offset calculation that does not use multiplication */
+static INLINE UINT32 CalculateFBROffset(UCHAR FuncNo) {
+    UCHAR i = FuncNo;
+    UINT32 offset = 0;
+    while (i) {
+        offset += 0x100;
+        i--;
+    }
+    return offset;
+}
+/* Function info */
+#define FBR_FUNC_INFO_REG_OFFSET(fbr)   ((fbr) + 0x00)
+#define FUNC_INFO_SUPPORTS_CSA_MASK     0x40
+#define FUNC_INFO_ENABLE_CSA            0x80
+#define FUNC_INFO_DEVICE_CODE_MASK      0x0F
+#define FUNC_INFO_DEVICE_CODE_LAST      0x0F
+#define FBR_FUNC_EXT_DEVICE_CODE_OFFSET(fbr) ((fbr) + 0x01)
+/* Function Power selection */
+#define FBR_FUNC_POWER_SELECT_OFFSET(fbr)    ((fbr) + 0x02)
+#define FUNC_POWER_SELECT_SPS           0x01
+#define FUNC_POWER_SELECT_EPS           0x02
+/* Function CIS ptr */
+#define FBR_FUNC_CIS_LOW_OFFSET(fbr)   ((fbr) + 0x09)
+#define FBR_FUNC_CIS_MID_OFFSET(fbr)   ((fbr) + 0x0a)
+#define FBR_FUNC_CIS_HI_OFFSET(fbr)    ((fbr) + 0x0b)
+/* Function CSA ptr */
+#define FBR_FUNC_CSA_LOW_OFFSET(fbr)   ((fbr) + 0x0c)
+#define FBR_FUNC_CSA_MID_OFFSET(fbr)   ((fbr) + 0x0d)
+#define FBR_FUNC_CSA_HI_OFFSET(fbr)    ((fbr) + 0x0e)
+/* Function CSA data window */
+#define FBR_FUNC_CSA_DATA_OFFSET(fbr)  ((fbr) + 0x0f)
+/* Function Block Size Control */
+#define FBR_FUNC_BLK_SIZE_LOW_OFFSET(fbr)  ((fbr) + 0x10)
+#define FBR_FUNC_BLK_SIZE_HI_OFFSET(fbr)   ((fbr) + 0x11)
+#define SDIO_CIS_AREA_BEGIN   0x00001000
+#define SDIO_CIS_AREA_END     0x00017fff
+/* Tuple definitions */
+#define CISTPL_NULL         0x00
+#define CISTPL_CHECKSUM     0x10
+#define CISTPL_VERS_1       0x15
+#define CISTPL_ALTSTR       0x16
+#define CISTPL_MANFID       0x20
+#define CISTPL_FUNCID       0x21
+#define CISTPL_FUNCE        0x22
+#define CISTPL_VENDOR       0x91
+#define CISTPL_END          0xff
+#define CISTPL_LINK_END     0xff
+
+
+/* these structures must be packed */
+
+#include "ctstartpack.h"
+
+/* Manufacturer ID tuple */
+struct SDIO_MANFID_TPL {
+    UINT16  ManufacturerCode;   /* jedec code */
+    UINT16  ManufacturerInfo;   /* manufacturer specific code */
+}CT_PACK_STRUCT;
+
+/* Function ID Tuple */
+struct SDIO_FUNC_ID_TPL {
+    UINT8  DeviceCode;  /* device code */
+    UINT8  InitMask;    /* system initialization mask (not used) */
+}CT_PACK_STRUCT;
+
+    /* Extended Function Tuple (Common) */
+struct SDIO_FUNC_EXT_COMMON_TPL {
+    UINT8   Type;                               /* type */
+    UINT16  Func0_MaxBlockSize;                 /* max function 0 block transfer size */
+    UINT8   MaxTransSpeed;                      /* max transfer speed (encoded) */
+#define TRANSFER_UNIT_MULTIPIER_MASK  0x07
+#define TIME_VALUE_MASK               0x78
+#define TIME_VALUE_SHIFT              3
+}CT_PACK_STRUCT;
+
+/* Extended Function Tuple (Per Function) */
+struct SDIO_FUNC_EXT_FUNCTION_TPL {
+    UINT8   Type;                               /* type */
+#define SDIO_FUNC_INFO_WAKEUP_SUPPORT 0x01
+    UINT8   FunctionInfo;                       /* function info */
+    UINT8   SDIORev;                            /* revision */
+    UINT32  CardPSN;                            /* product serial number */
+    UINT32  CSASize;                            /* CSA size */
+    UINT8   CSAProperties;                      /* CSA properties */
+    UINT16  MaxBlockSize;                       /* max block size for block transfers */
+    UINT32  FunctionOCR;                        /* optimal function OCR */
+    UINT8   OpMinPwr;                           /* operational min power */
+    UINT8   OpAvgPwr;                           /* operational average power */
+    UINT8   OpMaxPwr;                           /* operation maximum power */
+    UINT8   SbMinPwr;                           /* standby minimum power */
+    UINT8   SbAvgPwr;                           /* standby average power */
+    UINT8   SbMaxPwr;                           /* standby maximum power */
+    UINT16  MinBandWidth;                       /* minimum bus bandwidth */
+    UINT16  OptBandWidth;                       /* optimalbus bandwitdh */
+}CT_PACK_STRUCT;
+
+struct SDIO_FUNC_EXT_FUNCTION_TPL_1_1 {
+    struct SDIO_FUNC_EXT_FUNCTION_TPL CommonInfo;  /* from 1.0*/
+    UINT16  EnableTimeOut;                  /* timeout for enable */
+    UINT16  OperPwrMaxPwr;
+    UINT16  OperPwrAvgPwr;
+    UINT16  HiPwrMaxPwr;
+    UINT16  HiPwrAvgPwr;
+    UINT16  LowPwrMaxPwr;
+    UINT16  LowPwrAvgPwr;
+}CT_PACK_STRUCT;
+
+#include "ctendpack.h"
+
+static INLINE SDIO_STATUS ConvertCMD52ResponseToSDIOStatus(UINT8 CMD52ResponseFlags) {
+    if (!(CMD52ResponseFlags & SD_R5_ERRORS)) {
+        return SDIO_STATUS_SUCCESS;
+    }
+    if (CMD52ResponseFlags & SD_R5_ILLEGAL_CMD) {
+        return SDIO_STATUS_DATA_STATE_INVALID;
+    } else if (CMD52ResponseFlags & SD_R5_INVALID_FUNC) {
+        return SDIO_STATUS_INVALID_FUNC;
+    } else if (CMD52ResponseFlags & SD_R5_ARG_RANGE_ERR) {
+        return SDIO_STATUS_FUNC_ARG_ERROR;
+    } else {
+        return SDIO_STATUS_DATA_ERROR_UNKNOWN;
+    }
+}
+
+/* CMD6 mode switch definitions */
+
+#define SD_SWITCH_FUNC_CHECK    0
+#define SD_SWITCH_FUNC_SET      ((UINT32)(1 << 31))
+#define SD_FUNC_NO_SELECT_MASK  0x00FFFFFF
+#define SD_SWITCH_GRP_1         0
+#define SD_SWITCH_GRP_2         1
+#define SD_SWITCH_GRP_3         2
+#define SD_SWITCH_GRP_4         3
+#define SD_SWITCH_GRP_5         4
+#define SD_SWITCH_GRP_6         5
+
+#define SD_SWITCH_HIGH_SPEED_GROUP     SD_SWITCH_GRP_1
+#define SD_SWITCH_HIGH_SPEED_FUNC_NO   1
+
+#define SD_SWITCH_MAKE_SHIFT(grp) ((grp) * 4)
+
+#define SD_SWITCH_MAKE_GRP_PATTERN(FuncGrp,FuncNo) \
+     ((SD_FUNC_NO_SELECT_MASK & (~(0xF << SD_SWITCH_MAKE_SHIFT(FuncGrp)))) |  \
+        (((FuncNo) & 0xF) << SD_SWITCH_MAKE_SHIFT(FuncGrp)))                 \
+
+#define SD_SWITCH_FUNC_ARG_GROUP_CHECK(FuncGrp,FuncNo) \
+    (SD_SWITCH_FUNC_CHECK | SD_SWITCH_MAKE_GRP_PATTERN(FuncGrp,FuncNo))
+
+#define SD_SWITCH_FUNC_ARG_GROUP_SET(FuncGrp,FuncNo)   \
+    (SD_SWITCH_FUNC_SET | SD_SWITCH_MAKE_GRP_PATTERN(FuncGrp,FuncNo))
+
+#define SD_SWITCH_FUNC_STATUS_BLOCK_BYTES 64
+
+#define SD_SWITCH_FUNC_STATUS_GET_GRP_BIT_MASK(pBuffer,FuncGrp) \
+    (USHORT)((pBuffer)[50 + ((FuncGrp)*2)] | ((pBuffer)[51 + ((FuncGrp)*2)] << 8))
+
+#define SD_SWITCH_FUNC_STATUS_GET_MAX_CURRENT(pBuffer) \
+     (USHORT)((pBuffer)[62] | ((pBuffer)[63] << 8))
+
+static INLINE UINT8 SDSwitchGetSwitchResult(PUINT8 pBuffer, UINT8 FuncGrp)
+{
+    switch (FuncGrp) {
+        case 0:
+            return (pBuffer[47] & 0xF);
+        case 1:
+            return (pBuffer[47] >> 4);
+        case 2:
+            return (pBuffer[48] & 0xF);
+        case 3:
+            return (pBuffer[48] >> 4);
+        case 4:
+            return (pBuffer[49] & 0xF);
+        case 5:
+            return (pBuffer[49] >> 4);
+        default:
+            return 0xF;
+    }
+}
+
+#endif
Index: linux-2.6/include/linux/sdio/ctendpack.h
===================================================================
--- /dev/null
+++ linux-2.6/include/linux/sdio/ctendpack.h
@@ -0,0 +1,64 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: ctendpack.h
+
+@abstract: end compiler-specific structure packing
+
+@notice: Copyright (c), 2006 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#ifdef VXWORKS
+#endif /* VXWORKS */
+
+#if defined(LINUX) || defined(__linux__)
+#endif /* LINUX */
+
+#ifdef QNX
+#endif /* QNX */
+
+#ifdef INTEGRITY
+#include "integrity/ctendpack_integrity.h"
+#endif /* INTEGRITY */
+
+#ifdef NUCLEUS
+#endif /* NUCLEUS */
+
+#ifdef UNDER_CE
+#include "wince/ctendpack_wince.h"
+#endif /* WINCE */
+
Index: linux-2.6/include/linux/sdio/ctstartpack.h
===================================================================
--- /dev/null
+++ linux-2.6/include/linux/sdio/ctstartpack.h
@@ -0,0 +1,65 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: ctstartpack.h
+
+@abstract: start compiler-specific structure packing
+
+@notice: Copyright (c), 2006 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+#ifdef VXWORKS
+#endif /* VXWORKS */
+
+#if defined(LINUX) || defined(__linux__)
+#endif /* LINUX */
+
+#ifdef QNX
+#endif /* QNX */
+
+#ifdef INTEGRITY
+#include "integrity/ctstartpack_integrity.h"
+#endif /* INTEGRITY */
+
+#ifdef NUCLEUS
+#endif /* NUCLEUS */
+
+#ifdef UNDER_CE
+#include "wince/ctstartpack_wince.h"
+#endif /* WINCE */
+
Index: linux-2.6/include/linux/sdio/ctsystem.h
===================================================================
--- /dev/null
+++ linux-2.6/include/linux/sdio/ctsystem.h
@@ -0,0 +1,115 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: cpsystem.h
+
+@abstract: common system include file.
+
+@notice: Copyright (c), 2004-2006 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#ifndef __CPSYSTEM_H___
+#define __CPSYSTEM_H___
+
+/* SDIO stack status defines */
+/* < 0 error, >0 warning, 0 success */
+#define SDIO_IS_WARNING(status) ((status) > 0)
+#define SDIO_IS_ERROR(status) ((status) < 0)
+#define SDIO_SUCCESS(status) ((SDIO_STATUS)(status) >= 0)
+#define SDIO_STATUS_SUCCESS             0
+#define SDIO_STATUS_ERROR              -1
+#define SDIO_STATUS_INVALID_PARAMETER  -2
+#define SDIO_STATUS_PENDING             3
+#define SDIO_STATUS_DEVICE_NOT_FOUND   -4
+#define SDIO_STATUS_DEVICE_ERROR       -5
+#define SDIO_STATUS_INTERRUPTED        -6
+#define SDIO_STATUS_NO_RESOURCES       -7
+#define SDIO_STATUS_CANCELED           -8
+#define SDIO_STATUS_BUFFER_TOO_SMALL   -9
+#define SDIO_STATUS_NO_MORE_MESSAGES   -10
+#define SDIO_STATUS_BUS_RESP_TIMEOUT   -20    /* response timed-out */
+#define SDIO_STATUS_BUS_READ_TIMEOUT   -21    /* read data timed-out */
+#define SDIO_STATUS_BUS_READ_CRC_ERR   -22   /* data CRC failed */
+#define SDIO_STATUS_BUS_WRITE_ERROR    -23   /* write failed */
+#define SDIO_STATUS_BUS_RESP_CRC_ERR   -24   /* response received with a CRC error */
+#define SDIO_STATUS_INVALID_TUPLE_LENGTH -25 /* tuple length was invalid */
+#define SDIO_STATUS_TUPLE_NOT_FOUND      -26 /* tuple could not be found */
+#define SDIO_STATUS_CIS_OUT_OF_RANGE     -27 /* CIS is out of range in the tuple scan */
+#define SDIO_STATUS_FUNC_ENABLE_TIMEOUT  -28 /* card timed out enabling or disabling */
+#define SDIO_STATUS_DATA_STATE_INVALID   -29 /* card is in an invalid state for data */
+#define SDIO_STATUS_DATA_ERROR_UNKNOWN   -30 /* card cannot process data transfer */
+#define SDIO_STATUS_INVALID_FUNC         -31 /* sdio request is not valid for the function */
+#define SDIO_STATUS_FUNC_ARG_ERROR       -32 /* sdio request argument is invalid or out of range */
+#define SDIO_STATUS_INVALID_COMMAND      -33 /* SD COMMAND is invalid for the card state */
+#define SDIO_STATUS_SDREQ_QUEUE_FAILED   -34 /* request failed to insert into queue */
+#define SDIO_STATUS_BUS_RESP_TIMEOUT_SHIFTABLE -35  /* response timed-out, possibily shiftable to correct  */
+#define SDIO_STATUS_UNSUPPORTED          -36  /* not supported  */
+#define SDIO_STATUS_PROGRAM_TIMEOUT      -37  /* memory card programming timeout  */
+#define SDIO_STATUS_PROGRAM_STATUS_ERROR -38  /* memory card programming errors  */
+
+#include <linux/sdio/ctsystem_linux.h>
+
+/* get structure from contained field */
+#define CONTAINING_STRUCT(address, struct_type, field_name)\
+            ((struct_type *)((ULONG_PTR)(address) - (ULONG_PTR)(&((struct_type *)0)->field_name)))
+
+#define ZERO_OBJECT(obj) memset(&(obj),0,sizeof(obj))
+#define ZERO_POBJECT(pObj) memset((pObj),0,sizeof(*(pObj)))
+
+
+/* bit field support functions */
+static INLINE void SetBit(PULONG pField, UINT position) {
+    *pField |= 1 << position;
+}
+static INLINE void ClearBit(PULONG pField, UINT position) {
+    *pField &= ~(1 << position);
+}
+static INLINE BOOL IsBitSet(PULONG pField, UINT position) {
+    return (*pField & (1 << position));
+}
+static INLINE INT FirstClearBit(PULONG pField) {
+    UINT ii;
+    for(ii = 0; ii < sizeof(ULONG)*8; ii++) {
+        if (!IsBitSet(pField, ii)) {
+            return ii;
+        }
+    }
+    /* no clear bits found */
+    return -1;
+}
+
+#endif /* __CPSYSTEM_H___ */
Index: linux-2.6/include/linux/sdio/ctsystem_linux.h
===================================================================
--- /dev/null
+++ linux-2.6/include/linux/sdio/ctsystem_linux.h
@@ -0,0 +1,1058 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: ctsystem_linux.h
+
+@abstract: common system include file for Linux.
+
+@notice: Copyright (c), 2004-2006 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#ifndef __CPSYSTEM_LINUX_H___
+#define __CPSYSTEM_LINUX_H___
+
+/* #define DBG_TIMESTAMP 1 */
+#define SD_TRACK_REQ 1
+
+/* LINUX support */
+#include <linux/version.h>
+
+#ifndef KERNEL_VERSION
+  #error KERNEL_VERSION macro not defined!
+#endif
+
+#ifndef  LINUX_VERSION_CODE
+  #error LINUX_VERSION_CODE macro not defined!
+#endif
+
+#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/module.h>
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,20)
+#include <linux/slab.h>
+#endif
+
+#include <linux/interrupt.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,9)
+#include <linux/pnp.h>
+#include <asm/hardirq.h>
+#endif
+#include <asm/semaphore.h>
+#include <asm/io.h>
+#include <asm/scatterlist.h>
+#ifdef DBG_TIMESTAMP
+#include <asm/timex.h>
+#endif /* DBG_TIMESTAMP */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,9)
+#ifndef in_atomic
+    /* released version of 2.6.9 */
+#include <linux/hardirq.h>
+#endif
+#endif
+#include <linux/delay.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <linux/device.h>
+#endif
+
+#if 1
+	/* The build breaks if SDIO_USE_LINUX_PNP is not defined. */
+#define SDIO_USE_LINUX_PNP
+#else
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)) && (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,16))
+    /* for legacy systems that have PnP enabled */
+#define SDIO_USE_LINUX_PNP
+#endif
+#endif
+
+/* generic types */
+typedef    unsigned char    UCHAR;
+typedef    unsigned char *  PUCHAR;
+typedef    char             TEXT;
+typedef    char *           PTEXT;
+typedef    unsigned short   USHORT;
+typedef    unsigned short*  PUSHORT;
+typedef    unsigned int     UINT;
+typedef    unsigned int*    PUINT;
+typedef    int              INT;
+typedef    int*             PINT;
+typedef    unsigned long    ULONG;
+typedef    unsigned long*   PULONG;
+typedef    u8               UINT8;
+typedef    u16              UINT16;
+typedef    u32              UINT32;
+typedef    u8*              PUINT8;
+typedef    u16*             PUINT16;
+typedef    u32*             PUINT32;
+typedef    unsigned char *  ULONG_PTR;
+typedef    void*            PVOID;
+typedef    unsigned char    BOOL;
+typedef    BOOL*            PBOOL;
+typedef    int              SDIO_STATUS;
+typedef    int              SYSTEM_STATUS;
+typedef    unsigned int     EVENT_TYPE;
+typedef    unsigned int     EVENT_ARG;
+typedef    unsigned int*    PEVENT_TYPE;
+typedef    struct semaphore OS_SEMAPHORE;
+typedef    struct semaphore* POS_SEMAPHORE;
+typedef    struct semaphore  OS_SIGNAL;    /* OS signals are just semaphores */
+typedef    struct semaphore* POS_SIGNAL;
+typedef    spinlock_t OS_CRITICALSECTION;
+typedef    spinlock_t *POS_CRITICALSECTION;
+typedef    int              SDPOWER_STATE;
+typedef    unsigned long    ATOMIC_FLAGS;
+typedef    INT              THREAD_RETURN;
+typedef    dma_addr_t       DMA_ADDRESS;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,9)
+typedef    struct task_struct* PKERNEL_TASK;
+typedef    struct device_driver OS_DRIVER;
+typedef    struct device_driver* POS_DRIVER;
+typedef    struct device    OS_DEVICE;
+typedef    struct device*   POS_DEVICE;
+
+#ifdef SDIO_USE_LINUX_PNP
+typedef    struct pnp_driver OS_PNPDRIVER;
+typedef    struct pnp_driver* POS_PNPDRIVER;
+typedef    struct pnp_dev   OS_PNPDEVICE;
+typedef    struct pnp_dev*  POS_PNPDEVICE;
+#else
+    /* not using PnP subsystem */
+typedef    PVOID            OS_PNPDRIVER;
+typedef    PVOID*           POS_PNPDRIVER;
+typedef    PVOID            OS_PNPDEVICE;
+typedef    PVOID*           POS_PNPDEVICE;
+#endif
+
+typedef    struct module*   POS_MODULE;
+#else
+/* 2.4 */
+typedef    int              PKERNEL_TASK;
+typedef    PVOID            OS_DRIVER;
+typedef    PVOID*           POS_DRIVER;
+typedef    PVOID            OS_DEVICE;
+typedef    PVOID*           POS_DEVICE;
+typedef    PVOID            OS_PNPDRIVER;
+typedef    PVOID*           POS_PNPDRIVER;
+typedef    PVOID            OS_PNPDEVICE;
+typedef    PVOID*           POS_PNPDEVICE;
+typedef    struct module*   POS_MODULE;
+#define    module_param(a,b,c) MODULE_PARM(a, "i")
+#endif
+
+typedef    int              CT_DEBUG_LEVEL;
+
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+#ifndef FALSE
+#define FALSE 0
+#endif
+#ifndef NULL
+#define NULL ((PVOID)0)
+#endif
+#define SDDMA_DESCRIPTION_FLAG_DMA   0x1  /* DMA enabled */
+#define SDDMA_DESCRIPTION_FLAG_SGDMA 0x2  /* Scatter-Gather DMA enabled */
+typedef struct _SDDMA_DESCRIPTION {
+    UINT16      Flags;      /* SDDMA_DESCRIPTION_FLAG_xxx */
+    UINT16      MaxDescriptors; /* number of supported scatter gather entries */
+    UINT32      MaxBytesPerDescriptor;  /* maximum bytes in a DMA descriptor entry */
+    u64         Mask;              /* dma address mask */
+    UINT32      AddressAlignment;  /* dma address alignment mask, least significant bits indicate illegal address bits */
+    UINT32      LengthAlignment;   /* dma buffer length alignment mask, least significant bits indicate illegal length bits  */
+}SDDMA_DESCRIPTION, *PSDDMA_DESCRIPTION;
+typedef struct scatterlist SDDMA_DESCRIPTOR, *PSDDMA_DESCRIPTOR;
+
+#define INLINE  inline
+#define CT_PACK_STRUCT __attribute__ ((packed))
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,9)
+#define CT_DECLARE_MODULE_PARAM_INTEGER(p)  module_param(p, int, 0644);
+#else
+#define CT_DECLARE_MODULE_PARAM_INTEGER(p)  MODULE_PARM(p, "i");
+#endif
+
+/* debug print macros */
+//#define SDDBG_KERNEL_PRINT_LEVEL KERN_DEBUG
+#define SDDBG_KERNEL_PRINT_LEVEL KERN_ALERT
+#ifdef DEBUG
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Evaluation the expression and throw an assertion if false.
+
+  @function name: DBG_ASSERT
+  @prototype: void DBG_ASSERT(test)
+  @category: Support_Reference
+  @input:  test   - boolean expression
+
+  @output: none
+
+  @return:
+
+  @notes: This function can be conditionally compiled using the c-define DEBUG.
+
+  @see also: DBG_PRINT
+  @example: Assert test:
+        count--;
+        DBG_ASSERT(count >= 0);
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define DBG_ASSERT(test) \
+{                         \
+    if (!(test)) {          \
+        DBG_PRINT(SDDBG_ERROR, ("Debug Assert Caught, File %s, Line: %d, Test:%s \n",__FILE__, __LINE__,#test)); \
+    }                     \
+}
+#define DBG_ASSERT_WITH_MSG(test,s) \
+{                                   \
+    if (!(test)) {                  \
+        DBG_PRINT(SDDBG_ERROR, ("Assert:%s File %s, Line: %d \n",(s),__FILE__, __LINE__)); \
+    }                     \
+}
+
+#ifdef DBG_DECLARE
+CT_DEBUG_LEVEL debuglevel = DBG_DECLARE;
+#ifdef DBG_TIMESTAMP
+cycles_t g_lasttimestamp = 0;
+#endif /* DBG_TIMESTAMP */
+#else  /* DBG_DECLARE */
+extern CT_DEBUG_LEVEL debuglevel;
+#ifdef DBG_TIMESTAMP
+extern cycles_t g_lasttimestamp;
+#endif /* DBG_TIMESTAMP */
+#endif /* DBG_DECLARE */
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Print a string to the debugger or console
+
+  @function name: DBG_PRINT
+  @prototype: void DBG_PRINT(INT Level, string)
+  @category: Support_Reference
+  @input:  Level - debug level for the print
+
+  @output: none
+
+  @return:
+
+  @notes: If Level is less than the current debug level, the print will be
+          issued.  This function can be conditionally compiled using the c-define DEBUG.
+  @see also: REL_PRINT
+  @example: DBG_PRINT(MY_DBG_LEVEL, ("Return Status: %d\r\n",status));
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#ifdef DBG_TIMESTAMP
+#define DBG_PRINT(lvl, args)\
+    {if (lvl <= DBG_GET_DEBUG_LEVEL()) {\
+          ulong _delta_timestamp;\
+          cycles_t _last_timestamp = g_lasttimestamp;\
+          g_lasttimestamp = get_cycles();\
+          /* avoid 64-bit divides, to microseconds*/\
+          _delta_timestamp =((ulong)(g_lasttimestamp - _last_timestamp)/(ulong)(cpu_khz/(ulong)1000));\
+          printk(SDDBG_KERNEL_PRINT_LEVEL "(%lld:%ldus) ", g_lasttimestamp, _delta_timestamp);\
+          printk(SDDBG_KERNEL_PRINT_LEVEL _DBG_PRINTX_ARG args);\
+        }\
+    }
+#else /* DBG_TIMESTAMP */
+#define DBG_PRINT(lvl, args)\
+    {if (lvl <= DBG_GET_DEBUG_LEVEL())\
+        printk(SDDBG_KERNEL_PRINT_LEVEL _DBG_PRINTX_ARG args);\
+    }
+#endif /* DBG_TIMESTAMP */
+#else /* DEBUG */
+
+#ifdef DBG_DECLARE
+CT_DEBUG_LEVEL debuglevel = DBG_DECLARE;
+#else  /* DBG_DECLARE */
+extern CT_DEBUG_LEVEL debuglevel;
+#endif /* DBG_DECLARE */
+
+#define DBG_PRINT(lvl, str)
+#define DBG_ASSERT(test)
+#define DBG_ASSERT_WITH_MSG(test,s)
+#endif /* DEBUG */
+
+#define _DBG_PRINTX_ARG(arg...) arg /* unroll the parens around the var args*/
+#define DBG_GET_DEBUG_LEVEL() debuglevel
+#define DBG_SET_DEBUG_LEVEL(v) debuglevel = (v)
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Print a string to the debugger or console
+
+  @function name: REL_PRINT
+  @prototype: void REL_PRINT(INT Level, string)
+  @category: Support_Reference
+  @input:  Level - debug level for the print
+
+  @output: none
+
+  @return:
+
+  @notes: If Level is less than the current debug level, the print will be
+          issued. This print cannot be conditionally compiled.
+  @see also: DBG_PRINT
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define REL_PRINT(lvl, args)\
+    {if (lvl <= DBG_GET_DEBUG_LEVEL())\
+        printk(SDDBG_KERNEL_PRINT_LEVEL _DBG_PRINTX_ARG args);\
+    }
+/* debug output levels, this must be order low number to higher */
+#define SDDBG_ERROR 3
+#define SDDBG_WARN  4
+#define SDDBG_DEBUG 6
+#define SDDBG_TRACE 7
+
+#ifdef DBG_CRIT_SECTION_RECURSE
+   /* this macro thows an exception if the lock is recursively taken
+    * the kernel must be configured with: CONFIG_DEBUG_SPINLOCK=y */
+#define call_spin_lock(pCrit) \
+{                                     \
+  UINT32 unlocked = 1;                \
+  if ((pCrit)->lock) {unlocked = 0;}  \
+  spin_lock_bh(pCrit);                \
+  if (!unlocked) {                     \
+     unlocked = 0x01;                   \
+     unlocked = *((volatile UINT32 *)unlocked); \
+  }                                   \
+}
+
+#define call_spin_lock_irqsave(pCrit,isc) \
+{                                     \
+  UINT32 unlocked = 1;                \
+  if ((pCrit)->lock) {unlocked = 0;}  \
+  spin_lock_irqsave(pCrit,isc);                \
+  if (!unlocked) {                     \
+     unlocked = 0x01;                   \
+     unlocked = *((volatile UINT32 *)unlocked); \
+  }                                   \
+}
+
+#else
+#define call_spin_lock(s) spin_lock_bh(s)
+#define call_spin_lock_irqsave(s,isc) spin_lock_irqsave(s,isc)
+#endif
+
+#define call_spin_unlock(s) spin_unlock_bh((s))
+#define call_spin_unlock_irqrestore(s,isc) spin_unlock_irqrestore(s,isc)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,9)
+#define NonSchedulable() (in_atomic() || irqs_disabled())
+#else
+#define NonSchedulable() (irqs_disabled())
+#endif
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Initialize a critical section object.
+
+  @function name: CriticalSectionInit
+  @prototype: SDIO_STATUS CriticalSectionInit(POS_CRITICALSECTION pCrit)
+  @category: Support_Reference
+  @output: pCrit - pointer to critical section to initialize
+
+  @return: SDIO_STATUS_SUCCESS on success.
+
+  @notes:  CriticalSectionDelete() must be called to cleanup any resources
+           associated with the critical section.
+
+  @see also: CriticalSectionDelete, CriticalSectionAcquire, CriticalSectionRelease
+  @example: To initialize a critical section:
+        status = CriticalSectionInit(&pDevice->ListLock);
+        if (!SDIO_SUCCESS(status)) {
+                .. failed
+            return status;
+        }
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static inline SDIO_STATUS CriticalSectionInit(POS_CRITICALSECTION pCrit) {
+    spin_lock_init(pCrit);
+    return SDIO_STATUS_SUCCESS;
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Acquire a critical section lock.
+
+  @function name: CriticalSectionAcquire
+  @prototype: SDIO_STATUS CriticalSectionAcquire(POS_CRITICALSECTION pCrit)
+  @category: Support_Reference
+
+  @input: pCrit - pointer to critical section that was initialized
+
+  @return: SDIO_STATUS_SUCCESS on success.
+
+  @notes:  The critical section lock is acquired when this function returns
+           SDIO_STATUS_SUCCESS.  Use CriticalSectionRelease() to release
+           the critical section lock.
+
+  @see also: CriticalSectionRelease
+
+  @example: To acquire a critical section lock:
+        status = CriticalSectionAcquire(&pDevice->ListLock);
+        if (!SDIO_SUCCESS(status)) {
+                .. failed
+            return status;
+        }
+        ... access protected data
+            // unlock
+        status = CriticalSectionRelease(&pDevice->ListLock);
+        if (!SDIO_SUCCESS(status)) {
+                .. failed
+            return status;
+        }
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static inline SDIO_STATUS CriticalSectionAcquire(POS_CRITICALSECTION pCrit) {
+    call_spin_lock(pCrit);
+    return SDIO_STATUS_SUCCESS;
+}
+
+// macro-tized versions
+#define CriticalSectionAcquire_M(pCrit) \
+    SDIO_STATUS_SUCCESS; call_spin_lock(pCrit)
+#define CriticalSectionRelease_M(pCrit) \
+    SDIO_STATUS_SUCCESS; call_spin_unlock(pCrit)
+
+#define CT_DECLARE_IRQ_SYNC_CONTEXT() unsigned long _ctSyncFlags
+
+#define CriticalSectionAcquireSyncIrq(pCrit) \
+    SDIO_STATUS_SUCCESS; call_spin_lock_irqsave(pCrit,_ctSyncFlags)
+
+#define CriticalSectionReleaseSyncIrq(pCrit) \
+    SDIO_STATUS_SUCCESS; call_spin_unlock_irqrestore(pCrit,_ctSyncFlags)
+
+
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Release a critical section lock.
+
+  @function name: CriticalSectionRelease
+  @prototype: SDIO_STATUS CriticalSectionRelease(POS_CRITICALSECTION pCrit)
+  @category: Support_Reference
+
+  @input: pCrit - pointer to critical section that was initialized
+
+  @return: SDIO_STATUS_SUCCESS on success.
+
+  @notes:  The critical section lock is released when this function returns
+           SDIO_STATUS_SUCCESS.
+
+  @see also: CriticalSectionAcquire
+
+  @example: see CriticalSectionAcquire
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static inline SDIO_STATUS CriticalSectionRelease(POS_CRITICALSECTION pCrit) {
+    call_spin_unlock(pCrit);
+    return SDIO_STATUS_SUCCESS;
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Cleanup a critical section object
+
+  @function name: CriticalSectionDelete
+  @prototype: void CriticalSectionDelete(POS_CRITICALSECTION pCrit)
+  @category: Support_Reference
+
+  @input: pCrit - an initialized critical section object
+
+  @return: SDIO_STATUS_SUCCESS on success.
+
+  @notes:
+
+  @see also: CriticalSectionInit, CriticalSectionAcquire, CriticalSectionRelease
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static inline void CriticalSectionDelete(POS_CRITICALSECTION pCrit) {
+    return;
+}
+
+/* internal use */
+static inline SDIO_STATUS SignalInitialize(POS_SIGNAL pSignal) {
+    sema_init(pSignal, 0);
+    return SDIO_STATUS_SUCCESS;
+}
+/* internal use */
+static inline void SignalDelete(POS_SIGNAL pSignal) {
+    return;
+}
+/* internal use */
+static inline SDIO_STATUS SignalWaitInterruptible(POS_SIGNAL pSignal) {
+    DBG_ASSERT_WITH_MSG(!NonSchedulable(),"SignalWaitInterruptible not allowed\n");
+    if (down_interruptible(pSignal) == 0) {
+        return SDIO_STATUS_SUCCESS;
+    } else {
+        return SDIO_STATUS_INTERRUPTED;
+    }
+}
+/* internal use */
+static inline SDIO_STATUS SignalWait(POS_SIGNAL pSignal) {
+    DBG_ASSERT_WITH_MSG(!NonSchedulable(),"SignalWait not allowed\n");
+    down(pSignal);
+    return SDIO_STATUS_SUCCESS;
+}
+
+/* internal use */
+static inline SDIO_STATUS SignalSet(POS_SIGNAL pSignal) {
+    up(pSignal);
+    return SDIO_STATUS_SUCCESS;
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Initialize a semaphore object.
+
+  @function name: SemaphoreInitialize
+  @prototype: SDIO_STATUS SemaphoreInitialize(POS_SEMAPHORE pSem, UINT value)
+  @category: Support_Reference
+
+  @input:  value - initial value of the semaphore
+
+  @output: pSem - pointer to a semaphore object to initialize
+
+  @return: SDIO_STATUS_SUCCESS on success.
+
+  @notes:  SemaphoreDelete() must be called to cleanup any resources
+           associated with the semaphore
+
+  @see also: SemaphoreDelete, SemaphorePend, SemaphorePendInterruptable
+
+  @example: To initialize a semaphore:
+        status = SemaphoreInitialize(&pDevice->ResourceSem,1);
+        if (!SDIO_SUCCESS(status)) {
+                .. failed
+            return status;
+        }
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static inline SDIO_STATUS SemaphoreInitialize(POS_SEMAPHORE pSem, UINT value) {
+    sema_init(pSem, value);
+    return SDIO_STATUS_SUCCESS;
+}
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Cleanup a semaphore object.
+
+  @function name: SemaphoreDelete
+  @prototype: void SemaphoreDelete(POS_SEMAPHORE pSem)
+  @category: Support_Reference
+
+  @input: pSem - pointer to a semaphore object to cleanup
+
+  @return:
+
+  @notes:
+
+  @see also: SemaphoreInitialize
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static inline void SemaphoreDelete(POS_SEMAPHORE pSem) {
+    return;
+}
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Acquire the semaphore or pend if the resource is not available
+
+  @function name: SemaphorePend
+  @prototype: SDIO_STATUS SemaphorePend(POS_SEMAPHORE pSem)
+  @category: Support_Reference
+
+  @input: pSem - pointer to an initialized semaphore object
+
+  @return: SDIO_STATUS_SUCCESS on success.
+
+  @notes: If the semaphore count is zero this function blocks until the count
+          becomes non-zero, otherwise the count is decremented and execution
+          continues. While waiting, the task/thread cannot be interrupted.
+          If the task or thread should be interruptible, use SemaphorePendInterruptible.
+          On some OSes SemaphorePend and SemaphorePendInterruptible behave the same.
+
+  @see also: SemaphorePendInterruptable, SemaphorePost
+  @example: To wait for a resource using a semaphore:
+        status = SemaphorePend(&pDevice->ResourceSem);
+        if (!SDIO_SUCCESS(status)) {
+                .. failed
+            return status;
+        }
+        ... resource acquired
+        SemaphorePost(&pDevice->ResourceSem);
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static inline SDIO_STATUS SemaphorePend(POS_SEMAPHORE pSem) {
+    DBG_ASSERT_WITH_MSG(!NonSchedulable(),"SemaphorePend not allowed\n");
+    down(pSem);
+    return SDIO_STATUS_SUCCESS;
+}
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Acquire the semaphore or pend if the resource is not available
+
+  @function name: SemaphorePendInterruptable
+  @prototype: SDIO_STATUS SemaphorePendInterruptable(POS_SEMAPHORE pSem)
+  @category: Support_Reference
+
+  @input: pSem - pointer to an initialized semaphore object
+
+  @return: SDIO_STATUS_SUCCESS on success.
+
+  @notes: If the semaphore count is zero this function blocks until the count
+          becomes non-zero, otherwise the count is decremented and execution
+          continues. While waiting, the task/thread can be interrupted.
+          If the task or thread should not be interruptible, use SemaphorePend.
+
+  @see also: SemaphorePend, SemaphorePost
+  @example: To wait for a resource using a semaphore:
+        status = SemaphorePendInterruptable(&pDevice->ResourceSem);
+        if (!SDIO_SUCCESS(status)) {
+                .. failed, could have been interrupted
+            return status;
+        }
+        ... resource acquired
+        SemaphorePost(&pDevice->ResourceSem);
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static inline SDIO_STATUS SemaphorePendInterruptable(POS_SEMAPHORE pSem) {
+    DBG_ASSERT_WITH_MSG(!NonSchedulable(),"SemaphorePendInterruptable not allowed\n");
+    if (down_interruptible(pSem) == 0) {
+        return SDIO_STATUS_SUCCESS;
+    } else {
+        return SDIO_STATUS_INTERRUPTED;
+    }
+}
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Post a semaphore.
+
+  @function name: SemaphorePost
+  @prototype: SDIO_STATUS SemaphorePost(POS_SEMAPHORE pSem)
+  @category: Support_Reference
+
+  @input: pSem - pointer to an initialized semaphore object
+
+  @return: SDIO_STATUS_SUCCESS on success.
+
+  @notes: This function increments the semaphore count.
+
+  @see also: SemaphorePend, SemaphorePendInterruptable.
+  @example: Posting a semaphore:
+        status = SemaphorePendInterruptable(&pDevice->ResourceSem);
+        if (!SDIO_SUCCESS(status)) {
+                .. failed, could have been interrupted
+            return status;
+        }
+        ... resource acquired
+            // post the semaphore
+        SemaphorePost(&pDevice->ResourceSem);
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static inline SDIO_STATUS SemaphorePost(POS_SEMAPHORE pSem) {
+    DBG_ASSERT_WITH_MSG(!NonSchedulable(),"SemaphorePost not allowed\n");
+    up(pSem);
+    return SDIO_STATUS_SUCCESS;
+}
+
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Allocate a block of kernel accessible memory
+
+  @function name: KernelAlloc
+  @prototype: PVOID KernelAlloc(UINT size)
+  @category: Support_Reference
+
+  @input: size - size of memory block to allocate
+
+  @return: pointer to the allocated memory, NULL if allocation failed
+
+  @notes: For operating systems that use paging, the allocated memory is always
+          non-paged memory.  Caller should only use KernelFree() to release the
+          block of memory.  This call can potentially block and should only be called
+          from a schedulable context.  Use KernelAllocIrqSafe() if the allocation
+          must be made from a non-schedulable context.
+
+  @see also: KernelFree, KernelAllocIrqSafe
+  @example: allocating memory:
+        pBlock = KernelAlloc(1024);
+        if (pBlock == NULL) {
+                .. failed, no memory
+            return SDIO_STATUS_INSUFFICIENT_RESOURCES;
+        }
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static inline PVOID KernelAlloc(UINT size) {
+    PVOID pMem = kmalloc(size, GFP_KERNEL);
+    if (pMem != NULL) { memset(pMem,0,size); }
+    return pMem;
+}
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Free a block of kernel accessible memory.
+
+  @function name: KernelFree
+  @prototype: void KernelFree(PVOID ptr)
+  @category: Support_Reference
+
+  @input: ptr - pointer to memory allocated with KernelAlloc()
+
+  @return:
+
+  @notes: Caller should only use KernelFree() to release memory that was allocated
+          with KernelAlloc().
+
+  @see also: KernelAlloc
+  @example: KernelFree(pBlock);
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static inline void KernelFree(PVOID ptr) {
+    kfree(ptr);
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Allocate a block of kernel accessible memory in an IRQ-safe manner
+
+  @function name: KernelAllocIrqSafe
+  @prototype: PVOID KernelAllocIrqSafe(UINT size)
+  @category: Support_Reference
+
+  @input: size - size of memory block to allocate
+
+  @return: pointer to the allocated memory, NULL if allocation failed
+
+  @notes: This variant of KernelAlloc allows the allocation of small blocks of
+          memory from an ISR or from a context where scheduling has been disabled.
+          The allocations should be small as the memory is typically allocated
+          from a critical heap. The caller should only use KernelFreeIrqSafe()
+          to release the block of memory.
+
+  @see also: KernelAlloc, KernelFreeIrqSafe
+  @example: allocating memory:
+        pBlock = KernelAllocIrqSafe(16);
+        if (pBlock == NULL) {
+                .. failed, no memory
+            return SDIO_STATUS_INSUFFICIENT_RESOURCES;
+        }
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static inline PVOID KernelAllocIrqSafe(UINT size) {
+    return kmalloc(size, GFP_ATOMIC);
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Free a block of kernel accessible memory.
+
+  @function name: KernelFreeIrqSafe
+  @prototype: void KernelFreeIrqSafe(PVOID ptr)
+  @category: Support_Reference
+
+  @input: ptr - pointer to memory allocated with KernelAllocIrqSafe()
+
+  @return:
+
+  @notes: Caller should only use KernelFreeIrqSafe() to release memory that was allocated
+          with KernelAllocIrqSafe().
+
+  @see also: KernelAllocIrqSafe
+  @example: KernelFreeIrqSafe(pBlock);
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static inline void KernelFreeIrqSafe(PVOID ptr) {
+    kfree(ptr);
+}
+
+/* error status conversions */
+static inline SYSTEM_STATUS SDIOErrorToOSError(SDIO_STATUS status) {
+    switch (status) {
+        case SDIO_STATUS_SUCCESS:
+            return 0;
+        case SDIO_STATUS_INVALID_PARAMETER:
+            return -EINVAL;
+        case SDIO_STATUS_PENDING:
+            return -EAGAIN; /* try again */
+        case SDIO_STATUS_DEVICE_NOT_FOUND:
+            return -ENXIO;
+        case SDIO_STATUS_DEVICE_ERROR:
+            return -EIO;
+        case SDIO_STATUS_INTERRUPTED:
+            return -EINTR;
+        case SDIO_STATUS_NO_RESOURCES:
+            return -ENOMEM;
+        case SDIO_STATUS_ERROR:
+        default:
+            return -EFAULT;
+    }
+}
+static inline SDIO_STATUS OSErrorToSDIOError(SYSTEM_STATUS status) {
+    if (status >=0) {
+        return SDIO_STATUS_SUCCESS;
+    }
+    switch (status) {
+        case -EINVAL:
+            return SDIO_STATUS_INVALID_PARAMETER;
+        case -ENXIO:
+            return SDIO_STATUS_DEVICE_NOT_FOUND;
+        case -EIO:
+            return SDIO_STATUS_DEVICE_ERROR;
+        case -EINTR:
+            return SDIO_STATUS_INTERRUPTED;
+        case -ENOMEM:
+            return SDIO_STATUS_NO_RESOURCES;
+        case -EFAULT:
+            return SDIO_STATUS_ERROR;
+        default:
+            return SDIO_STATUS_ERROR;
+    }
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Sleep or delay the execution context for a number of milliseconds.
+
+  @function name: OSSleep
+  @prototype: SDIO_STATUS OSSleep(INT SleepInterval)
+  @category: Support_Reference
+
+  @input: SleepInterval - time in milliseconds to put the execution context to sleep
+
+  @return: SDIO_STATUS_SUCCESS if sleep succeeded.
+
+  @notes: Caller should be in a context that allows it to sleep or block.  The
+  minimum duration of sleep may be greater than 1 MS on some platforms and OSes.
+
+  @see also: OSSleep
+  @example: Using sleep to delay
+        EnableSlotPower(pSlot);
+            // wait for power to settle
+        status = OSSleep(100);
+        if (!SDIO_SUCCESS(status)){
+            // failed..
+        }
+
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static inline SDIO_STATUS OSSleep(INT SleepInterval) {
+    UINT32 delta;
+
+    DBG_ASSERT_WITH_MSG(!NonSchedulable(),"OSSleep not allowed\n");
+        /* convert timeout to ticks */
+    delta = (SleepInterval * HZ)/1000;
+    if (delta == 0) {
+        delta = 1;
+    }
+    set_current_state(TASK_INTERRUPTIBLE);
+    if (schedule_timeout(delta) != 0) {
+        return SDIO_STATUS_INTERRUPTED;
+    }
+    return SDIO_STATUS_SUCCESS;
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: get the OSs device object
+
+  @function name: SD_GET_OS_DEVICE
+  @prototype: POS_DEVICE SD_GET_OS_DEVICE(PSDDEVICE pDevice)
+  @category: Support_Reference
+
+  @input: pDevice - the device on the HCD
+
+  @return: pointer to the OSs device
+
+  @see also:
+  @example: obtain low level device
+        pFunctionContext->GpsDevice.Port.dev = SD_GET_OS_DEVICE(pDevice);
+
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SD_GET_OS_DEVICE(pDevice) &((pDevice)->Device.dev)
+
+
+#ifdef __iomem
+    /* new type checking in 2.6.9 */
+    /* I/O Access macros */
+#define _READ_DWORD_REG(reg)  \
+        readl((const volatile void __iomem *)(reg))
+#define _READ_WORD_REG(reg)  \
+        readw((const volatile void __iomem *)(reg))
+#define _READ_BYTE_REG(reg)  \
+        readb((const volatile void __iomem *)(reg))
+#define _WRITE_DWORD_REG(reg,value)  \
+        writel((value),(volatile void __iomem *)(reg))
+#define _WRITE_WORD_REG(reg,value)  \
+        writew((value),(volatile void __iomem *)(reg))
+#define _WRITE_BYTE_REG(reg,value)  \
+        writeb((value),(volatile void __iomem *)(reg))
+#else
+    /* I/O Access macros */
+#define _READ_DWORD_REG(reg)  \
+        readl((reg))
+#define _READ_WORD_REG(reg)  \
+        readw((reg))
+#define _READ_BYTE_REG(reg)  \
+        readb((reg))
+#define _WRITE_DWORD_REG(reg,value)  \
+        writel((value),(reg))
+#define _WRITE_WORD_REG(reg,value)  \
+        writew((value),(reg))
+#define _WRITE_BYTE_REG(reg,value)  \
+        writeb((value),(reg))
+#endif
+    /* atomic operators */
+static inline ATOMIC_FLAGS AtomicTest_Set(volatile ATOMIC_FLAGS *pValue, INT BitNo) {
+    return test_and_set_bit(BitNo,(ATOMIC_FLAGS *)pValue);
+}
+static inline ATOMIC_FLAGS AtomicTest_Clear(volatile ATOMIC_FLAGS *pValue, INT BitNo) {
+    return test_and_clear_bit(BitNo,(ATOMIC_FLAGS *)pValue);
+}
+
+struct _OSKERNEL_HELPER;
+
+typedef THREAD_RETURN (*PHELPER_FUNCTION)(struct _OSKERNEL_HELPER *);
+
+typedef struct _OSKERNEL_HELPER {
+    PKERNEL_TASK            pTask;
+    BOOL                    ShutDown;
+    OS_SIGNAL               WakeSignal;
+    struct completion       Completion;
+    PVOID                   pContext;
+    PHELPER_FUNCTION        pHelperFunc;
+}OSKERNEL_HELPER, *POSKERNEL_HELPER;
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Wake the helper thread
+
+  @function name: SD_WAKE_OS_HELPER
+  @prototype: SD_WAKE_OS_HELPER(POSKERNEL_HELPER pOSHelper)
+  @category: Support_Reference
+
+  @input: pOSHelper - the OS helper object
+
+  @return: SDIO_STATUS
+
+  @see also: SDLIB_OSCreateHelper
+
+  @example: Waking up a helper thread
+        status = SD_WAKE_OS_HELPER(&pInstance->OSHelper);
+
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SD_WAKE_OS_HELPER(p)        SignalSet(&(p)->WakeSignal)
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Obtains the context for the helper function
+
+  @function name: SD_GET_OS_HELPER_CONTEXT
+  @prototype: SD_GET_OS_HELPER_CONTEXT(POSKERNEL_HELPER pOSHelper)
+  @category: Support_Reference
+
+  @input: pOSHelper - the OS helper object
+
+  @return: helper specific context
+
+  @notes: This macro should only be called by the function associated with
+          the helper object.
+
+  @see also: SDLIB_OSCreateHelper
+
+  @example: Getting the helper specific context
+        PMYCONTEXT pContext = (PMYCONTEXT)SD_GET_OS_HELPER_CONTEXT(pHelper);
+
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SD_GET_OS_HELPER_CONTEXT(p)     (p)->pContext
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Check helper function shut down flag.
+
+  @function name: SD_IS_HELPER_SHUTTING_DOWN
+  @prototype: SD_IS_HELPER_SHUTTING_DOWN(POSKERNEL_HELPER pOSHelper)
+  @category: Support_Reference
+
+  @input: pOSHelper - the OS helper object
+
+  @return: TRUE if shutting down, else FALSE
+
+  @notes: This macro should only be called by the function associated with
+          the helper object.  The function should call this macro when it
+          unblocks from the call to SD_WAIT_FOR_WAKEUP().  If this function
+          returns TRUE, the function should clean up and exit.
+
+  @see also: SDLIB_OSCreateHelper , SD_WAIT_FOR_WAKEUP
+
+  @example: Checking for shutdown
+        while(1) {
+              status = SD_WAIT_FOR_WAKEUP(pHelper);
+              if (!SDIO_SUCCESS(status)) {
+                  break;
+              }
+              if (SD_IS_HELPER_SHUTTING_DOWN(pHelper)) {
+                  ... shutting down
+                  break;
+              }
+        }
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SD_IS_HELPER_SHUTTING_DOWN(p)   (p)->ShutDown
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Suspend and wait for wakeup signal
+
+  @function name: SD_WAIT_FOR_WAKEUP
+  @prototype: SD_WAIT_FOR_WAKEUP(POSKERNEL_HELPER pOSHelper)
+  @category: Support_Reference
+
+  @input: pOSHelper - the OS helper object
+
+  @return: SDIO_STATUS
+
+  @notes: This macro should only be called by the function associated with
+          the helper object.  The function should call this function to suspend (block)
+          itself and wait for a wake up signal. The function should always check
+          whether the function should exit by calling SD_IS_HELPER_SHUTTING_DOWN.
+
+  @see also: SDLIB_OSCreateHelper , SD_IS_HELPER_SHUTTING_DOWN
+
+  @example: block on the wake signal
+        while(1) {
+              status = SD_WAIT_FOR_WAKEUP(pHelper);
+              if (!SDIO_SUCCESS(status)) {
+                  break;
+              }
+              if (SD_IS_HELPER_SHUTTING_DOWN(pHelper)) {
+                  ... shutting down
+                  break;
+              }
+        }
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SD_WAIT_FOR_WAKEUP(p)   SignalWait(&(p)->WakeSignal);
+
+#define CT_LE16_TO_CPU_ENDIAN(x) __le16_to_cpu(x)
+#define CT_LE32_TO_CPU_ENDIAN(x) __le32_to_cpu(x)
+#define CT_CPU_ENDIAN_TO_LE16(x) __cpu_to_le16(x)
+#define CT_CPU_ENDIAN_TO_LE32(x) __cpu_to_le32(x)
+
+#define CT_CPU_ENDIAN_TO_BE16(x) __cpu_to_be16(x)
+#define CT_CPU_ENDIAN_TO_BE32(x) __cpu_to_be32(x)
+#define CT_BE16_TO_CPU_ENDIAN(x) __be16_to_cpu(x)
+#define CT_BE32_TO_CPU_ENDIAN(x) __be32_to_cpu(x)
+#endif /* __CPSYSTEM_LINUX_H___ */
+
Index: linux-2.6/include/linux/sdio/mmc_defs.h
===================================================================
--- /dev/null
+++ linux-2.6/include/linux/sdio/mmc_defs.h
@@ -0,0 +1,103 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: mmc_defs.h
+
+@abstract: MMC definitions not already defined in _sdio_defs.h
+
+@notice: Copyright (c), 2004-2006 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#ifndef ___MMC_DEFS_H___
+#define ___MMC_DEFS_H___
+
+#define MMC_MAX_BUS_CLOCK    20000000 /* max clock speed in hz */
+#define MMC_HS_MAX_BUS_CLOCK 52000000 /* MMC PLUS (high speed) max clock rate in hz */
+
+/* R2 (CSD) macros */
+#define GET_MMC_CSD_TRANS_SPEED(pR) (pR)[12]
+#define GET_MMC_SPEC_VERSION(pR)    (((pR)[15] >> 2) & 0x0F)
+#define MMC_SPEC_1_0_TO_1_2         0x00
+#define MMC_SPEC_1_4                0x01
+#define MMC_SPEC_2_0_TO_2_2         0x02
+#define MMC_SPEC_3_1                0x03
+#define MMC_SPEC_4_0_TO_4_1         0x04
+
+#define MMC_CMD_SWITCH    6
+#define MMC_CMD8    8
+
+#define MMC_SWITCH_CMD_SET    0
+#define MMC_SWITCH_SET_BITS   1
+#define MMC_SWITCH_CLEAR_BITS 2
+#define MMC_SWITCH_WRITE_BYTE 3
+#define MMC_SWITCH_CMD_SET0   0
+#define MMC_SWITCH_BUILD_ARG(cmdset,access,index,value) \
+     (((cmdset) & 0x07) | (((access) & 0x03) << 24) | (((index) & 0xFF) << 16) | (((value) & 0xFF) << 8))
+
+#define MMC_EXT_CSD_SIZE                     512
+
+#define MMC_EXT_S_CMD_SET_OFFSET             504
+#define MMC_EXT_MIN_PERF_W_8_52_OFFSET       210
+#define MMC_EXT_MIN_PERF_R_8_52_OFFSET       209
+#define MMC_EXT_MIN_PERF_W_8_26_4_52_OFFSET  208
+#define MMC_EXT_MIN_PERF_R_8_26_4_52_OFFSET  207
+#define MMC_EXT_MIN_PERF_W_4_26_OFFSET       206
+#define MMC_EXT_MIN_PERF_R_4_56_OFFSET       205
+#define MMC_EXT_PWR_CL_26_360_OFFSET         203
+#define MMC_EXT_PWR_CL_52_360_OFFSET         202
+#define MMC_EXT_PWR_CL_26_195_OFFSET         201
+#define MMC_EXT_PWR_CL_52_195_OFFSET         200
+#define MMC_EXT_GET_PWR_CLASS(reg)    ((reg) & 0xF)
+#define MMC_EXT_MAX_PWR_CLASSES       16
+#define MMC_EXT_CARD_TYPE_OFFSET             196
+#define MMC_EXT_CARD_TYPE_HS_52  (1 << 1)
+#define MMC_EXT_CARD_TYPE_HS_26  (1 << 0)
+#define MMC_EXT_CSD_VER_OFFSET               194
+#define MMC_EXT_VER_OFFSET                   192
+#define MMC_EXT_VER_1_0          0
+#define MMC_EXT_VER_1_1          1
+#define MMC_EXT_CMD_SET_OFFSET               191
+#define MMC_EXT_CMD_SET_REV_OFFSET           189
+#define MMC_EXT_PWR_CLASS_OFFSET             187
+#define MMC_EXT_HS_TIMING_OFFSET             185
+#define MMC_EXT_HS_TIMING_ENABLE   0x01
+#define MMC_EXT_BUS_WIDTH_OFFSET             183
+#define MMC_EXT_BUS_WIDTH_1_BIT    0x00
+#define MMC_EXT_BUS_WIDTH_4_BIT    0x01
+#define MMC_EXT_BUS_WIDTH_8_BIT    0x02
+
+#endif
Index: linux-2.6/include/linux/sdio/sdio_busdriver.h
===================================================================
--- /dev/null
+++ linux-2.6/include/linux/sdio/sdio_busdriver.h
@@ -0,0 +1,1440 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdio_busdriver.h
+
+@abstract: include file for registration of SDIO function drivers
+  and SDIO host controller bus drivers.
+
+@notice: Copyright (c), 2004-2006 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#ifndef __SDIO_BUSDRIVER_H___
+#define __SDIO_BUSDRIVER_H___
+
+typedef UINT8      CT_VERSION_CODE;
+#define CT_SDIO_STACK_VERSION_CODE ((CT_VERSION_CODE)0x26)   /* version code that must be set in various structures */
+#define CT_SDIO_STACK_VERSION_MAJOR(v) (((v) & 0xF0) >> 4)
+#define CT_SDIO_STACK_VERSION_MINOR(v) (((v) & 0x0F))
+#define SET_SDIO_STACK_VERSION(p) (p)->Version = CT_SDIO_STACK_VERSION_CODE
+#define GET_SDIO_STACK_VERSION(p) (p)->Version
+#define GET_SDIO_STACK_VERSION_MAJOR(p) CT_SDIO_STACK_VERSION_MAJOR(GET_SDIO_STACK_VERSION(p))
+#define GET_SDIO_STACK_VERSION_MINOR(p) CT_SDIO_STACK_VERSION_MINOR(GET_SDIO_STACK_VERSION(p))
+#include "sdlist.h"
+
+/* card flags */
+typedef UINT16      CARD_INFO_FLAGS;
+#define CARD_MMC        0x0001    /* Multi-media card */
+#define CARD_SD         0x0002    /* SD-Memory present */
+#define CARD_SDIO       0x0004    /* SDIO present */
+#define CARD_RAW        0x0008    /* Raw card */
+#define CARD_COMBO      (CARD_SD | CARD_SDIO)  /* SDIO with SD */
+#define CARD_TYPE_MASK  0x000F    /* card type mask */
+#define CARD_SD_WP      0x0010    /* SD WP on */
+#define CARD_PSEUDO     0x0020    /* pseudo card (internal use) */
+#define CARD_HIPWR      0x0040    /* card can use more than 200mA (SDIO 1.1 or greater)*/
+#define GET_CARD_TYPE(flags) ((flags) & CARD_TYPE_MASK)
+
+/* bus mode and clock rate */
+typedef UINT32  SD_BUSCLOCK_RATE;       /* clock rate in hz */
+typedef UINT16  SD_BUSMODE_FLAGS;
+#define SDCONFIG_BUS_WIDTH_RESERVED           0x00
+#define SDCONFIG_BUS_WIDTH_SPI                0x01
+#define SDCONFIG_BUS_WIDTH_1_BIT              0x02
+#define SDCONFIG_BUS_WIDTH_4_BIT              0x03
+#define SDCONFIG_BUS_WIDTH_MMC8_BIT           0x04
+#define SDCONFIG_BUS_WIDTH_MASK               0x0F
+#define SDCONFIG_SET_BUS_WIDTH(flags,width) \
+{                       \
+    (flags) &= ~SDCONFIG_BUS_WIDTH_MASK; \
+    (flags) |= (width);                  \
+}
+#define SDCONFIG_GET_BUSWIDTH(flags) ((flags) & SDCONFIG_BUS_WIDTH_MASK)
+#define SDCONFIG_BUS_MODE_SPI_NO_CRC         0x40   /* SPI bus is operating with NO CRC */
+#define SDCONFIG_BUS_MODE_SD_HS              0x80   /* set interface to SD high speed mode  */
+#define SDCONFIG_BUS_MODE_MMC_HS             0x20   /* set interface to MMC high speed mode */
+
+typedef UINT16 SD_SLOT_CURRENT;      /* slot current in mA */
+
+typedef UINT8 SLOT_VOLTAGE_MASK;     /* slot voltage */
+#define SLOT_POWER_3_3V  0x01
+#define SLOT_POWER_3_0V  0x02
+#define SLOT_POWER_2_8V  0x04
+#define SLOT_POWER_2_0V  0x08
+#define SLOT_POWER_1_8V  0x10
+#define SLOT_POWER_1_6V  0x20
+
+#define MAX_CARD_RESPONSE_BYTES 17
+
+/* plug and play information for SD cards */
+typedef struct _SD_PNP_INFO {
+    UINT16 SDIO_ManufacturerCode;  /* JEDEC Code */
+    UINT16 SDIO_ManufacturerID;    /* manf-specific ID */
+    UINT8  SDIO_FunctionNo;        /* function number 1-7 */
+    UINT8  SDIO_FunctionClass;     /* function class */
+    UINT8  SDMMC_ManfacturerID;    /* card CID's MANF-ID */
+    UINT16 SDMMC_OEMApplicationID; /* card CID's OEMAPP-ID */
+    CARD_INFO_FLAGS CardFlags;     /* card flags */
+}SD_PNP_INFO, *PSD_PNP_INFO;
+
+#define IS_LAST_SDPNPINFO_ENTRY(id)\
+    (((id)->SDIO_ManufacturerCode == 0) &&\
+     ((id)->SDIO_ManufacturerID == 0) &&\
+     ((id)->SDIO_FunctionNo == 0) &&\
+     ((id)->SDIO_FunctionClass == 0) &&\
+     ((id)->SDMMC_OEMApplicationID == 0) && \
+     ((id)->CardFlags == 0))
+
+/* card properties */
+typedef struct _CARD_PROPERTIES {
+    UINT8              IOFnCount;      /* number of I/O functions */
+    UINT8              SDIORevision;   /* SDIO revision */
+#define SDIO_REVISION_1_00 0x00
+#define SDIO_REVISION_1_10 0x01
+#define SDIO_REVISION_1_20 0x02
+    UINT8              SD_MMC_Revision; /* SD or MMC revision */
+#define SD_REVISION_1_01  0x00
+#define SD_REVISION_1_10  0x01
+#define MMC_REVISION_1_0_2_2 0x00
+#define MMC_REVISION_3_1  0x01
+#define MMC_REVISION_4_0  0x02
+    UINT16 SDIO_ManufacturerCode;      /* JEDEC Code */
+    UINT16 SDIO_ManufacturerID;        /* manf-specific ID */
+    UINT32             CommonCISPtr;   /* common CIS ptr */
+    UINT16             RCA;            /* relative card address */
+    UINT8              SDIOCaps;       /* SDIO card capabilities (refer to SDIO spec for decoding) */
+    UINT8              CardCSD[MAX_CARD_RESPONSE_BYTES];    /* for SD/MMC cards */
+    CARD_INFO_FLAGS    Flags;          /* card flags */
+    SD_BUSCLOCK_RATE   OperBusClock;   /* operational bus clock (based on HCD limit)*/
+    SD_BUSMODE_FLAGS   BusMode;        /* current card bus mode */
+    UINT16             OperBlockLenLimit; /* operational bytes per block length limit*/
+    UINT16             OperBlockCountLimit; /* operational number of blocks per transfer limit */
+    UINT8              CardState;      /* card state flags */
+    SLOT_VOLTAGE_MASK  CardVoltage;    /* card operational voltage */
+#define CARD_STATE_REMOVED 0x01
+}CARD_PROPERTIES, *PCARD_PROPERTIES;
+
+/* SDREQUEST request flags */
+typedef UINT32 SDREQUEST_FLAGS;
+/* write operation */
+#define SDREQ_FLAGS_DATA_WRITE         0x8000
+/* has data (read or write) */
+#define SDREQ_FLAGS_DATA_TRANS         0x4000
+/* command is an atomic APP command, requiring CMD55 to be issued */
+#define SDREQ_FLAGS_APP_CMD            0x2000
+/* transfer should be handled asynchronously */
+#define SDREQ_FLAGS_TRANS_ASYNC        0x1000
+/* host should skip the SPI response filter for this command */
+#define SDREQ_FLAGS_RESP_SKIP_SPI_FILT 0x0800
+/* host should skip the response check for this data transfer */
+#define SDREQ_FLAGS_DATA_SKIP_RESP_CHK 0x0400
+/* flag requesting a CMD12 be automatically issued by host controller */
+#define SDREQ_FLAGS_AUTO_CMD12         0x0200
+/* flag indicating that the data buffer meets HCD's DMA restrictions   */
+#define SDREQ_FLAGS_DATA_DMA           0x0010
+/* indicate to host that this is a short and quick transfer, the HCD may optimize
+ * this request to reduce interrupt overhead */
+#define SDREQ_FLAGS_DATA_SHORT_TRANSFER   0x00010000
+/* indicate to the host that this is a raw request */
+#define SDREQ_FLAGS_RAW                   0x00020000
+/* auto data transfer status check for MMC and Memory cards */
+#define SDREQ_FLAGS_AUTO_TRANSFER_STATUS  0x00100000
+
+#define SDREQ_FLAGS_UNUSED1               0x00200000
+#define SDREQ_FLAGS_UNUSED2               0x00400000
+#define SDREQ_FLAGS_UNUSED3               0x00800000
+#define SDREQ_FLAGS_UNUSED4               0x01000000
+#define SDREQ_FLAGS_UNUSED5               0x02000000
+
+/* the following flags are internal use only */
+#define SDREQ_FLAGS_FORCE_DEFERRED_COMPLETE 0x0100
+/* flag indicating that response has been converted (internal use) */
+#define SDREQ_FLAGS_RESP_SPI_CONVERTED      0x0040
+/* request was cancelled - internal use only */
+#define SDREQ_FLAGS_CANCELED                0x0020
+/* a barrier operation */
+#define SDREQ_FLAGS_BARRIER                 0x00040000
+/* a pseudo bus request */
+#define SDREQ_FLAGS_PSEUDO                  0x00080000
+/* queue to the head */
+#define SDREQ_FLAGS_QUEUE_HEAD              0x04000000
+
+#define SDREQ_FLAGS_I_UNUSED1               0x08000000
+#define SDREQ_FLAGS_I_UNUSED2               0x10000000
+#define SDREQ_FLAGS_I_UNUSED3               0x20000000
+#define SDREQ_FLAGS_I_UNUSED4               0x40000000
+#define SDREQ_FLAGS_I_UNUSED5               0x80000000
+
+/* response type mask */
+#define SDREQ_FLAGS_RESP_MASK       0x000F
+#define GET_SDREQ_RESP_TYPE(flags)     ((flags) & SDREQ_FLAGS_RESP_MASK)
+#define IS_SDREQ_WRITE_DATA(flags)     ((flags) & SDREQ_FLAGS_DATA_WRITE)
+#define IS_SDREQ_DATA_TRANS(flags)     ((flags) & SDREQ_FLAGS_DATA_TRANS)
+#define IS_SDREQ_RAW(flags)            ((flags) & SDREQ_FLAGS_RAW)
+#define IS_SDREQ_FORCE_DEFERRED_COMPLETE(flags) ((flags) & SDREQ_FLAGS_FORCE_DEFERRED_COMPLETE)
+#define SDREQ_FLAGS_NO_RESP         0x0000
+#define SDREQ_FLAGS_RESP_R1         0x0001
+#define SDREQ_FLAGS_RESP_R1B        0x0002
+#define SDREQ_FLAGS_RESP_R2         0x0003
+#define SDREQ_FLAGS_RESP_R3         0x0004
+#define SDREQ_FLAGS_RESP_MMC_R4     0x0005 /* not supported, for future use */
+#define SDREQ_FLAGS_RESP_MMC_R5     0x0006 /* not supported, for future use */
+#define SDREQ_FLAGS_RESP_R6         0x0007
+#define SDREQ_FLAGS_RESP_SDIO_R4    0x0008
+#define SDREQ_FLAGS_RESP_SDIO_R5    0x0009
+
+struct _SDREQUEST;
+struct _SDFUNCTION;
+
+typedef void (*PSDEQUEST_COMPLETION)(struct _SDREQUEST *);
+
+/* defines SD/MMC and SDIO requests for the RAW-mode API */
+typedef struct _SDREQUEST {
+    SDLIST  SDList;             /* internal use list*/
+    UINT32  Argument;           /* SD/SDIO/MMC 32 bit argument */
+    SDREQUEST_FLAGS Flags;      /* request flags */
+    ATOMIC_FLAGS InternalFlags; /* internal use flags */
+    UINT8   Command;            /* SD/SDIO/MMC 8 bit command */
+    UINT8   Response[MAX_CARD_RESPONSE_BYTES];       /* buffer for CMD response */
+    UINT16  BlockCount;         /* number of blocks to send/rcv */
+    UINT16  BlockLen;           /* length of each block */
+    UINT16  DescriptorCount;    /* number of DMA descriptor entries in pDataBuffer if DMA */
+    PVOID   pDataBuffer;        /* starting address of buffer (or ptr to PSDDMA_DESCRIPTOR*/
+    UINT32  DataRemaining;      /* number of bytes remaining in the transfer (internal use) */
+    PVOID   pHcdContext;        /* internal use context */
+    PSDEQUEST_COMPLETION pCompletion; /* function driver completion routine */
+    PVOID   pCompleteContext;   /* function driver completion context */
+    SDIO_STATUS Status;         /* completion status */
+    struct _SDFUNCTION* pFunction; /* function driver that generated request (internal use)*/
+    INT     RetryCount;          /* number of times to retry on error, non-data cmds only */
+    PVOID   pBdRsv1;        /* reserved */
+    PVOID   pBdRsv2;
+    PVOID   pBdRsv3;
+}SDREQUEST, *PSDREQUEST;
+
+    /* a request queue */
+typedef struct _SDREQUESTQUEUE {
+    SDLIST        Queue;           /* the queue of requests */
+    BOOL          Busy;            /* busy flag */
+}SDREQUESTQUEUE, *PSDREQUESTQUEUE;
+
+
+typedef UINT16 SDCONFIG_COMMAND;
+/* SDCONFIG request flags */
+/* get operation */
+#define SDCONFIG_FLAGS_DATA_GET       0x8000
+/* put operation */
+#define SDCONFIG_FLAGS_DATA_PUT       0x4000
+/* host controller */
+#define SDCONFIG_FLAGS_HC_CONFIG      0x2000
+/* both */
+#define SDCONFIG_FLAGS_DATA_BOTH      (SDCONFIG_FLAGS_DATA_GET | SDCONFIG_FLAGS_DATA_PUT)
+/* no data */
+#define SDCONFIG_FLAGS_DATA_NONE      0x0000
+
+/* SDCONFIG commands */
+#define SDCONFIG_GET_HCD_DEBUG   (SDCONFIG_FLAGS_HC_CONFIG | SDCONFIG_FLAGS_DATA_GET  | 275)
+#define SDCONFIG_SET_HCD_DEBUG   (SDCONFIG_FLAGS_HC_CONFIG | SDCONFIG_FLAGS_DATA_PUT  | 276)
+
+/* custom hcd commands */
+#define SDCONFIG_GET_HOST_CUSTOM   (SDCONFIG_FLAGS_HC_CONFIG | SDCONFIG_FLAGS_DATA_GET  | 300)
+#define SDCONFIG_PUT_HOST_CUSTOM   (SDCONFIG_FLAGS_HC_CONFIG | SDCONFIG_FLAGS_DATA_PUT  | 301)
+
+/* function commands */
+#define SDCONFIG_FUNC_ENABLE_DISABLE         (SDCONFIG_FLAGS_DATA_PUT  | 18)
+#define SDCONFIG_FUNC_UNMASK_IRQ             (SDCONFIG_FLAGS_DATA_NONE | 21)
+#define SDCONFIG_FUNC_MASK_IRQ               (SDCONFIG_FLAGS_DATA_NONE | 22)
+#define SDCONFIG_FUNC_ACK_IRQ                (SDCONFIG_FLAGS_DATA_NONE | 23)
+#define SDCONFIG_FUNC_SPI_MODE_DISABLE_CRC   (SDCONFIG_FLAGS_DATA_NONE | 24)
+#define SDCONFIG_FUNC_SPI_MODE_ENABLE_CRC    (SDCONFIG_FLAGS_DATA_NONE | 25)
+#define SDCONFIG_FUNC_ALLOC_SLOT_CURRENT     (SDCONFIG_FLAGS_DATA_PUT  | 26)
+#define SDCONFIG_FUNC_FREE_SLOT_CURRENT      (SDCONFIG_FLAGS_DATA_NONE | 27)
+#define SDCONFIG_FUNC_CHANGE_BUS_MODE        (SDCONFIG_FLAGS_DATA_BOTH | 28)
+#define SDCONFIG_FUNC_CHANGE_BUS_MODE_ASYNC  (SDCONFIG_FLAGS_DATA_BOTH | 29)
+#define SDCONFIG_FUNC_NO_IRQ_PEND_CHECK      (SDCONFIG_FLAGS_DATA_NONE | 30)
+
+typedef UINT8  FUNC_ENABLE_DISABLE_FLAGS;
+typedef UINT32 FUNC_ENABLE_TIMEOUT;
+
+    /* function enable */
+typedef struct _SDCONFIG_FUNC_ENABLE_DISABLE_DATA {
+#define SDCONFIG_DISABLE_FUNC   0x0000
+#define SDCONFIG_ENABLE_FUNC    0x0001
+    FUNC_ENABLE_DISABLE_FLAGS    EnableFlags;     /* enable flags*/
+    FUNC_ENABLE_TIMEOUT          TimeOut;         /* timeout in milliseconds */
+    void (*pOpComplete)(PVOID Context, SDIO_STATUS status); /* reserved */
+    PVOID                        pOpCompleteContext;        /* reserved */
+}SDCONFIG_FUNC_ENABLE_DISABLE_DATA, *PSDCONFIG_FUNC_ENABLE_DISABLE_DATA;
+
+    /* slot current allocation data */
+typedef struct _SDCONFIG_FUNC_SLOT_CURRENT_DATA {
+    SD_SLOT_CURRENT     SlotCurrent;    /* slot current to request in mA*/
+}SDCONFIG_FUNC_SLOT_CURRENT_DATA, *PSDCONFIG_FUNC_SLOT_CURRENT_DATA;
+
+/* slot bus mode configuration */
+typedef struct _SDCONFIG_BUS_MODE_DATA {
+    SD_BUSCLOCK_RATE   ClockRate;       /* clock rate in Hz */
+    SD_BUSMODE_FLAGS   BusModeFlags;    /* bus mode flags */
+    SD_BUSCLOCK_RATE   ActualClockRate; /* actual rate in KHz */
+}SDCONFIG_BUS_MODE_DATA, *PSDCONFIG_BUS_MODE_DATA;
+
+/* defines configuration requests for the HCD */
+typedef struct _SDCONFIG {
+    SDCONFIG_COMMAND  Cmd;          /* configuration command */
+    PVOID   pData;        /* configuration data */
+    INT     DataLength;   /* config data length */
+}SDCONFIG, *PSDCONFIG;
+
+#define SET_SDCONFIG_CMD_INFO(pHdr,cmd,pC,len) \
+{           \
+  (pHdr)->Cmd = (cmd);                     \
+  (pHdr)->pData = (PVOID)(pC);             \
+  (pHdr)->DataLength = (len);              \
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get a pointer to the configuration command data.
+
+  @function name: GET_SDCONFIG_CMD
+  @prototype: UNIT16 GET_SDCONFIG_CMD (PSDCONFIG pCommand)
+  @category: HD_Reference
+
+  @input:  pCommand - config command structure.
+
+  @return: command code
+
+  @notes: Implemented as a macro. This macro returns the command code for this
+          configuration request.
+
+  @example: getting the command code:
+    cmd = GET_SDCONFIG_CMD(pConfig);
+    switch (cmd) {
+        case SDCONFIG_GET_WP:
+             .. get write protect switch position
+           break;
+        ...
+    }
+
+  @see also: GET_SDCONFIG_CMD_LEN, GET_SDCONFIG_CMD_DATA
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define GET_SDCONFIG_CMD(pBuffer)     ((pBuffer)->Cmd)
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get a pointer to the configuration command data.
+
+  @function name: GET_SDCONFIG_CMD_LEN
+  @prototype: INT GET_SDCONFIG_CMD_LEN (PSDCONFIG pCommand)
+  @category: HD_Reference
+
+  @input:  pCommand - config command structure.
+
+  @return: length of config command data
+
+  @notes: Implemented as a macro. Host controller drivers can use this macro to extract
+          the number of bytes of command specific data. This can be used to validate the
+          config data buffer size.
+
+  @example: getting the data length:
+    length = GET_SDCONFIG_CMD_LEN(pConfig);
+    if (length < CUSTOM_COMMAND_XXX_SIZE) {
+       ... invalid length
+    }
+
+  @see also: GET_SDCONFIG_CMD, GET_SDCONFIG_CMD_DATA
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define GET_SDCONFIG_CMD_LEN(pBuffer) ((pBuffer)->DataLength)
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get a pointer to the configuration command data.
+
+  @function name: GET_SDCONFIG_CMD_DATA
+  @prototype: (casted ptr) GET_SDCONFIG_CMD_DATA (type, PSDCONFIG pCommand)
+  @category: HD_Reference
+
+  @input:  type - pointer type to cast the returned pointer to.
+           pCommand - config command structure.
+
+  @return: type-casted pointer to the command's data
+
+  @notes: Implemented as a macro.  Host controller drivers can use this macro to extract
+          a pointer to the command specific data in an HCD configuration request.
+
+  @example: getting the pointer:
+        // get interrupt control data
+    pIntControl = GET_SDCONFIG_CMD_DATA(PSDCONFIG_SDIO_INT_CTRL_DATA,pConfig);
+    if (pIntControl->SlotIRQEnable) {
+       ... enable slot IRQ detection
+    }
+
+  @see also: GET_SDCONFIG_CMD, GET_SDCONFIG_CMD_LEN
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define GET_SDCONFIG_CMD_DATA(type,pBuffer) ((type)((pBuffer)->pData))
+#define IS_SDCONFIG_CMD_GET(pBuffer)  ((pBuffer)->Cmd & SDCONFIG_FLAGS_DATA_GET)
+#define IS_SDCONFIG_CMD_PUT(pBuffer)  ((pBuffer)->Cmd & SDCONFIG_FLAGS_DATA_PUT)
+
+struct _SDDEVICE;
+struct _SDHCD;
+
+typedef UINT8   SD_FUNCTION_FLAGS;
+#define SDFUNCTION_FLAG_REMOVING       0x01
+
+/* function driver registration structure */
+typedef struct _SDFUNCTION {
+    CT_VERSION_CODE Version;    /* version code of the SDIO stack */
+	SDLIST     SDList;          /* internal use list*/
+    PTEXT      pName;           /* name of registering driver */
+    UINT       MaxDevices;      /* maximum number of devices supported by this function */
+    UINT       NumDevices;      /* number of devices supported by this function */
+    PSD_PNP_INFO pIds;          /* null terminated table of supported devices*/
+    BOOL (*pProbe)(struct _SDFUNCTION *pFunction, struct _SDDEVICE *pDevice);/* New device inserted */
+                                /* Device removed (NULL if not a hot-plug capable driver) */
+    void (*pRemove)(struct _SDFUNCTION *pFunction, struct _SDDEVICE *pDevice);
+    SDIO_STATUS (*pSuspend)(struct _SDFUNCTION *pFunction, SDPOWER_STATE state); /* Device suspended */
+    SDIO_STATUS (*pResume)(struct _SDFUNCTION *pFunction); /* Device woken up */
+                                /* Enable wake event */
+    SDIO_STATUS (*pWake) (struct _SDFUNCTION *pFunction, SDPOWER_STATE state, BOOL enable);
+	PVOID      pContext;        /* function driver use data */
+	OS_PNPDRIVER Driver;	    /* driver registration with base system */
+	SDLIST     DeviceList;	    /* the list of devices this driver is using*/
+    OS_SIGNAL   CleanupReqSig;  /* wait for requests completion on cleanup (internal use) */
+    SD_FUNCTION_FLAGS Flags;    /* internal flags (internal use) */
+}SDFUNCTION, *PSDFUNCTION;
+
+typedef UINT8  HCD_EVENT;
+
+    /* device info for SDIO functions */
+typedef struct _SDIO_DEVICE_INFO {
+    UINT32  FunctionCISPtr;         /* function's CIS ptr */
+    UINT32  FunctionCSAPtr;         /* function's CSA ptr */
+    UINT16  FunctionMaxBlockSize;   /* function's reported max block size */
+}SDIO_DEVICE_INFO, *PSDIO_DEVICE_INFO;
+
+    /* device info for SD/MMC card functions */
+typedef struct _SDMMC_INFO{
+    UINT8  Unused;    /* reserved */
+}SDMMC_INFO, *PSDMMC_INFO;
+
+    /* union of SDIO function and device info */
+typedef union _SDDEVICE_INFO {
+    SDIO_DEVICE_INFO AsSDIOInfo;
+    SDMMC_INFO       AsSDMMCInfo;
+}SDDEVICE_INFO, *PSDDEVICE_INFO;
+
+
+typedef UINT8   SD_DEVICE_FLAGS;
+#define SDDEVICE_FLAG_REMOVING       0x01
+
+/* inserted device description, describes an inserted card */
+typedef struct _SDDEVICE {
+    SDLIST      SDList;             /* internal use list*/
+    SDLIST      FuncListLink;       /* internal use list */
+                                    /* read/write request function */
+    SDIO_STATUS (*pRequest)(struct _SDDEVICE *pDev, PSDREQUEST req);
+                                    /* get/set configuration */
+    SDIO_STATUS (*pConfigure)(struct _SDDEVICE *pDev, PSDCONFIG config);
+    PSDREQUEST  (*AllocRequest)(struct _SDDEVICE *pDev);      /* allocate a request */
+    void        (*FreeRequest)(struct _SDDEVICE *pDev, PSDREQUEST pReq); /* free the request */
+    void        (*pIrqFunction)(PVOID pContext);       /* interrupt routine, synchronous calls allowed */
+    void        (*pIrqAsyncFunction)(PVOID pContext); /* async IRQ function , asynch only calls */
+    PVOID       IrqContext;         /* irq context */
+    PVOID       IrqAsyncContext;    /* irq async context */
+    PSDFUNCTION pFunction;          /* function driver supporting this device */
+    struct _SDHCD  *pHcd;           /* host controller this device is on (internal use) */
+    SDDEVICE_INFO   DeviceInfo;     /* device info */
+    SD_PNP_INFO pId[1];             /* id of this device  */
+    OS_PNPDEVICE Device;            /* device registration with base system */
+    SD_SLOT_CURRENT  SlotCurrentAlloc; /* allocated slot current for this device/function (internal use) */
+    SD_DEVICE_FLAGS Flags;          /* internal use flags */
+    CT_VERSION_CODE Version;        /* version code of the bus driver */
+}SDDEVICE, *PSDDEVICE;
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get SDIO Bus Driver Version Major number
+
+  @function name: SDDEVICE_GET_VERSION_MAJOR
+  @prototype: INT SDDEVICE_GET_VERSION_MAJOR(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: integer value for the major version
+
+  @notes: Implemented as a macro.
+
+  @see also: SDDEVICE_GET_VERSION_MINOR
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_VERSION_MAJOR(pDev) (GET_SDIO_STACK_VERSION_MAJOR(pDev))
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get SDIO Bus Driver Version Minor number
+
+  @function name: SDDEVICE_GET_VERSION_MINOR
+  @prototype: INT SDDEVICE_GET_VERSION_MINOR(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: integer value for the minor version
+
+  @notes: Implemented as a macro.
+
+  @see also: SDDEVICE_GET_VERSION_MAJOR
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_VERSION_MINOR(pDev) (GET_SDIO_STACK_VERSION_MINOR(pDev))
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Test the SDIO revision for greater than or equal to 1.10
+
+  @function name: SDDEVICE_IS_SDIO_REV_GTEQ_1_10
+  @prototype: BOOL SDDEVICE_IS_SDIO_REV_GTEQ_1_10(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: TRUE if the revision is greater than or equal to 1.10
+
+  @notes: Implemented as a macro.
+
+  @see also: SDDEVICE_IS_SD_REV_GTEQ_1_10
+  @see also: SDDEVICE_IS_MMC_REV_GTEQ_4_0
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_IS_SDIO_REV_GTEQ_1_10(pDev) ((pDev)->pHcd->CardProperties.SDIORevision >= SDIO_REVISION_1_10)
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Test the SDIO revision for greater than or equal to 1.20
+
+  @function name: SDDEVICE_IS_SDIO_REV_GTEQ_1_20
+  @prototype: BOOL SDDEVICE_IS_SDIO_REV_GTEQ_1_20(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: TRUE if the revision is greater than or equal to 1.20
+
+  @notes: Implemented as a macro.
+
+  @see also: SDDEVICE_IS_SD_REV_GTEQ_1_10
+  @see also: SDDEVICE_IS_SDIO_REV_GTEQ_1_10
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_IS_SDIO_REV_GTEQ_1_20(pDev) ((pDev)->pHcd->CardProperties.SDIORevision >= SDIO_REVISION_1_20)
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Test the SD revision for greater than or equal to 1.10
+
+  @function name: SDDEVICE_IS_SD_REV_GTEQ_1_10
+  @prototype: BOOL SDDEVICE_IS_SD_REV_GTEQ_1_10(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: TRUE if the revision is greater than or equal to 1.10
+
+  @notes: Implemented as a macro.
+
+  @see also: SDDEVICE_IS_SDIO_REV_GTEQ_1_10
+  @see also: SDDEVICE_IS_MMC_REV_GTEQ_4_0
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_IS_SD_REV_GTEQ_1_10(pDev) ((pDev)->pHcd->CardProperties.SD_MMC_Revision >= SD_REVISION_1_10)
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Test the MMC revision for greater than or equal to 4.0
+
+  @function name: SDDEVICE_IS_MMC_REV_GTEQ_4_0
+  @prototype: BOOL SDDEVICE_IS_MMC_REV_GTEQ_4_0(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: TRUE if the revision is greater than or equal to 4.0
+
+  @notes: Implemented as a macro.
+
+  @see also: SDDEVICE_IS_SDIO_REV_GTEQ_1_10
+  @see also: SDDEVICE_IS_SD_REV_GTEQ_1_10
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_IS_MMC_REV_GTEQ_4_0(pDev) ((pDev)->pHcd->CardProperties.SD_MMC_Revision >= MMC_REVISION_4_0)
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Test for write protect enabled
+
+  @function name: SDDEVICE_IS_CARD_WP_ON
+  @prototype: BOOL SDDEVICE_IS_CARD_WP_ON(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: TRUE if device is write protected.
+
+  @notes: Implemented as a macro.
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_IS_CARD_WP_ON(pDev)       ((pDev)->pHcd->CardProperties.Flags & CARD_SD_WP)
+
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get the device's manufacturer specific ID
+
+  @function name: SDDEVICE_GET_SDIO_MANFID
+  @prototype: UINT16 SDDEVICE_GET_SDIO_MANFID(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: function number
+
+  @notes: Implemented as a macro.
+
+  @see also: SDDEVICE_GET_SDIO_MANFCODE
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_SDIO_MANFID(pDev)     (pDev)->pId[0].SDIO_ManufacturerID
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get the device's manufacturer code
+
+  @function name: SDDEVICE_GET_SDIO_MANFCODE
+  @prototype: UINT16 SDDEVICE_GET_SDIO_MANFCODE(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: function number
+
+  @notes: Implemented as a macro.
+
+  @see also: SDDEVICE_GET_SDIO_MANFID
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_SDIO_MANFCODE(pDev)     (pDev)->pId[0].SDIO_ManufacturerCode
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get the device's function number
+
+  @function name: SDDEVICE_GET_SDIO_FUNCNO
+  @prototype: UINT8 SDDEVICE_GET_SDIO_FUNCNO(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: function number
+
+  @notes: Implemented as a macro.
+
+  @see also: SDDEVICE_GET_SDIO_FUNC_CLASS
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_SDIO_FUNCNO(pDev)     (pDev)->pId[0].SDIO_FunctionNo
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get the functions's class
+
+  @function name: SDDEVICE_GET_SDIO_FUNC_CLASS
+  @prototype: UINT8 SDDEVICE_GET_SDIO_FUNC_CLASS(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: class number
+
+  @notes: Implemented as a macro.
+
+  @see also: SDDEVICE_GET_SDIO_FUNCNO
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_SDIO_FUNC_CLASS(pDev) (pDev)->pId[0].SDIO_FunctionClass
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get the functions's Card Information Structure pointer
+
+  @function name: SDDEVICE_GET_SDIO_FUNC_CISPTR
+  @prototype: UINT32 SDDEVICE_GET_SDIO_FUNC_CISPTR(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: CIS offset
+
+  @notes: Implemented as a macro.
+
+  @see also: SDDEVICE_GET_SDIO_FUNC_CSAPTR
+  @see also: SDDEVICE_GET_SDIO_COMMON_CISPTR
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_SDIO_FUNC_CISPTR(pDev)(pDev)->DeviceInfo.AsSDIOInfo.FunctionCISPtr
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get the functions's Code Stoarge Area pointer
+
+  @function name: SDDEVICE_GET_SDIO_FUNC_CSAPTR
+  @prototype: UINT32 SDDEVICE_GET_SDIO_FUNC_CSAPTR(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: CSA offset
+
+  @notes: Implemented as a macro.
+
+  @see also: SDDEVICE_GET_SDIO_FUNC_CISPTR
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_SDIO_FUNC_CSAPTR(pDev)(pDev)->DeviceInfo.AsSDIOInfo.FunctionCSAPtr
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get the functions's maximum reported block size
+
+  @function name: SDDEVICE_GET_SDIO_FUNC_MAXBLKSIZE
+  @prototype: UINT16 SDDEVICE_GET_SDIO_FUNC_MAXBLKSIZE(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: block size
+
+  @notes: Implemented as a macro.
+
+  @see also:
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_SDIO_FUNC_MAXBLKSIZE(pDev) (pDev)->DeviceInfo.AsSDIOInfo.FunctionMaxBlockSize
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get the common Card Information Structure pointer
+
+  @function name: SDDEVICE_GET_SDIO_COMMON_CISPTR
+  @prototype: UINT32 SDDEVICE_GET_SDIO_COMMON_CISPTR(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: Common CIS Address (in SDIO address space)
+
+  @notes: Implemented as a macro.
+
+  @see also: SDDEVICE_GET_SDIO_FUNC_CSAPTR
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_SDIO_COMMON_CISPTR(pDev) (pDev)->pHcd->CardProperties.CommonCISPtr
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get the card capabilities
+
+  @function name: SDDEVICE_GET_SDIO_CARD_CAPS
+  @prototype: UINT8 SDDEVICE_GET_SDIO_CARD_CAPS(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: 8-bit card capabilities register
+
+  @notes: Implemented as a macro. Refer to SDIO spec for decoding.
+
+  @see also: SDDEVICE_GET_CARD_FLAGS
+  @see also: SDDEVICE_GET_SDIOCARD_CAPS
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_SDIO_CARD_CAPS(pDev)     (pDev)->pHcd->CardProperties.SDIOCaps
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get the card flags
+
+  @function name: SDDEVICE_GET_CARD_FLAGS
+  @prototype: CARD_INFO_FLAGS SDDEVICE_GET_CARD_FLAGS(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: flags
+
+  @notes: Implemented as a macro.
+
+  @example: Get card type:
+        CARD_INFO_FLAGS flags;
+        flags = SDDEVICE_GET_CARD_FLAGS(pDevice);
+        switch(GET_CARD_TYPE(flags)) {
+            case CARD_MMC: // Multi-media card
+                ...
+            case CARD_SD:  // SD-Memory present
+                ...
+            case CARD_SDIO: // SDIO card present
+                ...
+            case CARD_COMBO: //SDIO card with SD
+                ...
+        }
+        if (flags & CARD_SD_WP) {
+            ...SD write protect on
+        }
+
+  @see also: SDDEVICE_GET_SDIO_CARD_CAPS
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_CARD_FLAGS(pDev)      (pDev)->pHcd->CardProperties.Flags
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get the Relative Card Address register
+
+  @function name: SDDEVICE_GET_CARD_RCA
+  @prototype: UINT16 SDDEVICE_GET_CARD_RCA(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: register address
+
+  @notes: Implemented as a macro. Refer to SDIO spec for decoding.
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_CARD_RCA(pDev)        (pDev)->pHcd->CardProperties.RCA
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get operational bus clock
+
+  @function name: SDDEVICE_GET_OPER_CLOCK
+  @prototype: SD_BUSCLOCK_RATE SDDEVICE_GET_OPER_CLOCK(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: clock rate
+
+  @notes: Implemented as a macro. Returns the current bus clock rate.
+          This may be lower than reported by the card due to Host Controller,
+          Bus driver, or power management limitations.
+
+  @see also: SDDEVICE_GET_MAX_CLOCK
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_OPER_CLOCK(pDev)      (pDev)->pHcd->CardProperties.OperBusClock
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get maximum bus clock
+
+  @function name: SDDEVICE_GET_MAX_CLOCK
+  @prototype: SD_BUSCLOCK_RATE SDDEVICE_GET_MAX_CLOCK(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: clock rate
+
+  @notes: To obtain the current maximum clock rate use SDDEVICE_GET_OPER_CLOCK().
+          This rate my be lower than the host controllers maximum obtained using
+          SDDEVICE_GET_MAX_CLOCK().
+
+  @see also: SDDEVICE_GET_OPER_CLOCK
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_MAX_CLOCK(pDev)       (pDev)->pHcd->MaxClockRate
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get operational maximum block length.
+
+  @function name: SDDEVICE_GET_OPER_BLOCK_LEN
+  @prototype: UINT16 SDDEVICE_GET_OPER_BLOCK_LEN(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: block size in bytes
+
+  @notes: Implemented as a macro. Returns the maximum current block length.
+          This may be lower than reported by the card due to Host Controller,
+          Bus driver, or power management limitations.
+
+  @see also: SDDEVICE_GET_MAX_BLOCK_LEN
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_OPER_BLOCK_LEN(pDev)  (pDev)->pHcd->CardProperties.OperBlockLenLimit
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get maximum block length.
+
+  @function name: SDDEVICE_GET_MAX_BLOCK_LEN
+  @prototype: UINT16 SDDEVICE_GET_MAX_BLOCK_LEN(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: block size in bytes
+
+  @notes: Implemented as a macro. Use SDDEVICE_GET_OPER_BLOCK_LEN to obtain
+          the current block length.
+
+  @see also: SDDEVICE_GET_OPER_BLOCK_LEN
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_MAX_BLOCK_LEN(pDev)   (pDev)->pHcd->MaxBytesPerBlock
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get operational maximum block count.
+
+  @function name: SDDEVICE_GET_OPER_BLOCKS
+  @prototype: UINT16 SDDEVICE_GET_OPER_BLOCKS(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: maximum number of blocks per transaction.
+
+  @notes: Implemented as a macro. Returns the maximum current block count.
+          This may be lower than reported by the card due to Host Controller,
+          Bus driver, or power management limitations.
+
+  @see also: SDDEVICE_GET_MAX_BLOCK_LEN
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_OPER_BLOCKS(pDev)     (pDev)->pHcd->CardProperties.OperBlockCountLimit
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get maximum block count.
+
+  @function name: SDDEVICE_GET_MAX_BLOCKS
+  @prototype: UINT16 SDDEVICE_GET_MAX_BLOCKS(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: maximum number of blocks per transaction.
+
+  @notes: Implemented as a macro. Use SDDEVICE_GET_OPER_BLOCKS to obtain
+          the current block count.
+
+  @see also: SDDEVICE_GET_OPER_BLOCKS
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_MAX_BLOCKS(pDev)      (pDev)->pHcd->MaxBlocksPerTrans
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get applied slot voltage
+
+  @function name: SDDEVICE_GET_SLOT_VOLTAGE_MASK
+  @prototype: SLOT_VOLTAGE_MASK SDDEVICE_GET_SLOT_VOLTAGE_MASK(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: slot voltage mask
+
+  @notes: This function returns the applied voltage on the slot. The voltage value is a
+          mask having the following values:
+          SLOT_POWER_3_3V
+          SLOT_POWER_3_0V
+          SLOT_POWER_2_8V
+          SLOT_POWER_2_0V
+          SLOT_POWER_1_8V
+          SLOT_POWER_1_6V
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_SLOT_VOLTAGE_MASK(pDev)   (pDev)->pHcd->CardProperties.CardVoltage
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get the Card Specific Data Register.
+
+  @function name: SDDEVICE_GET_CARDCSD
+  @prototype: PUINT8 SDDEVICE_GET_CARDCSD(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return:  UINT8 CardCSD[MAX_CARD_RESPONSE_BYTES] array of CSD data.
+
+  @notes: Implemented as a macro.
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_CARDCSD(pDev)         (pDev)->pHcd->CardProperties.CardCSD
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get the bus mode flags
+
+  @function name: SDDEVICE_GET_BUSMODE_FLAGS
+  @prototype: SD_BUSMODE_FLAGS SDDEVICE_GET_BUSMODE_FLAGS(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return:
+
+  @notes: Implemented as a macro.  This function returns the raw bus mode flags.  This
+          is useful for function drivers that wish to override the bus clock without
+          modifying the current bus mode.
+
+  @see also: SDDEVICE_GET_BUSWIDTH
+  @see also: SDCONFIG_BUS_MODE_CTRL
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_BUSMODE_FLAGS(pDev)  (pDev)->pHcd->CardProperties.BusMode
+
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get the bus width.
+
+  @function name: SDDEVICE_GET_BUSWIDTH
+  @prototype: UINT8 SDDEVICE_GET_BUSWIDTH(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return:  bus width: SDCONFIG_BUS_WIDTH_SPI, SDCONFIG_BUS_WIDTH_1_BIT, SDCONFIG_BUS_WIDTH_4_BIT
+
+  @notes: Implemented as a macro.
+
+  @see also: SDDEVICE_IS_BUSMODE_SPI
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_BUSWIDTH(pDev)        SDCONFIG_GET_BUSWIDTH((pDev)->pHcd->CardProperties.BusMode)
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Is bus in SPI mode.
+
+  @function name: SDDEVICE_IS_BUSMODE_SPI
+  @prototype: BOOL SDDEVICE_IS_BUSMODE_SPI(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return:  TRUE, SPI mode.
+
+  @notes: Implemented as a macro.
+
+  @see also: SDDEVICE_GET_BUSWIDTH
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_IS_BUSMODE_SPI(pDev) (SDDEVICE_GET_BUSWIDTH(pDev) == SDCONFIG_BUS_WIDTH_SPI)
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Send a request to a device.
+
+  @function name: SDDEVICE_CALL_REQUEST_FUNC
+  @prototype: SDIO_STATUS SDDEVICE_CALL_REQUEST_FUNC(PSDDEVICE pDevice, PSDREQUEST pRequest)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+  @input:  pRequest  - the request to be sent
+
+  @output: none
+
+  @return: SDIO_STATUS
+
+  @notes: Sends a request to the specified device. If the request is successfully sent, then
+          the response flags can be checked to detemine the result of the request.
+
+  @example: Example of sending a request to a device:
+    PSDREQUEST  pReq = NULL;
+    //allocate a request
+    pReq = SDDeviceAllocRequest(pDevice);
+    if (NULL == pReq) {
+        return SDIO_STATUS_NO_RESOURCES;
+    }
+    //initialize the request
+    SDLIB_SetupCMD52Request(FuncNo, Address, Write, *pData, pReq);
+    //send the request to the target
+    status = SDDEVICE_CALL_REQUEST_FUNC(pDevice,pReq);
+    if (!SDIO_SUCCESS(status)) {
+        break;
+    }
+    //check the request response (based on the request type)
+    if (SD_R5_GET_RESP_FLAGS(pReq->Response) & SD_R5_ERRORS) {
+        ...
+    }
+    if (!Write) {
+            // store the byte
+        *pData =  SD_R5_GET_READ_DATA(pReq->Response);
+    }
+    //free the request
+    SDDeviceFreeRequest(pDevice,pReq);
+    ...
+
+  @see also: SDDeviceAllocRequest
+  @see also: SDDEVICE_CALL_CONFIG_FUNC
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_CALL_REQUEST_FUNC(pDev,pReq)  (pDev)->pRequest((pDev),(pReq))
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Send configuration to a device.
+
+  @function name: SDDEVICE_CALL_CONFIG_FUNC
+  @prototype: SDIO_STATUS SDDEVICE_CALL_CONFIG_FUNC(PSDDEVICE pDevice, PSDCONFIG pConfigure)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+  @input:  pConfigure - configuration request
+
+  @output: none
+
+  @return: SDIO_STATUS
+
+  @notes: Sends a configuration request to the specified device.
+
+  @example: Example of sending a request to a device:
+        SDCONFIG  configHdr;
+        SDCONFIG_FUNC_ENABLE_DISABLE_DATA fData;
+        fData.EnableFlags = SDCONFIG_ENABLE_FUNC;
+        fData.TimeOut = 500;
+        SET_SDCONFIG_CMD_INFO(&configHdr, SDCONFIG_FUNC_ENABLE_DISABLE, fData, sizeof(fData));
+        return SDDEVICE_CALL_CONFIG_FUNC(pDevice, &configHdr);
+
+  @see also: SDLIB_IssueConfig
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_CALL_CONFIG_FUNC(pDev,pCfg)   (pDev)->pConfigure((pDev),(pCfg))
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Allocate a request structure.
+
+  @function name: SDDeviceAllocRequest
+  @prototype: PSDREQUEST SDDeviceAllocRequest(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: request pointer or NULL if not available.
+
+  @notes:  This function must not be called in a non-schedulable (interrupts off) context.
+           Allocating memory on some OSes may block.
+
+  @see also: SDDEVICE_CALL_REQUEST_FUNC
+  @see also: SDDeviceFreeRequest
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDeviceAllocRequest(pDev)        (pDev)->AllocRequest((pDev))
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Free a request structure.
+
+  @function name: SDDeviceFreeRequest
+  @prototype: void SDDeviceFreeRequest(PSDDEVICE pDevice, PSDREQUEST pRequest)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+  @input:  pRequest  - request allocated by SDDeviceAllocRequest().
+
+  @output: none
+
+  @return: none
+
+  @notes: This function must not be called in a non-schedulable (interrupts off) context.
+          Freeing memory on some OSes may block.
+
+  @see also: SDDEVICE_CALL_REQUEST_FUNC
+  @see also: SDDeviceAllocRequest
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDeviceFreeRequest(pDev,pReq)    (pDev)->FreeRequest((pDev),pReq)
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Register an interrupt handler for a device.
+
+  @function name: SDDEVICE_SET_IRQ_HANDLER
+  @prototype: void SDDEVICE_SET_IRQ_HANDLER(PSDDEVICE pDevice,
+                                            void (*pIrqFunction)(PVOID pContext),
+                                            PVOID pContext)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+  @input:  pIrqFunction  - the interrupt function to execute.
+  @input:  pContext  - context value passed into interrupt routine.
+
+  @output: none
+
+  @return: none
+
+  @notes: The registered routine will be called upon each card interrupt.
+          The interrupt function should acknowledge the interrupt when it is
+          ready to handle more interrupts using:
+          SDLIB_IssueConfig(pDevice, SDCONFIG_FUNC_ACK_IRQ, NULL, 0);
+          The interrupt handler can perform synchronous request calls.
+
+  @see also: SDDEVICE_SET_ASYNC_IRQ_HANDLER
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_SET_IRQ_HANDLER(pDev,pFn,pContext)  \
+{                                                    \
+    (pDev)->pIrqFunction = (pFn);                    \
+    (pDev)->IrqContext = (PVOID)(pContext);          \
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Register an asynchronous interrupt handler for a device.
+
+  @function name: SDDEVICE_SET_ASYNC_IRQ_HANDLER
+  @prototype: void SDDEVICE_SET_ASYNC_IRQ_HANDLER(PSDDEVICE pDevice,
+                                            void (*pIrqAsyncFunction)(PVOID pContext),
+                                            PVOID pContext)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+  @input:  pIrqAsyncFunction  - the interrupt function to execute.
+  @input:  pContext  - context value passed into interrupt routine.
+
+  @output: none
+
+  @return: none
+
+  @notes: The registered routine will be called upon each card interrupt.
+          The interrupt function should acknowledge the interrupt when it is
+          ready to handle more interrupts using:
+          SDLIB_IssueConfig(pDevice, SDCONFIG_FUNC_ACK_IRQ, NULL, 0);
+          The interrupt handler can not perform any synchronous request calls.
+          Using this call provides a faster interrupt dispatch, but limits all
+          requests to asynchronous mode.
+
+  @see also: SDDEVICE_SET_IRQ_HANDLER
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_SET_ASYNC_IRQ_HANDLER(pDev,pFn,pContext)  \
+{                                                          \
+    (pDev)->pIrqAsyncFunction = (pFn);                     \
+    (pDev)->IrqAsyncContext = (PVOID)(pContext);           \
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get the SDIO capabilities rgeister.
+
+  @function name: SDDEVICE_GET_SDIOCARD_CAPS
+  @prototype: UINT8 SDDEVICE_GET_SDIOCARD_CAPS(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return: SD capabilities
+
+  @notes: See SD specification for decoding of these capabilities.
+
+  @see also: SDDEVICE_GET_SDIO_CARD_CAPS
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_SDIOCARD_CAPS(pDev) (pDev)->pHcd->CardProperties.SDIOCaps
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get HCD driver name
+
+  @function name: SDDEVICE_GET_HCDNAME
+  @prototype: PTEXT SDDEVICE_GET_HCDNAME(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice   - the target device for this request
+
+  @output: none
+
+  @return:  pointer to a string containing the name of the underlying HCD
+
+  @notes: Implemented as a macro.
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_HCDNAME(pDev)  (pDev)->pHcd->pName
+
+
+#define SDDEVICE_CALL_IRQ_HANDLER(pDev)       (pDev)->pIrqFunction((pDev)->IrqContext)
+#define SDDEVICE_CALL_IRQ_ASYNC_HANDLER(pDev) (pDev)->pIrqAsyncFunction((pDev)->IrqAsyncContext)
+
+
+#define SDDEVICE_SET_SDIO_FUNCNO(pDev,Num) (pDev)->pId[0].SDIO_FunctionNo = (Num)
+#define SDDEVICE_IS_CARD_REMOVED(pDev)     ((pDev)->pHcd->CardProperties.CardState & \
+                                             CARD_STATE_REMOVED)
+
+
+typedef enum _SDHCD_IRQ_PROC_STATE {
+    SDHCD_IDLE = 0,
+    SDHCD_IRQ_PENDING = 1,
+    SDHCD_IRQ_HELPER  = 2
+}SDHCD_IRQ_PROC_STATE, *PSDHCD_IRQ_PROC_STATE;
+
+/* host controller bus driver registration structure */
+typedef struct _SDHCD {
+    CT_VERSION_CODE Version;    /* version code of the SDIO stack */
+    SDLIST  SDList;             /* internal use list*/
+    PTEXT   pName;              /* name of registering host/slot driver */
+    UINT32  Attributes;         /* attributes of host controller */
+    UINT16  MaxBytesPerBlock;   /* max bytes per block */
+    UINT16  MaxBlocksPerTrans;  /* max blocks per transaction */
+    SD_SLOT_CURRENT  MaxSlotCurrent;  /* max current per slot in milli-amps */
+    UINT8   SlotNumber;         /* sequential slot number for this HCD, set by bus driver */
+    SD_BUSCLOCK_RATE    MaxClockRate;         /* max clock rate in hz */
+    SLOT_VOLTAGE_MASK   SlotVoltageCaps;      /* slot voltage capabilities */
+    SLOT_VOLTAGE_MASK   SlotVoltagePreferred; /* preferred slot voltage */
+    PVOID   pContext;                         /* host controller driver use data   */
+    SDIO_STATUS (*pRequest)(struct _SDHCD *pHcd);
+                                /* get/set configuration */
+    SDIO_STATUS (*pConfigure)(struct _SDHCD *pHcd, PSDCONFIG pConfig);
+        /* everything below this line is for bus driver use */
+    OS_SEMAPHORE    ConfigureOpsSem;    /* semaphore to make specific configure ops atomic, internal use */
+    OS_CRITICALSECTION HcdCritSection;  /* critical section to protect hcd data structures (internal use) */
+    SDREQUESTQUEUE  RequestQueue;       /* request queue, internal use */
+    PSDREQUEST      pCurrentRequest;    /* current request we are working on */
+    CARD_PROPERTIES CardProperties;     /* properties for the currently inserted card*/
+    OSKERNEL_HELPER SDIOIrqHelper;      /* synch IRQ helper, internal use */
+    SDDEVICE        *pPseudoDev;        /* pseudo device used for initialization (internal use) */
+    UINT8           PendingHelperIrqs;  /* IRQ helper pending IRQs */
+    UINT8           PendingIrqAcks;     /* pending IRQ acks from function drivers */
+    UINT8           IrqsEnabled;        /* current irq enabled mask */
+    SDHCD_IRQ_PROC_STATE IrqProcState;  /* irq processing state */
+    POS_DEVICE      pDevice;            /* device registration with base system */
+    SD_SLOT_CURRENT SlotCurrentAllocated; /* slot current allocated (internal use ) */
+    ATOMIC_FLAGS    HcdFlags;             /* HCD Flags */
+#define HCD_REQUEST_CALL_BIT  0
+#define HCD_IRQ_NO_PEND_CHECK 1           /* HCD flag to bypass interrupt pending register
+                                             check, typically done on single function cards */
+    SDREQUESTQUEUE  CompletedRequestQueue; /* completed request queue, internal use */
+    PSDDMA_DESCRIPTION pDmaDescription; /* description of HCD's DMA capabilities */
+    POS_MODULE         pModule;         /* OS-specific module information */
+    INT                Recursion;       /* recursion level */
+    PVOID              Reserved1;
+    PVOID              Reserved2;
+}SDHCD, *PSDHCD;
+
+/* Protects the host controller insertion/removal handlers,
+ *  in case of e.g. a power failure, rf kill switch
+ */
+extern struct semaphore athsdio_init_lock;
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get a pointer to the HCD's DMA description
+
+  @function name: SDGET_DMA_DESCRIPTION
+  @prototype: PSDDMA_DESCRIPTION SDGET_DMA_DESCRIPTION(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice - device structure
+
+  @return: PSDDMA_DESCRIPTION or NULL if no DMA support
+
+  @notes: Implemented as a macro.
+
+  @example: getting the current request:
+          PSDDMA_DESCRIPTION pDmaDescrp = SDGET_DMA_DESCRIPTION(pDevice);
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDGET_DMA_DESCRIPTION(pDevice)     (pDevice)->pHcd->pDmaDescription
+
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get the logical slot number the device is assigned to.
+
+  @function name: SDDEVICE_GET_SLOT_NUMBER
+  @prototype: UINT8 SDDEVICE_GET_SLOT_NUMBER(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input:  pDevice - device structure
+
+  @return: unsigned number representing the slot number
+
+  @notes: Implemented as a macro. This value is unique for each physical slot in the system
+          and assigned by the bus driver. Devices on a multi-function card will share the same
+          slot number.
+
+  @example: getting the slot number:
+          UINT8 thisSlot = SDDEVICE_GET_SLOT_NUMBER(pDevice);
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDDEVICE_GET_SLOT_NUMBER(pDevice) (pDevice)->pHcd->SlotNumber
+
+/* for function use */
+SDIO_STATUS SDIO_RegisterFunction(PSDFUNCTION pFunction);
+SDIO_STATUS SDIO_UnregisterFunction(PSDFUNCTION pFunction);
+
+#include "sdio_hcd_defs.h"
+#endif /* __SDIO_BUSDRIVER_H___ */
Index: linux-2.6/include/linux/sdio/sdio_hcd_defs.h
===================================================================
--- /dev/null
+++ linux-2.6/include/linux/sdio/sdio_hcd_defs.h
@@ -0,0 +1,219 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdio_hcd_defs.h
+
+@abstract: host controller driver definitions
+
+@notice: Copyright (c), 2005-2006 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#ifndef __SDIO_HCD_DEFS_H___
+#define __SDIO_HCD_DEFS_H___
+
+    /* write protect switch position data */
+typedef UINT8 SDCONFIG_WP_VALUE;
+
+    /* HC commands */
+#define SDCONFIG_SEND_INIT_CLOCKS  (SDCONFIG_FLAGS_HC_CONFIG | SDCONFIG_FLAGS_DATA_PUT  | 1)
+#define SDCONFIG_SDIO_INT_CTRL     (SDCONFIG_FLAGS_HC_CONFIG | SDCONFIG_FLAGS_DATA_PUT  | 2)
+#define SDCONFIG_SDIO_REARM_INT    (SDCONFIG_FLAGS_HC_CONFIG | SDCONFIG_FLAGS_DATA_NONE | 3)
+#define SDCONFIG_BUS_MODE_CTRL     (SDCONFIG_FLAGS_HC_CONFIG | SDCONFIG_FLAGS_DATA_BOTH | 4)
+#define SDCONFIG_POWER_CTRL        (SDCONFIG_FLAGS_HC_CONFIG | SDCONFIG_FLAGS_DATA_PUT  | 5)
+#define SDCONFIG_GET_WP            (SDCONFIG_FLAGS_HC_CONFIG | SDCONFIG_FLAGS_DATA_GET  | 6)
+
+    /* slot init clocks control */
+typedef struct _SDCONFIG_INIT_CLOCKS_DATA  {
+    UINT16  NumberOfClocks;  /* number of clocks to issue in the current bus mode*/
+}SDCONFIG_INIT_CLOCKS_DATA, *PSDCONFIG_INIT_CLOCKS_DATA;
+
+/* slot power control */
+typedef struct _SDCONFIG_POWER_CTRL_DATA  {
+    BOOL                SlotPowerEnable;            /* turn on/off slot power */
+    SLOT_VOLTAGE_MASK   SlotPowerVoltageMask;       /* slot power voltage mask */
+}SDCONFIG_POWER_CTRL_DATA, *PSDCONFIG_POWER_CTRL_DATA;
+
+typedef UINT8 SDIO_IRQ_MODE_FLAGS;
+/* SDIO Interrupt control */
+typedef struct _SDCONFIG_SDIO_INT_CTRL_DATA  {
+    BOOL                  SlotIRQEnable;      /* turn on/off Slot IRQ detection */
+    SDIO_IRQ_MODE_FLAGS   IRQDetectMode;      /* slot IRQ detect mode , only valid if Enabled = TRUE */
+#define IRQ_DETECT_RAW       0x00
+#define IRQ_DETECT_MULTI_BLK 0x01
+#define IRQ_DETECT_4_BIT     0x02
+#define IRQ_DETECT_1_BIT     0x04
+#define IRQ_DETECT_SPI       0x08
+}SDCONFIG_SDIO_INT_CTRL_DATA, *PSDCONFIG_SDIO_INT_CTRL_DATA;
+
+/* card insert */
+#define EVENT_HCD_ATTACH               1
+/* card remove */
+#define EVENT_HCD_DETACH               2
+/* card slot interrupt */
+#define EVENT_HCD_SDIO_IRQ_PENDING     3
+/* transfer done */
+#define EVENT_HCD_TRANSFER_DONE        4
+/* (internal use only) */
+#define EVENT_HCD_CD_POLLING           5
+/* NOP */
+#define EVENT_HCD_NOP                  0
+
+/* attrib_flags */
+#define SDHCD_ATTRIB_SUPPORTS_POWER   0x0001  /* host controller driver supports power managment */
+#define SDHCD_ATTRIB_BUS_1BIT         0x0002  /* SD Native 1 - bit mode */
+#define SDHCD_ATTRIB_BUS_4BIT         0x0004  /* SD Native 4 - bit mode */
+#define SDHCD_ATTRIB_BUS_SPI          0x0008  /* SPI mode capable */
+#define SDHCD_ATTRIB_READ_WAIT        0x0010  /* read wait supported (SD-only) */
+#define SDHCD_ATTRIB_MULTI_BLK_IRQ    0x0020  /* interrupts between multi-block capable (SD-only) */
+#define SDHCD_ATTRIB_BUS_MMC8BIT      0x0040  /* MMC  8-bit */
+#define SDHCD_ATTRIB_SLOT_POLLING     0x0080  /* requires slot polling for Card Detect */
+#define SDHCD_ATTRIB_POWER_SWITCH     0x0100  /* host has power switch control, must be set if SPI
+                                                 mode can be switched to 1 or 4 bit mode */
+#define SDHCD_ATTRIB_NO_SPI_CRC       0x0200  /* when in SPI mode,
+                                                 host wants to run without SPI CRC */
+#define SDHCD_ATTRIB_AUTO_CMD12       0x0400  /* host controller supports auto CMD12 */
+#define SDHCD_ATTRIB_NO_4BIT_IRQ      0x0800  /* host controller does not support 4 bit IRQ mode*/
+#define SDHCD_ATTRIB_RAW_MODE         0x1000  /* host controller is a raw mode hcd*/
+#define SDHCD_ATTRIB_SD_HIGH_SPEED    0x2000  /* host controller supports SD high speed interface */
+#define SDHCD_ATTRIB_MMC_HIGH_SPEED   0x4000  /* host controller supports MMC high speed interface */
+
+#define IS_CARD_PRESENT(pHcd)         ((pHcd)->CardProperties.Flags & CARD_TYPE_MASK)
+#define SET_CURRENT_REQUEST(pHcd,Req) (pHcd)->pCurrentRequest = (Req)
+#define IS_HCD_RAW(pHcd)              ((pHcd)->Attributes & SDHCD_ATTRIB_RAW_MODE)
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get a pointer to the current bus request for a host controller
+
+  @function name: GET_CURRENT_REQUEST
+  @prototype: PSDREQUEST GET_CURRENT_REQUEST (PSDHCD pHcd)
+  @category: HD_Reference
+
+  @input:  pHcd - host structure
+
+  @return: current SD/SDIO bus request being worked on
+
+  @notes: Implemented as a macro. This macro returns the current SD request that is
+          being worked on.
+
+  @example: getting the current request:
+          pReq = GET_CURRENT_REQUEST(&pHct->Hcd);
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define GET_CURRENT_REQUEST(pHcd)     (pHcd)->pCurrentRequest
+#define GET_CURRENT_BUS_WIDTH(pHcd) SDCONFIG_GET_BUSWIDTH((pHcd)->CardProperties.BusMode)
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Get host controller's current operational bus clock
+
+  @function name: SDHCD_GET_OPER_CLOCK
+  @prototype: SD_BUSCLOCK_RATE SDHCD_GET_OPER_CLOCK(PSDHCD pHcd)
+  @category: HD_Reference
+
+  @input:  pHcd   - the registered host structure
+
+  @output: none
+
+  @return: clock rate
+
+  @notes: Implemented as a macro. Returns the current bus clock rate.
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDHCD_GET_OPER_CLOCK(pHcd)      (pHcd)->CardProperties.OperBusClock
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Is host controller operating in SPI mode
+
+  @function name: IS_HCD_BUS_MODE_SPI
+  @prototype: BOOL IS_HCD_BUS_MODE_SPI (PSDHCD pHcd)
+  @category: HD_Reference
+
+  @input:  pHcd - host structure
+
+  @return: TRUE if in SPI mode
+
+  @notes: Implemented as a macro. Host controllers that operate in SPI mode
+          dynamically can use this macro to check for SPI operation.
+
+  @example: testing for SPI mode:
+          if (IS_HCD_BUS_MODE_SPI(&pHct->Hcd)) {
+             .. in spi mode
+          }
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define IS_HCD_BUS_MODE_SPI(pHcd)   (GET_CURRENT_BUS_WIDTH(pHcd) == SDCONFIG_BUS_WIDTH_SPI)
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Is host controller using SPI in non-CRC mode
+
+  @function name: IS_HCD_BUS_MODE_SPI_NO_CRC
+  @prototype: BOOL IS_HCD_BUS_MODE_SPI_NO_CRC(PSDHCD pHcd)
+  @category: HD_Reference
+
+  @input:  pHcd - host structure
+
+  @return: TRUE if CRC mode is off
+
+  @notes: Implemented as a macro. SPI-capable cards and systems can operate in
+          non-CRC protected mode.  In this mode the host controller should ignore
+          CRC fields and/or disable CRC generation when issuing command or data
+          packets.  This option is useful for software based SPI mode where CRC
+          should be turned off in order to reduce processing overhead.
+
+  @example: test for non-CRC SPI mode:
+          if (IS_HCD_BUS_MODE_SPI_NO_CRC(&pHct->Hcd)) {
+             .. disable CRC checking in hardware.
+          }
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define IS_HCD_BUS_MODE_SPI_NO_CRC(pHcd)   ((pHcd)->CardProperties.BusMode & \
+                                                        SDCONFIG_BUS_MODE_SPI_NO_CRC)
+
+typedef UINT8 SDHCD_RESPONSE_CHECK_MODE;
+/* have SDIO core check the response token and see if it is okay to continue with
+   * the data portion */
+#define SDHCD_CHECK_DATA_TRANS_OK   0x01
+/* have SDIO core check the SPI token received */
+#define SDHCD_CHECK_SPI_TOKEN       0x02
+
+/* prototypes */
+/* for HCD use */
+SDIO_STATUS SDIO_RegisterHostController(PSDHCD pHcd);
+SDIO_STATUS SDIO_UnregisterHostController(PSDHCD pHcd);
+SDIO_STATUS SDIO_HandleHcdEvent(PSDHCD pHcd, HCD_EVENT Event);
+SDIO_STATUS SDIO_CheckResponse(PSDHCD pHcd, PSDREQUEST pReq, SDHCD_RESPONSE_CHECK_MODE CheckMode);
+SDIO_STATUS SDIO_BusAddOSDevice(PSDDMA_DESCRIPTION pDma, POS_PNPDRIVER pDriver, POS_PNPDEVICE pDevice);
+void SDIO_BusRemoveOSDevice(POS_PNPDRIVER pDriver, POS_PNPDEVICE pDevice);
+
+#endif /* __SDIO_BUSDRIVER_H___ */
Index: linux-2.6/include/linux/sdio/sdio_lib.h
===================================================================
--- /dev/null
+++ linux-2.6/include/linux/sdio/sdio_lib.h
@@ -0,0 +1,270 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdio_lib.h
+
+@abstract: SDIO Library include
+
+#notes:
+
+@notice: Copyright (c), 2004-2006 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#ifndef __SDIO_LIB_H___
+#define __SDIO_LIB_H___
+
+#ifdef UNDER_CE
+#include "wince\sdio_lib_wince.h"
+#endif /* WINCE */
+
+#define CMD52_DO_READ  FALSE
+#define CMD52_DO_WRITE TRUE
+
+    /* read/write macros to any function */
+#define Cmd52WriteByteFunc(pDev,Func,Address,pValue) \
+                SDLIB_IssueCMD52((pDev),(Func),(Address),(pValue),1,CMD52_DO_WRITE)
+#define Cmd52ReadByteFunc(pDev,Func,Address,pValue) \
+                SDLIB_IssueCMD52((pDev),(Func),(Address),pValue,1,CMD52_DO_READ)
+#define Cmd52ReadMultipleFunc(pDev,Func, Address, pBuf,length) \
+                SDLIB_IssueCMD52((pDev),(Func),(Address),(pBuf),(length),CMD52_DO_READ)
+
+   /* macros to access common registers */
+#define Cmd52WriteByteCommon(pDev, Address, pValue) \
+                Cmd52WriteByteFunc((pDev),0,(Address),(pValue))
+#define Cmd52ReadByteCommon(pDev, Address, pValue) \
+                Cmd52ReadByteFunc((pDev),0,(Address),(pValue))
+#define Cmd52ReadMultipleCommon(pDev, Address, pBuf,length) \
+                Cmd52ReadMultipleFunc((pDev),0,(Address),(pBuf),(length))
+
+#define SDLIB_SetupCMD52RequestAsync(f,a,w,wd,pR)   \
+{                                                   \
+    SDLIB_SetupCMD52Request((f),(a),(w),(wd),(pR)); \
+    (pR)->Flags |= SDREQ_FLAGS_TRANS_ASYNC;         \
+}
+
+    /* a message block */
+typedef struct _SDMESSAGE_BLOCK {
+    SDLIST  SDList;                   /* list entry */
+    INT     MessageLength;            /* number of bytes in this message */
+    UINT8   MessageStart[1];          /* message start */
+}SDMESSAGE_BLOCK, *PSDMESSAGE_BLOCK;
+
+    /* message queue */
+typedef struct _SDMESSAGE_QUEUE {
+    SDLIST          MessageList;        /* message list */
+    OS_CRITICALSECTION MessageCritSection; /* message semaphore */
+    SDLIST          FreeMessageList;    /* free message list */
+    INT             MaxMessageLength;   /* max message block length */
+}SDMESSAGE_QUEUE, *PSDMESSAGE_QUEUE;
+
+/* internal library prototypes that can be proxied */
+SDIO_STATUS _SDLIB_IssueCMD52(PSDDEVICE     pDevice,
+                        UINT8         FuncNo,
+                        UINT32        Address,
+                        PUINT8        pData,
+                        INT           ByteCount,
+                        BOOL          Write);
+SDIO_STATUS _SDLIB_FindTuple(PSDDEVICE  pDevice,
+                             UINT8      Tuple,
+                             UINT32     *pTupleScanAddress,
+                             PUINT8     pBuffer,
+                             UINT8      *pLength);
+SDIO_STATUS _SDLIB_IssueConfig(PSDDEVICE        pDevice,
+                               SDCONFIG_COMMAND Command,
+                               PVOID            pData,
+                               INT              Length);
+void _SDLIB_PrintBuffer(PUCHAR pBuffer, INT Length,PTEXT pDescription);
+void _SDLIB_SetupCMD52Request(UINT8         FuncNo,
+                              UINT32        Address,
+                              BOOL          Write,
+                              UINT8         WriteData,
+                              PSDREQUEST    pRequest);
+SDIO_STATUS _SDLIB_SetFunctionBlockSize(PSDDEVICE        pDevice,
+                                        UINT16           BlockSize);
+
+SDIO_STATUS _SDLIB_GetDefaultOpCurrent(PSDDEVICE  pDevice,
+                                       SD_SLOT_CURRENT *pOpCurrent);
+PSDMESSAGE_QUEUE _CreateMessageQueue(INT MaxMessages, INT MaxMessageLength);
+void _DeleteMessageQueue(PSDMESSAGE_QUEUE pQueue);
+SDIO_STATUS _PostMessage(PSDMESSAGE_QUEUE pQueue, PVOID pMessage, INT MessageLength);
+SDIO_STATUS _GetMessage(PSDMESSAGE_QUEUE pQueue, PVOID pData, INT *pBufferLength);
+
+#ifdef CTSYSTEM_NO_FUNCTION_PROXIES
+    /* OS port requires no proxy functions, use methods directly from the library */
+#define SDLIB_IssueCMD52        _SDLIB_IssueCMD52
+#define SDLIB_SetupCMD52Request _SDLIB_SetupCMD52Request
+#define SDLIB_FindTuple         _SDLIB_FindTuple
+#define SDLIB_IssueConfig       _SDLIB_IssueConfig
+#define SDLIB_SetFunctionBlockSize  _SDLIB_SetFunctionBlockSize
+#define SDLIB_GetDefaultOpCurrent   _SDLIB_GetDefaultOpCurrent
+#define SDLIB_CreateMessageQueue    _CreateMessageQueue
+#define SDLIB_DeleteMessageQueue    _DeleteMessageQueue
+#define SDLIB_PostMessage           _PostMessage
+#define SDLIB_GetMessage            _GetMessage
+#define SDLIB_PrintBuffer           _SDLIB_PrintBuffer
+#else
+
+/* proxied versions */
+SDIO_STATUS SDLIB_IssueCMD52(PSDDEVICE     pDevice,
+                             UINT8         FuncNo,
+                             UINT32        Address,
+                             PUINT8        pData,
+                             INT           ByteCount,
+                             BOOL          Write);
+
+void SDLIB_SetupCMD52Request(UINT8         FuncNo,
+                             UINT32        Address,
+                             BOOL          Write,
+                             UINT8         WriteData,
+                             PSDREQUEST    pRequest);
+
+SDIO_STATUS SDLIB_FindTuple(PSDDEVICE  pDevice,
+                        UINT8      Tuple,
+                        UINT32     *pTupleScanAddress,
+                        PUINT8     pBuffer,
+                        UINT8      *pLength);
+
+SDIO_STATUS SDLIB_IssueConfig(PSDDEVICE        pDevice,
+                              SDCONFIG_COMMAND Command,
+                              PVOID            pData,
+                              INT              Length);
+
+SDIO_STATUS SDLIB_SetFunctionBlockSize(PSDDEVICE        pDevice,
+                                       UINT16           BlockSize);
+
+void SDLIB_PrintBuffer(PUCHAR pBuffer, INT Length,PTEXT pDescription);
+
+SDIO_STATUS SDLIB_GetDefaultOpCurrent(PSDDEVICE  pDevice, SD_SLOT_CURRENT *pOpCurrent);
+
+PSDMESSAGE_QUEUE SDLIB_CreateMessageQueue(INT MaxMessages, INT MaxMessageLength);
+
+void SDLIB_DeleteMessageQueue(PSDMESSAGE_QUEUE pQueue);
+
+SDIO_STATUS SDLIB_PostMessage(PSDMESSAGE_QUEUE pQueue, PVOID pMessage, INT MessageLength);
+
+SDIO_STATUS SDLIB_GetMessage(PSDMESSAGE_QUEUE pQueue, PVOID pData, INT *pBufferLength);
+#endif /* CTSYSTEM_NO_FUNCTION_PROXIES */
+
+
+SDIO_STATUS SDLIB_OSCreateHelper(POSKERNEL_HELPER pHelper,
+                           PHELPER_FUNCTION pFunction,
+                           PVOID            pContext);
+
+void SDLIB_OSDeleteHelper(POSKERNEL_HELPER pHelper);
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Check message queue is empty
+
+  @function name: SDLIB_IsQueueEmpty
+  @prototype: BOOL SDLIB_IsQueueEmpty(PSDMESSAGE_QUEUE pQueue)
+  @category: Support_Reference
+
+  @input: pQueue - message queue to check
+
+  @return: TRUE if empty else false
+
+  @see also: SDLIB_CreateMessageQueue
+
+  @example: Check message queue :
+              if (SDLIB_IsQueueEmpty(pInstance->pQueue)) {
+                   .. message queue is empty
+              }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static INLINE BOOL SDLIB_IsQueueEmpty(PSDMESSAGE_QUEUE pQueue) {
+    return SDLIST_IS_EMPTY(&pQueue->MessageList);
+}
+
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Issue an I/O abort request
+
+  @function name: SDLIB_IssueIOAbort
+  @prototype: SDIO_STATUS SDLIB_IssueIOAbort(PSDDEVICE pDevice)
+  @category: PD_Reference
+
+  @input: pDevice - the device that is the target of this request
+
+  @return: SDIO_STATUS
+
+  @notes: This procedure can be called to issue an I/O abort request to an I/O function.
+          This procedure cannot be used to abort a data (block) transfer already in progress.
+          It is intended to be used when a data (block) transfer completes with an error and only if
+          the I/O function requires an abort action.  Some I/O functions may automatically
+          recover from such failures and not require this action. This function issues
+          the abort command synchronously and can potentially block.
+          If an async request is required, you must allocate a request and use
+          SDLIB_SetupIOAbortAsync() to prepare the request.
+
+  @example: Issuing I/O Abort synchronously :
+              .. check status from last block operation:
+              if (status == SDIO_STATUS_BUS_READ_TIMEOUT) {
+                   .. on failure, issue I/O abort
+                   status2 = SDLIB_IssueIOAbort(pDevice);
+              }
+            Issuing I/O Abort asynchronously:
+                ... allocate a request
+                ... setup the request:
+                 SDLIB_SetupIOAbortAsync(pDevice,pReq);
+                 pReq->pCompletion = myIOAbortCompletion;
+                 pReq->pCompleteContext = pDevice;
+                 status = SDDEVICE_CALL_REQUEST_FUNC(pDevice,pReq);
+
+   @see also: SDLIB_SetupIOAbortAsync
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+static INLINE SDIO_STATUS SDLIB_IssueIOAbort(PSDDEVICE pDevice) {
+    UINT8 value = SDDEVICE_GET_SDIO_FUNCNO(pDevice);
+    return Cmd52WriteByteCommon(pDevice,0x06,&value);
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @function: Setup an I/O abort request for async operation
+
+  @function name: SDLIB_SetupIOAbortAsync
+  @prototype: SDLIB_SetupIOAbortAsync(PSDDEVICE pDevice, PSDREQUEST pRequest)
+  @category: PD_Reference
+
+  @input: pDevice - the device that is the target of this request
+          pRequest - the request to set up
+
+  @see also: SDLIB_IssueIOAbort
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#define SDLIB_SetupIOAbortAsync(pDevice, pReq) \
+        SDLIB_SetupCMD52RequestAsync(0,0x06,TRUE,SDDEVICE_GET_SDIO_FUNCNO(pDevice),(pReq))
+
+
+#endif /* __SDIO_LIB_H___*/
Index: linux-2.6/include/linux/sdio/sdlist.h
===================================================================
--- /dev/null
+++ linux-2.6/include/linux/sdio/sdlist.h
@@ -0,0 +1,141 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+@file: sdlist.h
+
+@abstract: OS independent list functions
+
+@notice: Copyright (c), 2004-2006 Atheros Communications, Inc.
+
+
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *  Portions of this code were developed with information supplied from the
+ *  SD Card Association Simplified Specifications. The following conditions and disclaimers may apply:
+ *
+ *   The following conditions apply to the release of the SD simplified specification (�Simplified
+ *   Specification�) by the SD Card Association. The Simplified Specification is a subset of the complete
+ *   SD Specification which is owned by the SD Card Association. This Simplified Specification is provided
+ *   on a non-confidential basis subject to the disclaimers below. Any implementation of the Simplified
+ *   Specification may require a license from the SD Card Association or other third parties.
+ *   Disclaimers:
+ *   The information contained in the Simplified Specification is presented only as a standard
+ *   specification for SD Cards and SD Host/Ancillary products and is provided "AS-IS" without any
+ *   representations or warranties of any kind. No responsibility is assumed by the SD Card Association for
+ *   any damages, any infringements of patents or other right of the SD Card Association or any third
+ *   parties, which may result from its use. No license is granted by implication, estoppel or otherwise
+ *   under any patent or other rights of the SD Card Association or any third party. Nothing herein shall
+ *   be construed as an obligation by the SD Card Association to disclose or distribute any technical
+ *   information, know-how or other confidential information to any third party.
+ *
+ *
+ *  The initial developers of the original code are Seung Yi and Paul Lever
+ *
+ *  sdio@atheros.com
+ *
+ *
+
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+#ifndef __SDLIST_H___
+#define __SDLIST_H___
+
+/* list functions */
+/* pointers for the list */
+typedef struct _SDLIST {
+    struct _SDLIST *pPrev;
+    struct _SDLIST *pNext;
+}SDLIST, *PSDLIST;
+/*
+ * SDLIST_INIT , circular list
+*/
+#define SDLIST_INIT(pList)\
+    {(pList)->pPrev = pList; (pList)->pNext = pList;}
+#define SDLIST_INIT_DECLARE(List)\
+    SDLIST List =   {&List, &List}
+
+
+#define SDLIST_IS_EMPTY(pList) (((pList)->pPrev == (pList)) && ((pList)->pNext == (pList)))
+#define SDLIST_GET_ITEM_AT_HEAD(pList) (pList)->pNext
+#define SDLIST_GET_ITEM_AT_TAIL(pList) (pList)->pPrev
+/*
+ * SDITERATE_OVER_LIST pStart is the list, pTemp is a temp list member
+ * NOT: do not use this function if the items in the list are deleted inside the
+ * iteration loop
+*/
+#define SDITERATE_OVER_LIST(pStart, pTemp) \
+    for((pTemp) =(pStart)->pNext; pTemp != (pStart); (pTemp) = (pTemp)->pNext)
+
+
+/* safe iterate macro that allows the item to be removed from the list
+ * the iteration continues to the next item in the list
+ */
+#define SDITERATE_OVER_LIST_ALLOW_REMOVE(pStart,pItem,st,offset)  \
+{                                                       \
+    PSDLIST  pTemp;                                     \
+    pTemp = (pStart)->pNext;                            \
+    while (pTemp != (pStart)) {                         \
+        (pItem) = CONTAINING_STRUCT(pTemp,st,offset);   \
+         pTemp = pTemp->pNext;                          \
+
+#define SDITERATE_END }}
+
+/*
+ * SDListInsertTail - insert pAdd to the end of the list
+*/
+static INLINE PSDLIST SDListInsertTail(PSDLIST pList, PSDLIST pAdd) {
+        /* this assert catches when an item is added twice */
+    DBG_ASSERT(pAdd->pNext != pList);
+        /* insert at tail */
+    pAdd->pPrev = pList->pPrev;
+    pAdd->pNext = pList;
+    pList->pPrev->pNext = pAdd;
+    pList->pPrev = pAdd;
+    return pAdd;
+}
+
+/*
+ * SDListInsertHead - insert pAdd into the head of the list
+*/
+static INLINE PSDLIST SDListInsertHead(PSDLIST pList, PSDLIST pAdd) {
+        /* this assert catches when an item is added twice */
+    DBG_ASSERT(pAdd->pPrev != pList);
+        /* insert at head */
+    pAdd->pPrev = pList;
+    pAdd->pNext = pList->pNext;
+    pList->pNext->pPrev = pAdd;
+    pList->pNext = pAdd;
+    return pAdd;
+}
+
+#define SDListAdd(pList,pItem) SDListInsertHead((pList),(pItem))
+/*
+ * SDListRemove - remove pDel from list
+*/
+static INLINE PSDLIST SDListRemove(PSDLIST pDel) {
+    pDel->pNext->pPrev = pDel->pPrev;
+    pDel->pPrev->pNext = pDel->pNext;
+        /* point back to itself just to be safe, incase remove is called again */
+    pDel->pNext = pDel;
+    pDel->pPrev = pDel;
+    return pDel;
+}
+
+/*
+ * SDListRemoveItemFromHead - get a list item from the head
+*/
+static INLINE PSDLIST SDListRemoveItemFromHead(PSDLIST pList) {
+    PSDLIST pItem = NULL;
+    if (pList->pNext != pList) {
+        pItem = pList->pNext;
+            /* remove the first item from head */
+        SDListRemove(pItem);
+    }
+    return pItem;
+}
+#endif /* __SDLIST_H___ */
Index: linux-2.6/drivers/net/wireless/hostap/hostap_ioctl.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/hostap/hostap_ioctl.c
+++ linux-2.6/drivers/net/wireless/hostap/hostap_ioctl.c
@@ -1089,6 +1089,9 @@ static int prism2_ioctl_giwrange(struct 
 	range->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |
 		IW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;
 
+	if (local->sta_fw_ver >= PRISM2_FW_VER(1,3,1))
+		range->scan_capa = IW_SCAN_CAPA_ESSID;
+
 	return 0;
 }
 
Index: linux-2.6/drivers/net/wireless/ipw2200.c
===================================================================
--- linux-2.6.orig/drivers/net/wireless/ipw2200.c
+++ linux-2.6/drivers/net/wireless/ipw2200.c
@@ -8912,6 +8912,8 @@ static int ipw_wx_get_range(struct net_d
 	range->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |
 		IW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;
 
+	range->scan_capa = IW_SCAN_CAPA_ESSID | IW_SCAN_CAPA_TYPE;
+
 	IPW_DEBUG_WX("GET Range\n");
 	return 0;
 }
Index: linux-2.6/include/linux/wireless.h
===================================================================
--- linux-2.6.orig/include/linux/wireless.h
+++ linux-2.6/include/linux/wireless.h
@@ -541,6 +541,16 @@
 /* Maximum size of returned data */
 #define IW_SCAN_MAX_DATA	4096	/* In bytes */
 
+/* Scan capability flags - in (struct iw_range *)->scan_capa */
+#define IW_SCAN_CAPA_NONE		0x00
+#define IW_SCAN_CAPA_ESSID		0x01
+#define IW_SCAN_CAPA_BSSID		0x02
+#define IW_SCAN_CAPA_CHANNEL	0x04
+#define IW_SCAN_CAPA_MODE		0x08
+#define IW_SCAN_CAPA_RATE		0x10
+#define IW_SCAN_CAPA_TYPE		0x20
+#define IW_SCAN_CAPA_TIME		0x40
+
 /* Max number of char in custom event - use multiple of them if needed */
 #define IW_CUSTOM_MAX		256	/* In bytes */
 
@@ -963,6 +973,9 @@ struct	iw_range
 	__u16		old_num_channels;
 	__u8		old_num_frequency;
 
+	/* Scan capabilities */
+	__u8		scan_capa; 	/* IW_SCAN_CAPA_* bit field */
+
 	/* Wireless event capability bitmasks */
 	__u32		event_capa[6];
 
Index: linux-2.6/net/mac80211/ieee80211_ioctl.c
===================================================================
--- linux-2.6.orig/net/mac80211/ieee80211_ioctl.c
+++ linux-2.6/net/mac80211/ieee80211_ioctl.c
@@ -218,6 +218,8 @@ static int ieee80211_ioctl_giwrange(stru
 	IW_EVENT_CAPA_SET(range->event_capa, SIOCGIWAP);
 	IW_EVENT_CAPA_SET(range->event_capa, SIOCGIWSCAN);
 
+	range->scan_capa |= IW_SCAN_CAPA_ESSID;
+
 	return 0;
 }
 
Index: linux-2.6/drivers/mmc/host/omap_hsmmc.c
===================================================================
--- /dev/null
+++ linux-2.6/drivers/mmc/host/omap_hsmmc.c
@@ -0,0 +1,1278 @@
+/*
+ * drivers/mmc/host/omap_hsmmc.c
+ *
+ * Driver for OMAP2430/3430 MMC controller.
+ *
+ * Copyright (C) 2007 Texas Instruments.
+ *
+ * Authors:
+ *	Syed Mohammed Khasim	<x0khasim@ti.com>
+ *	Madhusudhan		<madhu.cr@ti.com>
+ *	Mohit Jalori		<mjalori@ti.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/workqueue.h>
+#include <linux/timer.h>
+#include <linux/clk.h>
+#include <linux/mmc/host.h>
+#include <linux/io.h>
+#include <asm/semaphore.h>
+#include <asm/dma.h>
+#include <asm/hardware.h>
+#include <asm/arch/board.h>
+#include <asm/arch/mmc.h>
+#include <asm/arch/cpu.h>
+
+/* OMAP HSMMC Host Controller Registers */
+#define OMAP_HSMMC_SYSCONFIG	0x0010
+#define OMAP_HSMMC_CON		0x002C
+#define OMAP_HSMMC_BLK		0x0104
+#define OMAP_HSMMC_ARG		0x0108
+#define OMAP_HSMMC_CMD		0x010C
+#define OMAP_HSMMC_RSP10	0x0110
+#define OMAP_HSMMC_RSP32	0x0114
+#define OMAP_HSMMC_RSP54	0x0118
+#define OMAP_HSMMC_RSP76	0x011C
+#define OMAP_HSMMC_DATA		0x0120
+#define OMAP_HSMMC_PSTATE	0x0124
+#define OMAP_HSMMC_HCTL		0x0128
+#define OMAP_HSMMC_SYSCTL	0x012C
+#define OMAP_HSMMC_STAT		0x0130
+#define OMAP_HSMMC_IE		0x0134
+#define OMAP_HSMMC_ISE		0x0138
+#define OMAP_HSMMC_CAPA		0x0140
+
+#define VS18			(1<<26)
+#define VS30			(1<<25)
+#define SDVS18			(0x5<<9)
+#define SDVS30			(0x6<<9)
+#define SDVSCLR			0xFFFFF1FF
+#define SDVSDET			0x00000400
+#define AUTOIDLE		0x1
+#define SDBP			(1<<8)
+#define DTO			0xe
+#define ICE			0x1
+#define ICS			0x2
+#define CEN			(1<<2)
+#define CLKD_MASK		0x0000FFC0
+#define CLKD_SHIFT		6
+#define DTO_MASK		0x000F0000
+#define DTO_SHIFT		16
+#define INT_EN_MASK		0x307F0033
+#define INIT_STREAM		(1<<1)
+#define DP_SELECT		(1<<21)
+#define DDIR			(1<<4)
+#define DMA_EN			0x1
+#define MSBS			1<<5
+#define BCE			1<<1
+#define FOUR_BIT		1 << 1
+#define CC			0x1
+#define TC			0x02
+#define BWR			0x10		/* buffer write ready */
+#define BRR			0x20		/* buffer read ready */
+#define CTPL			(1 << 11)	/* control power for dat[1] */
+#define OD			0x1
+#define ERR			(1 << 15)
+#define CMD_TIMEOUT		(1 << 16)
+#define DATA_TIMEOUT		(1 << 20)
+#define CMD_CRC			(1 << 17)
+#define DATA_CRC		(1 << 21)
+#define CARD_ERR		(1 << 28)
+#define CARD_INT		(1 << 8)
+#define STAT_CLEAR		0xFFFFFFFF
+#define INIT_STREAM_CMD		0x00000000
+#define DUAL_VOLT_OCR_BIT	7
+#define SRC			(1 << 25)
+#define SRD			(1 << 26)
+#define DATI			(1 << 1)
+
+#define OMAP_MMC1_DEVID		1
+#define OMAP_MMC2_DEVID		2
+#define OMAP_MMC_DATADIR_NONE	0
+#define OMAP_MMC_DATADIR_READ	1
+#define OMAP_MMC_DATADIR_WRITE	2
+#define MMC_TIMEOUT_MS		20
+#define OMAP_MMC_MASTER_CLOCK	96000000
+#define DRIVER_NAME		"mmci-omap"
+/*
+ * slot_id is device id - 1, device id is a static value
+ * of 1 to represent device 1 etc..
+ */
+#define mmc_slot(host)		(host->pdata->slots[host->slot_id])
+
+/*
+ * MMC Host controller read/write API's
+ */
+#define OMAP_HSMMC_READ(base, reg)	\
+	__raw_readl((base) + OMAP_HSMMC_##reg)
+
+#define OMAP_HSMMC_WRITE(base, reg, val) \
+	__raw_writel((val), (base) + OMAP_HSMMC_##reg)
+
+/*
+ * The OMAP2430 host controller can only do DMA transfers when the transfer
+ * length is a multiple of 4 bytes and the transfer address is 4-byte aligned.
+ * Furthermore, dma buffers should be cache-line aligned in order to avoid
+ * cache coherency errors.  In the case of transfers from the device, it is
+ * mandatory for the dma buffers to be cache-line aligned, since it is not
+ * safe to invalidate cache lines that only partially intersect the buffer, and
+ * even if we do invalidate them they could become dirty again during the
+ * transfer due to writes to the part of a cache line that is outside of the
+ * buffer.  Thus, we always use PIO transfers for reads that are not cache-line
+ * aligned.  We can relax the alignment restriction for transfers to the device,
+ * as it is generally safe to clean cache lines that partially intersect the
+ * the buffer.
+ */
+#define transfer_via_pio(data) (((((data)->flags & MMC_DATA_READ) != 0)			\
+		&& ((((data)->sg->offset & (L1_CACHE_BYTES - 1)) != 0)			\
+		|| (((data)->blksz & (L1_CACHE_BYTES - 1)) != 0)))			\
+	|| (((data)->blksz & 3) != 0)							\
+	|| (((data)->sg->offset & 3) != 0))
+
+struct mmc_omap_host {
+	struct	device		*dev;
+	struct	mmc_host	*mmc;
+	struct	mmc_request	*mrq;
+	struct	mmc_command	*cmd;
+	struct	mmc_data	*data;
+	struct	clk		*fclk;
+	struct	clk		*iclk;
+	struct	clk		*dbclk;
+	struct	semaphore	sem;
+	struct	work_struct	mmc_carddetect_work;
+	void	__iomem		*base;
+	resource_size_t		mapbase;
+	unsigned long		int_en_mask;
+	unsigned int		id;
+	unsigned int		dma_len;
+	unsigned int		dma_dir;
+	unsigned char		bus_mode;
+	unsigned char		datadir;
+	unsigned char		*buffer;
+	u32			bytesleft;
+	int			suspended;
+	int			irq;
+	int			carddetect;
+	int			dma_ch;
+	int			initstr;
+	int			slot_id;
+	int			dbclk_enabled;
+	spinlock_t		lock;
+	struct	omap_mmc_platform_data	*pdata;
+};
+
+/*
+ * Stop clock to the card
+ */
+static void omap_mmc_stop_clock(struct mmc_omap_host *host)
+{
+	OMAP_HSMMC_WRITE(host->base, SYSCTL,
+		OMAP_HSMMC_READ(host->base, SYSCTL) & ~CEN);
+	if ((OMAP_HSMMC_READ(host->base, SYSCTL) & CEN) != 0x0)
+		dev_dbg(mmc_dev(host->mmc), "MMC Clock is not stoped\n");
+}
+
+/*
+ * Send init stream sequence to card
+ * before sending IDLE command
+ */
+static void send_init_stream(struct mmc_omap_host *host)
+{
+	int reg = 0;
+	unsigned long timeout;
+
+	disable_irq(host->irq);
+	OMAP_HSMMC_WRITE(host->base, CON,
+		OMAP_HSMMC_READ(host->base, CON) | INIT_STREAM);
+	OMAP_HSMMC_WRITE(host->base, CMD, INIT_STREAM_CMD);
+
+	timeout = jiffies + msecs_to_jiffies(MMC_TIMEOUT_MS);
+	while ((reg != CC) && time_before(jiffies, timeout))
+		reg = OMAP_HSMMC_READ(host->base, STAT) & CC;
+
+	OMAP_HSMMC_WRITE(host->base, CON,
+		OMAP_HSMMC_READ(host->base, CON) & ~INIT_STREAM);
+	enable_irq(host->irq);
+}
+
+/*
+ * Configure the response type and send the cmd.
+ */
+static void
+mmc_omap_start_command(struct mmc_omap_host *host, struct mmc_command *cmd,
+	struct mmc_data *data)
+{
+	int cmdreg = 0, resptype = 0, cmdtype = 0;
+	unsigned long flags;
+
+	dev_dbg(mmc_dev(host->mmc), "%s: CMD%d, argument 0x%08x\n",
+		mmc_hostname(host->mmc), cmd->opcode, cmd->arg);
+	host->cmd = cmd;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	if (OMAP_HSMMC_READ(host->base, PSTATE) & DATI) {
+		dev_dbg(mmc_dev(host->mmc), "mmc_omap_start_command: "
+			" resetting data state machine\n");
+		OMAP_HSMMC_WRITE(host->base, SYSCTL,
+			OMAP_HSMMC_READ(host->base, SYSCTL) | SRD);
+		while (OMAP_HSMMC_READ(host->base, SYSCTL) & SRD);
+	}
+
+	/*
+	 * If we have a data phase, then we can suppress the command complete
+	 * interrupt.
+	 */
+	if (data)
+		host->int_en_mask &= ~CC;
+	else
+		host->int_en_mask |=  CC;
+
+	/*
+	 * Clear status bits and enable interrupts
+	 */
+	OMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);
+	OMAP_HSMMC_WRITE(host->base, ISE,  host->int_en_mask);
+	OMAP_HSMMC_WRITE(host->base, IE, host->int_en_mask);
+
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		if (cmd->flags & MMC_RSP_136)
+			resptype = 1;
+		else
+			resptype = 2;
+	}
+
+	/*
+	 * Unlike OMAP1 controller, the cmdtype does not seem to be based on
+	 * ac, bc, adtc, bcr. Only CMD12 needs a val of 0x3, rest 0x0.
+	 */
+	if (cmd->opcode == 12)
+		cmdtype = 0x3;
+
+	cmdreg = (cmd->opcode << 24) | (resptype << 16) | (cmdtype << 22);
+
+	if (data) {
+		cmdreg |= DP_SELECT | MSBS | BCE;
+		if (data->flags & MMC_DATA_READ)
+			cmdreg |= DDIR;
+		else
+			cmdreg &= ~(DDIR);
+		if (!transfer_via_pio(data))
+			cmdreg |= DMA_EN;
+	}
+
+	OMAP_HSMMC_WRITE(host->base, ARG, cmd->arg);
+	OMAP_HSMMC_WRITE(host->base, CMD, cmdreg);
+
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static void
+mmc_omap_pio_write(struct mmc_omap_host *host, struct mmc_data *data)
+{
+	unsigned char *buf;
+	unsigned int i, j, fifo, length;
+
+	if ((data == NULL)  || (data->sg == NULL) || (host->buffer == NULL)) {
+		dev_err(mmc_dev(host->mmc),
+			"Unexpected PIO write interrupt.\n");
+		return;
+	}
+
+	buf = host->buffer;
+	length = min_t(unsigned int, data->blksz, data->sg->length);
+	length = min_t(unsigned int, length, host->bytesleft);
+
+	/* write one block */
+	for (i = 0; i < length; i += 4) {
+		fifo = 0;
+		for (j = 0; j < min_t(unsigned int, (length - i), 4); j++)
+			fifo |= (*(buf + i + j) << (8*j));
+		OMAP_HSMMC_WRITE(host->base, DATA, fifo);
+	}
+
+	host->buffer += length;
+	host->bytesleft -= length;
+}
+
+static void
+mmc_omap_pio_read(struct mmc_omap_host *host, struct mmc_data *data)
+{
+	unsigned char *buf;
+	unsigned int i, j, fifo, length;
+
+	if ((data == NULL)  || (data->sg == NULL) || (host->buffer == NULL)) {
+		dev_err(mmc_dev(host->mmc),
+			"Unexpected PIO read interrupt.\n");
+		return;
+	}
+
+	buf = host->buffer;
+	length = min_t(unsigned int, data->blksz, data->sg->length);
+	length = min_t(unsigned int, length, host->bytesleft);
+
+	/* read one block */
+	for (i = 0; i < length; i += 4) {
+		fifo = OMAP_HSMMC_READ(host->base, DATA);
+		for (j = 0; j < min_t(unsigned int, (length - i), 4); j++)
+			*(buf + i + j) = ((fifo >> (8*j)) & 0xff);
+	}
+
+	host->buffer += length;
+	host->bytesleft -= length;
+}
+
+/*
+ * Notify the transfer complete to MMC core
+ */
+static void
+mmc_omap_xfer_done(struct mmc_omap_host *host, struct mmc_data *data)
+{
+	host->data = NULL;
+
+	if (host->dma_ch != -1)
+		dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->dma_len,
+			host->dma_dir);
+
+	host->datadir = OMAP_MMC_DATADIR_NONE;
+
+	if (!data->error)
+		data->bytes_xfered += data->blocks * (data->blksz);
+	else
+		data->bytes_xfered = 0;
+
+	if (!data->stop) {
+		host->mrq = NULL;
+		mmc_request_done(host->mmc, data->mrq);
+		return;
+	}
+	mmc_omap_start_command(host, data->stop, NULL);
+}
+
+/*
+ * Notify the core about command completion
+ */
+static void
+mmc_omap_cmd_done(struct mmc_omap_host *host, struct mmc_command *cmd)
+{
+	host->cmd = NULL;
+
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		if (cmd->flags & MMC_RSP_136) {
+			/* response type 2 */
+			cmd->resp[3] = OMAP_HSMMC_READ(host->base, RSP10);
+			cmd->resp[2] = OMAP_HSMMC_READ(host->base, RSP32);
+			cmd->resp[1] = OMAP_HSMMC_READ(host->base, RSP54);
+			cmd->resp[0] = OMAP_HSMMC_READ(host->base, RSP76);
+		} else {
+			/* response types 1, 1b, 3, 4, 5, 6 */
+			cmd->resp[0] = OMAP_HSMMC_READ(host->base, RSP10);
+		}
+	}
+	if (host->data == NULL || cmd->error) {
+		host->mrq = NULL;
+		mmc_request_done(host->mmc, cmd->mrq);
+	}
+}
+
+/*
+ * DMA clean up for command errors
+ */
+static void mmc_dma_cleanup(struct mmc_omap_host *host)
+{
+	host->data->error = -ETIMEDOUT;
+
+	if (host->dma_ch != -1) {
+		dma_unmap_sg(mmc_dev(host->mmc), host->data->sg, host->dma_len,
+			host->dma_dir);
+		omap_free_dma(host->dma_ch);
+		host->dma_ch = -1;
+		up(&host->sem);
+	}
+	host->data = NULL;
+	host->datadir = OMAP_MMC_DATADIR_NONE;
+}
+
+/*
+ * MMC controller IRQ handler
+ */
+static irqreturn_t mmc_omap_irq(int irq, void *dev_id)
+{
+	struct mmc_omap_host *host = dev_id;
+	struct mmc_data *data;
+	int end_cmd = 0, end_trans = 0, status;
+
+	data = host->data;
+	status = OMAP_HSMMC_READ(host->base, STAT);
+	dev_dbg(mmc_dev(host->mmc), "IRQ Status is %x\n", status);
+
+	if (status & CARD_INT)
+		mmc_signal_sdio_irq(host->mmc);
+
+	if (host->cmd == NULL && host->data == NULL) {
+		OMAP_HSMMC_WRITE(host->base, STAT, status);
+		return IRQ_HANDLED;
+	}
+
+	if (status & ERR) {
+		if ((status & CMD_TIMEOUT) ||
+			(status & CMD_CRC)) {
+			if (host->cmd) {
+				if (status & CMD_TIMEOUT) {
+					OMAP_HSMMC_WRITE(host->base, SYSCTL,
+						OMAP_HSMMC_READ(host->base,
+								SYSCTL) | SRC);
+					while (OMAP_HSMMC_READ(host->base,
+								SYSCTL) & SRC) ;
+					host->cmd->error = -ETIMEDOUT;
+				} else {
+					host->cmd->error = -EILSEQ;
+				}
+				end_cmd = 1;
+			}
+			if (host->data)
+				mmc_dma_cleanup(host);
+		}
+		if ((status & DATA_TIMEOUT) ||
+			(status & DATA_CRC)) {
+			if (host->data) {
+				if (status & DATA_TIMEOUT)
+					mmc_dma_cleanup(host);
+				else
+					host->data->error = -EILSEQ;
+				OMAP_HSMMC_WRITE(host->base, SYSCTL,
+					OMAP_HSMMC_READ(host->base,
+							SYSCTL) | SRD);
+				while (OMAP_HSMMC_READ(host->base,
+							SYSCTL) & SRD) ;
+				end_trans = 1;
+			}
+		}
+		if (status & CARD_ERR) {
+			dev_dbg(mmc_dev(host->mmc),
+				"Ignoring card err CMD%d\n", host->cmd->opcode);
+			if (host->cmd)
+				end_cmd = 1;
+			if (host->data)
+				end_trans = 1;
+		}
+	}
+
+	OMAP_HSMMC_WRITE(host->base, STAT, status);
+
+	if (status & BRR)
+		mmc_omap_pio_read(host, data);
+	if (status & BWR)
+		mmc_omap_pio_write(host, data);
+	if (end_cmd || (status & (CC | TC)))
+		mmc_omap_cmd_done(host, host->cmd);
+	if (end_trans || (status & TC))
+		mmc_omap_xfer_done(host, data);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Switch MMC operating voltage
+ */
+static int omap_mmc_switch_opcond(struct mmc_omap_host *host, int vdd)
+{
+	u32 reg_val = 0;
+	int ret;
+
+	/* Disable the clocks */
+	clk_disable(host->fclk);
+	clk_disable(host->iclk);
+	clk_disable(host->dbclk);
+
+	/* Turn the power off */
+	ret = mmc_slot(host).set_power(host->dev, host->slot_id, 0, 0);
+	if (ret != 0)
+		goto err;
+
+	/* Turn the power ON with given VDD 1.8 or 3.0v */
+	ret = mmc_slot(host).set_power(host->dev, host->slot_id, 1, vdd);
+	if (ret != 0)
+		goto err;
+
+	clk_enable(host->fclk);
+	clk_enable(host->iclk);
+	clk_enable(host->dbclk);
+
+	OMAP_HSMMC_WRITE(host->base, HCTL,
+		OMAP_HSMMC_READ(host->base, HCTL) & SDVSCLR);
+	reg_val = OMAP_HSMMC_READ(host->base, HCTL);
+	/*
+	 * If a MMC dual voltage card is detected, the set_ios fn calls
+	 * this fn with VDD bit set for 1.8V. Upon card removal from the
+	 * slot, mmc_omap_detect fn sets the VDD back to 3V.
+	 *
+	 * Only MMC1 supports 3.0V.  MMC2 will not function if SDVS30 is
+	 * set in HCTL.
+	 */
+	if (host->id == OMAP_MMC1_DEVID && (((1 << vdd) == MMC_VDD_32_33) ||
+				((1 << vdd) == MMC_VDD_33_34)))
+		reg_val |= SDVS30;
+	if ((1 << vdd) == MMC_VDD_165_195)
+		reg_val |= SDVS18;
+
+	OMAP_HSMMC_WRITE(host->base, HCTL, reg_val);
+
+	OMAP_HSMMC_WRITE(host->base, HCTL,
+		OMAP_HSMMC_READ(host->base, HCTL) | SDBP);
+
+	return 0;
+err:
+	dev_dbg(mmc_dev(host->mmc), "Unable to switch operating voltage\n");
+	return ret;
+}
+
+/*
+ * Work Item to notify the core about card insertion/removal
+ */
+static void mmc_omap_detect(struct work_struct *work)
+{
+	u16 vdd = 0;
+	struct mmc_omap_host *host = container_of(work, struct mmc_omap_host,
+						mmc_carddetect_work);
+
+	if (host->carddetect) {
+		if (!(OMAP_HSMMC_READ(host->base, HCTL) & SDVSDET)) {
+			/*
+			 * Set the VDD back to 3V when the card is removed
+			 * before the set_ios fn turns off the power.
+			 */
+			vdd = fls(host->mmc->ocr_avail) - 1;
+			if (omap_mmc_switch_opcond(host, vdd) != 0)
+				host->mmc->ios.vdd = vdd;
+		}
+		mmc_detect_change(host->mmc, (HZ * 200) / 1000);
+	} else {
+		OMAP_HSMMC_WRITE(host->base, SYSCTL,
+			OMAP_HSMMC_READ(host->base, SYSCTL) | SRD);
+		while (OMAP_HSMMC_READ(host->base, SYSCTL) & SRD) ;
+		mmc_detect_change(host->mmc, (HZ * 50) / 1000);
+	}
+}
+
+/*
+ * ISR for handling card insertion and removal
+ */
+static irqreturn_t omap_mmc_cd_handler(int irq, void *dev_id)
+{
+	struct mmc_omap_host *host = (struct mmc_omap_host *)dev_id;
+
+	host->carddetect = mmc_slot(host).card_detect(irq);
+	schedule_work(&host->mmc_carddetect_work);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * DMA call back function
+ */
+static void mmc_omap_dma_cb(int lch, u16 ch_status, void *data)
+{
+	struct mmc_omap_host *host = data;
+
+	if (ch_status & OMAP2_DMA_MISALIGNED_ERR_IRQ)
+		dev_dbg(mmc_dev(host->mmc), "MISALIGNED_ADRS_ERR\n");
+
+	if (host->dma_ch < 0)
+		return;
+
+	omap_free_dma(host->dma_ch);
+	host->dma_ch = -1;
+	/*
+	 * DMA Callback: run in interrupt context.
+	 * mutex_unlock will through a kernel warning if used.
+	 */
+	up(&host->sem);
+}
+
+/*
+ * Configure dma src and destination parameters
+ */
+static int mmc_omap_config_dma_param(int sync_dir, struct mmc_omap_host *host,
+				struct mmc_data *data)
+{
+	if (sync_dir == 0) {
+		omap_set_dma_dest_params(host->dma_ch, 0,
+			OMAP_DMA_AMODE_CONSTANT,
+			(host->mapbase + OMAP_HSMMC_DATA), 0, 0);
+		omap_set_dma_src_params(host->dma_ch, 0,
+			OMAP_DMA_AMODE_POST_INC,
+			sg_dma_address(&data->sg[0]), 0, 0);
+	} else {
+		omap_set_dma_src_params(host->dma_ch, 0,
+			OMAP_DMA_AMODE_CONSTANT,
+			(host->mapbase + OMAP_HSMMC_DATA), 0, 0);
+		omap_set_dma_dest_params(host->dma_ch, 0,
+			OMAP_DMA_AMODE_POST_INC,
+			sg_dma_address(&data->sg[0]), 0, 0);
+	}
+	return 0;
+}
+/*
+ * Routine to configure and start DMA for the MMC card
+ */
+static int
+mmc_omap_start_dma_transfer(struct mmc_omap_host *host, struct mmc_request *req)
+{
+	int sync_dev, sync_dir = 0;
+	int dma_ch = 0, ret = 0, err = 1;
+	struct mmc_data *data = req->data;
+
+	/*
+	 * If for some reason the DMA transfer is still active,
+	 * we wait for timeout period and free the dma
+	 */
+	if (host->dma_ch != -1) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(100);
+		if (down_trylock(&host->sem)) {
+			omap_free_dma(host->dma_ch);
+			host->dma_ch = -1;
+			up(&host->sem);
+			return err;
+		}
+	} else {
+		if (down_trylock(&host->sem))
+			return err;
+	}
+
+	if (!(data->flags & MMC_DATA_WRITE)) {
+		host->dma_dir = DMA_FROM_DEVICE;
+		if (host->id == OMAP_MMC1_DEVID)
+			sync_dev = OMAP24XX_DMA_MMC1_RX;
+		else
+			sync_dev = OMAP24XX_DMA_MMC2_RX;
+	} else {
+		host->dma_dir = DMA_TO_DEVICE;
+		if (host->id == OMAP_MMC1_DEVID)
+			sync_dev = OMAP24XX_DMA_MMC1_TX;
+		else
+			sync_dev = OMAP24XX_DMA_MMC2_TX;
+	}
+
+	ret = omap_request_dma(sync_dev, "MMC/SD", mmc_omap_dma_cb,
+			host, &dma_ch);
+	if (ret != 0) {
+		dev_dbg(mmc_dev(host->mmc),
+			"%s: omap_request_dma() failed with %d\n",
+			mmc_hostname(host->mmc), ret);
+		return ret;
+	}
+
+	host->dma_len = dma_map_sg(mmc_dev(host->mmc), data->sg,
+			data->sg_len, host->dma_dir);
+	host->dma_ch = dma_ch;
+
+	if (!(data->flags & MMC_DATA_WRITE))
+		mmc_omap_config_dma_param(1, host, data);
+	else
+		mmc_omap_config_dma_param(0, host, data);
+
+	if (((data->blksz % 4) == 0) &&
+		((sg_dma_address(&data->sg[0]) % 4) == 0))
+		omap_set_dma_transfer_params(dma_ch, OMAP_DMA_DATA_TYPE_S32,
+			(data->blksz / 4), data->blocks, OMAP_DMA_SYNC_FRAME,
+			sync_dev, sync_dir);
+	else
+		/* REVISIT: The MMC buffer increments only when MSB is written.
+		 * Return error for blksz which is non multiple of four
+		 * or for buffer address which is non multiple of four.
+		 */
+		return -EINVAL;
+
+	omap_start_dma(dma_ch);
+	return 0;
+}
+
+static void set_data_timeout(struct mmc_omap_host *host,
+			     struct mmc_request *req)
+{
+	unsigned int timeout, cycle_ns;
+	uint32_t reg, clkd, dto = 0;
+
+	reg = OMAP_HSMMC_READ(host->base, SYSCTL);
+	clkd = (reg & CLKD_MASK) >> CLKD_SHIFT;
+	if (clkd == 0)
+		clkd = 1;
+
+	cycle_ns = 1000000000 / (clk_get_rate(host->fclk) / clkd);
+	timeout = req->data->timeout_ns / cycle_ns;
+	timeout += req->data->timeout_clks;
+	if (timeout) {
+		while ((timeout & 0x80000000) == 0) {
+			dto += 1;
+			timeout <<= 1;
+		}
+		dto = 31 - dto;
+		timeout <<= 1;
+		if (timeout && dto)
+			dto += 1;
+		if (dto >= 13)
+			dto -= 13;
+		else
+			dto = 0;
+		if (dto > 14)
+			dto = 14;
+	}
+
+	reg &= ~DTO_MASK;
+	reg |= dto << DTO_SHIFT;
+	OMAP_HSMMC_WRITE(host->base, SYSCTL, reg);
+}
+
+/*
+ * Configure block length for MMC/SD cards and initiate the transfer.
+ */
+static int
+mmc_omap_prepare_data(struct mmc_omap_host *host, struct mmc_request *req)
+{
+	int ret;
+	host->data = req->data;
+
+	if (req->data == NULL) {
+		host->datadir = OMAP_MMC_DATADIR_NONE;
+		OMAP_HSMMC_WRITE(host->base, BLK, 0);
+		return 0;
+	}
+
+	OMAP_HSMMC_WRITE(host->base, BLK, (req->data->blksz)
+					| (req->data->blocks << 16));
+	set_data_timeout(host, req);
+
+	host->datadir = (req->data->flags & MMC_DATA_WRITE) ?
+			OMAP_MMC_DATADIR_WRITE : OMAP_MMC_DATADIR_READ;
+
+	if (transfer_via_pio(req->data)) {
+		host->buffer = (unsigned char *)
+			(page_address(sg_page(req->data->sg)) +
+			req->data->sg->offset);
+		host->bytesleft = req->data->blocks * req->data->blksz;
+		return 0;
+	} else {
+		host->buffer = NULL;
+		host->bytesleft = 0;
+	}
+
+	ret = mmc_omap_start_dma_transfer(host, req);
+	if (ret != 0) {
+		dev_dbg(mmc_dev(host->mmc), "MMC start dma failure\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+/*
+ * Request function. for read/write operation
+ */
+static void omap_mmc_request(struct mmc_host *mmc, struct mmc_request *req)
+{
+	struct mmc_omap_host *host = mmc_priv(mmc);
+
+	WARN_ON(host->mrq != NULL);
+	host->mrq = req;
+	mmc_omap_prepare_data(host, req);
+	mmc_omap_start_command(host, req->cmd, req->data);
+}
+
+
+/* Routine to configure clock values. Exposed API to core */
+static void omap_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct mmc_omap_host *host = mmc_priv(mmc);
+	u16 dsor = 0;
+	unsigned long regval;
+	unsigned long timeout;
+
+	switch (ios->power_mode) {
+	case MMC_POWER_OFF:
+		mmc_slot(host).set_power(host->dev, host->slot_id, 0, 0);
+		break;
+	case MMC_POWER_UP:
+		mmc_slot(host).set_power(host->dev, host->slot_id, 1, ios->vdd);
+		break;
+	}
+
+	switch (mmc->ios.bus_width) {
+	case MMC_BUS_WIDTH_4:
+		OMAP_HSMMC_WRITE(host->base, HCTL,
+			OMAP_HSMMC_READ(host->base, HCTL) | FOUR_BIT);
+		break;
+	case MMC_BUS_WIDTH_1:
+		OMAP_HSMMC_WRITE(host->base, HCTL,
+			OMAP_HSMMC_READ(host->base, HCTL) & ~FOUR_BIT);
+		break;
+	}
+
+	if (host->id == OMAP_MMC1_DEVID) {
+		/* Only MMC1 can operate at 3V/1.8V */
+		if ((OMAP_HSMMC_READ(host->base, HCTL) & SDVSDET) &&
+			(ios->vdd == DUAL_VOLT_OCR_BIT)) {
+				/*
+				 * The mmc_select_voltage fn of the core does
+				 * not seem to set the power_mode to
+				 * MMC_POWER_UP upon recalculating the voltage.
+				 * vdd 1.8v.
+				 */
+				if (omap_mmc_switch_opcond(host, ios->vdd) != 0)
+					dev_dbg(mmc_dev(host->mmc),
+						"Switch operation failed\n");
+		}
+	}
+
+	if (ios->clock) {
+		dsor = OMAP_MMC_MASTER_CLOCK / ios->clock;
+		if (dsor < 1)
+			dsor = 1;
+
+		if (OMAP_MMC_MASTER_CLOCK / dsor > ios->clock)
+			dsor++;
+
+		if (dsor > 250)
+			dsor = 250;
+	}
+	omap_mmc_stop_clock(host);
+	regval = OMAP_HSMMC_READ(host->base, SYSCTL);
+	regval = regval & ~(CLKD_MASK);
+	regval = regval | (dsor << 6) | (DTO << 16);
+	OMAP_HSMMC_WRITE(host->base, SYSCTL, regval);
+	OMAP_HSMMC_WRITE(host->base, SYSCTL,
+		OMAP_HSMMC_READ(host->base, SYSCTL) | ICE);
+
+	/* Wait till the ICS bit is set */
+	timeout = jiffies + msecs_to_jiffies(MMC_TIMEOUT_MS);
+	while ((OMAP_HSMMC_READ(host->base, SYSCTL) & ICS) != 0x2
+		&& time_before(jiffies, timeout))
+		msleep(1);
+
+	OMAP_HSMMC_WRITE(host->base, SYSCTL,
+		OMAP_HSMMC_READ(host->base, SYSCTL) | CEN);
+
+	if (ios->power_mode == MMC_POWER_ON)
+		send_init_stream(host);
+
+	if (ios->bus_mode == MMC_BUSMODE_OPENDRAIN)
+		OMAP_HSMMC_WRITE(host->base, CON,
+				OMAP_HSMMC_READ(host->base, CON) | OD);
+}
+
+static void omap_mmc_enable_sdio_irq(struct mmc_host *mmc, int enable)
+{
+	struct mmc_omap_host *host = mmc_priv(mmc);
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	if (enable) {
+		OMAP_HSMMC_WRITE(host->base, CON,
+			OMAP_HSMMC_READ(host->base, CON) | CTPL);
+		host->int_en_mask |= CARD_INT;
+	} else {
+		OMAP_HSMMC_WRITE(host->base, CON,
+			OMAP_HSMMC_READ(host->base, CON) & ~CTPL);
+		host->int_en_mask &= ~CARD_INT;
+	}
+	OMAP_HSMMC_WRITE(host->base, ISE, host->int_en_mask);
+	OMAP_HSMMC_WRITE(host->base, IE, host->int_en_mask);
+
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (enable && OMAP_HSMMC_READ(host->base, STAT) & CARD_INT)
+		mmc_signal_sdio_irq(mmc);
+}
+
+/* NOTE: Read only switch not supported yet */
+static struct mmc_host_ops mmc_omap_ops = {
+	.request = omap_mmc_request,
+	.set_ios = omap_mmc_set_ios,
+	.enable_sdio_irq = omap_mmc_enable_sdio_irq,
+};
+
+static int __init omap_mmc_probe(struct platform_device *pdev)
+{
+	struct omap_mmc_platform_data *pdata = pdev->dev.platform_data;
+	struct mmc_host *mmc;
+	struct mmc_omap_host *host = NULL;
+	struct resource *res;
+	int ret = 0, irq;
+	u32 hctl, capa;
+
+	if (pdata == NULL) {
+		dev_err(&pdev->dev, "Platform Data is missing\n");
+		return -ENXIO;
+	}
+
+	if (pdata->nr_slots == 0) {
+		dev_err(&pdev->dev, "No Slots\n");
+		return -ENXIO;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_get_irq(pdev, 0);
+	if (res == NULL || irq < 0)
+		return -ENXIO;
+
+	res = request_mem_region(res->start, res->end - res->start + 1,
+							pdev->name);
+	if (res == NULL)
+		return -EBUSY;
+
+	mmc = mmc_alloc_host(sizeof(struct mmc_omap_host), &pdev->dev);
+	if (!mmc) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	host		= mmc_priv(mmc);
+	host->mmc	= mmc;
+	host->pdata	= pdata;
+	host->dma_ch	= -1;
+	host->irq	= irq;
+	host->id	= pdev->id;
+	host->slot_id	= 0;
+	host->mapbase	= res->start;
+	host->base	= ioremap(host->mapbase, SZ_4K);
+	mmc->ops	= &mmc_omap_ops;
+	mmc->f_min	= 400000;
+	mmc->f_max	= 52000000;
+
+	sema_init(&host->sem, 1);
+	spin_lock_init(&host->lock);
+
+	if (cpu_is_omap2430())
+		host->iclk = clk_get(&pdev->dev, "mmchs_ick");
+	else
+		host->iclk = clk_get(&pdev->dev, "mmc_ick");
+	if (IS_ERR(host->iclk)) {
+		ret = PTR_ERR(host->iclk);
+		host->iclk = NULL;
+		goto err1;
+	}
+	if (cpu_is_omap2430())
+		host->fclk = clk_get(&pdev->dev, "mmchs_fck");
+	else
+		host->fclk = clk_get(&pdev->dev, "mmc_fck");
+	if (IS_ERR(host->fclk)) {
+		ret = PTR_ERR(host->fclk);
+		host->fclk = NULL;
+		clk_put(host->iclk);
+		goto err1;
+	}
+
+	if (clk_enable(host->fclk) != 0) {
+		clk_put(host->iclk);
+		clk_put(host->fclk);
+		goto err1;
+	}
+
+	if (clk_enable(host->iclk) != 0) {
+		clk_disable(host->fclk);
+		clk_put(host->iclk);
+		clk_put(host->fclk);
+		goto err1;
+	}
+
+	host->dbclk = clk_get(&pdev->dev, "mmchsdb_fck");
+	/*
+	 * MMC can still work without debounce clock.
+	 */
+	if (IS_ERR(host->dbclk))
+		dev_dbg(mmc_dev(host->mmc), "Failed to get debounce clock\n");
+	else
+		if (clk_enable(host->dbclk) != 0)
+			dev_dbg(mmc_dev(host->mmc), "Enabling debounce"
+							" clk failed\n");
+		else
+			host->dbclk_enabled = 1;
+
+#ifdef CONFIG_MMC_BLOCK_BOUNCE
+	mmc->max_phys_segs = 1;
+	mmc->max_hw_segs = 1;
+#endif
+	mmc->max_blk_size = 512;       /* Block Length at max can be 1024 */
+	mmc->max_blk_count = 0xFFFF;    /* No. of Blocks is 16 bits */
+	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
+	mmc->max_seg_size = mmc->max_req_size;
+
+	mmc->ocr_avail = mmc_slot(host).ocr_mask;
+	mmc->caps |= MMC_CAP_MULTIWRITE | MMC_CAP_MMC_HIGHSPEED |
+				MMC_CAP_SD_HIGHSPEED | MMC_CAP_SDIO_IRQ;
+
+	if (pdata->conf.wire4)
+		mmc->caps |= MMC_CAP_4_BIT_DATA;
+
+	/* Only MMC1 supports 3.0V */
+	if (host->id == OMAP_MMC1_DEVID) {
+		hctl = SDVS30;
+		capa = VS30 | VS18;
+	} else {
+		hctl = SDVS18;
+		capa = VS18;
+	}
+
+	OMAP_HSMMC_WRITE(host->base, HCTL,
+			OMAP_HSMMC_READ(host->base, HCTL) | hctl);
+
+	OMAP_HSMMC_WRITE(host->base, CAPA,
+			OMAP_HSMMC_READ(host->base, CAPA) | capa);
+
+	/* Set the controller to AUTO IDLE mode */
+	OMAP_HSMMC_WRITE(host->base, SYSCONFIG,
+			OMAP_HSMMC_READ(host->base, SYSCONFIG) | AUTOIDLE);
+
+	/* Set SD bus power bit */
+	OMAP_HSMMC_WRITE(host->base, HCTL,
+			OMAP_HSMMC_READ(host->base, HCTL) | SDBP);
+
+	host->int_en_mask = INT_EN_MASK;
+
+	/* Request IRQ for MMC operations */
+	ret = request_irq(host->irq, mmc_omap_irq, IRQF_DISABLED, pdev->name,
+			 host);
+	if (ret) {
+		dev_dbg(mmc_dev(host->mmc), "Unable to grab HSMMC IRQ\n");
+		goto irq_err;
+	}
+
+	/* Request IRQ for card detect */
+	if ((mmc_slot(host).card_detect_irq) && (mmc_slot(host).card_detect)) {
+		ret = request_irq(mmc_slot(host).card_detect_irq,
+				  omap_mmc_cd_handler, IRQF_SHARED | IRQF_DISABLED | IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING, "MMC CD",
+				  host);
+		if (ret) {
+			dev_dbg(mmc_dev(host->mmc),
+				"Unable to grab MMC CD IRQ");
+			free_irq(host->irq, host);
+			goto irq_err;
+		}
+	}
+
+	INIT_WORK(&host->mmc_carddetect_work, mmc_omap_detect);
+	if (pdata->init != NULL) {
+		if (pdata->init(&pdev->dev) != 0) {
+			free_irq(mmc_slot(host).card_detect_irq, host);
+			free_irq(host->irq, host);
+			goto irq_err;
+		}
+	}
+
+	/* Setup rescan for driver */
+	omap_mmc_set_rescan(omap_mmc_cd_handler,
+						mmc_slot(host).card_detect_irq,
+						(void*)host);
+
+	OMAP_HSMMC_WRITE(host->base, ISE, host->int_en_mask);
+	OMAP_HSMMC_WRITE(host->base, IE, host->int_en_mask);
+
+	platform_set_drvdata(pdev, host);
+	mmc_add_host(mmc);
+
+	return 0;
+
+irq_err:
+	dev_dbg(mmc_dev(host->mmc), "Unable to configure MMC IRQs\n");
+	clk_disable(host->fclk);
+	clk_disable(host->iclk);
+	clk_put(host->fclk);
+	clk_put(host->iclk);
+	if (host->dbclk_enabled) {
+		clk_disable(host->dbclk);
+		clk_put(host->dbclk);
+	}
+
+err1:
+	iounmap(host->base);
+err:
+	dev_dbg(mmc_dev(host->mmc), "Probe Failed\n");
+	release_mem_region(res->start, res->end - res->start + 1);
+	if (host)
+		mmc_free_host(mmc);
+	return ret;
+}
+
+static int omap_mmc_remove(struct platform_device *pdev)
+{
+	struct mmc_omap_host *host = platform_get_drvdata(pdev);
+	struct resource *res;
+	u16 vdd = 0;
+
+	if (!(OMAP_HSMMC_READ(host->base, HCTL) & SDVSDET)) {
+	/*
+	 * Set the vdd back to 3V,
+	 * applicable for dual volt support.
+	 */
+		vdd = fls(host->mmc->ocr_avail) - 1;
+		if (omap_mmc_switch_opcond(host, vdd) != 0)
+			host->mmc->ios.vdd = vdd;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res)
+		release_mem_region(res->start, res->end - res->start + 1);
+
+	platform_set_drvdata(pdev, NULL);
+	if (host) {
+		mmc_remove_host(host->mmc);
+		if (host->pdata->cleanup)
+			host->pdata->cleanup(&pdev->dev);
+		free_irq(host->irq, host);
+		if (mmc_slot(host).card_detect_irq)
+			free_irq(mmc_slot(host).card_detect_irq, host);
+		flush_scheduled_work();
+
+		omap_mmc_set_rescan(NULL, 0, NULL);
+
+		clk_disable(host->fclk);
+		clk_disable(host->iclk);
+		clk_put(host->fclk);
+		clk_put(host->iclk);
+		if (host->dbclk_enabled) {
+			clk_disable(host->dbclk);
+			clk_put(host->dbclk);
+		}
+
+		mmc_free_host(host->mmc);
+		iounmap(host->base);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int omap_mmc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	int ret = 0;
+	struct mmc_omap_host *host = platform_get_drvdata(pdev);
+
+	if (host && host->suspended)
+		return 0;
+
+	if (host) {
+		ret = mmc_suspend_host(host->mmc, state);
+		if (ret == 0) {
+			host->suspended = 1;
+
+			OMAP_HSMMC_WRITE(host->base, ISE, 0);
+			OMAP_HSMMC_WRITE(host->base, IE, 0);
+
+			ret = host->pdata->suspend(&pdev->dev, host->slot_id);
+			if (ret)
+				dev_dbg(mmc_dev(host->mmc),
+					"Unable to handle MMC board"
+					" level suspend\n");
+
+			if (!(OMAP_HSMMC_READ(host->base, HCTL) & SDVSDET)) {
+				OMAP_HSMMC_WRITE(host->base, HCTL,
+					OMAP_HSMMC_READ(host->base, HCTL)
+					& SDVSCLR);
+				OMAP_HSMMC_WRITE(host->base, HCTL,
+					OMAP_HSMMC_READ(host->base, HCTL)
+					| SDVS30);
+				OMAP_HSMMC_WRITE(host->base, HCTL,
+					OMAP_HSMMC_READ(host->base, HCTL)
+					| SDBP);
+			}
+
+			clk_disable(host->fclk);
+			clk_disable(host->iclk);
+			clk_disable(host->dbclk);
+		}
+
+	}
+	return ret;
+}
+
+/* Routine to resume the MMC device */
+static int omap_mmc_resume(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct mmc_omap_host *host = platform_get_drvdata(pdev);
+
+	if (host && !host->suspended)
+		return 0;
+
+	if (host) {
+
+		ret = clk_enable(host->fclk);
+		if (ret)
+			goto clk_en_err;
+
+		ret = clk_enable(host->iclk);
+		if (ret) {
+			clk_disable(host->fclk);
+			clk_put(host->fclk);
+			goto clk_en_err;
+		}
+
+		if (clk_enable(host->dbclk) != 0)
+			dev_dbg(mmc_dev(host->mmc),
+					"Enabling debounce clk failed\n");
+
+		ret = host->pdata->resume(&pdev->dev, host->slot_id);
+		if (ret)
+			dev_dbg(mmc_dev(host->mmc),
+					"Unmask interrupt failed\n");
+
+		/* Notify the core to resume the host */
+		ret = mmc_resume_host(host->mmc);
+		if (ret == 0)
+			host->suspended = 0;
+	}
+
+	return ret;
+
+clk_en_err:
+	dev_dbg(mmc_dev(host->mmc),
+		"Failed to enable MMC clocks during resume\n");
+	return ret;
+}
+
+#else
+#define omap_mmc_suspend	NULL
+#define omap_mmc_resume		NULL
+#endif
+
+static struct platform_driver omap_mmc_driver = {
+	.probe		= omap_mmc_probe,
+	.remove		= omap_mmc_remove,
+	.suspend	= omap_mmc_suspend,
+	.resume		= omap_mmc_resume,
+	.driver		= {
+		.name = DRIVER_NAME,
+	},
+};
+
+static int __init omap_mmc_init(void)
+{
+	/* Register the MMC driver */
+	return platform_driver_register(&omap_mmc_driver);
+}
+
+static void __exit omap_mmc_cleanup(void)
+{
+	/* Unregister MMC driver */
+	platform_driver_unregister(&omap_mmc_driver);
+}
+
+module_init(omap_mmc_init);
+module_exit(omap_mmc_cleanup);
+
+MODULE_DESCRIPTION("OMAP High Speed Multimedia Card driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS(DRIVER_NAME);
+MODULE_AUTHOR("Texas Instruments Inc");
Index: linux-2.6/drivers/mmc/core/Kconfig
===================================================================
--- linux-2.6.orig/drivers/mmc/core/Kconfig
+++ linux-2.6/drivers/mmc/core/Kconfig
@@ -14,3 +14,18 @@ config MMC_UNSAFE_RESUME
 	  This option is usually just for embedded systems which use
 	  a MMC/SD card for rootfs. Most people should say N here.
 
+config SDIO_IRQ_ASSUME_FUNC_ONE
+       bool "Assume all SDIO interrupts are asserted by function one"
+       depends on SDIO_ATHSDIO
+       default y
+       help
+         The SDIO IRQ helper thread in the Linux SDIO stack reads the
+         interupt status register from card to determine which function
+         on the card is asserting the interrupt request.  Since most
+         cards only have one function, we can save a bit of overhead if
+         we assume that all interrupts are generated by function one
+         instead of reading the register.  When using the Atherios SDIO
+         stack in parallel with the Linux SDIO stack, the Atheros stack
+         will read the SDIO interrupt register, so it is redundant to
+         read it in the Linux stack as well.
+
Index: linux-2.6/drivers/mmc/core/sdio_cis.c
===================================================================
--- linux-2.6.orig/drivers/mmc/core/sdio_cis.c
+++ linux-2.6/drivers/mmc/core/sdio_cis.c
@@ -246,9 +246,8 @@ static int sdio_read_cis(struct mmc_card
 			this->size = tpl_link;
 			*prev = this;
 			prev = &this->next;
-			printk(KERN_DEBUG
-			       "%s: queuing CIS tuple 0x%02x length %u\n",
-			       mmc_hostname(card->host), tpl_code, tpl_link);
+			pr_debug("%s: queuing CIS tuple 0x%02x length %u\n",
+				 mmc_hostname(card->host), tpl_code, tpl_link);
 		} else {
 			const struct cis_tpl *tpl = cis_tpl_list + i;
 			if (tpl_link < tpl->min_size) {
Index: linux-2.6/drivers/mmc/core/sdio_irq.c
===================================================================
--- linux-2.6.orig/drivers/mmc/core/sdio_irq.c
+++ linux-2.6/drivers/mmc/core/sdio_irq.c
@@ -27,7 +27,10 @@
 
 static int process_sdio_pending_irqs(struct mmc_card *card)
 {
-	int i, ret, count;
+	int ret;
+	int count = 0;
+#ifndef CONFIG_SDIO_IRQ_ASSUME_FUNC_ONE
+	int i;
 	unsigned char pending;
 
 	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_INTx, 0, &pending);
@@ -37,7 +40,6 @@ static int process_sdio_pending_irqs(str
 		return ret;
 	}
 
-	count = 0;
 	for (i = 1; i <= 7; i++) {
 		if (pending & (1 << i)) {
 			struct sdio_func *func = card->sdio_func[i - 1];
@@ -56,6 +58,22 @@ static int process_sdio_pending_irqs(str
 			}
 		}
 	}
+#else
+	struct sdio_func *func = card->sdio_func[0];
+
+	if (!func) {
+		printk(KERN_WARNING "%s: pending IRQ for "
+			"non-existant function\n", mmc_card_id(card));
+		ret = -EINVAL;
+	} else if (func->irq_handler) {
+		func->irq_handler(func);
+		count++;
+	} else {
+		printk(KERN_WARNING "%s: pending IRQ with no handler\n",
+			sdio_func_id(func));
+		ret = -EINVAL;
+	}
+#endif
 
 	if (count)
 		return count;
Index: linux-2.6/include/asm-arm/arch-omap/dma.h
===================================================================
--- linux-2.6.orig/include/asm-arm/arch-omap/dma.h
+++ linux-2.6/include/asm-arm/arch-omap/dma.h
@@ -44,6 +44,7 @@
 #define OMAP_DMA_PCH1_SR		(OMAP_DMA_BASE + 0x482)
 #define OMAP_DMA_PCHD_SR		(OMAP_DMA_BASE + 0x4c0)
 
+#define MAX_DMA_CHANNELS		4
 /* Hardware registers for omap2 */
 #define OMAP24XX_DMA_BASE		(L4_24XX_BASE + 0x56000)
 #define OMAP_DMA4_REVISION		(OMAP24XX_DMA_BASE + 0x00)
