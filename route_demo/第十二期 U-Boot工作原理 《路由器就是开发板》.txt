 刚开始接触U-Boot时都是别人编译好的bin文件，拿来直接刷入就可以用，第一次从官网下载了一个U-Boot时瞬间被它的代码量吓住了，虽然代码量不足linux内核的5%，但它也完全有自己的分层结构，如果适度改造完全就是一个单进程的小系统，启动系统内核可能只是它功能的一小部分。从源代码级别修改U-Boot和拿别人编译好的U-Boot直接刷从技术层面上讲还是有很大差距的，在这里呼吁在论坛上发布各种U-Boot改造版本的大神发布bin文件时附带上源文件，这样可以方便学习者更好的学习，在开源的大环境里，大家互相分享才能共同提高。
        在分析U-Boot的工作原理之前，我们先要准备查看代码的环境，没有好的工具是非常影响学习效率的，U-Boot的复杂程度原超过普通教科书中的示例程序，所以有必要引入IDE开发工具把U-Boot当作一个project管理起来，U-Boot的编译环境需要linux所以还是直接在linux环境下阅读代码吧，如果对代码进行修改可以随时编译，直接就能看到结果。我这里使用了两种开发环境，一种是eclipse_cdt，另一种是vim+ctags，前者是重度的解决方案，后者是轻量级的解决方案。下面是两种IDE开发环境的截图：





        具体IDE环境怎么安装可以到网上找到很多教程，而且这是个非常个性化的过程，你可以根据自己的喜好打造属于自己的IDE风格，eclipse和vim都是基于插件的拓展方式，非常适合个性化改装。
        任何事情的入手都要找到切入点，要不然大海捞针的感觉实在是太茫然了，我结合自己走过的弯路总结出了一套雨伞模型的分析方法，在这里给大家分享一下，先看下面这张图：


        U-Boot的分析路线用图画出来像一把雨伞，所以我把它叫做雨伞分析法。上图中红色的原点是起始位置，U-Boot首先执行cpu/Ralink_soc/start.S里的代码，是基于mips架构的汇编语法，有兴趣可以系统学习一下，从起点沿着箭头方向一直分析直到进入main_loop循环，U-Boot的初始化过程就已结束，这时候U-Boot开始以命令的方式提供服务，实现的任何功能都是通过命令的方法进行调用，这些命令大体上呈水平分布，也就是雨伞的弧线结构，当把初始化的主线研究明白后就可以逐个的研究U-Boot命令的实现原理，当然也可以以自己的兴趣选几个命令进行研究，这些命令的实现会调用一些库函数，这些函数的实现都在雨伞内部蓝色方框命名的文件夹下。
        U-Boot相关的信息在互联网可以找到很多，这里就不一一赘述，我的中心思想是提供一个可以参考的分析方法，初学者可以参考我这种方法去发散学习，关于U-Boot的很多小细节都是可以在互联网上面搜索到的，只要你有明确的前进方向，慢慢的积累就能把U-Boot分析透彻，我属于比较愚钝的，大约一年才开窍。
        U-Boot分析的一个难点就是U-Boot为了兼容各种硬件平台在代码中加入了很多条件编译，比如#ifdef S3C24X0 ........ #endif ，如果不是对应的平台或者配置时没有选择此项，条件编译内的代码就会在预编译的环节被省略掉，这对于阅读代码确实带来很大障碍，有时候一分神读了半天发现根本就是其它平台的或者不相关的代码，这里我推荐使用eclipse_cdt进行分析，eclipse会分析包含文件内的定义信息对条件编译进行处理，条件编译不成立的代码会被显示为灰色，非常方便阅读。
        这一期的重点就是上面的雨伞模型，通过它可以拓展出非常多非常多的小细节，但作为以兴趣驱动的U-Boot学习方式，我希望大家自己去细细的发掘和体会U-Boot里面各种精彩的小细节。
---------------------------------------------------------------------------

SDK下载地址：   https://github.com/aggresss/RFDemo