C++ 的学习笔记
C++ primer	Plus 第六版 史蒂芬.普拉达

C++在C语言的基础上新增很多特性，包括：
类和对象，继承，多态，虚函数，RTTI（运行阶段类型识别）、函数重载，引用变量，泛型编程，异常机制，名称空间
第一章：
	预备知识：面向过程和面向对象之间的区别，创建C++程序的技巧，C++编译器的使用方法。
第二章：
	开始学习C++，
第三章：
	处理数据。C++提供内置类型来存储两种数据：整形和浮点数。如何处理不同类型之间的显式和隐式转换的
第四章：
	复合类型，最高级的类型是类，在9~13章讨论，本章讨论数组、指针、结构。创建和存储文本字符串及如何使用C-风格字符数组和C++ string类来处理文本输入和输出，内存分配，new和delete运算符
第五章：
	循环和关系表达式。for、while、do while
第六章：
	分支语句和逻辑运算符，if、if else、switch。确定字符关系（如测试字符是数字还是非打印字符）的函数库cctype，文件的输入/输出
第七章：
	函数 C函数和C++函数的共同特性，递归（调用自身），以及如何用它实现分而治之的策略。函数指针，它使得程序员可以通过函数的参数来使用另一个函数
第八章：
	函数探幽：C++新增的特性。1内联函数。2引用变量，提供了另一种将信息传递给函数的方式。3默认参数使得函数能够自动为函数调用中省略的函数参数提供值。4函数重载使得程序员能够创建多个参数列表不同的同名函数。类设计中经常使用这些特性。5另外函数模板使得程序员能够指定相
	关函数族的设计。
第九章：
	内存模型和名称空间：1如何创建多文件程序，2分配内存的各种方式、管理内存的各种方式以及作用域、链接、名称空间，这些内容决定了变量在程序的哪些部分可见。
第十章：
	对象和类：类是用户定义的类型，对象是类的实例。1面向对象编程和类设计，2对象申明描述的是存储在对象中的信息以及可对对象执行的操作（类方法），3对象的某些部分对于外界来说是可见的（共有部分），而某些部分却是隐藏的（私有部分）。4特殊的类方法（构造函数和析构函数）在对象创建和释放的时候发挥作用，5如何使用类来实现ADT，如栈
第十一章：
	使用类：深入了解类，1运算符重载，使得程序员能够定义与类对象一起使用的运算符，如+。2还将学习友元函数，这些函数可以访问外部世界不可访问的类数据，3一些构造函数和重载运算符成员函数是如何被用来管理类类型转换的。
第十二章：
	类和动态内存分配：让类成员指向动态分配的内存很有用。1如果程序员在类构造函数中使用new来分配动态内存，就有责任提供适当的析构函数，定义显式拷贝构造函数和显式赋值运算符。2在程序员没有提供显式定义时，将如何隐式的生成成员函数以及这些成员函数的行为。3通过使用对象指针了解队列模拟问题，扩充类方面的知识
第十三章：
	类继承：1面向对象编程中，继承是功能最强大的特性之一，通过继承，派生类可以继承基类的特性，可重用基类代码。2公有继承，这种继承模拟了is-a关系，即派生对象是基对象的特例。有些继承关系是多态的，这意味着相同的方法名称可能导致依赖于对象类型的行为。要实现这种行为，需要使用一种新的成员函数————虚函数。3有时，使用抽象基类是实现继承关系的最佳方式。
第十四章：
	C++的代码重用：公有继承只是代码重用的方式之一，本章介绍其他几种方式，1如果一个类包含了另一个类的对象，则称为包含，包含可以用来模拟has-a关系，其中一个类包含另一个类的对象。也可以用私有继承和保护继承来模拟这种关系。2各种方法之间的区别。3类模板，它让程序员能够使用泛型定义类，然后使用模板根据具体类型创建特定的类，例如栈模板使程序员可以创建整数栈或字符串栈。3多重公有继承，使用这种方式，一个类可以从多个类派生而来。
第十五章：
	友元、异常和其他：本章扩展了对友元的讨论，讨论了友元类和友元成员函数。然后从异常开始介绍了C++的几项新特性。RTTI，这种机制用来确定对象类型，最后介绍一种更安全的方法来替代不受限制的强制类型转换
第十六章：
	string类和标准模板库：C++语言新增的一些类库。对于C风格字符串来说，string类是一种方便且功能强大的替代方式。quto_ptr类帮助管理动态分配的内存。STL提供了几种类容器（包括数组、队列、链表、集合和映射）的模板表示，它还提供了高效的泛型算法库，这些算法可用于STL容器，也可以用于常规数组。模板类valarray为数值数组提供了支持。
第十七章：
	输入、输出和文件：本章复习C++I/O，并讨论如何格式化输出。如何使用类方法来确定输入或输出流的状态，了解输入类型是否匹配或是否检测到了文件尾。C++使用继承来派生用于管理文件输入和输出的类。如何打开文件，以进行输入和输出，如何在文件中追加数据，如何使用二进制文件，如何获得对文件的随机访问权。最后还将学习如何使用标准的I/O方法来读取和写入字符串
第十八章：
	探讨C++新标准：本章首先复习之前介绍过的几项C++11新功能，包括新类型、统一的初始化语法、自动类型推断、新的智能指针以及作用域内枚举。然后讨论新增的右值引用类型以及如何使用它来实现移动语义。接下来介绍了新增的类功能、lambda表达式和可变参数模板。
附录A：计数系统：本章讨论八进制、十六进制和二进制数
附录B：C++保留字
附录C：ASCII字符集
附录D：运算符优先级
附录E：其他运算符
附录F:模板类string
附录G：标准模板库方法和函数：总结了STL容器方法和通的STL算法函数
附录H：精选读物和网上资源
附录I：转换ISO标准C++
附录J：复习题答案


第一章：预备知识
		三种编程方式：C语言代表的过程性语言、C++在C语言基础上添加的类代表的面向对象语言、C++模板支持的泛型编程。 计算机语言要处理的两个概念：计算数据和算法。与强调算法的过程性编程不同，面向对象强调的是数据。OOP程序设计首先设计类，他们准确的表示了程序要处理的东西，它的重点不是放在任务上，而是放在表示概念上。
第二章： 开始学习C++
		名称空间：using是编译指令，用来区分不同版本或空间的相同名称，std::cout其种std为名称空间。using namespace std，这样声明后就可以省略前缀std::，当然这是偷懒的做法，其实更好的方法直接用using std::cout。
		"<<" 插入运算符，这个指出了信息流动的路径 std::cout << "hello world!"，这个像C语言中的左移运算符，这是一个运算符重载的例子，C语言也有重载的运算符，如“&”取指针和按位与， "*"乘号和指针解除引用
		控制符endl：endl是C++符号，表示一个重要的概念：重起一行，也可以用‘\n’换行符，这可以减少输入量
		类：用户定义的一种数据类型。要定义类，要描述它能表示什么信息和可以对数据执行哪些操作。
		C++提供两种发送消息的方式：类方法（函数调用）和重新定义运算符
		使用cout进行拼接 cout << "now you have" << carrots << "carrots!" << endl; ，也可以cout << "now you have"
																								<< carrots
																								<< "carrots!"
																								<< endl;
		using 编译指令
第三章：处理数据
		基本数据类型和复合数据类型
		C++11的另一种初始化方式（多用于数组和结构体也可单值赋值）大括号赋值：1、可以省略等号，2、大括号内没有值表示初始化为0   
		int emus{7}; int emus = {7}; int emus ={};
		cout还有的特殊特性，控制符dec、hex、oct分别表示十进制、十六进制、八进制，实际上控制符hex只是一条消息，告诉cout采取何种行为。
		cout << '$';//打印$的ascii码值
		cout.put('$');//打印字符$
		编码uncode和ISO10646
		修饰符（限定符）const，修改变量声明和初始化
		double、float、long double
		运算符重载：使用相同的符号进行多种操作叫做运算符重载
		类型转换：1、初始化和赋值进行的转换 2、以{}方式（列表初始化）初始化的转换 3、表达式中的转换 4、传递参数时的转换 5、强制类型转换（C方式的、类似函数的、转换运算符static_cast<TypeName>(value)）
	    3.4.5 auto声明 ： 自动根据初始值类型推断出变量的类型
第四章： 复合类型
		string类 
			原始(raw)字符串,在字符串中用"(原始字符串)"来作为定界符，前缀R标识为原始字符串。还有"+*(原始字符串)+*"
		结构体
		联合体
		指针和自由存储空间 
			在C++中穿件指针时，计算机将分配用来存储地址的内存，但是不分配存储指针所指向的数据的内存，为数据分配空间是一个独立的步骤。
			指针的真正用武之地是在运行阶段分配未命名的内存以存储数据。
			使用new来分配内存空间，
			4.8.5 自动存储、静态存储、动态存储
			内存泄漏：分配了动态内存，退出时时没有释放，导致该内存无法再使用。
		4.10 数组的替代品：模板类vector和array
		如果使用的是固定长度的数组，那么数组更好，只是不方便，但更高效。vector更灵活。
		比较string类字符串
5.4 基于范围的for循环（C++11） double princes[5] = {4,5,6,8,7,9}; for (double x : prince) cout << x << std::endl;
5.5 循环和文本输入   ： 函数重载，文件尾条件
6.3 字符函数库 cctype
6.4 ?: 运算符 可替换if else 
6.7 读取数字的循环
6.8简单文件的输入输出
8.2 引用变量(相当变量别名的意思) int rats; int & rodents = rats;//rodents is a reference，一定要在声明时将其初始化，更接近于const 指针【按值传递和按引用传递】
8.2.2 将引用用作函数参数 
8.2.4 将引用用作结构
8.2.5 将引用用于类对象
8.2.6 对象、继承、引用
8.2.7 何时使用引用参数
8.4 函数重载
8.4.2 何时使用函数重载
8.5 函数模板 通用的函数描述，泛型来定义函数
【公有继承实现继承功能，虚函数实现多态。在C语言中，用函数指针的赋值来实现多态，用结构体的类型定义来实现继承。】
explicit  ：首先, C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).
11.1 运算符重载
11.2.2 重载限制
11.3  友元 C++控制对类对象的私有部分的访问  
friend 关键字 ，总之，类的友元函数不是成员函数，其访问权限和成员函数相同，类方法和友元函数只是表达类接口的两种不同机制而已。
11.3.2 常用的友元：重载<<运算符
【在C++中，若一个变量声明为const类型，则试图修改该变量的值的操作都被视编译错误】
11.4 重载运算符：作为成员函数还是非成员函数，对于成员函数来说，有一个操作数通过this指针隐形地传递，其他要显式的传递。
11.6 类的自动转换和强制类型转换
11.6.1转换函数 operator int() const ;
12 类和动态内存分配
C++的几种构造函数
C++中的构造函数可以分为4类： 
（1）默认构造函数。以Student类为例，默认构造函数的原型为 
Student(）；//没有参数 
（2）初始化构造函数 
Student(int num，int age）；//有参数 
（3）复制（拷贝）构造函数 
Student(Student&）；//形参是本类对象的引用 
（4）转换构造函数 
Student(int r) ；//形参时其他类型变量，且只有一个形参
https://www.cnblogs.com/simplepaul/p/6861210.html  C++中 delete 和 delete[] 的区别
12.6 复习各种技术
12.6.1 重载运算符 <<
12.6.2 转换函数
12.6.3 其构造函数使用new的类
const的类成员初始化方法为
Queue: Queue(int qs) : qsize(qs) //initialize qsize to qs  【这个叫成员初始化列表】
{
    front = rear = NULL;
	item = 0;
}
成员初始化列表使用的括号方式也可以用于常规的初始化，这使得初始化内置类型像初始化类对象一样。
C++的类内初始化和构造函数的初始化列表是等价的。
12.7 【例子：银行ATM的排队队列类】
12.8 总结：如果对象包含指向new分配的内存的指针，则将一个对象初始化为另一个对象，或将一个对象赋值各另一个对象时，也会出现问题。在默认情况下，C++逐个对成员进行初始化和赋值，这意味着被初始化或被赋值的对象的成员将于原始对象完全相同。当程序最终删除这两个对象时，类的析构函数将试图删除同一个内存数据块两次，这将出错。 【解决办法】定义一个特殊的复制构造函数来重新定义初始化，并重载赋值运算符。
对象的存储持续性为自动或外部时，在它不再存在时将自动调用其析构函数。如果使用new运算符为对象分配内存，并将其地址赋给一个指针，则当将delete用于该指针时将自动为对象调用析构函数。然而，如果使用定位new运算符（而不是常规运算符）为类对象分配内存，则必须负责显式地为该对象调用析构函数，方法是使用该对象的指针调用析构函数方法。
C++允许在类中包含结构、类、枚举定义，作用域为整个类。
13 类继承
面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。

当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。
公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。
保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。
私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。

一个派生类继承了所有的基类方法，但下列情况除外：

基类的构造函数、析构函数和复制构造函数。
基类的重载运算符。
基类的友元函数。
13.4 静态联编和动态联编
虚函数
虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。

我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。

纯虚函数
您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。

我们可以把基类中的虚函数 area() 改写如下：

class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      // pure virtual function
      virtual int area() = 0;
};
= 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。
如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 "= 0" 来指定的
设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。

因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。

可用于实例化对象的类被称为具体类。

C++ 标准库
C++ 标准库可以分为两部分：

标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。
面向对象类库： 这个库是类及其相关函数的集合。
C++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。

标准函数库
标准函数库分为以下几类：

输入/输出 I/O
字符串和字符处理
数学
时间、日期和本地化
动态分配
其他
宽字符函数
面向对象类库
标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入/输出 I/O、字符串处理、数值处理。面向对象类库包含以下内容：

标准的 C++ I/O 类
String 类
数值类
STL 容器类
STL 算法
STL 函数对象
STL 迭代器
STL 分配器
本地化库
异常处理类
杂项支持库

RTTI C++有三个支持RTTI的元素： dynamic_cast运算符，typeid运算符，type_info结构
15.5 类型转换运算符
4种类型转换运算符：
dynamic_cast，类层次结构中向上转换
const_cast，将同类型的const指针转换成一个普通指针
static_cast，向下转换
reinterpret_cast ，普通类型转换
16 string类和标准模板库
对象名不会被看做是对象的地址（不同于数组）
16.1.2 strin类输入
对于C-风格有3种方式：
char info[100];
cin >> info;//read a word
cin.getline(info,100);//read a line ,discard \n
cin.get(info,100);//read a line ,leave \n in queue
对于string对象有两种方式：
 string stuff;
 cin >> stuff; //read a word 
 getline(cin,stuff); //read a line ,discard \n
 
 两个版本的getline都有一个可选参数，用于指定使用哪个字符来确定输入的边界:
 cin.getline(info,100,':'); // read up to :,discard :
 getline(stuff,':')// read up to  : ,discard :
 16.2.1 使用智能指针 （解决忘记调用delete的问题），模板auto_ptr，unique_ptr,shared_ptr
 要包含智能指针必须包含头文件memory
 两个常规指针指向同一个string对象，这是不能接受的，因为每个指针过期的时候都将删除该对象，这样就将一个对象删除两次了。要避免这种问题：
 1、定义赋值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中一个是另一个的副本。
 2、建立所有权（ownship）概念，对于特定的对象，只能有一个智能指针可拥有它。-- auto_ptr和unique_ptr采取的策略
 3、创建智能更高的指针，跟踪引用特定对象的智能指针数。这就是引用计数reference counting， -- shared_ptr采用的策略
 所有权的问题，已经不是简单的指针引用了，当指针赋值给另一个的时候，他的所有权也交出去了。
 16.2.4 选择智能指针
 如果程序要使用多个指向同一个对象的指针，选shared_ptr，这样的情况包括：有一个指针数组，并使用一些辅助指针来标识特定元素如最大最小，STL容器包含指针。这些操作只能用于shared_ptr，但不能用于unique_ptr（编译器发出告警）和quto_ptr（行为不确定）。如果你的编译器没有提供shared_ptr，可以使用Boost库提供的shared_ptr。
 如果程序不需要多个指向同一个对象的指针，则可以使用unique_ptr，如果函数使用new分配内存，并返回指向该内存的指针，将其返回unique_ptr是不错的选择。这样，所有权将转让给接受返回值的unique_ptr，该智能指针将负责调用delete。
 16.3 标准模板库 STL
 提供了一组表示容器、迭代器、函数对象、算法的模板
 STL不是面向对象的编程，而是一种不同的编程模式--泛型编程（generic programming）
 对象编程关注的是数据方面，泛型编程关注的是算法。他们的共同点事抽象和创建可重用代码，但是他们的理念决然不同。泛型编程旨在编写独立于数据类型的代码，在C++中，完成通用程序的工具就是模板。模板使得能够按泛型定义函数和类，而STL通过通用算法更进了一步。
 16.4.1 为何使用迭代器 
 理解迭代器是理解STL的关键，模板使得算法独立于存储的数据类型，而迭代器使得算法独立于使用的容器类型。
 为区分++运算符的前缀和后缀版本，C++将operator++作为前缀版本，将operator++(int)作为后缀版本；其中的参数永远不会用到，所以不必指定名称。
 16.4.2 迭代器类型
 输入迭代器 、输出迭代器、正向迭代器、双向迭代器和随机访问迭代器
 16.4.5 容器种类：STL具有容器概念和容器类型。概念是具有名称（如容器、序列容器、关联容器等）的通用类别，容器类型是可用于创建具体容器对象的模板。
 之前11个容器类别是deque、list、queue、priority queue、stack、vector、map、multimap、set、multiset、bitset，C++11新增了forward_list，unordered_mao、unordered_multimap、unordered_set和unordered_multiset。
 16.5 函数对象
 16.6 算法
 17 输入、输出、文件