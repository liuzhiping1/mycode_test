1、Linux 支持的设备种类繁多，不可能所有都掌握，某一子系统也只能是熟悉，因为同类设备还有许多自由的特性。
    写驱动的步骤可以概括为：
        1) 阅读设备规范，对设备的运行机理有所了解
           为了减少干扰，不考虑要支持的 OS，独立与 OS 考虑基本的功能如何实现
        2) 参考同类设备在 Linux 内核中的驱动架构
        3) 提供基本的 Linux 设备驱动接口和实现设备的基本功能，比如网卡收发小数据量
        4) 在性能上逐步提示，比如网卡传输的数据量加大、中断及时处理、避免死锁等
        5) 对边界条件进行完善，网卡上就是对一些特殊大小的数据包传输完善等
        6) 对设备进行更高级控制的支持，比如网卡支持 ethtool 等工具
        7) 反复调试、改进和优化
        
        
2、每一个子系统都巨大无比，而且涉及各种硬件规范，很难去搞明白所有。只能是遇到问题的时候，
    能对某一部分深入下去。之前了解过 SCSI 的架构，最上层的抽象，中间层的桥梁，最底层的设备
    驱动控制
    如果仅仅是做 driver 的工作，可以把精力放在设备特性上，Linux 内核部分只需要了解驱动
    接口和同步、内存管理等基本功能
    
    
3、Linux 内核驱动可以都是遵循一个逐层抽象的架构：
      最上层的抽象层便于系统软件的访问，
      中间层的实现硬件协议细节，同时提供上下两层连接的接口，
      对于最下层的 driver 来说就是要定义底层驱动要实现的接口和实际的设备控制
    由于 Linux 内核各类驱动的框架支持，driver 可以更加关注设备本身的特性 