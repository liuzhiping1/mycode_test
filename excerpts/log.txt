日志：
1214：通过sdk自带的应用和驱动程序学习修改移植。将sdk全部解压建仓，先看脚本文件，在看具体的代码。

1、查看文件D:\5-video\hi3516_sdk\Hi3516A V100R001C01SPC040\01.software\board\document_cn\Hi3516A／Hi3516D SDK 安装以及升级使用说明.txt
2、查看文件D:\5-video\work_code\video_myworks\osdrv\readme_cn.txt
3、【问题】编译osdrv的时候没有连接libc.so导致make yaffs工具的时候失败
    【解答】缺乏libc.a，zypper install glibc-static 安装库即可
    【原因】在很多第三方程序为了确保在没有相应动态库时运行正常，喜欢在编译最后应用程序时加入-static.在老版本中编译正常，但在新版Fedora下编译常常报错
4、参考 （查看硬件手册和软件手册）
    *硬件：D:\5-video\hi3516_sdk\Hi3516A V100R001C01SPC040\00.hardware\chip\document_cn\
        芯片手册  《Hi3516A／Hi3516D 专业型HD IP Camera Soc用户指南.pdf》
        用户手册  《Hi3516A 专业型HD IP Camera SoC产品简介.pdf》
        
    *软件：D:\5-video\hi3516_sdk\Hi3516A V100R001C01SPC040\01.software\board\document_cn
		《Hi3516A／Hi3516D SDK 安装以及升级使用说明.txt》
        《HiMPP IPC V2.0 媒体处理软件开发参考.pdf》
        《Hi3516A／Hi3516D Linux开发环境用户指南.pdf》
        《Hi3516A／Hi3516D SDK 安装以及升级使用说明.txt》  。。。。
        D:\5-video\hi3516_sdk\Hi3516A V100R001C01SPC040\01.software\pc\DEC_LIB\documents_cn
        《H.264 PC解码库软件 API参考.pdf》
        《H.264 PC解码库软件开发指南.pdf》
        《客户端AMR编解码库API参考.pdf》
        《客户端音频编解码库API参考.pdf》 。。。。
        D:\5-video\hi3516_sdk\Hi3516A V100R001C01SPC040\01.software\pc\IVE_CLIB
        《HiIVE Brief Specification.pdf》
        D:\5-video\hi3516_sdk\Hi3516A V100R001C01SPC040\01.software\pc\PQ_TOOL\documents_cn
        《图像质量调试工具使用指南.pdf》
    *源码：D:\5-video\hi3516_sdk\Hi3516A V100R001C01SPC040\01.software\board\Hi3516A_SDK_V1.0.4.0\package
        参考学习驱动和应用的例子，开发自己的应用和驱动。
    
    4.1->硬件特性：接口时序、管脚复用控制寄存器、软件复用管脚、硬件管脚复用、管脚驱动能力、管脚分布、
            ->系统管理：复位、时钟、处理器子系统（arm-Cortex-a7处理器600MHZ）、中断系统（96个中断源-64个外部中断）、系统控制器（三种工作模式）、DMA控制器（DMAC流控）、CIPHER（加解密）、定时器（4个timer）、看门狗（32bits减法计数器）、实时时钟（时钟显示和定时报警）、电源管理与低功耗模式控制（低功耗模式）
       
            ->存储器接口：DDR控制器、SPI NOR FLASH 存储控制器、NAND FLASH控制器、SPI NAND FLASH控制器
       
            ->GSF(千兆以太网交换接口实现网络接口的数据的接收和发送，支持10/100/1000Mbit/s模式可配置，EEE能效以太网、WoL网络唤醒功能)
       
            ->视频编码（视频编解码器是一个支持H.264/H.265/JPEG 的多协议编解码器，包括AVC、VEDU和JPGE 三部分，其中AVC 实现H.264 协议的编码，VEDU 实现H.265 协议的编解码，JPEG 实现JPEG 协议的编码）
            
            ->视频及图形处理（TDE-Two Dimensional engine，VPSS-Video process sub-system，VGS-video graph system）
       
            ->运动检测单元（MDU）
       
            ->智能加速引擎（IVE）
       
            ->视频接口（VICAP-视频捕获单元，VDP-video Display processor，MIPI Rx-移动行业处理器接口）
       
            ->ISP（图像处理）
       
            ->音频接口（i2s PCM,DMA方式存取数据）
       
            ->外围设备（I2C SPI UART MMC/SD/SDIO 红外接口 GPIO USB2.0 LSADC_CTRL PWM）
     
    4.2->sdk软件特性：系统控制、视频输入、视频输出、视频处理子系统、视频编码、视频监测分析、区域管理、音频、视频图形子系统、/proc调试信息
	(海思媒体处理平台的主要内部处理流程 ，主要分为视频输入（VI）、视频处理（VPSS）、视频编码（VENC）、视频解码（VDEC）、视频输出(VO)、视频侦测分析(VDA)、音频输入(AI)、音频输出(AO)、音频编码（AENC）、音频解码（ADEC）、区域管理（REGION）等模块)
	
1215：linux驱动设备模型+mpp设备驱动    华为开发者云（类似isource）
	1、音频驱动ak7756 
	2、应用程序摄像头 isp   -- sony_imx178
	3、在用户态下编程可以通过main()的参数来传递命令行参数，而编写一个内核模块则通过module_param()来传递参数
	
1218：mpp驱动
	1、himedia驱动
	2、linux编程：系统编程
		处理器总处于以下状态中的一种：
		1、内核态，运行于进程上下文，内核代表进程运行于内核空间；
		2、内核态，运行于中断上下文，内核代表硬件运行于内核空间；
		3、用户态，运行于用户空间。
	3、所谓的进程上下文，就是一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈中的内容，当内核需要切换到另一个进程时，它需要保存当 前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行（https://www.cnblogs.com/reality-soul/p/6377137.html）
		运行在进程上下文的内核代码是可以被抢占的（Linux2.6支持抢占）。但是一个中断上下文，通常都会始终占有CPU（当然中断可以嵌套，但我们一般不这样做），不可以被打断。正因为如此，运行在中断上下文的代码就要受一些限制，不能做下面的事情：

		3.1、睡眠或者放弃CPU。

		这样做的后果是灾难性的，因为内核在进入中断之前会关闭进程调度，一旦睡眠或者放弃CPU，这时内核无法调度别的进程来执行，系统就会死掉

		3.2、尝试获得信号量
	
		如果获得不到信号量，代码就会睡眠，会产生和上面相同的情况

		3.3、执行耗时的任务
	
		中断处理应该尽可能快，因为内核要响应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。

		3.4、访问用户空间的虚拟地址

		因为中断上下文是和特定进程无关的，它是内核代表硬件运行在内核空间，所以在终端上下文无法访问用户空间的虚拟地址
	4、linux输入子系统（http://www.cnblogs.com/reality-soul/p/4705712.html）
1219：新的一天新的逻辑新的开始（笔记是知识积累的重要载体），今天就是学习i2c的驱动，集中精力对准一点猛攻
https://www.cnblogs.com/xiaojiang1025/p/6500540.html linux i2c 子系统分析

	1、i2c驱动的分析
		1.1、硬件描述：模块的作用是完成cpu对i2c总线上的从设备的读写，在写操作的时候，CPU通过总线配置i2c的配置寄存器然后发送控制信息和操作数到i2c模块的数据通信寄存器，i2c模块解析命令后将数据	通道寄存器的数据通过i2c总线发送给从设备，发送完毕后将最终的状态通过中断反馈给cpu。读从设备的数据和写操作类似。   【【 CPU<-->I2C模块<--(通过I2C总线) -->从设备 】】
		   hi3516a包含3个I2C模块，寄存器基地址分别为：0X200d_0000 、0x2024_0000 、0x2025_0000  有26个寄存器
		1.2、i2c的操作指南
			准备工作：sdk发布的linux内核、文件系统（yafss2、jffs2、SqushFs、NFS）
			操作过程：启动单板，加载文件系统；加载内核模块（insmod）；在控制台下运行I2C读写命令或者自行在内核态和用户态的读写i2c的程序，就可以对挂载在i2c总线上的从设备进行读写操作
			接口速率设置：在内核配置的时候在【驱动选项】中选择配置
			操作示例：1.2.1、I2C读写命令  ~ $ i2c_read <i2c_num> <device_addr> <reg_addr> <end_reg_addr> <reg_width> <data_width> <reg_step>
										  ~ $ i2c_write <i2c_num> <device_addr> <reg_addr> <value> <reg_width> <data_width>
					  1.2.2、内核态读写程序 ：在内核态通过i2c读写程序对i2c外围设备的读写操作 (利用linux的i2c驱动体系结构)
								1)调用和核心层的函数获取一个描述控制器的结构体 i2c_adap = i2c_get_adapt(2);
								2)把控制器和设备关联起来 hi_client = i2c_new_device(i2c_adapt,hi_info);
								3)调用内核i2c核心层提供的接口对从设备进行读写
					  1.2.3、用户态读写程序：（把i2c设备当做普通的字符设备）
								1)打开i2c总线对应的设备文件获取文件描述符 fd = open("/dev/i2c-2", O_RDWR); 
								2)通过ioctl设置外围设备的地址、寄存器的位宽和数据位宽 ioctl(fd, I2C_SLAVE_FORCE, device_addr); ioctl(fd, I2C_16BIT_REG, 0); 
								3)使用read/write进行数据的读写read(fd, recvbuf, reg_width); 
								
		1.3、编写具体的I2C驱动时，工程师需要处理的主要工作如下：
 
　			　1).提供I2C适配器的硬件驱动，探测，初始化I2C适配器(如申请I2C的I/O地址和中断号)，驱动CPU控制的I2C适配器从硬件上产生。
　			　2).提供I2C控制的algorithm, 用具体适配器的xxx_xfer()函数填充i2c_algorithm的master_xfer指针，并把i2c_algorithm指针赋给i2c_adapter的algo指针。
              3).实现I2C设备驱动中的i2c_driver接口，用具体yyy的yyy_probe()，yyy_remove()，yyy_suspend(),yyy_resume()函数指针和i2c_device_id设备ID表赋给i2c_driver的probe,remove,suspend,resume和id_table指针。
　　		  4).实现I2C设备所对应类型的具体驱动，i2c_driver只是实现设备与总线的挂接。　
　　      		上面的工作中前两个属于I2C总线驱动，后面两个属于I2C设备驱动。
		1.4、 linux的i2c子系统
			除了分离，i2c子系统也体现的软件分层的设计思想, 整个i2c子系统由3层构成：设备驱动层--i2c核心--控制器驱动
			xx_driver->{probe->{init->init_device + ops->{open,release,ioctl}}}+{xx_remove}
		1.5、设备树 http://www.cnblogs.com/xiaojiang1025/p/6131381.html
		1.6、平台设备 http://www.cnblogs.com/xiaojiang1025/p/6367910.html
			写驱动也有一段时间了，可以发现，其实驱动本质上只做了两件事：向上提供接口，向下控制硬件，当然，这里的向上并不是直接提供接口到应用层，而是提供接口给内核再由内核间接的将我们的接口提供给应用层。而写驱动也是有一些套路可寻的，拿到一个硬件，我们大体可以按照下面的流程写一个驱动：
				http://www.cnblogs.com/xiaojiang1025/p/6367910.html
			1）确定驱动架构：根据硬件连接方式结合分层/分离思想设计驱动的基本结构
			2）确定驱动对象：内核中的一个驱动/设备就是一个对象，1.定义，2.初始化，3.注册，4.注销
			3）向上提供接口：根据业务需要确定提供cdev/proc/sysfs哪种接口
			4）向下控制硬件：1.查看原理图确定引脚和控制逻辑，2.查看芯片手册确定寄存器配置方式，3.进行内存映射，4.实现控制逻辑
			
		driver与device的匹配
			设备信息有三种表达方式，而一个驱动是可以匹配多个设备的，平台总线中的驱动要具有三种匹配信息的能力，基于这种需求，platform_driver中使用不同的成员来进行相应的匹配。
				of_match_table ： 对于使用设备树编码的设备信息，我们使用其父类device_driver中的of_match_table就是用来匹配
				id_table： 对于使用C语言编码的设备信息，我们用platform_driver对象中的id_table就是用来匹配
				name ：如果platform_driver和C语言编码的platform_device是一一匹配的，我们还可以使用device_driver中的name来进行匹配
		1.7、http://www.cnblogs.com/xiaojiang1025/p/6369065.html linux platform 驱动模型之 platform+cdev
		1.8   http://www.cnblogs.com/deng-tao/p/6130080.html
			I2C子系统提供的两种驱动实现方法（源码中I2C相关的驱动均位于：drivers/i2c目录下）

			(1)第一种叫i2c-dev，对应drivers/i2c/i2c-dev.c，这种方法只是封装了主机（I2Cmaster，一般是SoC中内置的I2C控制器）的I2C基本操作，并且向应用层提供相应的操作

				接口，应用层代码需要自己去实现对slave的控制和操作，所以这种I2C驱动相当于只是提供给应用层可以访问slave硬件设备的接口，本身并未对硬件做任何操作，应用需要实
				
				现对硬件的操作，因此写应用的人必须对硬件非常了解，其实相当于传统的驱动中干的活儿丢给应用去做了，所以这种I2C驱动又叫做“应用层驱动”，这种方式并不主流，它的优势是
				
				把差异化都放在应用中，这样在设备比较难缠（尤其是slave是非标准I2C时）时不用动驱动，而只需要修改应用就可以实现对各种设备的驱动。
				
			(2)第二种I2C驱动是所有的代码都放在驱动层实现，直接向应用层提供最终结果。应用层甚至不需要知道这里面有I2C存在，譬如电容式触摸屏驱动，直接向应用层提供/dev/input/event1
				
				的操作接口，应用层编程的人根本不知道event1中涉及到了I2C。
1220：继续搞i2c驱动，直接看代码！！！
	@i2c平台设备、平台驱动、具体i2c设备等都有相应的描述结构体，同时会耦合包含
	@i2c_probe：(当发现一个合适的设备时被bus driver调用)平台驱动的探测函数做的工作是将平台设备的一些信息继承到具体设备上来，然后初始化该具体设备，
				为具体设备注册中断函数，注册cpu频率，声明一个适配器，注册of_i2c,设置私有数据，使能设备的PM，打印信息，关闭时钟。
	@驱动结合设备对象才能描述好一个具体物理设备，体现分离的思想事项代码的复用。除了分离i2c子系统还体现了分层的设计思想：设备驱动层-i2c核心层-控制器驱动
	
	@i2c_adapter对象实现了一组通过一个i2c控制器发送消息的所有信息, 包括时序, 地址等等, 即封装了i2c控制器的"控制信息"。它被i2c主机驱动创建, 通过clien域和i2c_client和i2c_driver相连, 这样设备端驱动就可以通过其中的方法以及i2c物理控制器来和一个i2c总线的物理设备进行交互
	@i2c_algorithm描述一个i2c主机的发送时序的信息，该类的对象algo是i2c_adapter的一个域，其中的master_xfer()注册的函数最终被设备驱动端的i2c_transfer()回调。
	@i2c_client描述一个挂接在硬件i2c总线上的设备的设备信息，即i2c设备的设备对象，与i2c_driver对象匹配成功后通过detected和i2c_driver以及i2c_adapter相连，在控制器驱动与控制器设备匹配成功后被控制器驱动通过i2c_new_device()创建。
	@i2c_driver描述一个挂接在硬件i2c总线上的设备的驱动方法，即i2c设备的驱动对象，通过i2c_bus_type和设备信息i2c_client匹配，匹配成功后通过clients和i2c_client对象以及i2c_adapter对象相连
	@i2c_msg描述一个在设备端和主机端之间进行流动的数据, 在设备驱动中打包并通过i2c_transfer()发送。相当于skbuf之于网络设备，urb之于USB设备。
1221： 宋宝华的驱动开发书籍
	i2c协议的驱动
	前两天看的博客学习linux的i2c协议虽然有很大的跨越但是感觉还不是很清晰，今天看看宋宝华的书加固一下。
	除了内核模式的驱动程序还有用户空间的驱动程序。用i2c-dev模块开发用户空间的i2c驱动（具体见书籍）
	下面这些总结写的很好：
	1、确定设备的功能和接口技术，几乎linux的每一个驱动程序子系统都包含核心层（提供驱动程序服务）和抽象层（使应用程序独立于底层硬件之外），你所编写的驱动程序需要合乎此框架，并与子系统中的其他组件进行接口。如果你的设备是一个调制解调器，就需要学习UART、tty与线路规程层是如何如何工作的。如果待驱动的芯片是RTC或看门狗，就需要学习如何遵守相应的内核API。如果面对的是鼠标，就需要
	弄清楚如何将其与输入事件层联系在一起。如果是视频控制器，就要理解帧缓冲子系统。在开始驱动音频编解码器之前研究一下ALSA框架。
	2、获取设备的数据手册并理解其寄存器的编程模式。例如，对于i2c DVI发射机，需要弄明白设备的从地址以及初始化过程的编程顺序。对于SPI触摸控制器，理解如何实现其有限状态机。对于PCI以太网卡，研究其配置空间的操作。对于USB设备，需要弄清楚其支持的端点以及如何与其通信。
	3、在强大的内核源码树中，搜寻可作参考的驱动程序。研究候选的驱动程序，并修改合适的驱动程序。某些子系统提供的驱动程序框架例如sound/driver/dummy.c、driver/usb/usb-skeleton.c、drivers/net/pci-skeleton.c和drivers/video/skeletonfb.c），如果没有找到相应的参考程序，可以用它作为模型。
	4、如果未找到相近的参考驱动程序，或者你决定自己从头编写驱动程序，多花点时间在驱动程序及其数据结构的设计和框架构建上。
	5、既然已经掌握了所需的所有知识，配备一些软件工具（ctags、cscope和调试器）和实验室装备（示波器、万用表、分析仪），开始编写代码吧。
	《《【疑问】linux中的回调函数的参数是如何传递的？？？》》
	
	嵌入式硬件无关的应用程序和硬件相关的驱动程序
	---------------------------------------------------------------------与硬件无关的应用层
	X windows等     aplay等       gpm等          hwclock等     telnet等
		|				|			|				|				|
	    |				|			|				|				|
	----------------------------------------------------------------------内核抽象层
	帧缓冲API        ALSA接口  输入事件驱动程序  RTC API      套接字接口 
		|				|			|				|				|
	---------------------------------------------------------------------与硬件相关的应用层（驱动程序）
		|				|			|				|				|
	视频驱动程序	音频驱动程序 触摸屏驱动程序 RTC驱动程序	  网络驱动程序
		|				|			|				|				|
	---------------------------------------------------------------------物理硬件层
							硬件
	----------------------------------------------------------------------
	
	6、NOR存储器存放BootLoader和基本内核，而NAND存储器存放文件系统分区和驱动程序。闪存的驱动程序由内核的MTD子系统支持。
	7、有些驱动程序是直接或混合驱动程序，有些驱动程序通过procfs或者sysfs而不是/dev节点进行设备的访问
	
	8、wifi
		WLAN驱动程序的任务是让你的卡详通用的网络接口一样，驱动程序的实现分为以下几个部分：
		1）与linux网络协议栈通信的接口
		2）结构因数相关的代码
		3）芯片组特定部分
		4）对无线扩展的支持
	9、网络接口层  			****（最终的目的还是归结到提高看代码的能力，要一眼就会【用source insight看源码+驱动开发指南+网络博客】。）*****
		NIC不通过/dev 或/sys来与用户空间通信，应用程序是通过网络接口和NIC的驱动程序来互操作的。网络接口对底层协议栈的抽象。
		数据结构：		  
			@形成网络协议栈构造块的数据结构。定义在linux/skbuff.h文件中的sk_buff，是内核TCP/ip栈的关键结构体
			@定义NIC驱动程序和协议栈间接口的数据结构。定义在linux/netdevice.h文件中的net_device是构成该接口的核心结构体	
			@与IO总线相关的结构体，PCI及其派生的总线是常用的
	【总结】-{看代码的时候觉得结构体中包含父类的结构体指针的意义在于继承父类的数据，可以调用父类的资源和方法}-{写出好的驱动程序，要了解硬件的原理特性还要了解操作系统的体系结构才能融合进系统，利用系统的资源和方法}-{一个函数写得好还体现在逻辑上易于阅读} -{看代码要沿着代码的执行路线上来看，同时还是大路不是小路，梢枝末节要先忽略后面再研究}
			@设备打开时调用的函数{注册中断、分配ring、开始接收netif_start_queue}
			@设备的初始化函数：{分配一个网络设备结构体、填充对设备操作的方法如open、填充数据传送方法如hard_start_xmit、看门狗、统计和配置工具、挂载的总线的地址、注册该网络设备}
			@设备发生中断时的处理：{接收数据，追加在skb包尾，发给网络协议层如TCP/IP}
			@设备在关闭时调用的函数：{通知协议层不要继续发数据netif_stop_queue}
			@设备移除是调用的函数：{注销网络设备、释放资源}
			@用sys/class/net下的文件可以操作NIC驱动程序参数，用proc/sys/net可以配置协议变量，proc/net目录有系统相关的网络信息集合。
			-------------------------数据结构小节--------------------------------------------------
			sk_buff      /include/linux/skbuff.h   		sk_buff向linux网络层提供充分的缓冲区处理以及流控机制
			net_device	 /include/linux/netdevice.h 	NIC和TCP/IP协议栈的接口
			net_device_stats 同上						附属于某个网络设备上的统计信息
			ethtool_ops   /include/linux/ethtool.h   	将驱动程序与ethtool工具集绑定
			--------------------内核编程接口小节------------------
			alloc_netdev() 		net/core/dev.c  		分配 net_device
			alloc_etherdev()	net/ethernet/eth.c 		alloc_netdev()的封装
			free_netdev() 		net/core/dev.c 			alloc_netdev()的反操作
			register_netdev() 	net/core/dev.c			注册net_device
			unregister_netdev() net/core/dev.c
			dev_alloc_skb() 	include/linux/skbuff.h  为sk_buff分配内存，并为其关联数据包负载缓冲区
			dev_kfree_skb() 	include/linux/skbuff.h net/core/skbuff.c   上面的反操作
			skb_reserve() 		include/linux/skbuff.h   在数据包缓冲区和有效负载的开头之间填充
			skb_clone() 		net/core/skbuff.c		创建sk_buff的副本，但是不复制关联的缓冲区的内容
			skb_put() 			include/linux/skbuff.h   将数据进入数据包的尾部
			netif_rx() 			net/core/dev.c			将网络数据包传送给TCP/IP栈
			
			{netif_rx_schedule_prep() include/linux/netdevice.h 
			netif_rx_schedule()}    net/core/dev.c 					将网络数据包传送给TCP/IP栈（NAPI）
			netif_receive_skb()	 net/core/dev.c			从poll函数将数据包传递给TCP/IP协议栈（NAPI）
			netif_rx_complete() include/linux/netdevice.h 在轮询列表中移除设备（NAPI）
			netif_device_detach() net/core/dev.c		分离设备（通常在电源挂起时调用）
			netif_device_attach() net/core/dev.c		附着设备（电源恢复）
			netif_start_queue() include/linux/netdevice.h 表明开始从网络协议栈接收数据
			netif_stop_queue() include/linux/netdevice.h	要求网络层停止下传数据
			netif_wake_queue() include/linux/netdevice.h 重新开动发送队列
			netif_queue_stopped() include/linux/netdevice.h 检查流控状态
			