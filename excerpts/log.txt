刘志平-542431620@qq.com/15013523662
----------------------------------------------------------------------------------------------------------------------------------------------------------
技术标签：linux 、 C 、xml、json、驱动开发、应用开发、网络、USB等总线、Python、shell、makefile、gcc等开发调试工具、单片机原理（外设、中断、内存、定时器、uart、usb等，用过各类单片机-51内核、pic内核、arm内核）、git、wifi、bluetooth、硬件
----------------------------------------------------------------------------------------------------------------------------------------------------------
个人标签：精通C语言开发、精通linux应用驱动开发、 精通嵌入式单片机开发、精通数据库开发、精通视频处理（海思hi3516的sdk）、精通PIC和51汇编开发、精通使用各外设开发、熟练使用各通信协议、熟练使用版本管理git，图像处理，视频编解码算法H.264/MJEP
----------------------------------------------------------------------------------------------------------------------------------------------------------
项目产品：安防产品、智能家居、网络设备、视频雷达等
----------------------------------------------------------------------------------------------------------------------------------------------------------
关键字：linux、C、汇编、内核、应用、驱动、子系统、模块、版本管理、文件系统、设备、命令行、编译、代码阅读（SI/ctag+vim）、OpenGL、Python、ffmpeg、alsa
----------------------------------------------------------------------------------------------------------------------------------------------------------
参考书籍：
    C Primer Plus(第五版)中文版.pdf
	深入Linux内核架构-郭旭 -译.pdf
    宋宝华_精通LINUX设备驱动开发.pdf
	【宋宝华】linux设备驱动开发详解-第四版.pdf
    Linux／UNIX系统编程手册  上 PDF电子书下载 带书签目录 完整版.pdf
    Linux／UNIX系统编程手册  下 PDF电子书下载 带书签目录 完整版.pdf
    嵌入式实时操作系统uc_os-II原理及应用.pdf
    emWin5中文手册.pdf
    ARM Cortex-M3权威指南.pdf
    stm32F4xx参考手册.pdf
    USB 2.0规范中文版.pdf
	算法导论
	深入linux内核系列章节
	《Understanding Linux Network Internals》-pdf
	《linux device drivers》-O'reilly -pdf
    等等
----------------------------------------------------------------------------------------------------------------------------------------------------------
文件资料：见百度网盘（qq登入），github，华为云-DevCloud,微云
    Hi3516A V100R001C01SPC060 sdk
    linux-3.4.y 源码
    等等
----------------------------------------------------------------------------------------------------------------------------------------------------------
日志：【从今天开始，记录每天的学习和工作日志】
----------------------------------------------------------------------------------------------------------------------------------------------------------
20171214：通过sdk自带的应用和驱动程序学习修改移植。将sdk全部解压建仓，先看脚本文件，在看具体的代码。

1、查看文件D:\5-video\hi3516_sdk\Hi3516A V100R001C01SPC040\01.software\board\document_cn\Hi3516A／Hi3516D SDK 安装以及升级使用说明.txt
2、查看文件D:\5-video\work_code\video_myworks\osdrv\readme_cn.txt
3、【问题】编译osdrv的时候没有连接libc.so导致make yaffs工具的时候失败
    【解答】缺乏libc.a，zypper install glibc-static 安装库即可
    【原因】在很多第三方程序为了确保在没有相应动态库时运行正常，喜欢在编译最后应用程序时加入-static.在老版本中编译正常，但在新版Fedora下编译常常报错
4、参考 （查看硬件手册和软件手册）
    *硬件：D:\5-video\hi3516_sdk\Hi3516A V100R001C01SPC040\00.hardware\chip\document_cn\
        芯片手册  《Hi3516A／Hi3516D 专业型HD IP Camera Soc用户指南.pdf》
        用户手册  《Hi3516A 专业型HD IP Camera SoC产品简介.pdf》
        
    *软件：D:\5-video\hi3516_sdk\Hi3516A V100R001C01SPC040\01.software\board\document_cn
        《Hi3516A／Hi3516D SDK 安装以及升级使用说明.txt》
        《HiMPP IPC V2.0 媒体处理软件开发参考.pdf》
        《Hi3516A／Hi3516D Linux开发环境用户指南.pdf》
        《Hi3516A／Hi3516D SDK 安装以及升级使用说明.txt》  。。。。
        D:\5-video\hi3516_sdk\Hi3516A V100R001C01SPC040\01.software\pc\DEC_LIB\documents_cn
        《H.264 PC解码库软件 API参考.pdf》
        《H.264 PC解码库软件开发指南.pdf》
        《客户端AMR编解码库API参考.pdf》
        《客户端音频编解码库API参考.pdf》 。。。。
        D:\5-video\hi3516_sdk\Hi3516A V100R001C01SPC040\01.software\pc\IVE_CLIB
        《HiIVE Brief Specification.pdf》
        D:\5-video\hi3516_sdk\Hi3516A V100R001C01SPC040\01.software\pc\PQ_TOOL\documents_cn
        《图像质量调试工具使用指南.pdf》
    *源码：D:\5-video\hi3516_sdk\Hi3516A V100R001C01SPC040\01.software\board\Hi3516A_SDK_V1.0.4.0\package
        参考学习驱动和应用的例子，开发自己的应用和驱动。
    
    4.1->硬件特性：接口时序、管脚复用控制寄存器、软件复用管脚、硬件管脚复用、管脚驱动能力、管脚分布、
            ->系统管理：复位、时钟、处理器子系统（arm-Cortex-a7处理器600MHZ）、中断系统（96个中断源-64个外部中断）、系统控制器（三种工作模式）、DMA控制器（DMAC流控）、CIPHER（加解密）、定时器（4个timer）、看门狗（32bits减法计数器）、实时时钟（时钟显示和定时报警）、电源管理与低功耗模式控制（低功耗模式）
       
            ->存储器接口：DDR控制器、SPI NOR FLASH 存储控制器、NAND FLASH控制器、SPI NAND FLASH控制器
       
            ->GSF(千兆以太网交换接口实现网络接口的数据的接收和发送，支持10/100/1000Mbit/s模式可配置，EEE能效以太网、WoL网络唤醒功能)
       
            ->视频编码（视频编解码器是一个支持H.264/H.265/JPEG 的多协议编解码器，包括AVC、VEDU和JPGE 三部分，其中AVC 实现H.264 协议的编码，VEDU 实现H.265 协议的编解码，JPEG 实现JPEG 协议的编码）
            
            ->视频及图形处理（TDE-Two Dimensional engine，VPSS-Video process sub-system，VGS-video graph system）
       
            ->运动检测单元（MDU）
       
            ->智能加速引擎（IVE）
       
            ->视频接口（VICAP-视频捕获单元，VDP-video Display processor，MIPI Rx-移动行业处理器接口）
       
            ->ISP（图像处理）
       
            ->音频接口（i2s PCM,DMA方式存取数据）
       
            ->外围设备（I2C SPI UART MMC/SD/SDIO 红外接口 GPIO USB2.0 LSADC_CTRL PWM）
     
    4.2->sdk软件特性：系统控制、视频输入、视频输出、视频处理子系统、视频编码、视频监测分析、区域管理、音频、视频图形子系统、/proc调试信息
    (海思媒体处理平台的主要内部处理流程 ，主要分为视频输入（VI）、视频处理（VPSS）、视频编码（VENC）、视频解码（VDEC）、视频输出(VO)、视频侦测分析(VDA)、音频输入(AI)、音频输出(AO)、音频编码（AENC）、音频解码（ADEC）、区域管理（REGION）等模块)
----------------------------------------------------------------------------------------------------------------------------------------------------------
20171215：linux驱动设备模型+mpp设备驱动    华为开发者云（类似isource）
    1、音频驱动ak7756 
    2、应用程序摄像头 isp   -- sony_imx178
    3、在用户态下编程可以通过main()的参数来传递命令行参数，而编写一个内核模块则通过module_param()来传递参数
----------------------------------------------------------------------------------------------------------------------------------------------------------
20171218：mpp驱动
    1、himedia驱动
    2、linux编程：系统编程
        处理器总处于以下状态中的一种：
        1、内核态，运行于进程上下文，内核代表进程运行于内核空间；
        2、内核态，运行于中断上下文，内核代表硬件运行于内核空间；
        3、用户态，运行于用户空间。
    3、所谓的进程上下文，就是一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈中的内容，当内核需要切换到另一个进程时，它需要保存当 前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行（https://www.cnblogs.com/reality-soul/p/6377137.html）
        运行在进程上下文的内核代码是可以被抢占的（Linux2.6支持抢占）。但是一个中断上下文，通常都会始终占有CPU（当然中断可以嵌套，但我们一般不这样做），不可以被打断。正因为如此，运行在中断上下文的代码就要受一些限制，不能做下面的事情：

        3.1、睡眠或者放弃CPU。

        这样做的后果是灾难性的，因为内核在进入中断之前会关闭进程调度，一旦睡眠或者放弃CPU，这时内核无法调度别的进程来执行，系统就会死掉

        3.2、尝试获得信号量
    
        如果获得不到信号量，代码就会睡眠，会产生和上面相同的情况

        3.3、执行耗时的任务
    
        中断处理应该尽可能快，因为内核要响应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。

        3.4、访问用户空间的虚拟地址

        因为中断上下文是和特定进程无关的，它是内核代表硬件运行在内核空间，所以在终端上下文无法访问用户空间的虚拟地址
    4、linux输入子系统（http://www.cnblogs.com/reality-soul/p/4705712.html）
1219：新的一天新的逻辑新的开始（笔记是知识积累的重要载体），今天就是学习i2c的驱动，集中精力对准一点猛攻
https://www.cnblogs.com/xiaojiang1025/p/6500540.html linux i2c 子系统分析

    1、i2c驱动的分析
        1.1、硬件描述：模块的作用是完成cpu对i2c总线上的从设备的读写，在写操作的时候，CPU通过总线配置i2c的配置寄存器然后发送控制信息和操作数到i2c模块的数据通信寄存器，i2c模块解析命令后将数据   通道寄存器的数据通过i2c总线发送给从设备，发送完毕后将最终的状态通过中断反馈给cpu。读从设备的数据和写操作类似。   【【 CPU<-->I2C模块<--(通过I2C总线) -->从设备 】】
           hi3516a包含3个I2C模块，寄存器基地址分别为：0X200d_0000 、0x2024_0000 、0x2025_0000  有26个寄存器
        1.2、i2c的操作指南
            准备工作：sdk发布的linux内核、文件系统（yafss2、jffs2、SqushFs、NFS）
            操作过程：启动单板，加载文件系统；加载内核模块（insmod）；在控制台下运行I2C读写命令或者自行在内核态和用户态的读写i2c的程序，就可以对挂载在i2c总线上的从设备进行读写操作
            接口速率设置：在内核配置的时候在【驱动选项】中选择配置
            操作示例：1.2.1、I2C读写命令  ~ $ i2c_read <i2c_num> <device_addr> <reg_addr> <end_reg_addr> <reg_width> <data_width> <reg_step>
                                          ~ $ i2c_write <i2c_num> <device_addr> <reg_addr> <value> <reg_width> <data_width>
                      1.2.2、内核态读写程序 ：在内核态通过i2c读写程序对i2c外围设备的读写操作 (利用linux的i2c驱动体系结构)
                                1)调用和核心层的函数获取一个描述控制器的结构体 i2c_adap = i2c_get_adapt(2);
                                2)把控制器和设备关联起来 hi_client = i2c_new_device(i2c_adapt,hi_info);
                                3)调用内核i2c核心层提供的接口对从设备进行读写
                      1.2.3、用户态读写程序：（把i2c设备当做普通的字符设备）
                                1)打开i2c总线对应的设备文件获取文件描述符 fd = open("/dev/i2c-2", O_RDWR); 
                                2)通过ioctl设置外围设备的地址、寄存器的位宽和数据位宽 ioctl(fd, I2C_SLAVE_FORCE, device_addr); ioctl(fd, I2C_16BIT_REG, 0); 
                                3)使用read/write进行数据的读写read(fd, recvbuf, reg_width); 
                                
        1.3、编写具体的I2C驱动时，工程师需要处理的主要工作如下：
 
　           　1).提供I2C适配器的硬件驱动，探测，初始化I2C适配器(如申请I2C的I/O地址和中断号)，驱动CPU控制的I2C适配器从硬件上产生。
　           　2).提供I2C控制的algorithm, 用具体适配器的xxx_xfer()函数填充i2c_algorithm的master_xfer指针，并把i2c_algorithm指针赋给i2c_adapter的algo指针。
              3).实现I2C设备驱动中的i2c_driver接口，用具体yyy的yyy_probe()，yyy_remove()，yyy_suspend(),yyy_resume()函数指针和i2c_device_id设备ID表赋给i2c_driver的probe,remove,suspend,resume和id_table指针。
　　        4).实现I2C设备所对应类型的具体驱动，i2c_driver只是实现设备与总线的挂接。　
　　              上面的工作中前两个属于I2C总线驱动，后面两个属于I2C设备驱动。
        1.4、 linux的i2c子系统
            除了分离，i2c子系统也体现的软件分层的设计思想, 整个i2c子系统由3层构成：设备驱动层--i2c核心--控制器驱动
            xx_driver->{probe->{init->init_device + ops->{open,release,ioctl}}}+{xx_remove}
        1.5、设备树 http://www.cnblogs.com/xiaojiang1025/p/6131381.html
        1.6、平台设备 http://www.cnblogs.com/xiaojiang1025/p/6367910.html
            写驱动也有一段时间了，可以发现，其实驱动本质上只做了两件事：向上提供接口，向下控制硬件，当然，这里的向上并不是直接提供接口到应用层，而是提供接口给内核再由内核间接的将我们的接口提供给应用层。而写驱动也是有一些套路可寻的，拿到一个硬件，我们大体可以按照下面的流程写一个驱动：
                http://www.cnblogs.com/xiaojiang1025/p/6367910.html
            1）确定驱动架构：根据硬件连接方式结合分层/分离思想设计驱动的基本结构
            2）确定驱动对象：内核中的一个驱动/设备就是一个对象，1.定义，2.初始化，3.注册，4.注销
            3）向上提供接口：根据业务需要确定提供cdev/proc/sysfs哪种接口
            4）向下控制硬件：1.查看原理图确定引脚和控制逻辑，2.查看芯片手册确定寄存器配置方式，3.进行内存映射，4.实现控制逻辑
            
        driver与device的匹配
            设备信息有三种表达方式，而一个驱动是可以匹配多个设备的，平台总线中的驱动要具有三种匹配信息的能力，基于这种需求，platform_driver中使用不同的成员来进行相应的匹配。
                of_match_table ： 对于使用设备树编码的设备信息，我们使用其父类device_driver中的of_match_table就是用来匹配
                id_table： 对于使用C语言编码的设备信息，我们用platform_driver对象中的id_table就是用来匹配
                name ：如果platform_driver和C语言编码的platform_device是一一匹配的，我们还可以使用device_driver中的name来进行匹配
        1.7、http://www.cnblogs.com/xiaojiang1025/p/6369065.html linux platform 驱动模型之 platform+cdev
        1.8   http://www.cnblogs.com/deng-tao/p/6130080.html
            I2C子系统提供的两种驱动实现方法（源码中I2C相关的驱动均位于：drivers/i2c目录下）

            (1)第一种叫i2c-dev，对应drivers/i2c/i2c-dev.c，这种方法只是封装了主机（I2Cmaster，一般是SoC中内置的I2C控制器）的I2C基本操作，并且向应用层提供相应的操作

                接口，应用层代码需要自己去实现对slave的控制和操作，所以这种I2C驱动相当于只是提供给应用层可以访问slave硬件设备的接口，本身并未对硬件做任何操作，应用需要实
                
                现对硬件的操作，因此写应用的人必须对硬件非常了解，其实相当于传统的驱动中干的活儿丢给应用去做了，所以这种I2C驱动又叫做“应用层驱动”，这种方式并不主流，它的优势是
                
                把差异化都放在应用中，这样在设备比较难缠（尤其是slave是非标准I2C时）时不用动驱动，而只需要修改应用就可以实现对各种设备的驱动。
                
            (2)第二种I2C驱动是所有的代码都放在驱动层实现，直接向应用层提供最终结果。应用层甚至不需要知道这里面有I2C存在，譬如电容式触摸屏驱动，直接向应用层提供/dev/input/event1
                
                的操作接口，应用层编程的人根本不知道event1中涉及到了I2C。
----------------------------------------------------------------------------------------------------------------------------------------------------------
20171220：继续搞i2c驱动，直接看代码！！！
    @i2c平台设备、平台驱动、具体i2c设备等都有相应的描述结构体，同时会耦合包含
    @i2c_probe：(当发现一个合适的设备时被bus driver调用)平台驱动的探测函数做的工作是将平台设备的一些信息继承到具体设备上来，然后初始化该具体设备，
                为具体设备注册中断函数，注册cpu频率，声明一个适配器，注册of_i2c,设置私有数据，使能设备的PM，打印信息，关闭时钟。
    @驱动结合设备对象才能描述好一个具体物理设备，体现分离的思想事项代码的复用。除了分离i2c子系统还体现了分层的设计思想：设备驱动层-i2c核心层-控制器驱动
    
    @i2c_adapter对象实现了一组通过一个i2c控制器发送消息的所有信息, 包括时序, 地址等等, 即封装了i2c控制器的"控制信息"。它被i2c主机驱动创建, 通过clien域和i2c_client和i2c_driver相连, 这样设备端驱动就可以通过其中的方法以及i2c物理控制器来和一个i2c总线的物理设备进行交互
    @i2c_algorithm描述一个i2c主机的发送时序的信息，该类的对象algo是i2c_adapter的一个域，其中的master_xfer()注册的函数最终被设备驱动端的i2c_transfer()回调。
    @i2c_client描述一个挂接在硬件i2c总线上的设备的设备信息，即i2c设备的设备对象，与i2c_driver对象匹配成功后通过detected和i2c_driver以及i2c_adapter相连，在控制器驱动与控制器设备匹配成功后被控制器驱动通过i2c_new_device()创建。
    @i2c_driver描述一个挂接在硬件i2c总线上的设备的驱动方法，即i2c设备的驱动对象，通过i2c_bus_type和设备信息i2c_client匹配，匹配成功后通过clients和i2c_client对象以及i2c_adapter对象相连
    @i2c_msg描述一个在设备端和主机端之间进行流动的数据, 在设备驱动中打包并通过i2c_transfer()发送。相当于skbuf之于网络设备，urb之于USB设备。
----------------------------------------------------------------------------------------------------------------------------------------------------------
    20171221： 宋宝华的驱动开发书籍
    i2c协议的驱动
    前两天看的博客学习linux的i2c协议虽然有很大的跨越但是感觉还不是很清晰，今天看看宋宝华的书加固一下。
    除了内核模式的驱动程序还有用户空间的驱动程序。用i2c-dev模块开发用户空间的i2c驱动（具体见书籍）
    下面这些总结写的很好：
    1、确定设备的功能和接口技术，几乎linux的每一个驱动程序子系统都包含核心层（提供驱动程序服务）和抽象层（使应用程序独立于底层硬件之外），你所编写的驱动程序需要合乎此框架，并与子系统中的其他组件进行接口。如果你的设备是一个调制解调器，就需要学习UART、tty与线路规程层是如何如何工作的。如果待驱动的芯片是RTC或看门狗，就需要学习如何遵守相应的内核API。如果面对的是鼠标，就需要
    弄清楚如何将其与输入事件层联系在一起。如果是视频控制器，就要理解帧缓冲子系统。在开始驱动音频编解码器之前研究一下ALSA框架。
    2、获取设备的数据手册并理解其寄存器的编程模式。例如，对于i2c DVI发射机，需要弄明白设备的从地址以及初始化过程的编程顺序。对于SPI触摸控制器，理解如何实现其有限状态机。对于PCI以太网卡，研究其配置空间的操作。对于USB设备，需要弄清楚其支持的端点以及如何与其通信。
    3、在强大的内核源码树中，搜寻可作参考的驱动程序。研究候选的驱动程序，并修改合适的驱动程序。某些子系统提供的驱动程序框架例如sound/driver/dummy.c、driver/usb/usb-skeleton.c、drivers/net/pci-skeleton.c和drivers/video/skeletonfb.c），如果没有找到相应的参考程序，可以用它作为模型。
    4、如果未找到相近的参考驱动程序，或者你决定自己从头编写驱动程序，多花点时间在驱动程序及其数据结构的设计和框架构建上。
    5、既然已经掌握了所需的所有知识，配备一些软件工具（ctags、cscope和调试器）和实验室装备（示波器、万用表、分析仪），开始编写代码吧。
    《《【疑问】linux中的回调函数的参数是如何传递的？？？》》
    
    嵌入式硬件无关的应用程序和硬件相关的驱动程序
    ---------------------------------------------------------------------与硬件无关的应用层
    X windows等     aplay等       gpm等          hwclock等     telnet等
        |               |           |               |               |
        |               |           |               |               |
    ----------------------------------------------------------------------内核抽象层
    帧缓冲API        ALSA接口  输入事件驱动程序  RTC API      套接字接口 
        |               |           |               |               |
    ---------------------------------------------------------------------与硬件相关的应用层（驱动程序）
        |               |           |               |               |
    视频驱动程序  音频驱动程序 触摸屏驱动程序 RTC驱动程序    网络驱动程序
        |               |           |               |               |
    ---------------------------------------------------------------------物理硬件层
                            硬件
    ----------------------------------------------------------------------
    
    6、NOR存储器存放BootLoader和基本内核，而NAND存储器存放文件系统分区和驱动程序。闪存的驱动程序由内核的MTD子系统支持。
    7、有些驱动程序是直接或混合驱动程序，有些驱动程序通过procfs或者sysfs而不是/dev节点进行设备的访问
    
    8、wifi
        WLAN驱动程序的任务是让你的卡详通用的网络接口一样，驱动程序的实现分为以下几个部分：
        1）与linux网络协议栈通信的接口
        2）结构因数相关的代码
        3）芯片组特定部分
        4）对无线扩展的支持
    9、网络接口层             ****（最终的目的还是归结到提高看代码的能力，要一眼就会【用source insight看源码+驱动开发指南+网络博客】。）*****
        NIC不通过/dev 或/sys来与用户空间通信，应用程序是通过网络接口和NIC的驱动程序来互操作的。网络接口对底层协议栈的抽象。
        数据结构：         
            @形成网络协议栈构造块的数据结构。定义在linux/skbuff.h文件中的sk_buff，是内核TCP/ip栈的关键结构体
            @定义NIC驱动程序和协议栈间接口的数据结构。定义在linux/netdevice.h文件中的net_device是构成该接口的核心结构体   
            @与IO总线相关的结构体，PCI及其派生的总线是常用的
    【总结】-{看代码的时候觉得结构体中包含父类的结构体指针的意义在于继承父类的数据，可以调用父类的资源和方法}-{写出好的驱动程序，要了解硬件的原理特性还要了解操作系统的体系结构才能融合进系统，利用系统的资源和方法}-{一个函数写得好还体现在逻辑上易于阅读} -{看代码要沿着代码的执行路线上来看，同时还是大路不是小路，梢枝末节要先忽略后面再研究}
            @设备打开时调用的函数{注册中断、分配ring、开始接收netif_start_queue}
            @设备的初始化函数：{分配一个网络设备结构体、填充对设备操作的方法如open、填充数据传送方法如hard_start_xmit、看门狗、统计和配置工具、挂载的总线的地址、注册该网络设备}
            @设备发生中断时的处理：{接收数据，追加在skb包尾，发给网络协议层如TCP/IP}
            @设备在关闭时调用的函数：{通知协议层不要继续发数据netif_stop_queue}
            @设备移除是调用的函数：{注销网络设备、释放资源}
            @用sys/class/net下的文件可以操作NIC驱动程序参数，用proc/sys/net可以配置协议变量，proc/net目录有系统相关的网络信息集合。
            -------------------------数据结构小节--------------------------------------------------
            sk_buff      /include/linux/skbuff.h        sk_buff向linux网络层提供充分的缓冲区处理以及流控机制
            net_device   /include/linux/netdevice.h     NIC和TCP/IP协议栈的接口
            net_device_stats 同上                     附属于某个网络设备上的统计信息
            ethtool_ops   /include/linux/ethtool.h      将驱动程序与ethtool工具集绑定
            --------------------内核编程接口小节------------------
            alloc_netdev()      net/core/dev.c          分配 net_device
            alloc_etherdev()    net/ethernet/eth.c      alloc_netdev()的封装
            free_netdev()       net/core/dev.c          alloc_netdev()的反操作
            register_netdev()   net/core/dev.c          注册net_device
            unregister_netdev() net/core/dev.c
            dev_alloc_skb()     include/linux/skbuff.h  为sk_buff分配内存，并为其关联数据包负载缓冲区
            dev_kfree_skb()     include/linux/skbuff.h net/core/skbuff.c   上面的反操作
            skb_reserve()       include/linux/skbuff.h   在数据包缓冲区和有效负载的开头之间填充
            skb_clone()         net/core/skbuff.c       创建sk_buff的副本，但是不复制关联的缓冲区的内容
            skb_put()           include/linux/skbuff.h   将数据进入数据包的尾部
            netif_rx()          net/core/dev.c          将网络数据包传送给TCP/IP栈
            
            {netif_rx_schedule_prep() include/linux/netdevice.h 
            netif_rx_schedule()}    net/core/dev.c                  将网络数据包传送给TCP/IP栈（NAPI）
            netif_receive_skb()  net/core/dev.c         从poll函数将数据包传递给TCP/IP协议栈（NAPI）
            netif_rx_complete() include/linux/netdevice.h 在轮询列表中移除设备（NAPI）
            netif_device_detach() net/core/dev.c        分离设备（通常在电源挂起时调用）
            netif_device_attach() net/core/dev.c        附着设备（电源恢复）
            netif_start_queue() include/linux/netdevice.h 表明开始从网络协议栈接收数据
            netif_stop_queue() include/linux/netdevice.h    要求网络层停止下传数据
            netif_wake_queue() include/linux/netdevice.h 重新开动发送队列
            netif_queue_stopped() include/linux/netdevice.h 检查流控状态
----------------------------------------------------------------------------------------------------------------------------------------------------------          
20171222：视频驱动程序  （今天重点搞定）
        1、linux视频子系统--帧缓冲
            GUI/电影播放器等-->调用帧缓冲API-->帧缓冲驱动程序N-->视频卡N（显卡N）
            因此，内核的帧缓冲接口让应用程序和底层的图形硬件的变化无关。
            （核心层和抽象层是linux系统的常用设计）
            @ 帧缓冲API：核心层向用户空间提供设备节点，以便应用程序能够访问每个支持的视频设备
            视频卡的属性保存在fb_var_screeninfo  D:\5-video\linux-3.4.y\linux-3.4.y\include\linux\fb.h
            视频硬件的固定信息保存在fb_fix_screeninfo  D:\5-video\linux-3.4.y\linux-3.4.y\include\linux\fb.h
            颜色映射 fb_cmap 用于将用户定义的颜色分配信息传给底层视频硬件
            @ pixclock 显示每个像素的时间  HSYNC-显示每一行像素的时间  VSYNC-显示每一帧的时间
            @ 设备示例：导航系统
                GPS接收机通过UART接口向soc发送坐标数据流，应用程序根据收到的位置信息产生图像，并更新
                系统内存的帧缓冲，帧缓冲驱动程序通过DMA方式将这幅图像数据传输到作为soc LCD控制器一部分的显示缓冲区，控制器将像素数据传输到QVGA LCD面板显示。
                结构：应用程序读/dev/ttyS0从GPS接收机获取数据-->应用程序转换为图像，并将数据写入帧缓冲。
                （当前设备作为平台驱动程序来实现，platform是一种伪总线，与内核设备模型一起用于连接集成soc中的轻量级设备）
                数据结构：fb_info fb_ops
        2、控制台驱动程序  
            @包括顶层驱动程序和底层驱动程序
        3、可以/drivers/video/skeletonfb.c作为起点，写底层帧缓冲驱动程序。查阅/Documentation/fb/*    相关文档
        4、HIFB的应用，3516的fb驱动是基于linux FB的，驱动已经有提供，我们只要用于开发应用就行。见D:\5-video\hi3516_sdk\Hi3516A V100R001C01SPC040\01.software\board\document_cn\HiFB开发指南.pdf
        5、hi3516 Soc用户指南--应用场景、架构、启动模式、硬件特性、系统-复位、系统-时钟、系统-处理器子系统、中断系统、系统控制器、DMA控制器、定时器、看门狗、CIPHER、RTC、电源管理与低功耗模式控制、存储器接口、ISP、视频编码、GSF、视频及图形处理、运动检测单元、智能加速引擎、视频接口、音频接口、外围设备（i2c，uart，spi，sdio，红外，gpio，adc，USB2.0，pwm，）。。。
        6、继续回到书籍-驱动开发
            第二章：initramfs比initrd更优秀。后者模拟一个磁盘会有io开销，前者如同挂载一个文件系统，initrad要求内核挂载文件系统如EXT2。使用mkinitramfs可以创建一个initramfs映像（文档里有）。init接收？etc/initab的引导，首先执行/etc/rc.sysinit中的系统初始化脚本，接下来执行/etc/rc.d/rcX.d/目录下的脚本，X为运行等级这些脚本会启动动态命名子系统，并加载网络、音频、存储设备等驱动程序所对应的模块。最后init发起虚拟控制终端。
            @ 内核和用户模式：内核在内核模式，用户进程在用户模式，内核抢占特性让大多数的内核模式的代码也可以被抢占。
            @ 进程上下文和中断上下文
                内核可以处于两种上下文。中断上下文和进程上下文不可能同时发生。进程上下文会被抢占，但是中断上下文不会被抢断，会运行到结束。中断不能做的操作：
                    1）进入睡眠状态或主动放弃CPU 
                    2）占用互斥体
                    3）执行耗时的任务
                    4）访问用户空间虚拟内存
            @ kmalloc 分配物理连续的内存        vmalloc 分配虚拟连续物理不连续的内存
            第三章： 内核组件
                @ 内核线程 ：在ps命令中显示有方括号括起来了 运行在内核空间，可以访问内核函数和数据结构。很多驱动程序都使用了内核线程以完成辅助任务，如USB设备驱动程序核心khubd内核线程的作用就是监控USB集线器，并在热拔插的时候配置USB设备。
                kernel_thread()可以创建内核线程，由于内核线程对设备驱动程序起辅助的作用，往往在设备驱动程序初始化的时候被创建。
            第四章：基本概念
                @中断上下文
                @softirq和tasklet 
                    中断有两个矛盾的要求：需要处理大量的设备数据处理，有不得不尽快的退出。于是分成两部分：一个急切抢占并与硬件交互的顶半部，一个处理所有使能的中断的并不急切的底半部。
                    softirq、tasklet、工作队列（work queue）都可以用于内核将工作解析到底半部执行。
                    softirq可重用，tasklet不能。（见书上的例子导向杆驱动）
                @设备模型
                    引入了类似C++的抽象机制，对驱动程序总结出共性，并提取了总线和核心层的概念。分析构成设备模型的udev、sysfs、kobject、设备类等组件
                    【我的目的是写出优秀的linux应用程序和驱动程序】
                    udev: udev的规则在/etc/udev/rules.d/xxx.rules
                    sysfs: 和 procfs类似，procfs是内核内部的查看窗口，sysfs特定应用于设备模型
                    kobject和sysfs紧密关联   ，内核中的每个对象实例都有一个sysfs的代表。
                    【97页图4-5很有意思】
                    （总线---设备---驱动程序）--设备模型的有一抽象
                @ 热插拔和冷插拔
                    运行时插入设备叫热插拔，系统启动前连接叫冷插拔。
                    当侦测到热插拔事件后，他们会通过netlink套接字向用户空间派生uevent。其中【netlink套接字】是一种内核空间和用户空间透过套接字API进行通信的有效机制。用户空间的udevd（管理设备节点创建和移除的守护进程）
                @电源管理 
            第五章 ： 字符设备驱动程序
                @ 字符设备基础
                    自顶向下的方式学习字符设备：用户启动应用程序负责和该设备交互。为此需要得到相应驱动程序的标识符。驱动程序通过/dev/目录给用户提供接口
----------------------------------------------------------------------------------------------------------------------------------------------------------          
20171227:
        搞stm8的程序。
        续费华为云一个月。
----------------------------------------------------------------------------------------------------------------------------------------------------------
20171228:
    **D:\4-arm\stm32F4xx参考手册.pdf
    学习USB 【配合stm32的参考手册学习USB协议可以加深理解】
    1、高速 148Mb/s，全速12Mb/s ，低速1.5Mb/s 
    2、应用程序通过AHB接口对控制和状态寄存器（CSR）进行读写操作，以此来控制OTG_HS模块。
        这些都是32位寄存器，因此能够以32位的方式访问。CSR分一下几类：
            *模块全局寄存器 
            *主机模式寄存器 *主机全局寄存器 *主机端口CSR *主机通道相关寄存器
            *模块模式寄存器 *设备全局寄存器 *设备端点相关寄存器
            *电源和时钟门控寄存器
            *数据FIFO访问寄存器
    3、OTG_HS的编程模型
        1、模块初始化
            应用程序必须执行模块的初始化序列。如果在上电期间连接USB线，则当前工作模式反应在模块中断寄存器的当前操作模式位（OTG_HS_GINTSTS中的CMOD位）中反应。
            连接A型插头后，OTG_HS控制器进入主机模式；连接B型插头后，控制器进入设备模式。
            无论主机还是设备模式，应用程序都应该执行以下操作：
                1、配置全局AHB配置寄存器OTG_HS_GAHBCFG的以下字段： - DMA模式位  -AHB突发传输长度字段 -全局中断屏蔽位 GINT=1  -RxFIFO非空(RXFLVL位) -周期性TxFIFO空门限
                2、OTG_HS_GUSBCFG的字段： - HNP功能位 -SRP功能位 -FS超时校准字段 -USB周转时间字段
                3、软件必须取消对GINTMSK寄存器中以下为的屏蔽
                    -OTG中断屏蔽 -模式不匹配中断屏蔽
                4、通过读取OTG_HS_GINTSTS中的CMOD位，软件可以确定OTG_HS控制器是工作在主机模式还是设备模式。
        2、主机初始化  （要将模块作为主机初始化，应用程序必须执行以下步骤：）
            1、编程GIINMSK中的PRTIM以取消屏蔽
            2、编程OTG_HS_HCFG寄存器选择全速主机
            3、将OTG_HS_HPRT0中的PPWR位置1，给USB总线提供Vbus。
            4、等待OTG_HS_HPRT0中的PCDET中断。表示设备已经连接到主机端口。
            5、将OTG_HS_HPRT中的PRST位置1，在USB总线上发出复位信号
            6、至少等待10ms，已完成复位过程
            7、将OTG_HS_HPRT的PRST清零。
            8、等待OTG_HS_HPRT中的PENCHNG中断
            9、读取OTG_HS_HPRT中的PSPD位以获取枚举速度。
            10、使用所选PHY时钟，相应地设置HFIR寄存器。
            11、根据步骤9中的被检测设备的速度对OTG_FS_HCFG寄存器中的FSLSPCS字段进行编程。如果FSLSPCS发生更改，则执行端口复位。
            12、编程OTGHS_GRXFSIZ寄存器以选择接受FIFO的大小
            13、编程OTG_HS_GNPTXFSIZ寄存器，以选择用于周期(或非周期性)通信事务的周期(或非周期)性发送FIFO的大小和起始地址
            要与设备通信，系统软件必须初始化并至少使能一个通道！！
            
        3、设备初始化  （上电期间或者从主机模式切换为设备模式，应用程序必须执行下列步骤来将模块作为设备进行初始化）
            1、 在OTG_HS_DCFG寄存器中编程以下字段： - 设备速度  - 非零长度状态OUT握手信号
            2、编程OTG_HS_GINTMSK寄存器以取消屏蔽一下中断：
                - USB 复位   -枚举完成  -早期挂起   -USB挂起  - SOF
            3、编程OTG_HS_GCCFG寄存器中的VBUSBSEN位使能“B”设备模式的Vbus感应并把DP线上的上拉电阻上拉到5V
            4、等待OTG_HS_GINTSTS中的USBRST中断，此中断指示USB上检测到复位信号，复位过程自接收到此中断后约持续10ms。
            等待OTG_HS_GINTSTS中的ENUMDNE中断，此中断指示USB上复位结束。接收到此中断时，应用程序必须读取OTG_HSDSTS寄存器以确定枚举速度并执行枚举完成时的端点初始化中的所有步骤（如下）。
            
            5、对OTG_HS_DIEPCTL0中的MPSIZ字段进行编程设置最大数据包的大小。该步骤配置控制端点0.控制端点的最大数据包大小取决于枚举速度。
            
            6、在DMA模式下，编程DOEPCTL0 寄存器来使能控制OUT端点0，以接收SETUP数据包。  - 将DOEPCTL0的EPENA位置1
            
            此时，设备已准备好接收SOF数据包并在控制端点0上执行控制传输。
        4、DMA模式
            AHB主接口使用经过编程的DMA地址（主机模式HCDMAx寄存器和设备模式DIEPDMAx/DOEPDMAx）来访问数据缓冲区。
        
    **D:\0-linux\宋宝华_精通LINUX设备驱动开发.pdf
        优点：USB支持热插拔、数据传输模式多样、驱动程序通用
        主机控制器：
            UHCI（Universal Host Controller Interface,通用主机控制接口）
            OHCI（open Host Controller Interface，开发主机控制接口） 他的驱动程序比UHCI更简单
            EHCI（Enhanceed Host Controller Interface，增强型主机控制接口）支持高速usb2.0设备，通常包含低速的控制器
            USB OTG控制器：双重角色设备，用HNP（Host Negotiation Protocol，主机沟通协议）初始化设备连接后这样的设备在主机模式和设备模式之间任意切换。
----------------------------------------------------------------------------------------------------------------------------------------------------------
20171229： USB的学习-从linux的驱动程序着手 D:\0-linux\宋宝华_精通LINUX设备驱动开发.pdf 【在专注的学习子系统后，对代码的阅读也有很大的帮助】
    第11章 usb 子系统
    4种传输模式：控制传输模式、批量传输模式、中断传输模式、等时传输模式
    控制：传送外设和主机之间的控制、状态配置等信息
    批量；传输大量时延要求不高的数据
    中断：传输数据量小，但是对时延敏感，要求立即响应
    等时：传输实时数据，传输速度要预先感知
    **寻址：每个可寻址单元称作端点，为每个端点分配的地址叫端点地址，每个端点地址都有与之相关的传输模式。如果一个端点的传输模式是批量模式，该端点叫批量端点。地址为0的端点专门用来配置设备。
    上行方向：设备端数据到控制器 -IN传输
    下行方向：控制器端数据到设备端 -OUT传输
    **与I2C和PCI总线的共同点：和I2C一样采用主从结构，设备地址不占用CPU寻址范围，地址位数为7，设备内存没有映射到CPU内存和IO内存，因此不占用CPU资源。和PCI一样设备支持热插拔，设备驱动程序架构相似。驱动程序结构体都包含probe()函数和disconnect()函数，都包含识别设备的ID表，支持高速率数据传输，但比PCI低一点，和PCI控制器一样，USB主机控制器的内嵌有可以获得总线控制权的DMA引擎，支持多功能设备，USB支持每个功能都有其接口描述符，相应的多功能PCI设备的每个功能都有自己的设备ID表和配置空间
    **linux-USB子系统
    
    ---------------------------------------------------
    用户空间
              USB用户模式设备驱动程序        用户应用程序
    ------------------|--------------------------|--
    内核空间        usbfs   <-->   usbcore    /dev、 /sys、 其他内核层如SCSI、串行、网络、输入、蓝牙等
                                    /     \      |
                 USB主机控制器驱动程序    usb客户驱动程序
    内核空间                      |             |
    ------------------------------|-------------|--------
    硬件                  usb主机控制器  <--  USB设备
    -------------------------------------------------------
    **驱动程序的数据结构体： （每个设备驱动程序子系统都有区别与其他设备驱动程序的结构体，该结构体在内核中代表所驱动的设备如usb_device属于USB子系统，pci_dev属于PCI层，net_deivce属于网络驱动程序层。）
        1、struct usb_device；
        2、struct urb; (USB request block)usb传输机制使用的核心数据结构，urb共usb协议栈使用，相应的sk_buff供网络协议栈使用。
            urb的使用分三步：分配内存，初始化，提交。用usb_alloc_urb()分配内存并清零，之后初始化相关的kobject和保护URB的自旋锁，USB核心提供辅助例程usb_fill_[control|int|bulk]_urb()完成URB的初始化工作。
            调用usb_submit_urb()异步提交URb以供数据传输。核心层也提供了接口int usb_[control|interrupt|bulk]_msg(struct usb_device *usb_dev,unsigned int pipe, ...);
            urb任务完成后，usb_free_urb()函数释放该实例，usb_unlink_urb()函数取消一个待处理的URB。
            @管道：一个和URB相关的抽象的概念。
                管道包括-地址空间-数据传输方向（IN、OUT）-数据传输模式（控制、批量、中断、等时）
                usb核心提供现成的宏来创建管道：usb_[rcv|snd][ctrl|int|bulk|isoc]pipe(struct usb_device *usb_dev,__u8 endpointAddress);
        3、描述符结构
        struct usb_device_descriptor、struct usb_config_descriptor、struct usb_interface_descriptor、struct usb_endpoint_descriptor
        4、usb_device_id、usb_class_driver等等
    **设备实例：USB遥测卡
        设备的驱动程序通过USB总线连接处理器。
        USB遥测卡的端点说明：控制端点附在卡上一个配置寄存器中；批量IN负责把设备数据传递给处理器；批量OUT负责把处理器过来的数据
        可以基于drivers/usb/usb-skeleton.c文件提供的框架为设备编写设备驱动程序。
        因为PCI设备、PCMIA设备和USB设备有相似的特点，所以驱动程序有很多相似的函数和结构体，尤其是初始化和探测部分，所以可以多借鉴。
        【include/linux/mod_devicetable.h】文件定义usb_device_id结构体和相关的宏
        【结合之前i2c和sdio驱动的学习，再次学习linux的驱动框架原理和驱动模型，学习linux是一个持久的过程。同时要学习USB协议的工作流程和控制器的相关控制模式。最终达到掌握linux-usb子系统的代码和框架
        其实同时还是一个巩固各方面知识的过程如C语言，要有心用心去做。】
        【学以致用才能说掌握了这个东西，要不然一会忘记二别人也不行三没搞出东西就没有意义了】
        【有核心层的好处和有操作系统的好处和有函数库的好处是样一样的，不用自己写一些工具，只要调用接口就好，那些累活他们已经干好了，所以最主要的工作是在了解原理的基础上了解并会使用工具，
        厉害的话就可以自己写工具，之前的单片机程序就是这样，现在没有必要了，但是可以去学习学习】
        【向应用程序的入口是main一样，在linux系统中驱动程序也有入口module_init】
        @ completion机制： http://blog.csdn.net/dreamxu/article/details/5866593   
            因为异步提交必须使用回调函数，等待回调函数执行完成。
            1、定义和初始化：struct completion completion; init_completion(&completion);
            2、等待完成量：wait_for_completion()函数，/linux/kernel/sched.c
                wait_for_completion_interruptible()函数，/linux/kernel/sched.c
                wait_for_completion_interruptible_timeout()函数，/linux/kernel/sched.c
            3、唤醒完成量：completion()函数：/linux/kernel/sched.c
        @数据传输：
            tele_read()-同步读；函数会使用URB同步提交（会等待），因为调用该函数的进程会阻塞直到读到数据为止。
            tele_write()异步写，但是这个函数使用的是异步提交，提交完了就返回到调用它的线程了，不等待是否完成写的操作。异步提交必须使用回调函数
    **类驱动程序
        USB规范引入了设备类的概念，根据每一类驱动程序的功能把USB设备分成几大类：存储类，网络类、集线器类、串行转换器、音频类、视频类、图像类、调制解调器、打印机、和HID（人机接口设备）。每一类的驱动程序对该类的所有设备可以通用的，
        linux-usb的主页是www.linux-usb.org。登录www.usb.org/devlptor/docs可以下载USB2.0规范和OTG和其他标准
    @ USB2.0 规范中文版.pdf
    USB 设备通过管道和HOST 通信

   @继续回到书籍-驱动开发
   第六章 串行设备驱动
    回顾一下第三章内核组件中的内核线程和辅助接口。
    
----------------------------------------------------------------------------------------------------------------------------------------------------------
20180102:
    第三章：内核组件【一些内核机制】
        内核线程： ps -ef 显示的线程中用方括号括起来的是内核线程。[ksoftirqd/0]是实现软中断的助手，0为cpu序号。events/n线程实现工作队列，pdflush线程对高速缓冲中的脏页进行写回。[khubd]线程是usb集线器线程
                    kjournald线程是通用日志线程，由EXT3文件系统使用。linux网络文件系统是由一组nfsd线程组成。
                内核线程的状态：running、interruptible（可被打断的睡眠）、uninterruptible（不可被打断的睡眠）、zombie、stoped、traced、dead
                函数set_current_state()可以设置当前线程的状态
        用户模式辅助程序
            内核通过调用call_usermodehelper(argv[0], argv, envp, 0)来向用户模式的程序发出请求，让其执行某些程序。
        辅助接口：辅助接口有效的缓解了驱动工程师的负担，有链表list、工作队列work queeu、散列链表hlist、完成函数completion function、通知块notifier block和kthred等
            1、列表list(双向)： include/linux/list.h->  struct list_head 链表【驱动程序把一些工作放到工作队列里延后执行，达到不阻塞其他程序的目的】【概念：内核的部分（提交者submitter）提交工作（延后执行的工作worker）】
            2、散列列表hash-list：单一指针的链表头，fs/dcache.c中的高速缓冲的实现可以作为参考
            3、工作队列：工作队列、软中断和tasklet作为三种延后工作的方式。两个接口结构：workqueue_struct、work_struct
            4、通知链：drivers/net/wan/hdlc.c中的高级数据链路控制(HDLC)协议驱动程序，他会在网络设备通知链上注册，以侦测载波状态的改变。
            5、完成接口：激发某些单独的线程执行，之后等待他们完成。【daemonize("my_thread");通过调用reparent_to_init()将本线程的父线程置为init】
            6、kthread：简化线程管理任务。创建：kthread_create()；等待处理：wake_up_process(my_task);停止：kthread_should_stop()
            7、错误处理：
        查看源码：ksoftirqd、pdflush和khubd内核线程代码分别位于kernel/softirq.c、mm/pdflush.c、drivers/usb/core/hub.c文件中。在kernel/exit.c文件中可以找到daemonize()，以用户模式助手实现的代码在kernel/kmod.c文件。
        list和hlist库函数在include/linux/list.h。内核工作队列kernel/workqueue.c，为理解工作队列可以参照drivers/net/wireless/ipw2200.c
        内核通知链：kernel/sys.c和include/linux/notifier.h
        完成接口：include/linux/completion.h、kernel/sched.c
        kthread：kernel/kthread.c
        错误处理：include/linux/err.h
    【应用程序通过/dev操作设备，通过/sys收集设备信息】
    第七章：输入设备驱动程序
        输入事件驱动、输入设备驱动
    第九章：PCMCIA和CF （略）
    第十章：PCI  -peripheral component interconnect
        PCI实例的以太网-调制解调器卡是一个很好的例子，这个驱动有网络设备驱动和解调器设备驱动，网络设备驱动向网络层注册，调制解调器向串行层注册。
        概括来讲：1、对于每个功能，相应的驱动程序会注册pci_deivce_id和probe
        2、卡插入之后，从卡的配置空间读取厂家ID和设备ID，并找到包含这些ID的驱动程序
        3、找到之后对应的probe函数被激活执行
        4、probe函数方法为以太网和调制解调器分配资源，为网络设备生成网络接口ethX，调制解调器生成串行端口/dev/ttySX，之后用户程序就可以利用这两个文件读写数据了。
        @数据传输：分配DMA描述符，包含缓冲区地址、长度和控制字。还为描述符分配了缓冲区。
        具体的数据传输方式可以看看第15章的描述。发送和接收描述符采用链表环的形式，数据缓冲区采用【忙闲池】管理模式。缓冲区的数据采用流式DMA映射。
        在设备打开的时候，接收数据的缓冲区是以流式映射方式映射到内存池，发送数据的缓冲区则快速映射。
        
    ubuntu core 这个要关注一下了。有时间要玩玩这个。  http://blog.csdn.net/ubuntutouch/article/details/51886345
----------------------------------------------------------------------------------------------------------------------------------------------------------
20180103：
    https://developer.ubuntu.com/core/get-started/raspberry-pi-2-3  --ubuntu core for raspberry Pi 2 or 3
    第十六章：linux无线设备驱动
        wifi：类似有线网络在操作系统中以网络接口的形式存在，但是在链路层有显著的不同：1、802.11 WLAN标准使用冲突避免（CSMA/CA）机制，以太网使用的是冲突检测机制。WLAN帧需要确定（ACK），由于无线网络环境恶劣，WLAN使用WEP（有线等效加密）的加密手段，来保证与有线的安全性
        
    第十七章：存储技术设备
            linux-MTD子系统：MTD核心、映射驱动程序、NOR芯片驱动、NAND芯片驱动、用户模块、某些特殊闪存芯片的私有设备驱动程序。
            ----------------------------------------------------
            用户空间     文件IO         文件IO            原始IO，MTD工具
            ------------------|------------|----------------------|------
            内核空间          |            |                      |
                            -----------------                     |
                            |   VFS层       |                     |
                            -----------------                     |
                               |           |                _____/
                             特有文件系统  |         ______/       
                               |           |        /             
            ---------------------------------------               
            |mtdblock，FTL，NFTL | mtdchar | JFFS2| 用户模块    
            ---------------------------------------               
                    |       |                                     
                NAND芯片   核心
                驱动程序     \ \_
                    |         \   \___________
                    |          \              \____ 
                    |        nor芯片驱动程序      映射驱动程序(驱动程序模块)
            内核空间|            |                  /
            --------|------------|-----------------/------------------------
            硬件    nand芯片    nor芯片
----------------------------------------------------------------------------------------------------------------------------------------------------------
20180104:
    【不能装64bit虚拟机的原因是电脑BIOS里设置了不能用虚拟化，要开机按F8进入-高级设置里面设置开启，才能装64位系统】
    linux网络
    虚拟机 网络模式 NAT
    原来我之前没有接路由器时用桥接模式虚拟机不能上网的原因：如果你有路由器的话，那么就可以使用桥接方式上网，因为此时你申请的IP地址是写在了路由器上，而不是你的机器上，这样包括你的主机，虚拟机，也包括连在路由器上的其他人的机器，都将可以上网，使用着由路由器自动分配的IP地址
    https://www.cnblogs.com/wenanry/archive/2009/12/21/1629242.html  linux网络配置
-----------------------------------【key：虚拟机配置网络】-----------------------------------------------------------------------------------------------------------------------
20180105：用virtualbox的host-only网络连接模式，本地主机连接到了虚拟机。
    http://blog.csdn.net/a627088424/article/details/47421531  linux下网络调试工具
    DNS、网关、dhcp、子网掩码、NAT、路由、桥接、host-only、ssh、端口、网络接口
    ifconfig、netstat、route、ip、tcpdump、lsof、nslookup
    
    http://blog.csdn.net/u010137431/article/details/50345717  VirtualBox的网络配置，Host Only+NAT方式
    
    【总结】
	@ openSUSE ->
		当前我的虚拟机的联网模式是host-only、NAT模式，于是在虚拟机上有两个网络接口eth0和eth1,（ifconfig -a 查看没有起来的端口），在host-only模式下（eth0），虚拟机设置静态ip地址192.168.56.101/24，可以用ssh直接登入端口22，但是不能联网.
		于是配置NAT模式，该模式可以联网，设置NAT网络（网络ip10.0.2.0/24，主机ip用dhcp），然后在linux中设置eth1并up起来，此时可以上网了（宿主机能联网）。在NAT模式下，可以设置端口映射，设置宿主机9033端口映射虚拟机的22号端口，即可用宿主机ip+9033端口登入虚拟机了。所以我现在有两种方式登入：192.168.56.101:22和172.17.72.180:9033，前者只有我的电脑能用，使用的是虚拟机的eth0（用静态ip），后者宿主机所在局域网也能登入，用dhcp动态ip。
		挂在共享文件夹：sudo mount.vboxsf share /mnt/share  
	@ ubuntu->
		http://www.linuxidc.com/Linux/2012-07/64329.htm  Ubuntu下使用Vi是方向键变乱码 退格键不能使用的解决方法
		ubuntu的共享文件夹要先在虚拟机的【设备】中点击安装【安装增强功能】，ubuntu就会自动安装，然后在root权限下挂载好已经设置的共享文件夹：mount -t vboxsf share /mnt/share/
		也要设置ip地址才能生效。编辑vi /etc/network/interfaces 然后重启网络/etc/init.d/networking restart
----------------------------------------------------------------------------------------------------------------------------------------------------------
20180108:
	【parted 分区sdb块设备，mkfs.ext4格式化，挂载在/opt上 https://www.cnblogs.com/zhangpengme/archive/2011/12/29/2305963.html】
	第十七章：存储技术设备
		@内存屏障：memory barrier    http://blog.csdn.net/world_hello_100/article/details/50131497
		@JFFS2；日志结构闪存文件系统，是最适合闪存的文件系统
		@bash> mkfs.jffs2 -e 256KiB –r /path/to/filesystem/ -o jffs2.img 对目录/path/to/filesystem/下的树建立jffs文件系统映像
		@MTD工具包：ftp://ftp.infradead.org/pub/mtd-utils   
			要在NOR或NAND设备上擦除第二个闪存分区，可以bash> flash_eraseall –j /dev/mtd/2
	第十八章：嵌入式linxu
		@元器件选择->工具链->bootloader->内存布局->内核移植->嵌入式驱动程序->根文件系统
			内存布局：
		@Booting ARM linux：/osdrv/opensource/kernel/linux-3.4.y/Documentation/arm/Booting"
			Essentially, the boot loader should provide (as a minimum) the
			following:
			1. Setup and initialise the RAM.
			2. Initialise one serial port.
			3. Detect the machine type.
			4. Setup the kernel tagged list.
			5. Call the kernel image.
	
		@ RPC  http://blog.csdn.net/ok_wolf/article/details/40987005
		@ uClibc比glibc更短小。
		@ 紧凑型中间件（compact middleware）：busybox（小存储空间的shell环境）、uclibc（glibc的简化版）、TinyX（内存紧缺的X服务器）、Thttpd（微型HTTP服务器）、uIP（微控制器的压缩版TCP/协议栈）、Pico-IrDA，这些可以运用在嵌入式系统上。
	第十九章：用户空间的驱动程序 
			大部分驱动程序倾向于工作在拥有特权的内核模式，但是有些无所谓。
		@进程调度和响应时间、访问I/O区域、访问内存区域、用户模式USB、用户模式I2C、UIO
		usb、i2c等子系统在一定程度上支持用户模式驱动程序，因此可以不用写内核代码去驱动设备。
		@是否放在内核空间的一些经验：1、如果需要与大量低速设备通信，并且性能要求一般，可以尝试放在用户模式，如果有时间性要求，就放在内核。2、如果程序需要用到内核API的服务、访问内核变量和中断处理有关，那么一般放在内核空间。 3、如果代码所做的工作大部分是策略而不是机制，用户空间可能更好。4、如果内核需要调用程序的服务，可能就要放到内核中。5、在内核中不容易做浮点运算，但是在用户空间可以使用FPU（floating-point unit）指令。
		
		【有一个基于ARM9-S3C3410的网络收音机 http://www.eeworld.com.cn/mcu/article_2017091134326.html 】
----------------------------------------------------------------------------------------------------------------------------------------------------------
20180109：跟踪系统调用：strace data 2>&1 | grep open 【重定向：错误输出也定向到标准输出】，也可以 strace -e trace=open data
	export 理解为定义环境列表的变量，在当前进程中可用。
	会话：一组进程组（任务）
	伪终端：一组相互连接的虚拟设备，主从设备，之间有一条IPC信道，供数据双向传递。
	《linux/unix系统编程手册》
	第三章：系统编程概念
		GUN C 语言函数库glibc，用ldd myprog | grep libc可以查看程序链接库的版本
    
------------------------------【key: 宝华】----------------------------------------------------------------------------------------------------------------------------
20180110：学习宋宝华的联系代码。https://github.com/liuzhiping1/training 【宝华的笔记，可以节约我好多时间，如获至宝】
	shell：
		getopts h:ms option 判断命令行选项‘-’后是否为h或ms，没有参数就option为？，有的话实际参数给特殊变量OPTARG，特殊变量OPTIND是下一个参数的索引，初始为1
		shift： 位置参数左移
	backtrace：http://www.linuxidc.com/Linux/2012-11/73470.htm  追踪函数调用堆栈以及定位段错误
	proc_create_data函数（./include/linux/proc_fs.h） 【通过这个在linux下找更快： find -name "*" | xargs grep proc_create_data 2>/dev/null】
	【linux中面向对象的思想非常到位，定义数据和方法，高内聚和低耦合】
	【内核代码的头文件包含都在linux文件夹中如‘#include <linux/types.h>’，应用程序的还有平台的路径】
	makefile： 用"define func  ...  endef "来定义模块，用$(call func)来调用
	http://www.jobbole.com/  伯乐资源，里面东西还挺多的
	https://github.com/jobbole/ 史上最全的开发和设计资源大全
	LD_PRELOAD：用于动态库的加载的环境变量，加载顺序为LD_PRELOAD>LD_LIBRARY_PATH>/etc/ld.so.cache>/lib>/usr/lib
	mount 的 -t 指定文件类型，【见man】 在 cat /proc/filesystems 里面有
	设置主机环境：【见/training/env/setup-embedded-host.readme】
		(1)  SSH server:
			sudo apt-get install openssh-server
			sudo /etc/init.d/ssh stop
			sudo /etc/init.d/ssh start
		
		(2)  NFS server:
			sudo apt-get install nfs-kernel-server
			
			打开/etc/exports文件，在末尾加入：
			/home/baohua *(rw,sync,no_root_squash)
			注：nfs允许挂载的目录及权限，在文件/etc/exports中进行定义，各字段含义如下：
			/home/xgc：要共享的目录
			* ：允许所有的网段访问
			rw ：读写权限
			sync：资料同步写入内在和硬盘
			no_root_squash：nfs客户端共享目录使用者权限
			重启服务：
			#sudo service nfs-kernel-server restart
			#showmount -e
			现在可以在本机上试一下：
			#sudo mount -t nfs localhost:/home/baohua /mnt
			#sudo umount /mnt
			如果用在嵌入式设备上挂载，要加上参数-o nolock
		
		(3)  tftp server:
		
			1.安装tftp-server
			sudo apt-get install tftpd-hpa
			sudo apt-get install tftp-hpa(如果不需要客户端可以不安装)
			tftp-hpa是客户端
			tftpd-hpa是服务器端
			
			2.配置TFTP服务器
			sudo vim /etc/default/tftpd-hpa
			将原来的内容改为:
			TFTP_USERNAME="tftp"
			TFTP_ADDRESS="0.0.0.0:69"
			TFTP_DIRECTORY="tftp根目录" #服务器目录,需要设置权限为777,chomd 777
			TFTP_OPTIONS="-l -c -s"
			
			3.重新启动TFTP服务
			sudo service tftpd-hpa restart
---------------------------------【key: LCD驱动】------------------------------------------------------------------------------------------------------------------------
20180111：写LCD段码驱动TM1723
	芯片与mcu用spi串口通信，集成段码输出IO、PWM0~3输出、按键4X3读入。
	芯片级驱动 与 显示按键级驱动分层。
	将段码逻辑转化成资源文件resource.txt,然后在写成头文件，具体逻辑C实现用相关宏即可。
--------------------------------【key: linux 应用】----------------------------------------------------------------------------------------------------------------------
20180112：
readelf -S  Displays the information contained in the file's section headers
strace ./a.out 1>&log
strace ./a.out >log 2>&1 【strace是一个必不可少的 调试工具，strace用来监视系统调用。你不仅可以调试一个新开始的程序，也可以调试一个已经在运行的程序（把strace绑定到一个已有的PID上 面）。starce 的另一个用处是解决和动态库相关的问题】
int is_little_endian(void)
{
        unsigned short flag=0x4321;

        if(*(unsigned char*)&flag==0x21)
                return 1;
        else
                return 0;
}//字节顺序按照右低左高的就是小端。
if(signal(SIGINT,sigHandler) == SIG_ERR) --信号处理器
key_t ftok( const char * fname, int id ) --系统建立IPC通讯 （消息队列、信号量和共享内存） 时必须指定一个ID值。通常情况下，该id值通过ftok函数得到。
 pid_t wait (int * status); --wait()会暂时停止目前进程的执行，直到有信号来到或子进程结束
 atoi --atoi, atol, atoll - convert a string to an integer
 ------------------------------【key: 虚拟机】----------------------------------------------------------------------------------------------------------------------------
 20180115:编译qemu虚拟机，http://blog.csdn.net/linyt/article/details/42504975   https://jingyan.baidu.com/article/f00622281253e8fbd3f0c814.html
 安装前需要的工具：
 sudo apt-get install autoconf automake libtool 【这个没装会报错】
 sudo apt-get install zlib1g-dev
sudo apt-get install libglib2.0-0
sudo apt-get install libglib2.0-dev
配置内核：versatile_defconfig 这个常用 ：make versatile_defconfig ARCH=arm
这个也用make CROSS_COMPILE=arm-linux-gnueabi- ARCH=arm vexpress_defconfig
Ubuntu：
sudo apt-get insatll ncurses-dev
这个教程挺好的：http://blog.csdn.net/aggresss/article/details/74834155 虚拟机就是开发板
set：shell的变量，env：用户环境变量，export：将shell变量export到用户变量
【**】ubuntu shell 下默认的脚本解析器是dash, 会使一些bash脚本执行失败，通过如下方式改回bash:sudo dpkg-reconfigure dash 
http://blog.csdn.net/h002399/article/details/44940777  linux下的路由表详解【重要】
【make】make的调试命令选项：-n 、-p、函数$(warning xxx)
--------------------------【key: 路由】--------------------------------------------------------------------------------------------------------------------------------
20180116： 接着昨天路由的学习
@规则（rule）

　　规则是策略性的关键性的新的概念。我们可以用自然语言这样描述规则，例如我门可以指定这样的规则：

　　规则一：“所有来自192.16.152.24的IP包，使用路由表10， 本规则的优先级别是1500”

　　规则二：“所有的包，使用路由表253，本规则的优先级别是32767”

　　我们可以看到，规则包含3个要素：

　　什么样的包，将应用本规则（所谓的SELECTOR，可能是filter更能反映其作用）；

　　符合本规则的包将对其采取什么动作（ACTION），例如用那个表；

　　本规则的优先级别。优先级别越高的规则越先匹配（数值越小优先级别越高）。
@相关命令：route【Gateway	网关地址，”*” 表示目标是本主机所属的网络，不需要路由】
			# route  [add|del] [-net|-host] target [netmask Nm] [gw Gw] [[dev] If] 
						add : 添加一条路由规则
                       del : 删除一条路由规则
                       -net : 目的地址是一个网络
                       -host : 目的地址是一个主机
                       target : 目的网络或主机
                       netmask : 目的地址的网络掩码
                       gw : 路由数据包通过的网关
                       dev : 为路由指定的网络接口
		route 命令使用举例
			添加到主机的路由
			
			# route add -host 192.168.1.2 dev eth0:0
			# route add -host 10.20.30.148 gw 10.20.30.40
			添加到网络的路由
			
			# route add -net 10.20.30.40 netmask 255.255.255.248 eth0
			# route add -net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41
			# route add -net 192.168.1.0/24 eth1
			添加默认路由
			
			# route add default gw 192.168.1.1
			删除路由
			
			# route del -host 192.168.1.2 dev eth0:0
			# route del -host 10.20.30.148 gw 10.20.30.40
			# route del -net 10.20.30.40 netmask 255.255.255.248 eth0
			# route del -net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41
			# route del -net 192.168.1.0/24 eth1
			# route del default gw 192.168.1.1
		# sysctl -w net.ipv4.ip_forward=1 设置包的转发 
		# sysctl  net.ipv4.ip_forward 查看当前系统是否支持转发 
		【	# sysctl reads settings from the following locations:
			#   /boot/sysctl.conf-<kernelversion>
			#   /lib/sysctl.d/*.conf
			#   /usr/lib/sysctl.d/*.conf
			#   /usr/local/lib/sysctl.d/*.conf
			#   /etc/sysctl.d/*.conf
			#   /run/sysctl.d/*.conf
			#   /etc/sysctl.conf 】
	当一个主机不支持策略路由时，它只使用了两个路由表，一个是ip_fib_local_table，用于本地，另一个是ip_fib_main_table，用于接发。只有在查找ip_fib_local_table表时没有找到匹配的路由（不是发给本地的）它才会去查找ip_fib_main_table。当一个主机支持策略路由时，它就有可能存在着多个路由表，因而路由表的选择也就是查找的一部分。路由表的选择是由策略来确定的，而策略则是由应用（用户）来指定的，如能过ip rule命令：
ip rule add from 10.1.1.0/24 table TR1	
ip rule add iff eth0 table RT2

@如上，第一条命令创建了基于源地址路由的一条策略，这个策略使用了RT1这个路由表，第二条命令创建了基于数据包入口的一个策略，这个策略使用了RT2这个路由表。当被指定的路由表不存在时，相应的路由表将被创建。
步骤一：设置各个网络接口的IP，和默认网关：
ip addr add 172.16.100.1/24 dev eth1
ip route add default via a.b.c.d dev eth1
其它接口IP的设置和第一个接口一样，这时，如果没有其它设置，则所有的数据通过这个默认网关路由出去。
步骤二：使子网172.16.10.0/24可以通过gw2路由出去
ip route add 172.16.10.0/24 via e.f.g.h dev eth2
步骤三：添加一个路由表
echo “250 HS_RT” >> /etc/iproute2/rt_tables
步骤四：使用策略路由使192.168.1.0/24网段的主机可以通过e.f.g.h这个网关上网
ip rule add from 192.168.1.0/24 dev eth0 table HS_RT pref 32765
ip route add default via e.f.g.h dev eth2
iptables –t nat –A POSTROUTING –s 192.168.1.0/24 –j MASQUERADE
步骤五：刷新路由cache，使新的路由表生效
ip route flush cache
这样就可以实现了以上要求的策略路由了，并且可以通过traceroute工具来检测上面的设置是否能正常工作。
【在掌阅app上买了宋宝华的linux驱动开发详解】

【在opensuse上装qemu-2.11.0.tar.xz，之前2.0版本不兼容glib2.0】
虚拟机qemu：
 qemu-system-arm -M vexpress-a9 -kernel arch/arm/boot/zImage -nographic -append "console=ttyAMA0"
	busybox：make defconfig ARCH=arm ;make menuconfig ;make ARCH=arm CROSS_COMPILE=arm-hisiv300-linux- install 
	创建根文件系统：
		1.  创建rootfs目录（根目录），根文件系统内的文件全部放到这里：mkdir -p rootfs/{dev,etc/init.d,lib}
		2. 拷贝busybox命令到根目录下 ：cp busybox-1.20.2/_install/* -r rootfs/
		3. 从工具链中拷贝运行库到lib目录下：cp -P /opt/hisi-linux/x86-arm/arm-hisiv300-linux/arm-hisiv300-linux-uclibcgnueabi/lib/* rootfs/lib/
		4. 创建4个tty端终设备
		sudo mknod rootfs/dev/tty1 c 4 1
		sudo mknod rootfs/dev/tty2 c 4 2
		sudo mknod rootfs/dev/tty3 c 4 3
		sudo mknod rootfs/dev/tty4 c 4 4
	制作文件系统镜像：
		1. 生成32M大小的镜像：dd if=/dev/zero of=a9rootfs.ext3 bs=1M count=32
		2. 格式化成ext3文件系统 ：mkfs.ext3 a9rootfs.ext3
		3.  将文件拷贝到镜像中
			sudo mkdir tmpfs
			sudo mount -t ext3 a9rootfs.ext3 tmpfs/ -o loop
			sudo cp -r rootfs/*  tmpfs/
			sudo umount tmpfs
	启动：qemu-system-arm -M vexpress-a9 -m 512M -kernel zImage -nographic -append "root=/dev/mmcblk0 console=ttyAMA0" -sd /opt/Hi3516A_SDK_V1.0.6.0/osdrv/opensource/busybox/a9rootfs.ext3  【成功启动！！！】
--------------------------【key: 路由器就是开发板,虚拟机就是开发板】--------------------------------------------------------------------------------------------------------------------------------
http://blog.csdn.net/aggresss/article/details/52753098 路由器就是开发板：应用openWrt系统的路由器【这个一定要试一试】
http://blog.csdn.net/aggresss/article/details/74834155  虚拟机就是开发板  【这个关于qemu实践的更加详细靠谱一点，u-boot是2017-1版本，linux-kernel是4.1.38版本，busybox版本是1.26.2】
http://www.linuxfromscratch.org/  LFS
http://ftp.denx.de/pub/u-boot/ u-boot 【 export ARCH=arm ;export CROSS_COMPILE=arm-linux-gnueabi-;make vexpress_ca9x4_defconfig;make】
==1. 首先安装交叉编译器，执行： sudo apt-get install gcc-arm-linux-gnueabi
==        2. 下载U-Boot源文件： http://ftp.denx.de/pub/u-boot/ 我下载的是 u-boot-2017.01.tar.bz2
==        3. 解压源文件  tar jvxf u-boot-2017.01.tar.bz2 -C xxxx  （xxx为需要解压的目录）
==        4. 进入U-Boot 源文件目录，然后执行：
==                export ARCH=arm 
==                export CROSS_COMPILE=arm-linux-gnueabi-
==                make vexpress_ca9x4_defconfig
==                make
==                编译完成后，如果目录下生成 u-boot 文件，则说明编译成功。
==        5. 在U-Boot源码目录下编写脚本 run.sh
==                qemu-system-arm \
==                    -M vexpress-a9 \
==                    -nographic \
==                    -m 512M \
==                    -kernel u-boot
==        然后 chmod +x run.sh 增加文件执行权限。
==        6. 最后执行  ./run.sh
https://www.kernel.org/pub/linux/kernel/  linux-kernel 【export ARCH=arm ;export CROSS_COMPILE=arm-linux-gnueabi- ; make vexpress_defconfig; make zImage; make modules; make dtbs】
https://busybox.net/downloads/  busybox
**第一步：编译内核
**        1. 首先安装交叉编译器，执行： sudo apt-get install gcc-arm-linux-gnueabi
**        2. 下载内核源文件 https://www.kernel.org/pub/linux/kernel/ ，我这里下载的是 4.1.38 版本，一个比较稳定的版本；
**        3.解压内核  tar zvxf linux-4.1.38.tar.gz -C xxxx  （xxxx为需要解压的目录）
**        4. 进入kernel 源文件目录，然后执行：
**                export ARCH=arm 
**                export CROSS_COMPILE=arm-linux-gnueabi-
**                make vexpress_defconfig
**                make zImage
**                make modules
**                make dtbs
**                编译后生成 在 arch/arm/boot 目录下生成 zImage 文件，则说明编译成功。
**        第二步：制作根文件系统
**        1.制作根文件系统首先要生成一个虚拟磁盘，创建一个虚拟磁盘的两种方法：
**                dd if=/dev/zero of=vexpress.img bs=512 count=$((2*1024*100))
**                qemu-img create -f raw vexpress.img 100M
**        这两种方法任选一种执行就可以，目的就是生成一个vexpress.img的虚拟镜像文件，为了更好的兼容性选择 raw 格式的镜像。
**        2.虚拟磁盘中创建分区并修改：
**                (1). fdisk vexpress.img ，然后使用n命令创建分区，各种下一步就行；
**                (2). losetup /dev/loop0 vexpress.img ，挂载vexpress.img到/dev/loop0设备上；
**                (3). partx -u /dev/loop0 ，使用partx命令让系统刷新系统的分区信息；
**                (4). mkfs.ext2 /dev/loop0 ，制作ext2格式的文件系统；
**                (5). mkdir rootfs ，建立一个rootfs目录用来作为挂载目录，
**                      mount -o loop /dev/loop0 ./rootfs ，将生成的ext2格式的分区挂载到rootfs目录；
**                (6). 执行到这里虚拟磁盘就已经制作好了，下面的两个步骤是卸载磁盘时的操作，可以先跳过，直接到第三节去编译 busybox；
**                (7). partx -d /dev/loop0 ，卸载loop0设备下的分区； 如果执行不成功可以试试  sudo umount -f rootfs
**                (8). losetup -d /dev/loop0 ，卸载loop0设备；
**                说明：
**                如果直接使用 mkfs.ext3 写入img文件，无法使用fdisk显示分区信息；
**                fdisk n命令 默认的first sector 是2048扇区；默认分区名为 文件名+分区序号；
**                mount 挂载空分区会报错 wrong fs type, bad option, bad superblock；
**                losetup /dev/loop0 vexpress.img 命令相当于mount命令中的 -o loop 参数；
**                partx -u /dev/loop0  强制内核刷新可识别分区；
**                查看分区类型  df -Th；
**        3.编译 Busybox：
**                (1). 下载Busybox https://busybox.net/downloads/ ，我下载的版本是 1.26.2 ，一个比较稳定的版本；
**                (2). 解压内核  tar jvxf busybox-1.26.2.tar.bz2 -C xxxx  （xxx为需要解压的目录）
**                (3). 进入 Busybox 源文件目录下执行 make menuconfig
**                        做如下配置：
**[cpp] view plain copy
**Busybox Settings  --->  
**    Build Options  --->  
**        [*] Build BusyBox as a static binary (no shared libs)  
**        (arm-linux-gnueabi-) Cross Compiler prefix  
**                        使用交叉编译器编译Busybox
**                (4). 执行 make 编译Busybox  【编译busubox会有一些错误，把它们在配置的时候去掉就行，不编了】
**                (5). 执行 make install 会在 _install 目录下生成 需要的文件 bin linuxrc sbin usr  ；
**        4.制作根文件系统：
**                (1). 拷贝busybox
**                        sudo cp -raf busybox/_install/*  rootfs/
**                (2). 拷贝运行库
**                        sudo cp -arf /usr/arm-linux-gnueabi/lib rootfs/
**                        sudo rm rootfs/lib/*.a
**                        sudo arm-linux-gnueabi-strip rootfs/lib/*
**                (3). 创建必要目录
**                        sudo mkdir -p rootfs/proc/
**                        sudo mkdir -p rootfs/sys/
**                        sudo mkdir -p rootfs/tmp/
**                        sudo mkdir -p rootfs/root/
**                        sudo mkdir -p rootfs/var/
**                        sudo mkdir -p rootfs/mnt/
**                (4). 创建必要节点
**                        sudo mkdir -p rootfs/dev/
**                        sudo mknod rootfs/dev/tty1 c 4 1
**                        sudo mknod rootfs/dev/tty2 c 4 2
**                        sudo mknod rootfs/dev/tty3 c 4 3
**                        sudo mknod rootfs/dev/tty4 c 4 4
**                        sudo mknod rootfs/dev/console c 5 1
**                        sudo mknod rootfs/dev/null c 1 3
**                (5). 制作必要etc文件
**                        etc 目录下的必要文件有5个：fstab，init.d/rcS，inittab，profile，sysconfig/HOSTNAME
**                        我把这五个文件放到 https://github.com/aggresss/LKDemo 中 tools 目录下的 etc.tar.gz 里，可以下载并解压后使用；
**                        sudo cp -arf etc rootfs/
**        到这里根文件系统就已制作完成，退出rootfs目录并执行 losetup -d /dev/loop0 卸载虚拟磁盘文件。
**        第三步：调试运行
**        1. 启动Linux最小系统需要我们刚才生成的3个文件：
**                (1). Linux kernel目录下 arch/arm/boot/dts/vexpress-v2p-ca9.dtb  文件；
**                (2). Linux kernel目录下 arch/arm/boot/zImage 文件
**                (3). 生成的虚拟磁盘文件： vexpress.img；
**        将这三个文件放到同一个目录下。
**        2. 制作启动脚本：
**                在上面三个文件的同目录下创建启动脚本 vim run_linux.sh
**[cpp] view plain copy
**qemu-system-arm \  
**    -nographic \  
**    -sd vexpress.img \  
**    -M vexpress-a9 \  
**    -m 512M \  
**    -kernel zImage \  
**    -dtb vexpress-v2p-ca9.dtb \  
**    -smp 4 \  
**    -append "init=/linuxrc root=/dev/mmcblk0p1 rw rootwait earlyprintk console=ttyAMA0"  
**                增加可执行权限 chmod +x run_linux.sh
**        3. 调试运行：
**                执行 ./run_linux.sh，即可在模拟的开发板上运行Linux系统，下面是运行后的截图：
**
**                
**
**        4. 关闭模拟开发板进程：**
**                将下面的命令做成脚本运行便可以彻底关闭已经运行的QEMU进程：
**                ps -A | grep qemu-system-arm | awk '{print $1}' | xargs sudo kill -9
--------------------------【key: vim】--------------------------------------------------------------------------------------------------------------------------------
20180118:
【vim】设置好了tags文件，在定位变量/函数的定义时，最常用的快捷键是：Ctrl + ]，分屏：: 'set vsplit file' 切换分屏光标 ：'Ctrl + w'
		{ctags（Generate tag files for source code）是vim下方便代码阅读的工具。尽管ctags也可以支持其它编辑器，但是它正式支持的只有VIM。并且VIM中已经默认安装了Ctags，它可以帮助程序员很容易地浏览源代码。
		熟练的使用ctags仅需记住下面七条命令：
		1．$ctags –R * ($为Linux系统Shell提示符,这个命令上面已经有所介绍)
		2. $ vi –t tag (请把tag替换为您欲查找的变量或函数名)
		3．:ts(ts助记字：tagslist, “:”开头的命令为VI中命令行模式命令)
		4．:tp(tp助记字：tagspreview)---此命令不常用，可以不用记
		5．:tn(tn助记字：tagsnext) ---此命令不常用，可以不用记
		6．Ctrl+ ]跳到光标所在函数或者结构体的定义处
		7．Ctrl+ T返回查找或跳转
		“$vi –t tag” ：在运行vim的时候加上“-t”参数，例如：[/usr/src]$vim -tmain这个命令将打开定义“main”（变量或函数或其它）的文件，并把光标定位到这一行。如果这个变量或函数有多处定义，
		在VI命令行模式 “：ts”命令就能列出一个列表供用户选择。
		“：tp”为上一个tag标记文件，
		“：tn”为下一个tag标记文件。
		当然，若当前tags文件中用户所查找的变量或函数名只有一个，“:tp,:tn”命令不可用。
		（最方便的方法是把光标移到变量名或函数名上，然后按下“Ctrl+]”，这样就能直接跳到这个变量或函数定义的源文件中，并把光标定位到这一行。用“Ctrl+T”可以退回原来的地方。即使用户使用了N次“Ctrl+]”查找了N个变量，按N次“Ctrl+t”也能回到最初打开的文件，它会按原路返回 。
		注意：运行vim的时候，必须在“tags”文件所在的目录下运行。否则，运行vim的时候还要用“:set tags=”命令设定“tags”文件的路径，这样vim才能找到“tags”文件。在完成编码时，可以手工删掉tags文件}
【解决qemu启动失败：audio驱动问题】-按照提示输入export QEMU_AUDIO_DRV=wav;export QEMU_WAV_PATH=$HOME/tune.wav 即可。

==韦东山-嵌入式linux开发完全手册：编译进内核的入口是cs89x0_probe，编译成模块的入口函数是init_module。为什么是这样？
1、arm-hisiv300-linux-objcopy -O binary -R .note -R .comment -S vmlinux linux.bin -> 2、gzip -9 linux.bin -> 3、 mkimage -A arm -O linux -T kernel -C gzip -a 0x30008000 -e 0x30008000 -n "Linux Kernel Image" -d linux.bin.gz uImage【mkimage工具在编译u-boot后的tools中有】
【Bootloader与Kernel间参数传递机制】：linux-- arch/arm/include/asm/setup.h   u-boot--arch/arm/include/asm/setup.h ，u-boot和linux中定义相同的数据结构，u-boot把参数放在数据结构中，把地址传递给内核，实现数据的单向传递。
--------------------------【key: 看完书后就多看代码】--------------------------------------------------------------------------------------------------------------------------------
20180119：
http://releases.linaro.org/components/toolchain/binaries/6.1-2016.08/ arm交叉编译工具链
【qemu】qemu-system-arm -nographic -M vexpress-a9 -m 512M -kernel zImage -dtb vexpress-v2p-ca9.dtb -append "init=linuxrc root=/dev/mmcblk0p1 rw rootwait earlyprintk console=ttyAMA0"  今天又有点反应了！！！【注意：昨天没有反应的原因是因为脚本里面的console和‘=’之间有个空格】
【总结一下】1、uboot-2017.01：引导内核启动的程序，支持多种cpu和系统，当前我只关注arm系统的a9芯片，uboot在进行两个阶段的引导之后把控制权交给linux内核，在某个区域存放了传递给内核的参数，利用taglist，他们定义相同的数据类型，uboot把地址给内核，交叉编译生成uboot映像。
2、busybox-1.26.2：在嵌入式系统上的shell工具，在编译的时候定制一下就行，然后编译安装，生成一个文件夹_install，具体可以查看Makefile和Kconfig
3、linux3.4.35：配置、编译zImage、编译modules、安装modules_install、make dtbs.
4、qemu：qemu-system-arm -nographic -M vexpress-a9 -m 512M -kernel zImage -dtb vexpress-v2p-ca9.dtb -append "init=linuxrc root=/dev/mmcblk0p1 rw rootwait earlyprintk console=ttyAMA0"  
5、制作根文件系统：dd if=/dev/zero of=vexpress.img bs=512 count=$((1024*2*100)) 生成100M的数据文件，mkfs.ext3 vexpress.img 格式化改文件，然后用mount -t ext3 vexpress.img tmpfs/ 直接把vexpress.img挂载在tmpfs上，之后就可以像普通文件一样往里面添加或删除文件了，df -T|l 查看tmpfs挂在那个loop上，通过umount /dev/loop? 卸载。

内核的组成部分：进程调度，内存管理、虚拟文件系统、进程间通信、网络接口
--------------------------【key: 调试】--------------------------------------------------------------------------------------------------------------------------------
20180122:
WARN_ON()可以作为一个调试的小技巧，进入一个函数后，不知道函数是怎么一步一步调用进来的，可以在该函数中加入WARN_ON(1)函数
1、内核调试：gdb，printk()，DEBUG_LL和EARLY_PRINTK，/proc ，oops，strace，KGDB，BUG_ON()和WARN_ON()，
2、应用调试：top，vmstat，iostat，sysctl，netstat，sar1和sar2	，高级分析手段-Oprofile，gprof
【内建】linux有内建函数，shell有内建命令，用type可以查看类型
【自旋锁】spin_lock/spin_lock_irq/spin_lock_irqsave:都关闭内核抢占，_irq 关闭了本地中断，但是退出时开启中断，irqsave 保存了中断的状态
【等待队列】休眠方式：wait_event(queue, condition)：进程将被置于非中断休眠，wait_event_interruptible(queue, condition)：进程可被信号中断休眠,返回非0值表示休眠被信号中断，wait_event_timeout(queue, condition, timeout)    /*等待限定时间jiffy，condition满足其一返回0*/。 唤醒函数：void wake_up(wait_queue_head_t *queue);    /*唤醒等待在给定queue上的所有进程*
【驱动程序结构】
Linux的设备驱动程序可以分为3个主要组成部分：
1. 自动配置和初始化子程序，负责监测所要驱动的硬件设备是否存在和能否正常工作。如果该设备正常，则对这个设备及其相关的设备驱动程序需要的软件状态进行初始化。这部分驱动程序仅在初始化时被调用一次。
2. 服务于I/O请求的子程序，又称为驱动程序的上半部分。调用这部分程序是由于系统调用的结果。这部分程序在执行时，系统仍认为是与进行调用的进程属于同一个进程，只是由用户态变成了核心态，具有进行此系统调用的用户程序的运行环境，因而可以在其中调用sleep()等与进行运行环境有关的函数。
3. 中断服务子程序，又称为驱动程序的下半部分。在Linux系统中，并不是直接从中断向量表中调用设备驱动程序的中断服务子程序，而是由Linux系统来接收硬件中断，再由系统调用中断服务子程序。中断可以在任何一个进程运行时产生，因而在中断服务程序被调用时，不能依赖于任何进程的状态，也就不能调用任何与进程运行环境有关的函数。因为设备驱动程序一般支持同一类型的若干设备，所以一般在系统调用中断服务子程序时，都带有一个或多个参数，以唯一标识请求服务的设备。
【自旋锁和信号量】鉴于自旋锁与信号量的上述特点，一般而言，自旋锁适合于保持时间非常短的情况，它可以在任何上下文使用；信号量适合于保持时间较长的情况，只能在进程上下文使用。如果被保护的共享资源只在进程上下文访问，则可以以信号量来保护该共享资源，
如果对共享资源的访问时间非常短，自旋锁也是好的选择。
但是，如果被保护的共享资源需要在中断上下文访问
（包括底半部即中断处理句柄和顶半部即软中断），就必须使用自旋锁。
--------------------------【key: 驱动开发】-第六章和第七章-------------------------------------------------------------------------------------------------------------------------------
20180123：
驱动的学习呢是先熟悉机制，再熟悉内核接口，再实践开发。这个是基本的理论学习路线。当前要熟悉内核接口。
【字符设备内核接口】：结构体cdev，cdev_init(),cdev_alloc(),cdev_put(),cdev_add(),cdev_del(),[un]register_chrdev_region(),alloc_chrdev_region(),copy_to_user(),copy_from_user(),
字符设备的组成：加载/卸载函数，file_operations结构体中的成员函数
【通过vim-ctags查看源码】【总结：字符设备主要围绕cdev结构体】【强调：linux的面向对象和分层思想，数据和方法的封装】【坚持学习linux技术，夯实基础打磨驱动】
【驱动的并发控制】并发和竞态-1、多cpu，2、单cpu内进程和抢占它的进程3、中断（硬中断、软中断、tasklet、底半部）与进程之间。
解决竞态问题的途径就是保证对共享资源的互斥访问，就是一个执行单元在访问共享资源的时候，其他的执行单元被禁止访问。访问共享资源的代码区域称为【临界区】，临界区需要被某种互斥机制加以保护。【中断屏蔽、原子操作、自旋锁、信号量、互斥体等】这些途径可以实现互斥。
【编译乱序和执行乱序】编译乱序是编译器优化的结果，可以用编译屏障barrier()
以下为并发控制机制：
【1中断屏蔽】驱动不推荐，中断屏蔽使得中断与进程之间的并发不再发生，而且linux内核的进程调度等操作都依赖中断来实现，内核抢占进程之间的并发也避免了。内核接口：local_irq_disable(),local_irq_enable(),它们只能禁止和使能本cpu内的中断，因此并不能解决smp多cpu的竞态，驱动中使用它们通常意味着一个bug，还有local_irq_save(flag)/local_bh_disable()
【2原子操作】linux内核提供的原子操作分两类，分别针对位和整形变量进行原子操作。位和整形变量的原子操作都依赖于底层cpu的原子操作，因此所有这些函数都与cpu架构密切相关。整形原子操作：atomic_set(atomic_t *v , int i)/ATOMIC_INIT()/atomic_read()/atomic_add(int i , atomic_t)/atomic_sub(int i,atomic_t *v)/set_bit(nr,void *addr)
【3自旋锁】在arm体系架构下，自旋锁的实现借用了ldrex指令、strex指令、ARM处理器内存屏障指令dmb和dsb、wfe指令和sev指令。既要保证排他性，也要处理好内存屏障。4种操作：1、定义自旋锁 spinlock_t lock; 2、初始化自旋锁 spin_lock_init(lock) 3、获得自旋锁 spin_lock(lock) 该宏成功获得锁就马上返回，否则自旋直到自旋锁的保持者释放。 spin_trylock(lock) 该宏不阻塞，获得成功就返回true，失败就返回false，实际上不再“在原地打转了” 4、spin_unlock(lock)
spin_lock/spin_unlock是自旋锁机制的基础，他们和关开中断local_irq_disable(able)、关开底半部local_bh_disable(able)、关开中断并保存状态字local_irq_save()/local_irq_restore()结合形成了整套自旋锁机制。
spin_lock_irq() = spin_lock() + local_irq_disable()
spin_lock_irqsave() = spin_lock() + local_irq_save()
spin_lock_bh() = spin_lock() + lock_bh_disable() 解锁的同理。
使用自旋锁期间不能调用可能引起进程调度的函数，如copy_from_user()/copy_to_user()/kmalloc()/msleep()等函数，可能导致内核崩溃。
【4读写自旋锁】rwlock_t lock; rwlock_init(&lock);read_lock(&lock);write_lock_irqsave(&lick)在读的时候是可以并发的，所以多个进程同时读的话应该不锁，所以自旋锁衍生出了读写自旋锁，它允许读的并发，但是写操作只能最多一个写进程
【5顺序锁】读写自旋锁的进一步优化，允许读写同时进行，但是读的期间发生了写操作那么读操作要重新读以保证完整性。具体见书上page-175
【6读-复制-更新RCU】
详见书上178页
【7信号量】1、定义 struct semaphore sem；2、初始化 void sema_init(struct semaphore *sem,int val);3、获得信号量 void down(struct semaphore *sem);该函数用于获得信号量sem，会导致*睡眠*，因此不能在中断上下文中使用，int down_interruptible(struct semaphore * sem);类似down()，但是能够被信号打断，打断之后返回值非0. int down_trylock()不会导致调用者睡眠，可以用在中断上下文中。
4、释放信号量 void up(struct semaphore * sem),释放信号量sem，唤醒等待者
【8互斥体】用在用户空间，应该和信号量用法类似
【3项原则】1、当锁不能获得的时候，使用互斥体的开销是进程上下文切换时间，自旋锁的开销是等待获得自旋锁（由临界区执行时间决定），若临界区比较小，用自旋锁，若临界区大使用互斥体。2、互斥体所保护的临界区可以包含可能引起阻塞的代码，二自旋锁则绝对要避免用来保护包含这样的代码的临界区。因为阻塞意味着要进行进程的切换，如果进程切换出去后，另一个进程企图获得本自旋锁就会发生死锁了。3、互斥体存在于进程上下文，因此被保护的共享资源需要在中断和软中断情况下使用，则在互斥体和自旋锁之间只能使用自旋锁。当然一定要用互斥体则只能通过mutex_trylock的方式进行，不能获取就要立即返回以避免阻塞。
【9完成量】用于一个执行单元等待另一个执行单元执行完某事。1、定义 struct completion my_completion；2、初始化 init_completion(&my_completion);3、等待完成量 void wait_forcompletion(struct completion *c);4、唤醒完成量 void complete(struct completion *c);void complete_all(struct completion *c)
【第八章 linux设备中的阻塞和非阻塞I/O】
	1、阻塞I/O 阻塞是指在执行设备操作时若不能获得资源则挂起进程直到满足可操作的条件后再进行操作。被挂起的进程进入睡眠状态，被从调度器的运行队列移走，直到条件满足，而非阻塞操作的进程在不能进行设备操作时并不挂起，它要不就放弃要不就不停的查询，直到可以进行操作为止。
	进程睡眠之后，需要确保在某个地方唤醒，不然就永远醒不来了，而最大的可能是在中断里唤醒，因为在硬件资源获得的同时往往伴随着一个中断。
	进程睡眠之后，需要确保在某个地方唤醒，不然就永远醒不来了，而最大的可能是在中断里唤醒，因为在硬件资源获得的同时往往伴随着一个中断。
	在打开文件时可以指定是否已阻塞的方式打开，还可以通过ioctl()和fcntl()的方式改变读写的方式。
	2、等待队列
	在驱动程序中使用wait queue来实现阻塞进程的唤醒，1)定义等待队列头部 wait_queue_head_t my_queue 2)初始化头部 init_waitqueue_head()    3)定义等待队列元素 DECLARE_WATIQUEUE(name,tsk) 4)添加/移除等待队列 add_wait_queue()/remove_wait_queue() 5).等待事件wait_event()/wait_event_interruptible()/wait_event_timeout()/wait_event_interruptible_timeout() 6).唤醒队列 wake_up()/wake_up_interruptible()
	wake_up可以唤醒TASK_INTERRUPTIBLE和TASK_UNINTERRUPTIBLE的进程，而wake_up_interruptible()只能唤醒TASK_INTERRUPTIBLE的进程
	【注意：当多个等待队列、信号量、互斥体等机制同时出现时，谨防死锁】
	3、轮询操作
	当多路复用的文件数量庞大、IO流量频繁的时候，一般不太适合使用select()和poll()，此种情况下，使用epoll，epoll不会随着fd的数目增长而降低效率，select则会随着fd的数量增多性能下降明显
	设备驱动中的轮询编程：
--------------------------【key: 驱动开发】-第九章-------------------------------------------------------------------------------------------------------------------------------
20180124：【linux设备驱动中的异步通知和异步I/O 】
异步通知机制由驱动主动通知应用程序。一旦设备就绪就主动通知应用，不需要查询设备状态
异步IO：应用发起IO请求后立即返回，之后再查询IO完成情况，或者IO完成后被调回。
	@linux异步通知编程：使用信号来实现
	SIGHUP-挂起  SIGINT-终端中断 SIGQUIT-终端退出 SIGILL-无效命令 等等
	进程捕获一个信号后有相应的代码处理，否则内核将采用默认行为处理。
	【信号的接收】可以使用signal()函数处理对应信号的处理函数,如果signal()调用成功，返回最后一次为信号signum绑定的处理函数的handler值，失败则返回SIG_ERR。
	sigaction()函数可以改变进程接收到特定信号后的行为。
	【信号的释放】为使得设备支持异步通知机制，驱动程序中涉及3项工作：
	1、支持F_SETOWN命令，能在这个控制命令处理中处置filp->f_owner为对应的进程ID，内核已经完成，驱动无需处理
	2、支持F_SETFL命令的处理，每当FASYNC标志改变时，驱动中的fasync()函数将得以执行，因此驱动中要实现fasync()函数 
	3、在资源获得时，调用kill_fasync()函数激发相应的信号。
	所以在驱动中异步通知编程比较简单，主要用到一项数据结构和两个函数：
	fasync_struct结构体和 fasync_helper函数处理FASYNC标志变更、kill_fasync函数释放信号

	@linux异步I/O
	注意：异步的操作返回状态要调用函数来获得，不像同步IO是等待操作函数的返回值。
	aio_read()/aio_write()/aio_error()/aio_return()
第十章 中断与时钟
	@顶半部（紧急硬件操作）和底半部机制（延时的耗时操作）
	@中断来源：内部中断-cpu指令、溢出、除法错误等，外部中断-外设提出的中断请求。
	@向量中断和非向量中断：向量中断分配不同中断号，自动跳转到与该中断号对应的地址执行；非向量中断共享一个入口地址。
	@linux中断编程
		申请中断->释放中断
	@使能/屏蔽中断
		disable_irq()/disable_irq_nosync()/enable_irq()/local_irq_save()/local_irq_disable()
	@底半部机制：tasklet、工作队列、软中断、线程化irq
		1、tasklet  -执行上下文是软中断 只需要定义tasklet及其处理函数，并且关联两者即可。
		在顶半部中断处理函数后面调度就行tasklet_schedule()。
		2、工作队列  -执行上下文是内核线程，可以睡眠和调度
		3、软中断 -也是一种底半部处理机制
			open_softirq()注册软中断相应处理函数
			raise_softirq()触发一个软中断
		软中断和tasklet运行与软中断上下文，仍然属于原子上下文的一种，而工作队列运行在进程上下文，因此，软中断和tasklet处理函数中不允许睡眠，工作队列允许。
		local_bh_disable/local_bh_enable()是内核禁止和使能软中断及tasklet底半部机制的函数
		【内核采用softirq的地方：HI_SOFTIRQ,TIMER_SOFTIRQ,NET_TX_SOFTIRQ,NET_RX_SOFTIRQ,SCSI_SOFTIRQ,TASKLET_SOFTIRQ】
		【总结】硬中断：外部设备对cpu的中断
		软中断：中断底半部的一种处理机制
		信号：内核或进程对某个进程的中断
	@中断共享
	@内核定时器
	时钟中断处理程序会唤起TIMER_SOFTIRQ软中断，运行当前处理器上到期的所有定时器。
	@内核定时器编程
		1、timer_list结构体的一个实例对应一个定时器
		2、初始化定时器 init_timer(struct timer_list * timer);
		3、增加定时器 add_timer 注册内核定时器，将定时器加入到内核动态定时器链表中
		4、删除定时器 del_timer del_timer_sync是del_timer的同步版，在删除一个定时器时需要等待其被处理完，因此该函数的调用不能发生在中断上下文中。
		5、修改定时器的expire
		mod_timer 修改定时器的到期时间
		
	@内核中的延迟的工作delayed_work  -本质还是利用工作队列和定时器实现
	delayed_work结构体
	schedule_delayed_work，当指定的delay到来时，delayed_work结构体中的work成员work_func_t类型成员func()会被执行。
--------------------------【key: 驱动开发】-第十章 中断和时钟-------------------------------------------------------------------------------------------------------------------------------
【linux源码 同一个文件夹里的文件是什么关系：并列，耦合，可以从Makefile文件里面看出来，是哪几个文件合并编译成一个目标文件，还是都可配置性编程进obj】
20180125：
用户空间的策略：打开文件，关闭文件，定位文件，监控状态，读文件，写文件，调度进程，睡眠，错误判定，等
内核空间提供的机制：打开设备，关闭设备，注册设备，注册驱动，中断处理函数，软中断，工作队列，匹配
	@内核延时 长延时和短延时，睡着延时
第11章 内存与I/O访问
概念：常规内存，高端内存，虚拟地址，逻辑地址，总线地址，物理地址，I/O内存，设备内存，预留内存等
	内存管理单元：
		TLB（translation lookaside buffer） 转换旁路缓存 
		TTW(translation table walk) 转换表漫游
	用户进程只能访问用户空间的虚拟地址，不能访问内核空间的虚拟地址，用户进程只有通过系统调用(代表用户进程在内核态执行)等方式才可以访问到内核空间
	linux-x86中的1GB的内核地址空间又被划分为物理内存映射区、虚拟内存分配去、高端页面映射区、专用页面映射区和系统保留映射区
	linux-arm 见/opt/linux-4.1.38/Documentation/arm # vi memory.txt
	【linux内核总是按需调页(demand paging)】
	request_region --> inb()/outb().. --> release_region()
	request_mem_region --> ioremap() -->readb()/writeb().. --> iounmap() --> release_mem_region()
	【设备地址映射到用户空间】驱动用mmap()将设备地址映射到用户空间
	【linux下的DMA编程】DMA是一种内存和外设传输数据的方式
		1、dma区域 dma_mem_alloc()
		2、虚拟地址、物理地址和总线地址
		3、DMA地址掩码 dma_set_mask()
		4、一致性dma缓冲区 dma_alloc_coherent() 申请一片dma缓冲区，以进行地址映射并保证缓冲区的cache一致性
		5、流式dma映射  还是一致性问题，有些是内核的较上层用kmalloc申请的，这时候要用流式DMA映射。
			5.1 流式DMA映射 5.2 执行DMA操作 5.3流式DMA去映射
第12章 linux设备驱动的软件思想【这章要吃透】
	linux内核尽量做得更多，以便驱动可以做得更少，而且强调驱动的夸平台特性，因此linux内核势必会为不同的驱动子系统设计不同的框架
	驱动和设备分离、驱动分层、核心层和底层交互、主机和外设驱动分离
	【platform总线、设备和驱动】背景：SoC系统中集成的独立外设控制器、挂接在SoC内存空间的外设却不依附于此类总线。基于此，linux发明了一种虚拟的总线，成为platform总线，相应的设备platform_device，驱动为platform_driver。
	【引入platform的好处】 
	【总结：驱动的特点-用很多【结构体】封装描述设备和驱动+分层+回调函数+注册到内核】
--------------------------【key: 驱动开发】-第十二章 linux设备驱动的软件思想---【用面向对象的思想】----------------------------------------------------------------------------------------------------------------------------
20180126：
【总结：站在linux的角度上讲，需要多夸平台，高的移植性，所以分层思想、【核心+底层】的分离思想不言而喻，具体可参考第十二章的软件设计思想】
【输入设备驱动】
【RTC设备驱动】
【framebuffer驱动】
【终端设备驱动】
【misc设备驱动】
【驱动核心层】核心层的三大职责：1、对上提供结构file_opreation的读、写、ioctl等。 2、中间层实现通用逻辑，所有底层通用的逻辑都在中间层搞定，避免重复。 3、对下定义框架，底层不需要关心linux内核VFS的接口和各种可能的IO模型，只需要处理和硬件相关的访问。 【类似面向对象的类继承和多态】
【主机驱动和外设驱动分离】usb、i2c、spi等子系统采用主机驱动和外设驱动分离。4个软件模块：主机驱动、连接外设和主机的纽带、外设驱动、板级逻辑。
【总结：为什么很多函数在开头的时候会有从参数中导出某个结构体的指针呢？因为正是框架确定了该函数的原型，也就确认了传入的参数的原型，强调一遍：固定了框架也就是固定了函数接口的原型】
【spi主机和外设驱动】spi_master-主机驱动结构体 、 spi_driver-spi外设驱动结构体
spi_transfer-关键的数据结构，描述spi传输
【总结：就像linux中的makefile和学习时用的makefile不同一样，linux的驱动也没那么简单，它首先有个框架，其中又夹带platform。分层、分离的很多概念，因此要领悟本章的各个理论，还有之前的并发和控制知识点。本来学习就是这样，需要掌握其中的精髓和本质，才能一手掌握】
--第十三章 块设备驱动--
【块设备和字符设备IO操作的不同】
	1、块设备以块为单位，字符设备以字节为单位，不需要缓冲，
	2、块设备对于IO请求有对应的缓冲区，因此可以选择以什么顺序进行响应。可以调整读写顺序的作用巨大，因为读写连续扇区速度更快
	3、字符设备只能顺序读写，块设备可以随机访问
linux中通常通过文件系统访问磁盘，但是也有原始访问方式如/dev/sdb1等，他们都工作与VFS之下。
-------------块设备子系统---------------
虚拟文件系统VFS
----------------------------------------
磁盘文件系统 | 原始块设备 
----------------------------------------
块IO调度层
----------------------------------------
块设备驱动 | 块设备驱动 
----------------------------------------
【gendisk结构体】
【linux MMC子系统】MMC/SD存储卡
【块驱动的任务是处理请求，核心就是请求处理函数和制造请求的函数】
--第十四章  linux网络设备驱动
4个层次：网络协议接口层、网络设备接口层、提供实际功能的设备驱动功能层、网络设备与媒介层
【总结：指针的使用，在一层一层的数据传递过程中用指针会变得很高效，尤其是对于像网络设备的缓冲，数据量很大，在数据的处理过程中会经过很多的函数来处理】
【总结：学习linux的驱动就是要站在为了适应多平台和移植性的角度上去看代码的分层，提出通用部分作为核心，慢慢的，一切都变得开朗了】

【宏和内联函数】宏不能访问对象的私有成员，有二义性；内联函数和宏的区别：宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数只是在需要用到的时候内联函数就像宏一样展开，所以取消了函数的参数压栈减少了开销。
--------------------------------------------------------【CB机】调试TM1723的【LCD显示】【pwm调节背光三色灯】【按键】--------------------------------------------------------------------------
20180131:
调试tm1723的按键读取，时钟太快了导致读取失败,增大时钟线（SCL）的周期即可，同时之前忘记在读取时将数据线（SDA）转为输入口。
-----------------------------------------------------------------------------------------------------------------------------
20180201: 
tm1723的按键增加组合按键功能。
-----------------------------------------------------------------------------------------------------------------------------
20180202:
【makefile的subst函数】$(subst FROM, TO, TEXT)，即将字符串TEXT中的子串FROM变为TO。
https://lwn.net/Articles/496400/  【Supporting multi-platform ARM kernels】
http://blog.csdn.net/mrwangwang/article/details/35997153/ 【Linux内核之mmc子系统-sdio】这个讲的还挺好
++增加74hc595的驱动，IO口的配置在bank1，需要转换bank，在INSCON寄存器中配置。
-----------------------------------------------------------------------------------------------------------------------------
20180203： sdio接口的wifi驱动  http://blog.csdn.net/zqixiao_09/article/details/51105877
Drivers/net/wireless/libertas/if_sdio.c
------------------------------------------【春节伊始，先攻完深入理解linux内核这本书，linux是基础】----------------------------------------------------------------------------------------------------------------------------------------------------------------
20180226：深入理解linux内核-第十三章
IO体系结构和设备驱动模型，这些章节要熟记，多看几遍了然于胸。
用户态的udev工具集应用程序，在系统启动的时候根据配置文件创建/dev的设备文件
------------------------------------------------------------------------------------------------------------------------------
20180227：深入理解linux内核-第十章 系统调用
系统调用和应用编程接口：前者是通过软中断向内核发出一个明确的请求，后者只是一个函数定义，说明了如何获得一个给定的服务。
POSIX标准针对API而不是系统调用。
系统调用属于内核，用户态的库函数不属于内核。
普通C函数的参数传递是通过把参数值写入活动的程序栈（用户态或内核态栈）实现的。
系统调用在发出系统调用之前把参数写入cpu寄存器中，然后在调用系统服务例程之前，内核再把cpu中的参数拷贝到内核态栈中。
寄存器的使用使得系统调用处理程序的结构和其他的异常处理程序的结构类似。
进入系统调用：x86是int 0x80，arm的是swi 系统进入内核态，并执行内核函数	system_call()
【主要学习arm-linux】
http://blog.csdn.net/liduxun/article/details/48119849  ARM Linux系统调用详细分析 【三个文件：arch/arm/kernel/sys_arm.c、arch/arm/include/asm/unistd.h、arch/arm/kernel/calls.S】
http://www.cnblogs.com/pengdonglin137/p/3878316.html 浅析基于arm的linux系统调用的实现  ***
https://www.cnblogs.com/wxb20/p/6249580.html arm 汇编
【函数定义前加宏asmlinkage ,表示这些函数通过堆栈而不是通过寄存器传递参数。】
gcc编译器在汇编过程中调用c语言函数时传递参数有两种方法：一种是通过堆栈，另一种是通过寄存器。缺省时采用寄存器，假如你要在你的汇编过程中调用c语言函数，并且想通过堆栈传递参数，你定义的c函数时要在函数前加上宏asmlinkage
http://www.cnblogs.com/pengdonglin137/p/3603549.html   linux-2.6.26内核中ARM中断实现详解
http://blog.sina.com.cn/s/blog_59b189220100au1k.html  gun-arm-汇编

-------------------------------------------------------------------------------------------------------------------------------
20180228：
gun-arm-汇编：一个汇编文件的程序缺省入口是start标号，也可以在连接脚本中用ENTRY标志指明其他入口。
汇编中的宏:如果使用宏参数，那么在宏实体中使用参数的时候要添加前缀“\”。
【git 忽略一些文件或文件夹-增加.gitignore文件或在info/exclude文件中加入要忽略文件的文件名或文件夹名即可】
【openSuse 查看发行版本：cat /etc/os-release】
《Understanding Linux Network Internals》
《linux device drivers》
《understanding the linux kernel and linux device driver》
--------------------------------------------------------------------------------------------------------------------------------
20180301：
understanding linux network internals：总结：数据结构中的函数指针使得读代码有点小困难，所以关键在于找到该函数指针的初始化的地方
https://www.ibm.com/developerworks/cn/linux/l-rcu/  Linux 2.6内核中新的锁机制--RCU
http://www.cnblogs.com/mosp/p/3551006.html  深入理解linux网络技术内幕-通知链
https://www.cnblogs.com/Caden-liu8888/p/7725293.html EXPORT_SYMBOL使用 【使用EXPORT_SYMBOL可以将一个函数以符号的方式导出给其他模块使用】
摘录：
【hardware interrupts】They are defined in kernel/irq/manage.c and are
overridden by architecture-specific functions in arch/XXX/kernel/irq.c, where XXX is the
architecture-specific directory。When the kernel receives an interrupt notification, it uses the IRQ number to find
out the driver’s handler and then executes this handler.
【Interrupt types】With an interrupt, an NIC can tell its driver several different things. Among them
are:1、Reception of a frame 2、Transmission failure 3、DMA transfer has completed successfully 4、Device has enough memory to handle a new transmission
-----------------------------------------------------------------------------------------------------------------------------------
20180302：《linux device driver》
PCI驱动：
usb驱动：
http://digilander.libero.it/robang/rubrica/serial.htm  《Serial Programming Guide for POSIX Operating Systems》
http://blog.csdn.net/g1036583997/article/details/7906934 Linux 下串口USB等设备通信编程入门1

-----------------------------------------------------------------------------------------------------------------------------------
 ...  这段时间老婆住院，请假陪她。
-----------------------------------------------------------------------------------------------------------------------------------
20180312：
http://tinylab.org/learning-rlk4.0-in-linux-lab/ 泰晓科技-嵌入式
http://tinylab.org/  泰晓科技-聚焦嵌入式
http://tinylab.org/elinux-org-boot-time-optimization/ 优化linux启动时间
https://github.com/MintCN/linux-insides-zh linux-内核揭秘
https://elinux.org/Main_Page  Embedded Linux Wiki  【这个网址非常厉害了】
这样学习linux的速度可是太慢了，没有进步，每天瞎看又记不住，没有实用性。好好反思一下，首先讲究学习的效率，怎样才能提高吸收的力度很重要，关看源码不行，光看书也不行，光看文章也不行，光看不思考不消化，也不行，所以要综合，既要看源码、书籍、文章，同时也要暂停下来思考。这个是理论层面，还要实践，我的目标是灵活并熟练的使用linux。笼统的概括一下：阶段一：了解linux包括其逻辑思想 。阶段二：掌握linux的一个子系统，同时掌握类比方法能够很好的去掌握其他子系统。 阶段三：掌握多个子系统，能够熟练开发。我当前还是处于阶段一多一点，但是有没有达到阶段二。
我的注意力有点不那么集中，同时又容易摇摆，这是个问题。【提高记忆力，改进学习方法】
http://spblinux.de/2.0/doc/busyboxdocumentation.html  BusyBox - The Swiss Army Knife of Embedded Linux 【busybox的用法】
------------------------------------------------------------------------------------------------------------------------------------
20180314：
https://elinux.org/Tims_Notes_on_ARM_memory_allocation   【Tims Notes on ARM memory allocation】
A call tree for a regular page table setup is:
 start_kernel()
   setup_arch()
     paging_init()
       map_lowmem()
         create_mapping()
           alloc_init_pud() - for a range of pgd entries
             alloc_init_section() - for a range of "pud" entries
               *pmd = __pmd(<stuff>) - actually set the pmd/pgd entries for a SECTION mapping
               or
               alloc_init_pte()
                 early_pte_alloc() - to get a page for the pte table
                   pte_offset_kernel() - get address of 'linux' portion of pte table page
                 set_pte_ext(<stuff>) - create the individual PTE entries, for a range of entries
               =>  cpu_set_pte_ext() - macro to wrapper calling through a cpu-specific routine
               =>  processor.set_pte_ext() - function pointer to cpu-specific routine
               =>  cpu_armXXX_set_pte_ext() or cpu_procvX_set_pte_ext - cpu-specific-routine
https://www.kernel.org/doc/gorman/html/understand/ 【这个也厉害了，学习理解linux的利器啊】
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0333h/Babbhigi.html 【arm的内存管理单元】
https://www.cnblogs.com/yjf512/p/3298582.html 【linux中的cgroup-controller group】-Cgroup是将任意进程进行分组化管理的Linux内核功能 ，cgroup本身提供将进程进行分组化管理的功能和接口的基础结构

http://tinylab.org/lwn-577961-btrfs-working-with-multiple-devices/ 【Btrfs 同多设备协作，多设备功能是 Btrfs 早期设计目标之一】
http://tinylab.org/lwn-577218-btrfs-getting-started/ 【Btrfs 入门】
https://elinux.org/Device_Tree_Usage#Basic_Data_Format 【设备树的用法，这个更专业，英文的】
https://www.cnblogs.com/xiaojiang1025/p/6131381.html 【设备树语法详解】
在这种趋势下，内核中原本的中断源直接到中断号的方式已经很难继续发展了，为了解决这些问题，linux kernel的大牛们就创造了irq domain(中断域)这个概念。domain在内核中有很多，除了irqdomain，还有power domain，clock domain等等，所谓domain，就是领域，范围的意思，也就是说，任何的定义出了这个范围就没有意义了。如上所述，系统中所有的interrupt controller会形成树状结构，对于每个interrupt controller都可以连接若干个外设的中断请求（interrupt source，中断源），interrupt controller会对连接其上的interrupt source（根据其在Interrupt controller中物理特性）进行编号（也就是HW interrupt ID了）。有了irq domain这个概念之后，这个编号仅仅限制在本interrupt controller范围内，有了这样的设计，CPU(Linux 内核)就可以根据级联的规则一级一级的找到想要访问的中断。当然，通常我们关心的只是内核中的中断号，具体这个中断号是怎么找到相应的中断源的，我们作为程序员往往不需要关心，除了在写设备树的时候，设备树就是要描述嵌入式软件开发中涉及的所有硬件信息，所以，设备树就需要准确的描述硬件上处理中断的这种树状结构，如此，就有了我们的interrupt-parant这样的概念：用来连接这样的树状结构的上下级，用于表示这个中断归属于哪个interrupt controller，比如，一个接在GPIO上的按键，它的组织形式就是：
中断源--interrupt parent-->GPIO--interrupt parent-->GIC1--interrupt parent-->GIC2--...-->CPU
---------------------------------------------------------------------------------------------------------------------------------------
20180315：编译一个天嵌的嵌入式内核
1、配置
	配置Kconfig的过程就是对该文件中的各符号变量进行定义，他们分别在Makefile或其他脚本中会用到，这个可以通过搜索找到，也可以直接在menuconfig中按【？】键会直接跳出详细提示。【这个提示很详细，还是提示去参考Documentation中的哪个文档】
/proc/config.gz 保存当前系统的.config，用gzip -cd /proc/config.gz > log。
https://www.cnblogs.com/dakewei/p/7499014.html linux内核启动参数解析
http://blog.csdn.net/blueman2012/article/details/6693605 伯克利套接字（BSD socket）
【不可否认，百度翻译很好用】
---------------------------------------------------------------------------------------------------------------------------------------
20180316：
《linux device drivers》if the code enters an endless loop, the kernel stops scheduling,* and the system doesn’t
respond to any action, including the magic Ctrl-Alt-Del combination. You have two
choices for dealing with system hangs—either prevent them beforehand or be able to
debug them after the fact.
https://www.vpsee.com/2011/01/how-to-detect-if-a-linux-system-running-on-a-virtual-machine/ 判断linux是否运行在虚拟机上
---------------------------------------------------------------------------------------------------------------------------------------
20180320:
	内核文件系统ext3；
	USB规范2.0中文版：
		usb四种传输事务：控制，中断，批量、同步
		usb客户端软件层--usb系统软件层--usb主机控制层--usb设备（驱动）
		usb采用小端字节顺序，
		usb数据包格式，PID表征数据包的类型：令牌Token、数据Data、握手Handshake、特殊包。
		握手包包括：ACK肯定、NAK否定、STALL功能错误、NYET尚未准备要等待
		其中，包是usb总线的数据传输的最小单元，不能被打断，否则会引发错误。若干个数据包组成一个事务传输，一次事务传输也不能打断，属于一次事务传输的几个包必须连续，不能跨帧完成。一次传输由一次到多次事务传输构成，可以跨帧完成。
		usb的请求包括：标准请求11个、类请求、厂商请求
------------------------------------------------------------------------------------------------------------------------------------------
20180321：
	结合《usb2.0 specification》、《linux device driver》、linux源码3.4版本（代码和文档Documentation） 学习linux的usb协议驱动。
【The typical lifecycle of a urb is as follows:】
• Created by a USB device driver.
• Assigned to a specific endpoint of a specific USB device.
• Submitted to the USB core, by the USB device driver.
• Submitted to the specific USB host controller driver for the specified device by
the USB core.
• Processed by the USB host controller driver that makes a USB transfer to the
device.
• When the urb is completed, the USB host controller driver notifies the USB
device driver.

【Writing a USB Driver】
The approach to writing a USB device driver is similar to a pci_driver: the driver registers
its driver object with the USB subsystem and later uses vendor and device identifiers
to tell if its hardware has been installed.
---------------------------------------------------------------------------------------------------------------------------------------------
20180322: 通过开源软件boa（嵌入式级http服务器）来学习开发进阶级linux的应用程序。
僵尸进程：子进程结束了，但是父进程没有用wait/waitpid回收，也没有signal（SIGCHLD,SIG_IGN）通知内核说不关心子进程结束，最要命的是父进程还一直不是，所以该僵尸进程就一直占用进程号等资源。如果父进程死了那么就会有init进程回收，然后统一清理僵尸进程。
【关于autoconf和automake：】使用qutomake，只需写一些简单的含有预定义宏的文件，由autoconf根据宏文件生成configure，由automake根据另一个宏文件生成Makefile.in，再使用configure依据Makefile.in来生成Makefile
	source code --autoscan--> configure.scan --edit--> configure.in	
	configure.in --aclocal--> aclocal.m4
	Makefile.am + configure.in --automake-->Makefile.in
	configure.in + aclocal.m4 --autoconf-->configure
	Makefile.in + configure ---->Makefile [通过执行./configure]
	
1)	运行autoscan命令

2)	将configure.scan 文件重命名为configure.in，并修改configure.in文件

3)	在project目录下新建Makefile.am文件，并在core和shell目录下也新建makefile.am文件

4)	在project目录下新建NEWS、 README、 ChangeLog 、AUTHORS文件

5)	将/usr/share/automake-1.X/目录下的depcomp和complie文件拷贝到本目录下

6)	运行aclocal命令

7)	运行autoconf命令

8)	运行automake -a命令

9)	运行./confiugre脚本
【总结：要编写Makefile.am，修改configure.in】
	【明天继续学习boa的应用程序】
--------------------------------------------------------------------------------------------------------------------------------------------
20180323：继续学习开源软件boa、pixman、git应用程序，两点：1、掌握autoconf和automake自动生成makefile。2、用gdb调试boa程序。
	自动生成makefile：所必须的软件：autoconf/automake/m4/perl/libtool（其中libtool非必须）。	
	【参考 info automake】
	
The GNU Build System distinguishes two trees: the source tree, and the
build tree.
http://www.gnu.org/software/autoconf/manual/autoconf.html#Top 有时间还是看这个吧。当前放弃用autoconf。
---------------------------------------------------------------------------------------------------------------------------------------------
20180326：放弃autoconf和automake，这个有时间再看，或者真正用到再研究吧，全是英文的。
目标：学习基于git应用程序的C库函数和系统调用，并且用gdb调试。
【在早上9-11点这两个小时精神比较好的情况下，可以专研一些难的东西，记忆一些信息（看代码，记库函数和系统调用），后面的话就可以温习以前的知识（linux应用驱动开发，linux启动，uboot，shell脚本，makefile脚本，网络，环境搭建等）】
关于makefile：FORCE，函数patsubst，.PHONY，@，调试
关于top：h查看帮助,c切换进程名,L定位进程名,r设定进程优先级	... 
关于多线程：pthread_create创建线程，pthread_join等待指定线程结束
关于GDB：info threads ,print val,info args,info breakpoint,catch envent,watch ,step,run,continue,
-----------------------------------------------------------------------------------------------------------------------------------------------
20180327：
关于C库函数sysconf和pathconf：sysconf()用于获得与文件或目录无关的限制值，以及系统特征选项；pathconf()和fpathconf()用于获得与文件或目录有关的限制值

明天学习linux编程手册中的37章daemon
第64章 其他备选IO模型，对于select/poll，IO信号驱动，epoll
【我要不断的革新，这个过程是痛苦的，在不断的审视自己，理清前进的道路和已经走过的路。只有不断的审视，才知道下一步怎么走，遇到了这么多问题，年龄的增大，家庭的责任，和时代的进步，应该药】

------------------------------------------------------------------------------------------------------------------------------------------------
20180329：
守护进程daemon -> syslogd守护进程 -> syslog系统调用 ->linux/tool/hv/hv_kvp_daemon.c -> poll() -> readelf -a和objdump -d a.out -> gdb ./a.out  -> ni|si等等	
在linux源码树中的tools目录下有些工具文件可以参考

回归到海思视频处理芯片的研究上。 不要纠结于具体的arm芯片上了，显得那么苍白且无用。应该抬起头向上看的，解决真正的业务问题才是前（钱）途。
【新的要求：音视频编解码算法如H.264（隶属于MPEG-4编码），MJPEG压缩算法，ffmpeg录制转换以及流化，海思开发平台，ffmpeg，】

.avi文件、.mpeg文件、.rmvb文件、.mov文件、.wmv文件、ISO/BIN/IMG镜像文件、
avi文件：AVI是音频视频交错(Audio Video Interleaved)的英文缩写，它是Microsoft公司开发的一种符合RIFF文件规范的数字音频与视频文件格式，原先用于Microsoft Video for Windows (简称VFW)环境，现在已被Windows 95/98、OS/2等多数操作系统直接支持。AVI格式允许视频和音频交错在一起同步播放，支持256色和RLE压缩，但AVI文件并未限定压缩标准，因此，AVI文件格式只是作为控制界面上的标准，不具有兼容性，用不同压缩算法生成的AVI文件，必须使用相应的解压缩算法才能播放出来。常用的AVI播放驱动程序，主要是Microsoft Video for Windows或Windows 95/98中的Video 1，以及Intel公司的Indeo Video。AVI文件目前主要应用在多媒体光盘上，用来保存电影、电视等各种影像信息，有时也出现在Internet上，供用户下载、欣赏新影片的精彩片断
------------------------------------------------------------------------------------------------------------------------------------------------
20180330：
编写安全的特权程序
【策略和方法：linux相关，经常翻阅的有，linux应用开发设计的书籍参考，还有一些开源的应用软件(boa,git,ffmpeg,iwpriv等)，linux源码树，也许没有明确的路线，会不断切换资料】
IPC进程间通信：通信、信号、同步
通信：数据传输-字节流-管道/FIFO/流socket、数据传输-伪终端、数据传输-消息-systemV消息队列/POSIX消息队列/数据包socket、共享内存-POSIX/SystemV、内存映射-匿名映射、内存映射-映射文件
信号：实时信号、标准信号
同步：信号量-systemV信号量、信号量-POSIX信号量-无名/命名信号量、文件锁、互斥、条件变量

【doxygen  -- Generate documentation from source code】
http://www.cnblogs.com/lidabo/p/6069455.html  Linux下Wi-Fi的实现：wireless_tools和wpa_supplicant
------------------------------------------------------------------------------------------------------------------------------------------------
20180403：
ffmpeg 项目组成： 用来记录、转换数字音频、视频，并能将其转化为流
视频采集，视频格式转换，视频截图，给视频加水印
	
------------------------------------------------------------------------------------------------------------------------------------------------
20180404：以解决实际问题为基准
https://jingyan.baidu.com/article/91f5db1b17e8a01c7f05e3e6.html  VMware中三种网络连接的区别_百度经验
linux网络调试：netstat，ping，lsof -i，tcpdump
https://www.cnblogs.com/lidabo/p/4377545.html linux调试工具 
valgrind： 检查内存错误
 https://www.cnblogs.com/wangkangluo1/archive/2011/07/20/2111248.html valgrind的使用方法
 增加对于linux系统编程的学习笔记-记录各章节的系统调用和C库函数
 
 https://blog.csdn.net/u012063773/article/details/73846343 python解析execl表格的数据
 
-----------------------------------------------------------------------------------------------------------------------------------------------
2180410： 先专注于本职工作吧，不要盲目跟风没有根基，需沉淀几年有值得骄傲的事迹和项目再说，同时要记得学习Python、机器学习等先进技术。多交接一些牛人，这个很重要。