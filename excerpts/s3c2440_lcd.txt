http://www.cnblogs.com/armlinux/archive/2010/08/30/2396931.html

嵌入式Linux之我行——S3C2440上LCD驱动(FrameBuffer)实例开发讲解
嵌入式Linux之我行，主要讲述和总结了本人在学习嵌入式linux中的每个步骤。一为总结经验，二希望能给想入门嵌入式Linux的朋友提供方便。如有错误之处，谢请指正。
共享资源，欢迎转载：http://hbhuanggang.cublog.cn
一、开发环境

主  机：VMWare--Fedora 9
开发板：Mini2440--64MB Nand, Kernel:2.6.30.4
编译器：arm-linux-gcc-4.3.2
二、背景知识

1. LCD工作的硬件需求：
   要使一块LCD正常的显示文字或图像，不仅需要LCD驱动器，而且还需要相应的LCD控制器。在通常情况下，生产厂商把LCD驱动器会以COF/COG的形式与LCD玻璃基板制作在一起，而LCD控制器则是由外部的电路来实现，现在很多的MCU内部都集成了LCD控制器，如S3C2410/2440等。通过LCD控制器就可以产生LCD驱动器所需要的控制信号来控制STN/TFT屏了。
 
2. S3C2440内部LCD控制器结构图：

我们根据数据手册来描述一下这个集成在S3C2440内部的LCD控制器：
a：LCD控制器由REGBANK、LCDCDMA、TIMEGEN、VIDPRCS寄存器组成；
b：REGBANK由17个可编程的寄存器组和一块256*16的调色板内存组成，它们用来配置LCD控制器的；
c：LCDCDMA是一个专用的DMA，它能自动地把在侦内存中的视频数据传送到LCD驱动器，通过使用这个DMA通道，视频数据在不需要CPU的干预的情况下显示在LCD屏上；
d：VIDPRCS接收来自LCDCDMA的数据，将数据转换为合适的数据格式，比如说4/8位单扫，4位双扫显示模式，然后通过数据端口VD[23:0]传送视频数据到LCD驱动器；
e：TIMEGEN由可编程的逻辑组成，他生成LCD驱动器需要的控制信号，比如VSYNC、HSYNC、VCLK和LEND等等，而这些控制信号又与REGBANK寄存器组中的LCDCON1/2/3/4/5的配置密切相关，通过不同的配置，TIMEGEN就能产生这些信号的不同形态，从而支持不同的LCD驱动器(即不同的STN/TFT屏)。
 
3. 常见TFT屏工作时序分析：

LCD提供的外部接口信号：
VSYNC/VFRAME/STV：垂直同步信号(TFT)/帧同步信号(STN)/SEC TFT信号；
HSYNC/VLINE/CPV：水平同步信号(TFT)/行同步脉冲信号(STN)/SEC TFT信号；
VCLK/LCD_HCLK：象素时钟信号(TFT/STN)/SEC TFT信号；
VD[23:0]：LCD像素数据输出端口(TFT/STN/SEC TFT)；
VDEN/VM/TP：数据使能信号(TFT)/LCD驱动交流偏置信号(STN)/SEC TFT 信号；
LEND/STH：行结束信号(TFT)/SEC TFT信号；
LCD_LPCOE：SEC TFT OE信号；
LCD_LPCREV：SEC TFT REV信号；
LCD_LPCREVB：SEC TFT REVB信号。
 
所有显示器显示图像的原理都是从上到下，从左到右的。这是什么意思呢？这么说吧，一副图像可以看做是一个矩形，由很多排列整齐的点一行一行组成，这些点称之为像素。那么这幅图在LCD上的显示原理就是：
A：显示指针从矩形左上角的第一行第一个点开始，一个点一个点的在LCD上显示，在上面的时序图上用时间线表示就为VCLK，我们称之为像素时钟信号；
B：当显示指针一直显示到矩形的右边就结束这一行，那么这一行的动作在上面的时序图中就称之为1 Line；
C：接下来显示指针又回到矩形的左边从第二行开始显示，注意，显示指针在从第一行的右边回到第二行的左边是需要一定的时间的，我们称之为行切换；
D：如此类推，显示指针就这样一行一行的显示至矩形的右下角才把一副图显示完成。因此，这一行一行的显示在时间线上看，就是时序图上的HSYNC；
E：然而，LCD的显示并不是对一副图像快速的显示一下，为了持续和稳定的在LCD上显示，就需要切换到另一幅图上(另一幅图可以和上一副图一样或者不一样，目的只是为了将图像持续的显示在LCD上)。那么这一副一副的图像就称之为帧，在时序图上就表示为1 Frame，因此从时序图上可以看出1 Line只是1 Frame中的一行；
F：同样的，在帧与帧切换之间也是需要一定的时间的，我们称之为帧切换，那么LCD整个显示的过程在时间线上看，就可表示为时序图上的VSYNC。
 
上面时序图上各时钟延时参数的含义如下：(这些参数的值，LCD产生厂商会提供相应的数据手册)
VBPD(vertical back porch)：表示在一帧图像开始时，垂直同步信号以后的无效的行数，对应驱动中的upper_margin；
VFBD(vertical front porch)：表示在一帧图像结束后，垂直同步信号以前的无效的行数，对应驱动中的lower_margin；
VSPW(vertical sync pulse width)：表示垂直同步脉冲的宽度，用行数计算，对应驱动中的vsync_len；
HBPD(horizontal back porch)：表示从水平同步信号开始到一行的有效数据开始之间的VCLK的个数，对应驱动中的left_margin；
HFPD(horizontal front porth)：表示一行的有效数据结束到下一个水平同步信号开始之间的VCLK的个数，对应驱动中的right_margin；
HSPW(horizontal sync pulse width)：表示水平同步信号的宽度，用VCLK计算，对应驱动中的hsync_len；
 
对于以上这些参数的值将分别保存到REGBANK寄存器组中的LCDCON1/2/3/4/5寄存器中：(对寄存器的操作请查看S3c2440数据手册LCD部分)
LCDCON1：17 - 8位CLKVAL 
          6 - 5位扫描模式(对于STN屏:4位单/双扫、8位单扫) 
          4 - 1位色位模式(1BPP、8BPP、16BPP等)

LCDCON2：31 - 24位VBPD 
         23 - 14位LINEVAL 
         13 - 6位VFPD 
          5 - 0位VSPW

LCDCON3：25 - 19位HBPD 
         18 - 8位HOZVAL 
          7 - 0位HFPD

LCDCON4： 7 - 0位HSPW

LCDCON5：
 
4. 帧缓冲(FrameBuffer)：
   帧缓冲是Linux为显示设备提供的一个接口，它把一些显示设备描述成一个缓冲区，允许应用程序通过FrameBuffer定义好的接口访问这些图形设备，从而不用去关心具体的硬件细节。对于帧缓冲设备而言，只要在显示缓冲区与显示点对应的区域写入颜色值，对应的颜色就会自动的在屏幕上显示。下面来看一下在不同色位模式下缓冲区与显示点的对应关系：


三、帧缓冲(FrameBuffer)设备驱动结构：
 
     帧缓冲设备为标准的字符型设备，在Linux中主设备号29，定义在/include/linux/major.h中的FB_MAJOR，次设备号定义帧缓冲的个数，最大允许有32个FrameBuffer，定义在/include/linux/fb.h中的FB_MAX，对应于文件系统下/dev/fb%d设备文件。
1. 帧缓冲设备驱动在Linux子系统中的结构如下：

我们从上面这幅图看，帧缓冲设备在Linux中也可以看做是一个完整的子系统，大体由fbmem.c和xxxfb.c组成。向上给应用程序提供完善的设备文件操作接口(即对FrameBuffer设备进行read、write、ioctl等操作)，接口在Linux提供的fbmem.c文件中实现；向下提供了硬件操作的接口，只是这些接口Linux并没有提供实现，因为这要根据具体的LCD控制器硬件进行设置，所以这就是我们要做的事情了(即xxxfb.c部分的实现)。

2. 帧缓冲相关的重要数据结构：
   从帧缓冲设备驱动程序结构看，该驱动主要跟fb_info结构体有关，该结构体记录了帧缓冲设备的全部信息，包括设备的设置参数、状态以及对底层硬件操作的函数指针。在Linux中，每一个帧缓冲设备都必须对应一个fb_info，fb_info在/linux/fb.h中的定义如下：(只列出重要的一些)

struct fb_info {
    int node;
    int flags;
    struct fb_var_screeninfo var;/*LCD可变参数结构体*/
    struct fb_fix_screeninfo fix;/*LCD固定参数结构体*/
    struct fb_monspecs monspecs; /*LCD显示器标准*/
    struct work_struct queue;    /*帧缓冲事件队列*/
    struct fb_pixmap pixmap;     /*图像硬件mapper*/
    struct fb_pixmap sprite;     /*光标硬件mapper*/
    struct fb_cmap cmap;         /*当前的颜色表*/
    struct fb_videomode *mode;   /*当前的显示模式*/

#ifdef CONFIG_FB_BACKLIGHT
    struct backlight_device *bl_dev;/*对应的背光设备*/
    struct mutex bl_curve_mutex;
    u8 bl_curve[FB_BACKLIGHT_LEVELS];/*背光调整*/
#endif
#ifdef CONFIG_FB_DEFERRED_IO
    struct delayed_work deferred_work;
    struct fb_deferred_io *fbdefio;
#endif

    struct fb_ops *fbops; /*对底层硬件操作的函数指针*/
    struct device *device;
    struct device *dev;   /*fb设备*/
    int class_flag;    
#ifdef CONFIG_FB_TILEBLITTING
    struct fb_tile_ops *tileops; /*图块Blitting*/
#endif
    char __iomem *screen_base;   /*虚拟基地址*/
    unsigned long screen_size;   /*LCD IO映射的虚拟内存大小*/ 
    void *pseudo_palette;        /*伪16色颜色表*/ 
#define FBINFO_STATE_RUNNING    0
#define FBINFO_STATE_SUSPENDED  1
    u32 state;  /*LCD的挂起或恢复状态*/
    void *fbcon_par;
    void *par;    
};
其中，比较重要的成员有struct fb_var_screeninfo var、struct fb_fix_screeninfo fix和struct fb_ops *fbops，他们也都是结构体。下面我们一个一个的来看。

fb_var_screeninfo结构体主要记录用户可以修改的控制器的参数，比如屏幕的分辨率和每个像素的比特数等，该结构体定义如下：

struct fb_var_screeninfo {
    __u32 xres;                /*可见屏幕一行有多少个像素点*/
    __u32 yres;                /*可见屏幕一列有多少个像素点*/
    __u32 xres_virtual;        /*虚拟屏幕一行有多少个像素点*/        
    __u32 yres_virtual;        /*虚拟屏幕一列有多少个像素点*/
    __u32 xoffset;             /*虚拟到可见屏幕之间的行偏移*/
    __u32 yoffset;             /*虚拟到可见屏幕之间的列偏移*/
    __u32 bits_per_pixel;      /*每个像素的位数即BPP*/
    __u32 grayscale;           /*非0时，指的是灰度*/

    struct fb_bitfield red;    /*fb缓存的R位域*/
    struct fb_bitfield green;  /*fb缓存的G位域*/
    struct fb_bitfield blue;   /*fb缓存的B位域*/
    struct fb_bitfield transp; /*透明度*/    

    __u32 nonstd;              /* != 0 非标准像素格式*/
    __u32 activate;                
    __u32 height;              /*高度*/
    __u32 width;               /*宽度*/
    __u32 accel_flags;    

    /*定时：除了pixclock本身外，其他的都以像素时钟为单位*/
    __u32 pixclock;            /*像素时钟(皮秒)*/
    __u32 left_margin;         /*行切换，从同步到绘图之间的延迟*/
    __u32 right_margin;        /*行切换，从绘图到同步之间的延迟*/
    __u32 upper_margin;        /*帧切换，从同步到绘图之间的延迟*/
    __u32 lower_margin;        /*帧切换，从绘图到同步之间的延迟*/
    __u32 hsync_len;           /*水平同步的长度*/
    __u32 vsync_len;           /*垂直同步的长度*/
    __u32 sync;
    __u32 vmode;
    __u32 rotate;
    __u32 reserved[5];         /*保留*/
};
而fb_fix_screeninfo结构体又主要记录用户不可以修改的控制器的参数，比如屏幕缓冲区的物理地址和长度等，该结构体的定义如下：

struct fb_fix_screeninfo {
    char id[16];                /*字符串形式的标示符 */
    unsigned long smem_start;   /*fb缓存的开始位置 */
    __u32 smem_len;             /*fb缓存的长度 */
    __u32 type;                 /*看FB_TYPE_* */
    __u32 type_aux;             /*分界*/
    __u32 visual;               /*看FB_VISUAL_* */ 
    __u16 xpanstep;             /*如果没有硬件panning就赋值为0 */
    __u16 ypanstep;             /*如果没有硬件panning就赋值为0 */
    __u16 ywrapstep;            /*如果没有硬件ywrap就赋值为0 */
    __u32 line_length;          /*一行的字节数 */
    unsigned long mmio_start;   /*内存映射IO的开始位置*/
    __u32 mmio_len;             /*内存映射IO的长度*/
    __u32 accel;
    __u16 reserved[3];          /*保留*/
};
fb_ops结构体是对底层硬件操作的函数指针，该结构体中定义了对硬件的操作有:(这里只列出了常用的操作)

struct fb_ops {

    struct module *owner;

    //检查可变参数并进行设置
    int (*fb_check_var)(struct fb_var_screeninfo *var, struct fb_info *info);

    //根据设置的值进行更新，使之有效
    int (*fb_set_par)(struct fb_info *info);

    //设置颜色寄存器
    int (*fb_setcolreg)(unsigned regno, unsigned red, unsigned green,
             unsigned blue, unsigned transp, struct fb_info *info);

    //显示空白
    int (*fb_blank)(int blank, struct fb_info *info);

    //矩形填充
    void (*fb_fillrect) (struct fb_info *info, const struct fb_fillrect *rect);

    //复制数据
    void (*fb_copyarea) (struct fb_info *info, const struct fb_copyarea *region);

    //图形填充
    void (*fb_imageblit) (struct fb_info *info, const struct fb_image *image);
};
3. 帧缓冲设备作为平台设备：
   在S3C2440中，LCD控制器被集成在芯片的内部作为一个相对独立的单元，所以Linux把它看做是一个平台设备，故在内核代码/arch/arm/plat-s3c24xx/devs.c中定义有LCD相关的平台设备及资源，代码如下：

/* LCD Controller */
//LCD控制器的资源信息
static struct resource s3c_lcd_resource[] = {
    [0] = {
        .start = S3C24XX_PA_LCD, //控制器IO端口开始地址
        .end = S3C24XX_PA_LCD + S3C24XX_SZ_LCD - 1,//控制器IO端口结束地址
        .flags = IORESOURCE_MEM,//标识为LCD控制器IO端口，在驱动中引用这个就表示引用IO端口
    },
    [1] = {
        .start = IRQ_LCD,//LCD中断
        .end = IRQ_LCD,
        .flags = IORESOURCE_IRQ,//标识为LCD中断
    }
};

static u64 s3c_device_lcd_dmamask = 0xffffffffUL;

struct platform_device s3c_device_lcd = {
    .name         = "s3c2410-lcd",//作为平台设备的LCD设备名
    .id         = -1,
    .num_resources = ARRAY_SIZE(s3c_lcd_resource),//资源数量
    .resource     = s3c_lcd_resource,//引用上面定义的资源
    .dev = {
        .dma_mask = &s3c_device_lcd_dmamask,
        .coherent_dma_mask = 0xffffffffUL
    }
};

EXPORT_SYMBOL(s3c_device_lcd);//导出定义的LCD平台设备，好在mach-smdk2440.c的smdk2440_devices[]中添加到平台设备列表中

   除此之外，Linux还在/arch/arm/mach-s3c2410/include/mach/fb.h中为LCD平台设备定义了一个s3c2410fb_mach_info结构体，该结构体主要是记录LCD的硬件参数信息(比如该结构体的s3c2410fb_display成员结构中就用于记录LCD的屏幕尺寸、屏幕信息、可变的屏幕参数、LCD配置寄存器等)，这样在写驱动的时候就直接使用这个结构体。下面，我们来看一下内核是如果使用这个结构体的。在/arch/arm/mach-s3c2440/mach-smdk2440.c中定义有：
/* LCD driver info */
//LCD硬件的配置信息，注意这里我使用的LCD是NEC 3.5寸TFT屏，这些参数要根据具体的LCD屏进行设置
static struct s3c2410fb_display smdk2440_lcd_cfg __initdata = {
    //这个地方的设置是配置LCD寄存器5，这些宏定义在regs-lcd.h中，计算后二进制为：111111111111，然后对照数据手册上LCDCON5的各位来看，注意是从右边开始
    .lcdcon5 = S3C2410_LCDCON5_FRM565 |
               S3C2410_LCDCON5_INVVLINE |
               S3C2410_LCDCON5_INVVFRAME |
               S3C2410_LCDCON5_PWREN |
               S3C2410_LCDCON5_HWSWP,

    .type    = S3C2410_LCDCON1_TFT,//TFT类型

    /* NEC 3.5'' */
    .width        = 240,//屏幕宽度
    .height       = 320,//屏幕高度
    //以下一些参数在上面的时序图分析中讲到过,各参数的值请跟据具体的LCD屏数据手册结合上面时序分析来设定
    .pixclock     = 100000,//像素时钟
    .xres         = 240,//水平可见的有效像素
    .yres         = 320,//垂直可见的有效像素
    .bpp          = 16,//色位模式
    .left_margin  = 19,//行切换，从同步到绘图之间的延迟
    .right_margin = 36,//行切换，从绘图到同步之间的延迟
    .hsync_len    = 5,//水平同步的长度
    .upper_margin = 1,//帧切换，从同步到绘图之间的延迟
    .lower_margin = 5,//帧切换，从绘图到同步之间的延迟
    .vsync_len    = 1,//垂直同步的长度
};

static struct s3c2410fb_mach_info smdk2440_fb_info __initdata = {
    .displays        = &smdk2440_lcd_cfg,//应用上面定义的配置信息
    .num_displays    = 1,
    .default_display = 0,

    .gpccon          = 0xaaaa555a,//将GPC0、GPC1配置成LEND和VCLK，将GPC8-15配置成VD0-7,其他配置成普通输出IO口
    .gpccon_mask     = 0xffffffff,
    .gpcup           = 0x0000ffff,//禁止GPIOC的上拉功能
    .gpcup_mask      = 0xffffffff,
    .gpdcon          = 0xaaaaaaaa,//将GPD0-15配置成VD8-23
    .gpdcon_mask     = 0xffffffff,
    .gpdup           = 0x0000ffff,//禁止GPIOD的上拉功能
    .gpdup_mask      = 0xffffffff,

    .lpcsel          = 0x0,//这个是三星TFT屏的参数，这里不用
};
注意：可能有很多朋友不知道上面红色部分的参数是做什么的，其值又是怎么设置的？其实它是跟你的开发板LCD控制器密切相关的，看了下面两幅图相信就大概知道他们是干什么用的：





上面第一幅图是开发板原理图的LCD控制器部分，第二幅图是S3c2440数据手册中IO端口C和IO端口D控制器部分。原理图中使用了GPC8-15和GPD0-15来用做LCD控制器VD0-VD23的数据端口，又分别使用GPC0、GPC1端口用做LCD控制器的LEND和VCLK信号，对于GPC2-7则是用做STN屏或者三星专业TFT屏的相关信号。然而，S3C2440的各个IO口并不是单一的功能，都是复用端口，要使用他们首先要对他们进行配置。所以上面红色部分的参数就是把GPC和GPD的部分端口配置成LCD控制功能模式。

   从以上讲述的内容来看，要使LCD控制器支持其他的LCD屏，重要的是根据LCD的数据手册修改以上这些参数的值。下面，我们再看一下在驱动中是如果引用到s3c2410fb_mach_info结构体的(注意上面讲的是在内核中如何使用的)。在mach-smdk2440.c中有：

//S3C2440初始化函数
static void __init smdk2440_machine_init(void)
{
    //调用该函数将上面定义的LCD硬件信息保存到平台数据中
    s3c24xx_fb_set_platdata(&smdk2440_fb_info);
    
    s3c_i2c0_set_platdata(NULL);

    platform_add_devices(smdk2440_devices, ARRAY_SIZE(smdk2440_devices));
    smdk_machine_init();
}
s3c24xx_fb_set_platdata定义在plat-s3c24xx/devs.c中：

void __init s3c24xx_fb_set_platdata(struct s3c2410fb_mach_info *pd)
{
    struct s3c2410fb_mach_info *npd;

    npd = kmalloc(sizeof(*npd), GFP_KERNEL);
    if (npd) {
        memcpy(npd, pd, sizeof(*npd));
        //这里就是将内核中定义的s3c2410fb_mach_info结构体数据保存到LCD平台数据中，所以在写驱动的时候就可以直接在平台数据中获取s3c2410fb_mach_info结构体的数据(即LCD各种参数信息)进行操作
        s3c_device_lcd.dev.platform_data = npd;
    } else {
        printk(KERN_ERR "no memory for LCD platform data/n");
    }
}
   这里再讲一个小知识：不知大家有没有留意，在平台设备驱动中，platform_data可以保存各自平台设备实例的数据，但这些数据的类型都是不同的，为什么都可以保存？这就要看看platform_data的定义，定义在/linux/device.h中，void *platform_data是一个void类型的指针，在Linux中void可保存任何数据类型。

 

 

 

四、帧缓冲(FrameBuffer)设备驱动实例代码：

①、建立驱动文件：my2440_lcd.c，依就是驱动程序的最基本结构：FrameBuffer驱动的初始化和卸载部分及其他，如下：
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/errno.h>
#include <linux/init.h>
#include <linux/platform_device.h>
#include <linux/dma-mapping.h>
#include <linux/fb.h>
#include <linux/clk.h>
#include <linux/interrupt.h>
#include <linux/mm.h>
#include <linux/slab.h>
#include <linux/delay.h>
#include <asm/irq.h>
#include <asm/io.h>
#include <asm/div64.h>
#include <mach/regs-lcd.h>
#include <mach/regs-gpio.h>
#include <mach/fb.h>
#include <linux/pm.h>

/*FrameBuffer设备名称*/
static char driver_name[] = "my2440_lcd";

/*定义一个结构体用来维护驱动程序中各函数中用到的变量
  先别看结构体要定义这些成员，到各函数使用的地方就明白了*/
struct my2440fb_var
{
    int lcd_irq_no;           /*保存LCD中断号*/
    struct clk *lcd_clock;    /*保存从平台时钟队列中获取的LCD时钟*/
    struct resource *lcd_mem; /*LCD的IO空间*/
    void __iomem *lcd_base;   /*LCD的IO空间映射到虚拟地址*/
    struct device *dev;

    struct s3c2410fb_hw regs; /*表示5个LCD配置寄存器，s3c2410fb_hw定义在mach-s3c2410/include/mach/fb.h中*/

    /*定义一个数组来充当调色板。
    据数据手册描述，TFT屏色位模式为8BPP时，调色板(颜色表)的长度为256，调色板起始地址为0x4D000400*/
    u32    palette_buffer[256]; 
    u32 pseudo_pal[16];   
    unsigned int palette_ready; /*标识调色板是否准备好了*/
};

/*用做清空调色板(颜色表)*/
#define PALETTE_BUFF_CLEAR (0x80000000)    

/*LCD平台驱动结构体，平台驱动结构体定义在platform_device.h中，该结构体成员接口函数在第②步中实现*/
static struct platform_driver lcd_fb_driver = 
{
    .probe     = lcd_fb_probe,               /*FrameBuffer设备探测*/
    .remove    = __devexit_p(lcd_fb_remove), /*FrameBuffer设备移除*/
    .suspend   = lcd_fb_suspend,             /*FrameBuffer设备挂起*/
    .resume    = lcd_fb_resume,              /*FrameBuffer设备恢复*/
    .driver    = 
    {
        /*注意这里的名称一定要和系统中定义平台设备的地方一致，这样才能把平台设备与该平台设备的驱动关联起来*/
        .name = "s3c2410-lcd",
        .owner = THIS_MODULE,
    },
};

static int __init lcd_init(void)
{
    /*在Linux中，帧缓冲设备被看做是平台设备，所以这里注册平台设备*/
    return platform_driver_register(&lcd_fb_driver);
}

static void __exit lcd_exit(void)
{
    /*注销平台设备*/
    platform_driver_unregister(&lcd_fb_driver);
}

module_init(lcd_init);
module_exit(lcd_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Huang Gang");
MODULE_DESCRIPTION("My2440 LCD FrameBuffer Driver");
②、LCD平台设备各接口函数的实现：
/*LCD FrameBuffer设备探测的实现，注意这里使用一个__devinit宏，到lcd_fb_remove接口函数实现的地方讲解*/
static int __devinit lcd_fb_probe(struct platform_device *pdev)
{
    int i;
    int ret;
    struct resource *res;  /*用来保存从LCD平台设备中获取的LCD资源*/
    struct fb_info  *fbinfo; /*FrameBuffer驱动所对应的fb_info结构体*/
    struct s3c2410fb_mach_info *mach_info; /*保存从内核中获取的平台设备数据*/
    struct my2440fb_var *fbvar; /*上面定义的驱动程序全局变量结构体*/
    struct s3c2410fb_display *display; /*LCD屏的配置信息结构体，该结构体定义在mach-s3c2410/include/mach/fb.h中*/

    /*获取LCD硬件相关信息数据，在前面讲过内核使用s3c24xx_fb_set_platdata函数将LCD的硬件相关信息保存到
     了LCD平台数据中，所以这里我们就从平台数据中取出来在驱动中使用*/
    mach_info = pdev->dev.platform_data;
    if(mach_info == NULL)
    {
        /*判断获取数据是否成功*/
        dev_err(&pdev->dev, "no platform data for lcd/n");
        return -EINVAL;
    }

    /*获得在内核中定义的FrameBuffer平台设备的LCD配置信息结构体数据*/
    display = mach_info->displays + mach_info->default_display;
    /*给fb_info分配空间，大小为my2440fb_var结构的内存，framebuffer_alloc定义在fb.h中在fbsysfs.c中实现*/
    fbinfo = framebuffer_alloc(sizeof(struct my2440fb_var), &pdev->dev);
    if(!fbinfo)
    {
        dev_err(&pdev->dev, "framebuffer alloc of registers failed/n");
        ret = -ENOMEM;
        goto err_noirq;
    }
    platform_set_drvdata(pdev, fbinfo);/*重新将LCD平台设备数据设置为fbinfo，好在后面的一些函数中来使用*/

    /*这里的用途其实就是将fb_info的成员par(注意是一个void类型的指针)指向这里的私有变量结构体fbvar，
     目的是到其他接口函数中再取出fb_info的成员par，从而能继续使用这里的私有变量*/
    fbvar = fbinfo->par;
    fbvar->dev = &pdev->dev;

    /*在系统定义的LCD平台设备资源中获取LCD中断号,platform_get_irq定义在platform_device.h中*/
    fbvar->lcd_irq_no = platform_get_irq(pdev, 0);
    if(fbvar->lcd_irq_no < 0)
    {
        /*判断获取中断号是否成功*/
        dev_err(&pdev->dev, "no lcd irq for platform/n");
        return -ENOENT;
    }

    /*获取LCD平台设备所使用的IO端口资源，注意这个IORESOURCE_MEM标志和LCD平台设备定义中的一致*/
    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    if(res == NULL)
    {
        /*判断获取资源是否成功*/
        dev_err(&pdev->dev, "failed to get memory region resource/n");
        return -ENOENT;
    }

    /*申请LCD IO端口所占用的IO空间(注意理解IO空间和内存空间的区别),request_mem_region定义在ioport.h中*/
    fbvar->lcd_mem = request_mem_region(res->start, res->end - res->start + 1, pdev->name);
    if(fbvar->lcd_mem == NULL)
    {
        /*判断申请IO空间是否成功*/
        dev_err(&pdev->dev, "failed to reserve memory region/n");
        return -ENOENT;
    }

    /*将LCD的IO端口占用的这段IO空间映射到内存的虚拟地址，ioremap定义在io.h中
     注意：IO空间要映射后才能使用，以后对虚拟地址的操作就是对IO空间的操作*/
    fbvar->lcd_base = ioremap(res->start, res->end - res->start + 1);
    if(fbvar->lcd_base == NULL)
    {
        /*判断映射虚拟地址是否成功*/
        dev_err(&pdev->dev, "ioremap() of registers failed/n");
        ret = -EINVAL;
        goto err_nomem;
    }

    /*从平台时钟队列中获取LCD的时钟，这里为什么要取得这个时钟，从LCD屏的时序图上看，各种控制信号的延迟
     都跟LCD的时钟有关。系统的一些时钟定义在arch/arm/plat-s3c24xx/s3c2410-clock.c中*/
    fbvar->lcd_clock = clk_get(NULL, "lcd");
    if(!fbvar->lcd_clock)
    {
        /*判断获取时钟是否成功*/
        dev_err(&pdev->dev, "failed to find lcd clock source/n");
        ret = -ENOENT;
        goto err_nomap;
    }
    /*时钟获取后要使能后才可以使用，clk_enable定义在arch/arm/plat-s3c/clock.c中*/
    clk_enable(fbvar->lcd_clock);

    /*申请LCD中断服务，上面获取的中断号lcd_fb_irq，使用快速中断方式:IRQF_DISABLED
     中断服务程序为:lcd_fb_irq，将LCD平台设备pdev做参数传递过去了*/
    ret = request_irq(fbvar->lcd_irq_no, lcd_fb_irq, IRQF_DISABLED, pdev->name, fbvar);
    if(ret)
    {
        /*判断申请中断服务是否成功*/
        dev_err(&pdev->dev, "IRQ%d error %d/n", fbvar->lcd_irq_no, ret);
        ret = -EBUSY;
        goto err_noclk;
    }
    /*好了，以上是对要使用的资源进行了获取和设置。下面就开始初始化填充fb_info结构体*/

    /*首先初始化fb_info中代表LCD固定参数的结构体fb_fix_screeninfo*/
    /*像素值与显示内存的映射关系有5种，定义在fb.h中。现在采用FB_TYPE_PACKED_PIXELS方式，在该方式下，
    像素值与内存直接对应，比如在显示内存某单元写入一个"1"时，该单元对应的像素值也将是"1"，这使得应用层
    把显示内存映射到用户空间变得非常方便。Linux中当LCD为TFT屏时，显示驱动管理显示内存就是基于这种方式*/
    strcpy(fbinfo->fix.id, driver_name);/*字符串形式的标识符*/
    fbinfo->fix.type = FB_TYPE_PACKED_PIXELS;
    fbinfo->fix.type_aux = 0;/*以下这些根据fb_fix_screeninfo定义中的描述，当没有硬件是都设为0*/
    fbinfo->fix.xpanstep = 0;
    fbinfo->fix.ypanstep = 0;
    fbinfo->fix.ywrapstep= 0;
    fbinfo->fix.accel = FB_ACCEL_NONE;
    /*接着，再初始化fb_info中代表LCD可变参数的结构体fb_var_screeninfo*/
    fbinfo->var.nonstd          = 0;
    fbinfo->var.activate        = FB_ACTIVATE_NOW;
    fbinfo->var.accel_flags     = 0;
    fbinfo->var.vmode           = FB_VMODE_NONINTERLACED;
    fbinfo->var.xres            = display->xres;
    fbinfo->var.yres            = display->yres;
    fbinfo->var.bits_per_pixel  = display->bpp;
    /*指定对底层硬件操作的函数指针, 因内容较多故其定义在第③步中再讲*/
    fbinfo->fbops               = &my2440fb_ops;
    /*初始化色调色板(颜色表)为空*/
    for(i = 0; i < 256; i++)
    {
        fbvar->palette_buffer[i] = PALETTE_BUFF_CLEAR;
    }

    for (i = 0; i < mach_info->num_displays; i++) /*fb缓存的长度*/
    {
        /*计算FrameBuffer缓存的最大大小，这里右移3位(即除以8)是因为色位模式BPP是以位为单位*/
        unsigned long smem_len = (mach_info->displays[i].xres * mach_info->displays[i].yres * mach_info->displays[i].bpp) >> 3;

        if(fbinfo->fix.smem_len < smem_len)
        {
            fbinfo->fix.smem_len = smem_len;
        }
    }

    /*初始化LCD控制器之前要延迟一段时间*/
    msleep(1);

    /*初始化完fb_info后，开始对LCD各寄存器进行初始化，其定义在后面讲到*/
    my2440fb_init_registers(fbinfo);

    /*初始化完寄存器后，开始检查fb_info中的可变参数，其定义在后面讲到*/
    my2440fb_check_var(fbinfo);
    
    /*申请帧缓冲设备fb_info的显示缓冲区空间，其定义在后面讲到*/
    ret = my2440fb_map_video_memory(fbinfo);
    if (ret) 
    {
        dev_err(&pdev->dev, "failed to allocate video RAM: %d/n", ret);
        ret = -ENOMEM;
        goto err_nofb;
    }

    /*最后，注册这个帧缓冲设备fb_info到系统中, register_framebuffer定义在fb.h中在fbmem.c中实现*/
    ret = register_framebuffer(fbinfo);
    if (ret < 0) 
    {
        dev_err(&pdev->dev, "failed to register framebuffer device: %d/n", ret);
        goto err_video_nomem;
    }

    /*对设备文件系统的支持(对设备文件系统的理解请参阅：嵌入式Linux之我行——设备文件系统剖析与使用)
     创建frambuffer设备文件，device_create_file定义在linux/device.h中*/
    ret = device_create_file(&pdev->dev, &dev_attr_debug);
    if (ret) 
    {
        dev_err(&pdev->dev, "failed to add debug attribute/n");
    }

    return 0;

/*以下是上面错误处理的跳转点*/
err_nomem:
    release_resource(fbvar->lcd_mem);
    kfree(fbvar->lcd_mem);

err_nomap:
    iounmap(fbvar->lcd_base);

err_noclk:
    clk_disable(fbvar->lcd_clock);
    clk_put(fbvar->lcd_clock);

err_noirq:
    free_irq(fbvar->lcd_irq_no, fbvar);

err_nofb:
    platform_set_drvdata(pdev, NULL);
    framebuffer_release(fbinfo);

err_video_nomem:
    my2440fb_unmap_video_memory(fbinfo);

    return ret;
}

/*LCD中断服务程序*/
static irqreturn_t lcd_fb_irq(int irq, void *dev_id)
{
    struct my2440fb_var    *fbvar = dev_id;
    void __iomem *lcd_irq_base;
    unsigned long lcdirq;

    /*LCD中断挂起寄存器基地址*/
    lcd_irq_base = fbvar->lcd_base + S3C2410_LCDINTBASE;

    /*读取LCD中断挂起寄存器的值*/
    lcdirq = readl(lcd_irq_base + S3C24XX_LCDINTPND);

    /*判断是否为中断挂起状态*/
    if(lcdirq & S3C2410_LCDINT_FRSYNC)
    {
        /*填充调色板*/
        if (fbvar->palette_ready)
        {
            my2440fb_write_palette(fbvar);
        }

        /*设置帧已插入中断请求*/
        writel(S3C2410_LCDINT_FRSYNC, lcd_irq_base + S3C24XX_LCDINTPND);
        writel(S3C2410_LCDINT_FRSYNC, lcd_irq_base + S3C24XX_LCDSRCPND);
    }

    return IRQ_HANDLED;
}

/*填充调色板*/
static void my2440fb_write_palette(struct my2440fb_var *fbvar)
{
    unsigned int i;
    void __iomem *regs = fbvar->lcd_base;

    fbvar->palette_ready = 0;

    for (i = 0; i < 256; i++) 
    {
        unsigned long ent = fbvar->palette_buffer[i];

        if (ent == PALETTE_BUFF_CLEAR)
        {
            continue;
        }

        writel(ent, regs + S3C2410_TFTPAL(i));

        if (readw(regs + S3C2410_TFTPAL(i)) == ent)
        {
            fbvar->palette_buffer[i] = PALETTE_BUFF_CLEAR;
        }
        else
        {
            fbvar->palette_ready = 1;
        }
    }
}

/*LCD各寄存器进行初始化*/
static int my2440fb_init_registers(struct fb_info *fbinfo)
{
    unsigned long flags;
    void __iomem *tpal;
    void __iomem *lpcsel;

    /*从lcd_fb_probe探测函数设置的私有变量结构体中再获得LCD相关信息的数据*/
    struct my2440fb_var    *fbvar = fbinfo->par;
    struct s3c2410fb_mach_info *mach_info = fbvar->dev->platform_data;

    /*获得临时调色板寄存器基地址，S3C2410_TPAL宏定义在mach-s3c2410/include/mach/regs-lcd.h中。
    注意对于lpcsel这是一个针对三星TFT屏的一个专用寄存器，如果用的不是三星的TFT屏应该不用管它。*/
    tpal = fbvar->lcd_base + S3C2410_TPAL;
    lpcsel = fbvar->lcd_base + S3C2410_LPCSEL;

    /*在修改下面寄存器值之前先屏蔽中断，将中断状态保存到flags中*/
    local_irq_save(flags);

    /*这里就是在上一篇章中讲到的把IO端口C和D配置成LCD模式*/
    modify_gpio(S3C2410_GPCUP, mach_info->gpcup, mach_info->gpcup_mask);
    modify_gpio(S3C2410_GPCCON, mach_info->gpccon, mach_info->gpccon_mask);
    modify_gpio(S3C2410_GPDUP, mach_info->gpdup, mach_info->gpdup_mask);
    modify_gpio(S3C2410_GPDCON, mach_info->gpdcon, mach_info->gpdcon_mask);

    /*恢复被屏蔽的中断*/
    local_irq_restore(flags);

    writel(0x00, tpal);/*临时调色板寄存器使能禁止*/
    writel(mach_info->lpcsel, lpcsel);/*在上一篇中讲到过，它是三星TFT屏的一个寄存器，这里可以不管*/

    return 0;
}

/*该函数实现修改GPIO端口的值，注意第三个参数mask的作用是将要设置的寄存器值先清零*/
static inline void modify_gpio(void __iomem *reg, unsigned long set, unsigned long mask)
{
    unsigned long tmp;

    tmp = readl(reg) & ~mask;
    writel(tmp | set, reg);
}

/*检查fb_info中的可变参数*/
static int my2440fb_check_var(struct fb_info *fbinfo)
{
    unsigned i;

    /*从lcd_fb_probe探测函数设置的平台数据中再获得LCD相关信息的数据*/
    struct fb_var_screeninfo *var = &fbinfo->var;/*fb_info中的可变参数*/
    struct my2440fb_var    *fbvar = fbinfo->par;/*在lcd_fb_probe探测函数中设置的私有结构体数据*/
    struct s3c2410fb_mach_info *mach_info = fbvar->dev->platform_data;/*LCD的配置结构体数据，这个配置结构体的赋值在上一篇章的"3. 帧缓冲设备作为平台设备"中*/

    struct s3c2410fb_display *display = NULL;
    struct s3c2410fb_display *default_display = mach_info->displays + mach_info->default_display;
    int type = default_display->type;/*LCD的类型，看上一篇章的"3. 帧缓冲设备作为平台设备"中的type赋值是TFT类型*/

    /*验证X/Y解析度*/
    if (var->yres == default_display->yres && 
        var->xres == default_display->xres && 
        var->bits_per_pixel == default_display->bpp)
    {
        display = default_display;
    }
    else
    {
        for (i = 0; i < mach_info->num_displays; i++)
        {
            if (type == mach_info->displays[i].type &&
             var->yres == mach_info->displays[i].yres &&
             var->xres == mach_info->displays[i].xres &&
             var->bits_per_pixel == mach_info->displays[i].bpp) 
            {
                display = mach_info->displays + i;
                break;
            }
        }
    }

    if (!display) 
    {
        return -EINVAL;
    }

    /*配置LCD配置寄存器1中的5-6位(配置成TFT类型)和配置LCD配置寄存器5*/
    fbvar->regs.lcdcon1 = display->type;
    fbvar->regs.lcdcon5 = display->lcdcon5;

    /* 设置屏幕的虚拟解析像素和高度宽度 */
    var->xres_virtual = display->xres;
    var->yres_virtual = display->yres;
    var->height = display->height;
    var->width = display->width;

    /* 设置时钟像素，行、帧切换值，水平同步、垂直同步长度值 */
    var->pixclock = display->pixclock;
    var->left_margin = display->left_margin;
    var->right_margin = display->right_margin;
    var->upper_margin = display->upper_margin;
    var->lower_margin = display->lower_margin;
    var->vsync_len = display->vsync_len;
    var->hsync_len = display->hsync_len;

    /*设置透明度*/
    var->transp.offset = 0;
    var->transp.length = 0;

    /*根据色位模式(BPP)来设置可变参数中R、G、B的颜色位域。对于这些参数值的设置请参考CPU数据
    手册中"显示缓冲区与显示点对应关系图"，例如在上一篇章中我就画出了8BPP和16BPP时的对应关系图*/
    switch (var->bits_per_pixel) 
    {
        case 1:
        case 2:
        case 4:
            var->red.offset  = 0;
            var->red.length  = var->bits_per_pixel;
            var->green       = var->red;
            var->blue        = var->red;
            break;
        case 8:/* 8 bpp 332 */
            if (display->type != S3C2410_LCDCON1_TFT) 
            {
                var->red.length     = 3;
                var->red.offset     = 5;
                var->green.length   = 3;
                var->green.offset   = 2;
                var->blue.length    = 2;
                var->blue.offset    = 0;
            }else{
                var->red.offset     = 0;
                var->red.length     = 8;
                var->green          = var->red;
                var->blue           = var->red;
            }
            break;
        case 12:/* 12 bpp 444 */
            var->red.length         = 4;
            var->red.offset         = 8;
            var->green.length       = 4;
            var->green.offset       = 4;
            var->blue.length        = 4;
            var->blue.offset        = 0;
            break;
        case 16:/* 16 bpp */
            if (display->lcdcon5 & S3C2410_LCDCON5_FRM565) 
            {
                /* 565 format */
                var->red.offset      = 11;
                var->green.offset    = 5;
                var->blue.offset     = 0;
                var->red.length      = 5;
                var->green.length    = 6;
                var->blue.length     = 5;
            } else {
                /* 5551 format */
                var->red.offset      = 11;
                var->green.offset    = 6;
                var->blue.offset     = 1;
                var->red.length      = 5;
                var->green.length    = 5;
                var->blue.length     = 5;
            }
            break;
        case 32:/* 24 bpp 888 and 8 dummy */
            var->red.length        = 8;
            var->red.offset        = 16;
            var->green.length      = 8;
            var->green.offset      = 8;
            var->blue.length       = 8;
            var->blue.offset       = 0;
            break;
    }

    return 0;
}

/*申请帧缓冲设备fb_info的显示缓冲区空间*/
static int __init my2440fb_map_video_memory(struct fb_info *fbinfo)
{
    dma_addr_t map_dma;/*用于保存DMA缓冲区总线地址*/
    struct my2440fb_var    *fbvar = fbinfo->par;/*获得在lcd_fb_probe探测函数中设置的私有结构体数据*/
    unsigned map_size = PAGE_ALIGN(fbinfo->fix.smem_len);/*获得FrameBuffer缓存的大小, PAGE_ALIGN定义在mm.h中*/

    /*将分配的一个写合并DMA缓存区设置为LCD屏幕的虚拟地址(对于DMA请参考DMA相关知识)
    dma_alloc_writecombine定义在arch/arm/mm/dma-mapping.c中*/
    fbinfo->screen_base = dma_alloc_writecombine(fbvar->dev, map_size, &map_dma, GFP_KERNEL);

    if (fbinfo->screen_base) 
    {
        /*设置这片DMA缓存区的内容为空*/
        memset(fbinfo->screen_base, 0x00, map_size);

        /*将DMA缓冲区总线地址设成fb_info不可变参数中framebuffer缓存的开始位置*/
        fbinfo->fix.smem_start = map_dma;
    }

    return fbinfo->screen_base ? 0 : -ENOMEM;
}

/*释放帧缓冲设备fb_info的显示缓冲区空间*/
static inline void my2440fb_unmap_video_memory(struct fb_info *fbinfo)
{
    struct my2440fb_var    *fbvar = fbinfo->par;
    unsigned map_size = PAGE_ALIGN(fbinfo->fix.smem_len);

    /*跟申请DMA的地方想对应*/
    dma_free_writecombine(fbvar->dev, map_size, fbinfo->screen_base, fbinfo->fix.smem_start);
}


/*LCD FrameBuffer设备移除的实现，注意这里使用一个__devexit宏，和lcd_fb_probe接口函数相对应。
  在Linux内核中，使用了大量不同的宏来标记具有不同作用的函数和数据结构，这些宏在include/linux/init.h 
  头文件中定义，编译器通过这些宏可以把代码优化放到合适的内存位置，以减少内存占用和提高内核效率。
  __devinit、__devexit就是这些宏之一，在probe()和remove()函数中应该使用__devinit和__devexit宏。
  又当remove()函数使用了__devexit宏时，则在驱动结构体中一定要使用__devexit_p宏来引用remove()，
  所以在第①步中就用__devexit_p来引用lcd_fb_remove接口函数。*/
static int __devexit lcd_fb_remove(struct platform_device *pdev)
{
    struct fb_info *fbinfo = platform_get_drvdata(pdev);
    struct my2440fb_var    *fbvar = fbinfo->par;

    /*从系统中注销帧缓冲设备*/
    unregister_framebuffer(fbinfo);

    /*停止LCD控制器的工作*/
    my2440fb_lcd_enable(fbvar, 0);

    /*延迟一段时间，因为停止LCD控制器需要一点时间 */
    msleep(1);

    /*释放帧缓冲设备fb_info的显示缓冲区空间*/
    my2440fb_unmap_video_memory(fbinfo);

    /*将LCD平台数据清空和释放fb_info空间资源*/
    platform_set_drvdata(pdev, NULL);
    framebuffer_release(fbinfo);

    /*释放中断资源*/
    free_irq(fbvar->lcd_irq_no, fbvar);

    /*释放时钟资源*/
    if (fbvar->lcd_clock) 
    {
        clk_disable(fbvar->lcd_clock);
        clk_put(fbvar->lcd_clock);
        fbvar->lcd_clock = NULL;
    }

    /*释放LCD IO空间映射的虚拟内存空间*/
    iounmap(fbvar->lcd_base);

    /*释放申请的LCD IO端口所占用的IO空间*/
    release_resource(fbvar->lcd_mem);
    kfree(fbvar->lcd_mem);

    return 0;
}

/*停止LCD控制器的工作*/
static void my2440fb_lcd_enable(struct my2440fb_var *fbvar, int enable)
{
    unsigned long flags;

    /*在修改下面寄存器值之前先屏蔽中断，将中断状态保存到flags中*/
    local_irq_save(flags);

    if (enable)
    {
        fbvar->regs.lcdcon1 |= S3C2410_LCDCON1_ENVID;
    }
    else
    {
        fbvar->regs.lcdcon1 &= ~S3C2410_LCDCON1_ENVID;
    }

    writel(fbvar->regs.lcdcon1, fbvar->lcd_base + S3C2410_LCDCON1);

    /*恢复被屏蔽的中断*/
    local_irq_restore(flags);
}

/*对LCD FrameBuffer平台设备驱动电源管理的支持,CONFIG_PM这个宏定义在内核中*/
#ifdef CONFIG_PM
/*当配置内核时选上电源管理，则平台设备的驱动就支持挂起和恢复功能*/
static int lcd_fb_suspend(struct platform_device *pdev, pm_message_t state)
{
    /*挂起LCD设备，注意这里挂起LCD时并没有保存LCD控制器的各种状态，所以在恢复后LCD不会继续显示挂起前的内容
     若要继续显示挂起前的内容，则要在这里保存LCD控制器的各种状态，这里就不讲这个了，以后讲到电源管理再讲*/
    struct fb_info *fbinfo = platform_get_drvdata(pdev);
    struct my2440fb_var    *fbvar = fbinfo->par;

    /*停止LCD控制器的工作*/
    my2440fb_lcd_enable(fbvar, 0);

    msleep(1);

    /*停止时钟*/
    clk_disable(fbvar->lcd_clock);

    return 0;
}

static int lcd_fb_resume(struct platform_device *pdev)
{
    /*恢复挂起的LCD设备*/
    struct fb_info *fbinfo = platform_get_drvdata(pdev);
    struct my2440fb_var    *fbvar = fbinfo->par;

    /*开启时钟*/
    clk_enable(fbvar->lcd_clock);

    /*初始化LCD控制器之前要延迟一段时间*/
    msleep(1);

    /*恢复时重新初始化LCD各寄存器*/
    my2440fb_init_registers(fbinfo);

    /*重新激活fb_info中所有的参数配置，该函数定义在第③步中再讲*/
    my2440fb_activate_var(fbinfo);

    /*正与挂起时讲到的那样，因为没保存挂起时LCD控制器的各种状态，
    所以恢复后就让LCD显示空白，该函数定义也在第③步中再讲*/
    my2440fb_blank(FB_BLANK_UNBLANK, fbinfo);

    return 0;
}
#else
/*如果配置内核时没选上电源管理,则平台设备的驱动就不支持挂起和恢复功能,这两个函数也就无需实现了*/
#define lcd_fb_suspend    NULL
#define lcd_fb_resume    NULL
#endif
    fbinfo->flags               = FBINFO_FLAG_DEFAULT;
    fbinfo->pseudo_palette      = &fbvar->pseudo_pal;
 
③、帧缓冲设备驱动对底层硬件操作的函数接口实现(即：my2440fb_ops的实现)：
/*Framebuffer底层硬件操作各接口函数*/
static struct fb_ops my2440fb_ops = 
{
    .owner          = THIS_MODULE,
    .fb_check_var   = my2440fb_check_var,/*第②步中已实现*/
    .fb_set_par     = my2440fb_set_par,/*设置fb_info中的参数，主要是LCD的显示模式*/
    .fb_blank       = my2440fb_blank,/*显示空白(即：LCD开关控制)*/
    .fb_setcolreg   = my2440fb_setcolreg,/*设置颜色表*/
    /*以下三个函数是可选的，主要是提供fb_console的支持，在内核中已经实现，这里直接调用即可*/
    .fb_fillrect    = cfb_fillrect,/*定义在drivers/video/cfbfillrect.c中*/
    .fb_copyarea    = cfb_copyarea,/*定义在drivers/video/cfbcopyarea.c中*/
    .fb_imageblit   = cfb_imageblit,/*定义在drivers/video/cfbimgblt.c中*/
};

/*设置fb_info中的参数，这里根据用户设置的可变参数var调整固定参数fix*/
static int my2440fb_set_par(struct fb_info *fbinfo)
{
    /*获得fb_info中的可变参数*/
    struct fb_var_screeninfo *var = &fbinfo->var;

    /*判断可变参数中的色位模式，根据色位模式来设置色彩模式*/
    switch (var->bits_per_pixel) 
    {
        case 32:
        case 16:
        case 12:/*12BPP时，设置为真彩色(分成红、绿、蓝三基色)*/
            fbinfo->fix.visual = FB_VISUAL_TRUECOLOR;
            break;
        case 1:/*1BPP时，设置为黑白色(分黑、白两种色，FB_VISUAL_MONO01代表黑，FB_VISUAL_MONO10代表白)*/
            fbinfo->fix.visual = FB_VISUAL_MONO01;
            break;
        default:/*默认设置为伪彩色，采用索引颜色显示*/
            fbinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;
            break;
    }

    /*设置fb_info中固定参数中一行的字节数，公式：1行字节数=(1行像素个数*每像素位数BPP)/8 */
    fbinfo->fix.line_length = (var->xres_virtual * var->bits_per_pixel) / 8;

    /*修改以上参数后，重新激活fb_info中的参数配置(即：使修改后的参数在硬件上生效)*/
    my2440fb_activate_var(fbinfo);

    return 0;
}

/*重新激活fb_info中的参数配置*/
static void my2440fb_activate_var(struct fb_info *fbinfo)
{
    /*获得结构体变量*/
    struct my2440fb_var *fbvar = fbinfo->par;
    void __iomem *regs = fbvar->lcd_base;

    /*获得fb_info可变参数*/
    struct fb_var_screeninfo *var = &fbinfo->var;

    /*计算LCD控制寄存器1中的CLKVAL值, 根据数据手册中该寄存器的描述，计算公式如下：
    * STN屏：VCLK = HCLK / (CLKVAL * 2), CLKVAL要求>= 2
    * TFT屏：VCLK = HCLK / [(CLKVAL + 1) * 2], CLKVAL要求>= 0*/
    int clkdiv = my2440fb_calc_pixclk(fbvar, var->pixclock) / 2;

    /*获得屏幕的类型*/
    int type = fbvar->regs.lcdcon1 & S3C2410_LCDCON1_TFT;

    if (type == S3C2410_LCDCON1_TFT) 
    {
        /*根据数据手册按照TFT屏的要求配置LCD控制寄存器1-5*/
        my2440fb_config_tft_lcd_regs(fbinfo, &fbvar->regs);

        --clkdiv;

        if (clkdiv < 0)
        {
            clkdiv = 0;
        }
    } 
    else 
    {
        /*根据数据手册按照STN屏的要求配置LCD控制寄存器1-5*/
        my2440fb_config_stn_lcd_regs(fbinfo, &fbvar->regs);

        if (clkdiv < 2)
        {
            clkdiv = 2;
        }
    }

    /*设置计算的LCD控制寄存器1中的CLKVAL值*/
    fbvar->regs.lcdcon1 |= S3C2410_LCDCON1_CLKVAL(clkdiv);

    /*将各参数值写入LCD控制寄存器1-5中*/
    writel(fbvar->regs.lcdcon1 & ~S3C2410_LCDCON1_ENVID, regs + S3C2410_LCDCON1);
    writel(fbvar->regs.lcdcon2, regs + S3C2410_LCDCON2);
    writel(fbvar->regs.lcdcon3, regs + S3C2410_LCDCON3);
    writel(fbvar->regs.lcdcon4, regs + S3C2410_LCDCON4);
    writel(fbvar->regs.lcdcon5, regs + S3C2410_LCDCON5);

    /*配置帧缓冲起始地址寄存器1-3*/
    my2440fb_set_lcdaddr(fbinfo);

    fbvar->regs.lcdcon1 |= S3C2410_LCDCON1_ENVID,
    writel(fbvar->regs.lcdcon1, regs + S3C2410_LCDCON1);
}

/*计算LCD控制寄存器1中的CLKVAL值*/
static unsigned int my2440fb_calc_pixclk(struct my2440fb_var *fbvar, unsigned long pixclk)
{
    /*获得LCD的时钟*/
    unsigned long clk = clk_get_rate(fbvar->lcd_clock);

    /* 像素时钟单位是皮秒，而时钟的单位是赫兹，所以计算公式为：
     * Hz -> picoseconds is / 10^-12
     */
    unsigned long long div = (unsigned long long)clk * pixclk;

    div >>= 12;            /* div / 2^12 */
    do_div(div, 625 * 625UL * 625); /* div / 5^12, do_div宏定义在asm/div64.h中*/

    return div;
}

/*根据数据手册按照TFT屏的要求配置LCD控制寄存器1-5*/
static void my2440fb_config_tft_lcd_regs(const struct fb_info *fbinfo, struct s3c2410fb_hw *regs)
{
    const struct my2440fb_var *fbvar = fbinfo->par;
    const struct fb_var_screeninfo *var = &fbinfo->var;

    /*根据色位模式设置LCD控制寄存器1和5，参考数据手册*/
    switch (var->bits_per_pixel) 
    {
        case 1:/*1BPP*/
            regs->lcdcon1 |= S3C2410_LCDCON1_TFT1BPP;
            break;
        case 2:/*2BPP*/
            regs->lcdcon1 |= S3C2410_LCDCON1_TFT2BPP;
            break;
        case 4:/*4BPP*/
            regs->lcdcon1 |= S3C2410_LCDCON1_TFT4BPP;
            break;
        case 8:/*8BPP*/
            regs->lcdcon1 |= S3C2410_LCDCON1_TFT8BPP;
            regs->lcdcon5 |= S3C2410_LCDCON5_BSWP | S3C2410_LCDCON5_FRM565;
            regs->lcdcon5 &= ~S3C2410_LCDCON5_HWSWP;
            break;
        case 16:/*16BPP*/
            regs->lcdcon1 |= S3C2410_LCDCON1_TFT16BPP;
            regs->lcdcon5 &= ~S3C2410_LCDCON5_BSWP;
            regs->lcdcon5 |= S3C2410_LCDCON5_HWSWP;
            break;
        case 32:/*32BPP*/
            regs->lcdcon1 |= S3C2410_LCDCON1_TFT24BPP;
            regs->lcdcon5 &= ~(S3C2410_LCDCON5_BSWP | S3C2410_LCDCON5_HWSWP | S3C2410_LCDCON5_BPP24BL);
            break;
        default:/*无效的BPP*/
            dev_err(fbvar->dev, "invalid bpp %d/n", var->bits_per_pixel);
    }

    /*设置LCD配置寄存器2、3、4*/
    regs->lcdcon2 = S3C2410_LCDCON2_LINEVAL(var->yres - 1) |
            S3C2410_LCDCON2_VBPD(var->upper_margin - 1) |
            S3C2410_LCDCON2_VFPD(var->lower_margin - 1) |
            S3C2410_LCDCON2_VSPW(var->vsync_len - 1);

    regs->lcdcon3 = S3C2410_LCDCON3_HBPD(var->right_margin - 1) |
            S3C2410_LCDCON3_HFPD(var->left_margin - 1) |
            S3C2410_LCDCON3_HOZVAL(var->xres - 1);

    regs->lcdcon4 = S3C2410_LCDCON4_HSPW(var->hsync_len - 1);
}

/*根据数据手册按照STN屏的要求配置LCD控制寄存器1-5*/
static void my2440fb_config_stn_lcd_regs(const struct fb_info *fbinfo, struct s3c2410fb_hw *regs)
{
    const struct my2440fb_var    *fbvar = fbinfo->par;
    const struct fb_var_screeninfo *var = &fbinfo->var;

    int type = regs->lcdcon1 & ~S3C2410_LCDCON1_TFT;
    int hs = var->xres >> 2;
    unsigned wdly = (var->left_margin >> 4) - 1;
    unsigned wlh = (var->hsync_len >> 4) - 1;

    if (type != S3C2410_LCDCON1_STN4)
    {
        hs >>= 1;
    }

    /*根据色位模式设置LCD控制寄存器1，参考数据手册*/
    switch (var->bits_per_pixel) 
    {
        case 1:/*1BPP*/
            regs->lcdcon1 |= S3C2410_LCDCON1_STN1BPP;
            break;
        case 2:/*2BPP*/
            regs->lcdcon1 |= S3C2410_LCDCON1_STN2GREY;
            break;
        case 4:/*4BPP*/
            regs->lcdcon1 |= S3C2410_LCDCON1_STN4GREY;
            break;
        case 8:/*8BPP*/
            regs->lcdcon1 |= S3C2410_LCDCON1_STN8BPP;
            hs *= 3;
            break;
        case 12:/*12BPP*/
            regs->lcdcon1 |= S3C2410_LCDCON1_STN12BPP;
            hs *= 3;
            break;
        default:/*无效的BPP*/
            dev_err(fbvar->dev, "invalid bpp %d/n", var->bits_per_pixel);
    }
    
    /*设置LCD配置寄存器2、3、4, 参考数据手册*/
    if (wdly > 3) wdly = 3;
    if (wlh > 3) wlh = 3;
    regs->lcdcon2 = S3C2410_LCDCON2_LINEVAL(var->yres - 1);

    regs->lcdcon3 = S3C2410_LCDCON3_WDLY(wdly) |
            S3C2410_LCDCON3_LINEBLANK(var->right_margin / 8) |
            S3C2410_LCDCON3_HOZVAL(hs - 1);

    regs->lcdcon4 = S3C2410_LCDCON4_WLH(wlh);
}

/*配置帧缓冲起始地址寄存器1-3，参考数据手册*/
static void my2440fb_set_lcdaddr(struct fb_info *fbinfo)
{
    unsigned long saddr1, saddr2, saddr3;
    struct my2440fb_var *fbvar = fbinfo->par;
    void __iomem *regs = fbvar->lcd_base;

    saddr1 = fbinfo->fix.smem_start >> 1;
    saddr2 = fbinfo->fix.smem_start;
    saddr2 += fbinfo->fix.line_length * fbinfo->var.yres;
    saddr2 >>= 1;
    saddr3 = S3C2410_OFFSIZE(0) | S3C2410_PAGEWIDTH((fbinfo->fix.line_length / 2) & 0x3ff);

    writel(saddr1, regs + S3C2410_LCDSADDR1);
    writel(saddr2, regs + S3C2410_LCDSADDR2);
    writel(saddr3, regs + S3C2410_LCDSADDR3);
}

/*显示空白，blank mode有5种模式，定义在fb.h中，是一个枚举*/
static int my2440fb_blank(int blank_mode, struct fb_info *fbinfo)
{
    struct my2440fb_var *fbvar = fbinfo->par;
    void __iomem *regs = fbvar->lcd_base;

    /*根据显示空白的模式来设置LCD是开启还是停止*/
    if (blank_mode == FB_BLANK_POWERDOWN) 
    {
        my2440fb_lcd_enable(fbvar, 0);/*在第②步中定义*/
    } 
    else 
    {
        my2440fb_lcd_enable(fbvar, 1);/*在第②步中定义*/
    }

    /*根据显示空白的模式来控制临时调色板寄存器*/
    if (blank_mode == FB_BLANK_UNBLANK)
    {
        /*临时调色板寄存器无效*/
        writel(0x0, regs + S3C2410_TPAL);
    }
    else 
    {
        /*临时调色板寄存器有效*/
        writel(S3C2410_TPAL_EN, regs + S3C2410_TPAL);
    }

    return 0;
}

/*设置颜色表*/
static int my2440fb_setcolreg(unsigned regno,unsigned red,unsigned green,unsigned blue,unsigned transp,struct fb_info *fbinfo)
{
    unsigned int val;
    struct my2440fb_var *fbvar = fbinfo->par;
    void __iomem *regs = fbvar->lcd_base;

    switch (fbinfo->fix.visual) 
    {
        case FB_VISUAL_TRUECOLOR:
            /*真彩色*/
            if (regno < 16) 
            {
                u32 *pal = fbinfo->pseudo_palette;

                val = chan_to_field(red, &fbinfo->var.red);
                val |= chan_to_field(green, &fbinfo->var.green);
                val |= chan_to_field(blue, &fbinfo->var.blue);

                pal[regno] = val;
            }
            break;
        case FB_VISUAL_PSEUDOCOLOR:
            /*伪彩色*/
            if (regno < 256) 
            {
                val = (red >> 0) & 0xf800;
                val |= (green >> 5) & 0x07e0;
                val |= (blue >> 11) & 0x001f;

                writel(val, regs + S3C2410_TFTPAL(regno));

                /*修改调色板*/
                schedule_palette_update(fbvar, regno, val);
            }
            break;
        default:
            return 1;
    }

    return 0;
}

static inline unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)
{
    chan &= 0xffff;
    chan >>= 16 - bf->length;
    return chan << bf->offset;
}

/*修改调色板*/
static void schedule_palette_update(struct my2440fb_var    *fbvar, unsigned int regno, unsigned int val)
{
    unsigned long flags;
    unsigned long irqen;

    /*LCD中断挂起寄存器基地址*/
    void __iomem *lcd_irq_base = fbvar->lcd_base + S3C2410_LCDINTBASE;

    /*在修改中断寄存器值之前先屏蔽中断，将中断状态保存到flags中*/
    local_irq_save(flags);

    fbvar->palette_buffer[regno] = val;

    /*判断调色板是否准备就像*/
    if (!fbvar->palette_ready) 
    {
        fbvar->palette_ready = 1;

        /*使能中断屏蔽寄存器*/
        irqen = readl(lcd_irq_base + S3C24XX_LCDINTMSK);
        irqen &= ~S3C2410_LCDINT_FRSYNC;
        writel(irqen, lcd_irq_base + S3C24XX_LCDINTMSK);
    }

    /*恢复被屏蔽的中断*/
    local_irq_restore(flags);
}
 

五、从整体上再描述一下FrameBuffer设备驱动实例代码的结构：
 
1、在第①部分代码中主要做的事情有：
   a.将LCD设备注册到系统平台设备中；
   b.定义LCD平台设备结构体lcd_fb_driver。
 
2、在第②部分代码中主要做的事情有：
   a.获取和设置LCD平台设备的各种资源；
   b.分配fb_info结构体空间；
   c.初始化fb_info结构体中的各参数；
   d.初始化LCD控制器；
   e.检查fb_info中可变参数；
   f.申请帧缓冲设备的显示缓冲区空间；
   g.注册fb_info。
 
3、在第③部分代码中主要做的事情有：
   a.实现对fb_info相关参数进行检查的硬件接口函数；
   b.实现对LCD显示模式进行设定的硬件接口函数；
   c.实现对LCD显示开关(空白)的硬件接口函数等。